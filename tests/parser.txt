defpackage mypackage :
   import core
   import reader

;============================================================
;===================== Syntax Tree ==========================
;============================================================

deftype Exp
defstruct AddOp <: Exp : (x:Exp, y:Exp)
defstruct SubOp <: Exp : (x:Exp, y:Exp)
defstruct MulOp <: Exp : (x:Exp, y:Exp)
defstruct DivOp <: Exp : (x:Exp, y:Exp)
defstruct CallOp <: Exp : (f:Exp, args:List<Exp>)
defstruct Identifier <: Exp : (name:Symbol)
defstruct Number <: Exp : (value:Double)

defmethod print (o:OutputStream, e:Exp) :
   print{o, _} $ match(e) :
      (e:AddOp) : "%_ + %_" % [x(e), y(e)]
      (e:SubOp) : "%_ - %_" % [x(e), y(e)]
      (e:MulOp) : "%_ * %_" % [x(e), y(e)]
      (e:DivOp) : "%_ / %_" % [x(e), y(e)]
      (e:CallOp) : "%_(%,)" % [f(e), args(e)]
      (e:Identifier) : name(e)
      (e:Number) : value(e)

;============================================================
;================== Parser Definition =======================
;============================================================


defn* apply-suffix-ops (x:Exp, fs:List<(Exp -> Exp)>) -> Exp :
   if empty?(fs) : x
   else : apply-suffix-ops(head(fs)(x), tail(fs))

defsyntax mylang :
   defproduction exp :
      rule (?x:#exp0 ?ops:#op0 ...) : apply-suffix-ops(x, ops)
   defproduction exp0 :
      rule (?x:#exp1 ?ops:#op1 ...) : apply-suffix-ops(x, ops)
   defproduction exp1 :
      rule (?x:#term ?ops:#op2 ...) : apply-suffix-ops(x, ops)
   defproduction term :
      rule ((?e:#exp)) : e
      rule (?x:#id) : x
      rule (?x:#num) : x
      
   defproduction id :
      rule (?x) when unwrap-token(x) is Symbol :
         Identifier(unwrap-token(x))
   defproduction num :
      rule (?x) when unwrap-token(x) is Double :
         Number(unwrap-token(x))      
   defproduction op0 :
      rule (+ ?y:#exp0) : AddOp{_:Exp, y}
      rule (- ?y:#exp0) : SubOp{_:Exp, y}
   defproduction op1 :
      rule (* ?y:#exp1) : MulOp{_:Exp, y}
      rule (/ ?y:#exp1) : DivOp{_:Exp, y}
   defproduction op2 :
      rule ((@do ?args:#exp ...)) : CallOp{_:Exp, args}

defn parse-exps (form) -> List<Exp> :
   with-syntax(mylang) :
      match-syntax(form) :
         (?es:#exp ...) :
            es          

;============================================================
;===================== Driver ===============================
;============================================================

defn main () :
   ;Ensure filename given
   if length(command-line-arguments()) < 2 :
      println("Please provide a filename.")
      exit(-1)

   ;Get filename
   val filename = command-line-arguments()[1]

   ;Read
   val read = read-file(filename)

   ;Parse
   val exps = parse-exps(read)

   ;Print
   do(println, exps)

main()