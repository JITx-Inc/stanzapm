defpackage mypackage :
   import core
   import reader

;============================================================
;===================== Syntax Tree ==========================
;============================================================

deftype Exp
defstruct AddOp <: Exp : (x:Exp, y:Exp)
defstruct SubOp <: Exp : (x:Exp, y:Exp)
defstruct MulOp <: Exp : (x:Exp, y:Exp)
defstruct DivOp <: Exp : (x:Exp, y:Exp)
defstruct CallOp <: Exp : (f:Exp, args:List<Exp>)
defstruct Identifier <: Exp : (name:Symbol)
defstruct Number <: Exp : (value:Double)

defmethod print (o:OutputStream, e:Exp) :
   print{o, _} $ match(e) :
      (e:AddOp) : "(%_ + %_)" % [x(e), y(e)]
      (e:SubOp) : "(%_ - %_)" % [x(e), y(e)]
      (e:MulOp) : "(%_ * %_)" % [x(e), y(e)]
      (e:DivOp) : "(%_ / %_)" % [x(e), y(e)]
      (e:CallOp) : "%_(%,)" % [f(e), args(e)]
      (e:Identifier) : name(e)
      (e:Number) : value(e)

;============================================================
;================== Parser Definition =======================
;============================================================


defn* apply-suffix-ops (x:Exp, fs:List<(Exp -> Exp)>) -> Exp :
   if empty?(fs) : x
   else : apply-suffix-ops(head(fs)(x), tail(fs))

defsyntax mylang :
   public defproduction exp : Exp
   defproduction exp0 : Exp
   defproduction exp1 : Exp
   defproduction term : Exp
   defproduction id : Identifier
   defproduction num : Number
   defproduction op0 : Exp -> Exp
   defproduction op1 : Exp -> Exp
   public defproduction op2 : Exp -> Exp

   defrule exp = (?x:#exp0 ?ops:#op0 ...) : apply-suffix-ops(x, ops)
   defrule exp0 = (?x:#exp1 ?ops:#op1 ...) : apply-suffix-ops(x, ops)
   defrule exp1 = (?x:#term ?ops:#op2 ...) : apply-suffix-ops(x, ops)
   defrule term = ((?e:#exp)) : e
   defrule term = (?x:#id) : x
   defrule term = (?x:#num) : x
   
   defrule id = (?x) when unwrap-token(x) is Symbol :
      Identifier(unwrap-token(x))
   defrule num = (?x) when unwrap-token(x) is Double :
      Number(unwrap-token(x))      
   defrule op0 = (+ ?y:#exp0) : AddOp{_:Exp, y}
   defrule op0 = (- ?y:#exp0) : SubOp{_:Exp, y}
   defrule op1 = (* ?y:#exp1) : MulOp{_:Exp, y}
   defrule op1 = (/ ?y:#exp1) : DivOp{_:Exp, y}   

defsyntax call-op :
   import (op2, exp) from mylang
   defrule op2 = ((@do ?args:#exp ... ?rest ...)) :
      if not empty?(rest) :
         fatal("%_: Expected expression here." % [closest-info(rest)])
      CallOp{_, args}

defn parse-exps (form) -> List<Exp> :
   with-syntax(mylang + call-op) :
      match-syntax(form) :
         (?es:#exp ...) :
            es          

;============================================================
;===================== Driver ===============================
;============================================================

defn main () :
   ;Ensure filename given
   if length(command-line-arguments()) < 2 :
      println("Please provide a filename.")
      exit(-1)

   ;Get filename
   val filename = command-line-arguments()[1]

   ;Read
   val read = read-file(filename)

   ;Parse
   val exps = parse-exps(read)

   ;Print
   do(println, exps)

main()