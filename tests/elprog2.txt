load :
  package core :
    export 3 struct T(core,Int)<0> : (int)
    export 4 struct T(core,Box)<0> : (top)
    export 5 struct T(core,False)<0> : ()
    export 6 struct T(core,True)<0> : ()
    export 7 struct T(core,Fn)<0> : (long long top ...)
    export 100 lsfn(F<0>(core,cast-error,[]) -> int)
    export 101 lsfn(F<0>(core,variable-uninitialized-error,[]) -> int)
    export 102 lsfn(F<0>(core,no-branch-error,[]) -> int)
    export 103 lsfn(F<0>(core,amb-branch-error,[]) -> int)
    export 104 lsfn(F<0>(core,no-method-error,[]) -> int)
    export 105 lsfn(F<0>(core,amb-method-error,[]) -> int)

    export 204 multi(F<0>(core,try-function,[top]) -> top)

  package core :
    ;deftype Int
    defstruct T3 :
      int
    ;deftype Box
    defstruct T4 :
      top
    ;deftype False
    defstruct T5 : ()
    ;deftype True
    defstruct T6 : ()
    ;deftype Fn
    defstruct T7 :
      long
      long
      top ...

    ;cast-error
    defn V100 fn<> () -> int :
      return LV{0}
    ;variable-uninitialized-error
    defn V101 fn<> () -> int :
      return LV{0}
    ;no-branch-error
    defn V102 fn<> () -> int :
      return LV{0}
    ;amb-branch-error
    defn V103 fn<> () -> int :
      return LV{0}
    ;no-method-error
    defn V104 fn<> () -> int :
      return LV{0}
    ;amb-method-error
    defn V105 fn<> () -> int :
      return LV{0}

    ;function that returns 42
    defn V202 fn<> (V50:ref<T5>) -> ref<T3> :
      return V{42}
    ;function that returns 43
    defn V203 fn<> (V51:ref<T6>) -> ref<T3> :
      return V{43}

    ;multi
    defmulti V204<> (top) -> top
    defmethod V204<> (id = V205) fn<> (V52:ref<T5>) -> ref<T3> :
      return V{42}
    defmethod V204<> (id = V206) fn<> (V53:ref<T6>) -> ref<T3> :
      return V{43}
    defmethod V204<> (id = V207) fn<> (V54:or(ref<T5>,ref<T3>)) -> ref<T3> :
      return V{44}
    defmethod V204<> (id = V208) fn<> (V55:top) -> ref<T3> :
      return V{45}

    ;printf
    extern printf V211: fn<(ptr<byte>), ?, int>

    defval V209 : top
    init :
      defn V210 fn<> (V56:top) -> top :
        defval V57:top
        V57 = check-do V204(V{56}:top)
        return V57
      init-closures (V210)
      store V209 = V210

    init :
      defval V46:top
      defval V47:top
      defval V48:top
      V48 = check-do V209(V{true}:top)
      dump (V48)

    init lostanza :
      do-c V211(LV{"This is an integer: %d\n"}, LV{42})
  
