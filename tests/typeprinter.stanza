defpackage typeprinter :
  import core
  import collections

;============================================================
;=================== Record Ids =============================
;============================================================

public deftype RecId <: Hashable & Equalable
public defmulti package (r:RecId) -> Symbol
public defmulti name (r:RecId) -> Symbol

public defstruct ValId <: RecId :
  package: Symbol with: (as-method => true)
  name: Symbol with: (as-method => true)

public defstruct TypeId <: RecId :
  package: Symbol with: (as-method => true)
  name: Symbol with: (as-method => true)

public defstruct FnId <: RecId :
  package: Symbol with: (as-method => true)
  name: Symbol with: (as-method => true)
  ntargs: Int
  ncargs: Int
  a1: Tuple<DType>

;============================================================
;======================= Records ============================
;============================================================

public deftype Rec
public defmulti id (r:Rec) -> RecId

public defstruct ValRec <: Rec :
  id: ValId with: (as-method => true)
  type: DType
  mutable?: True|False
  lostanza?: True|False

public defstruct FnRec <: Rec :
  id: FnId with: (as-method => true)
  a2: DType
  lostanza?: True|False
  tail?: True|False

public defstruct MultiRec <: Rec :
  id: FnId with: (as-method => true)
  a2: DType

public defstruct ExternFnRec <: Rec :
  id: FnId with: (as-method => true)
  a2: DType
  lbl: Symbol

public defstruct ExternRec <: Rec :
  id: ValId with: (as-method => true)
  type: DType
  lbl: Symbol

public defstruct StructRec <: Rec :
  id: TypeId with: (as-method => true)
  ntargs: Int
  parent: False|DType
  base: Tuple<StructField>
  items: False|StructField

public defstruct TypeRec <: Rec :
  id: TypeId with: (as-method => true)
  ntargs: Int
  parent: False|DType
  children: Tuple<Child>

public defstruct TypeDecl <: Rec :
  id: TypeId with: (as-method => true)
  ntargs: Int
  parent: False|DType

public defstruct StructField <: Equalable :
  name: Symbol
  type: DType

public defstruct Child <: Equalable :
  id: TypeId
  ntargs: Int
  parent: DOf

;============================================================
;============================================================
;============================================================
  
public :

public deftype DType

;LoStanza Types
public defstruct DByte <: DType
public defstruct DInt <: DType
public defstruct DLong <: DType
public defstruct DFloat <: DType
public defstruct DDouble <: DType
public defstruct DUnknown <: DType
public defstruct DPtrT <: DType : (type:DType)
public defstruct DFnT <: DType : (a:Tuple<DType>, r:False|DType, b:DType)
public defstruct DStructT <: DType : (id:TypeId, targs:Tuple<DType>)

;HiStanza Types
public defstruct DOf <: DType: (id:TypeId, targs:Tuple<DType>)
public defstruct DTVar <: DType: (index:Int)
public defstruct DCap <: DType: (tvar:DTVar)
public defstruct DAnd <: DType:
  types:Tuple<DType>
public defstruct DOr <: DType:
  types:Tuple<DType>
public defstruct DTop <: DType
public defstruct DBot <: DType
public defstruct DTuple <: DType : (types:Tuple<DType>)
public defstruct DArrow <: DType : (a1:Tuple<DType>, a2:DType)


deftype Formatter
defmulti format (f:Formatter, t:DType, lostanza?:True|False) -> Printable
;defmulti varname (f:Formatter, index:Int) -> String
defmulti format (f:Formatter, r:Rec) -> Printable

defn Formatter () :
  val preferred-varnames = ["T" "S" "R" "U" "V" "X" "Y" "Z"
                            "A" "B" "C" "D" "E" "F" "G" "H"
                            "P" "Q" "K"]
  defn varname (index:Int) :
    val n = length(preferred-varnames)
    val v = preferred-varnames[index % n]
    val i = index / n
    if i == 0 : v
    else : string-join([v, i])

  ;Wrap closure in printable object
  defn wrap-printable (f:OutputStream -> False) :
    new Printable :
      defmethod print (o:OutputStream, this) :
        f(o)

  defn lslevel (t:DType) :
    match(t) :
      ;Function
      (t:DFnT) : 0
      ;Everything else is atomic
      (t) : 1
  defn hslevel (t:DType) :
    match(t) :
      ;Arrows
      (t:DArrow) : 0
      ;Or Types
      (t:DOr) : 1
      ;And Types
      (t:DAnd) : 2
      ;Atomic types
      (t:DOf|DTVar|DCap|DTop|DBot|DTuple) : 3
  defn hsfs (o:OutputStream, ts:Seqable<DType>, lvl:Int, angle-context:True|False) :
    for (t in ts, i in 0 to false) do :
      print(o, ", ") when i > 0
      hsf(o, t, lvl, angle-context)
  defn hsf (o:OutputStream, t:DType, lvl:Int, angle-context:True|False) :
    val paren? =
      if hslevel(t) < lvl : true
      else if angle-context : t is DArrow
    val angle-context* = angle-context and not paren?
    print(o, "(") when paren?
    match(t) :
      (t:DArrow) :
        if length(a1(t)) == 1 :
          hsf(o, a1(t)[0], 1, angle-context*)
          print(o, " -> ")
          hsf(o, a2(t), 0, angle-context*)
        else :
          print(o, "(")
          hsfs(o, a1(t), 0, false)
          print(o, ") -> ")
          hsf(o, a2(t), 0, angle-context*)
      (t:DOr) :
        for (t in types(t), i in 0 to false) do :
          print(o, "|") when i > 0
          hsf(o, t, 1, angle-context*)
      (t:DAnd) :
        for (t in types(t), i in 0 to false) do :
          print(o, "&") when i > 0
          hsf(o, t, 2, angle-context*)
      ;Atomic
      (t:DOf) :
        write(o, name(id(t)))
        if not empty?(targs(t)) :
          print(o, "<")
          hsfs(o, targs(t), 0, true)
          print(o, ">")
      (t:DTVar) :
        print(o, varname(index(t)))
      (t:DCap) :
        print(o, "?")
        print(o, varname(index(tvar(t))))
      (t:DTop) :
        print(o, "?")
      (t:DBot) :
        print(o, "Void")
      (t:DTuple) :
        print(o, "[")
        hsfs(o, types(t), 0, false)
        print(o, "]")
    print(o, ")") when paren?
  defn lsfs (o:OutputStream, ts:Seqable<DType>, lvl:Int, angle-context:True|False) :
    for (t in ts, i in 0 to false) do :
      print(o, ", ") when i > 0
      lsf(o, t, lvl, angle-context)
  defn lsf (o:OutputStream, t:DType, lvl:Int, angle-context:True|False) :
    val paren? =
      if lslevel(t) < lvl : true
      else if angle-context : t is DFnT
    val angle-context* = angle-context and not paren?
    print(o, "(") when paren?
    match(t) :
      ;Functions
      (t:DFnT) :
        if length(a(t)) == 1 and r(t) is False :
          lsf(o, a(t)[0], 1, angle-context*)
          print(o, " -> ")
          lsf(o, b(t), 0, angle-context*)
        else :
          print(o, "(")
          match(r(t)) :
            (r:False) :
              lsfs(o, a(t), 0, false)
              print(o, ") -> ")
            (r:DType) :
              lsfs(o, cat(a(t), [r]), 0, false)
              print(o, " ...) -> ")
          lsf(o, b(t), 0, angle-context*)
      ;Atomic
      (t:DByte) : print(o, "byte")
      (t:DInt) : print(o, "int")
      (t:DLong) : print(o, "long")
      (t:DFloat) : print(o, "float")
      (t:DDouble) : print(o, "double")
      (t:DUnknown) : print(o, "?")
      (t:DPtrT) :
        print(o, "ptr<")
        lsf(o, type(t), 0, true)
        print(o, ">")
      (t:DStructT) :
        write(o, name(id(t)))
        if not empty?(targs(t)) :
          print(o, "<")
          hsfs(o, targs(t), 0, true)
          print(o, ">")
      ;HiStanza
      (t) :
        print(o, "ref<")
        hsf(o, t, 0, true)
        print(o, ">")      
    print(o, ")") when paren?
  defn typef (t:DType, lostanza?:True|False) :
    if lostanza? :
      wrap-printable $ lsf{_, t, 0, false}
    else :
      wrap-printable $ hsf{_, t, 0, false}

  defn recf (o:OutputStream, r:Rec) :
    defn join-name (id:RecId) :
      symbol-join $ [package(id) "/" name(id)]
      
    defn fnf (id:FnId, a2:DType, lostanza?:True|False) :
      within o = wrap-printable() :
        write(o, join-name(id))
        if ntargs(id) + ncargs(id) > 0 :
          print(o, "<")
          for i in 0 to ntargs(id) + ncargs(id) do :
            print(o, ", ") when i > 0
            print(o, "?") when i >= ntargs(id)
            print(o, varname(i))          
          print(o, ">")
        print(o, " (%,) -> %_" % [
          seq(typef{_, lostanza?}, a1(id))
          typef(a2, lostanza?)])

    defn fieldf (f:StructField) :
      "%~: %_" % [name(f), typef(type(f), true)]

    defn deftypef (id:TypeId, ntargs:Int, parent:False|DType) :
      val tvar-str = "" when ntargs == 0
                else "<%,>" % [seq(varname, 0 to ntargs)]
      val pstr = match(parent) :
        (p:False) : ""
        (p:DType) : " <: %_" % [typef(p, false)]
      "%~%_%_" % [join-name(id), tvar-str, pstr]
        
    match(r) :
      (r:ValRec) :
        val ls-str = "lostanza " when lostanza?(r) else ""
        val val-str = "var" when mutable?(r) else "val"
        val name = join-name(id(r))
        val type = typef(type(r), lostanza?(r))
        print(o, "%_%_ %~ : %_" % [ls-str, val-str, name, type])
      (r:ExternRec) :
        val name = join-name(id(r))
        val type = typef(type(r), true)
        val label-str =
          if lbl(r) == /name(id(r)) : ""
          else : " with: (label => %~)" % [lbl(r)]
        print(o, "extern %_ : %_%_" % [name, type, label-str])
      (r:FnRec) :
        val ls-str = "lostanza " when lostanza?(r) else ""
        val tail-str = "*" when tail?(r) else ""
        print(o, "%_defn%_ %_" % [
          ls-str, tail-str, fnf(id(r) as FnId, a2(r), lostanza?(r))])        
      (r:MultiRec) :
        print(o, "defmulti %_" % [fnf(id(r) as FnId, a2(r), false)])
      (r:ExternFnRec) :
        val label-str =
          if lbl(r) == /name(id(r)) : ""
          else : " with: (label => %~)" % [lbl(r)]
        print(o, "extern defn %_%_" % [
          fnf(id(r) as FnId, a2(r), true)
          label-str])
      (r:StructRec) :
        print(o, "lostanza deftype %_" % [deftypef(id(r) as TypeId, ntargs(r), parent(r))])
        if not empty?(base(r)) or items(r) is-not False :
          print(o, " :")
          val o2 = IndentedStream(o)
          for f in base(r) do :
            print(o2, "\n%_" % [fieldf(f)])
          match(items(r)) :
            (f:StructField) : print(o2, "\n%_ ..." % [fieldf(f)])
            (f:False) : false
      (r:TypeRec) :
        print(o, "deftype %_" % [deftypef(id(r) as TypeId, ntargs(r), parent(r))])
        if not empty?(children(r)) :
          print(o, " :")
          val o2 = IndentedStream(o)
          for c in children(r) do :
            print(o2, "\n%_" % [deftypef(id(c), ntargs(c), parent(c))])
      (r:TypeDecl) :
        print(o, "deftype %_" % [deftypef(id(r) as TypeId, ntargs(r), parent(r))])

  ;Return new formatter
  new Formatter :
    defmethod format (this, t:DType, lostanza?:True|False) :
      typef(t, lostanza?)
    defmethod format (this, r:Rec) :
      wrap-printable(recf{_, r})

defn run-test () :
  val A = DOf(TypeId(`core, `A), [])
  val B = DOf(TypeId(`core, `B), [])
  val C = DOf(TypeId(`core, `C), [])
  val D = DOf(TypeId(`core, `D), [])
  val E = DOf(TypeId(`core, `E), [A, B])
  defn hsf (t:DType) :
    println $ format(Formatter(), t, false)
  defn lsf (t:DType) :
    println $ format(Formatter(), t, true)
  defn rf (r:Rec) :
    println $ format(Formatter(), r)
    
  println("Run tests")
  hsf(A)
  hsf(B)
  hsf(E)
  hsf(DTVar(0))
  hsf(DAnd([A,B]))
  hsf(DOr([A,B,C]))
  hsf(DCap(DTVar(0)))
  hsf(DTop())
  hsf(DBot())
  hsf(DTuple([A,B,C]))
  hsf(DArrow([A,B],C))
  hsf(DArrow([],C))
  hsf(DArrow([A],C))
  hsf(DArrow([DArrow([A],C), DArrow([A],C)],C))
  hsf(DArrow([DArrow([A],C)],C))
  hsf(DArrow([DArrow([A],C)],DArrow([A],C)))
  hsf(DOf(TypeId(`core, `F), [DArrow([A],C)]))
  hsf(DOf(TypeId(`core, `F), [DOr([A, B, DArrow([A],C)])]))

  lsf(A)
  lsf(B)
  lsf(E)
  lsf(DTVar(0))
  lsf(DAnd([A,B]))
  lsf(DOr([A,B,C]))
  lsf(DCap(DTVar(0)))
  lsf(DTop())
  lsf(DBot())
  lsf(DTuple([A,B,C]))
  lsf(DArrow([A,B],C))
  lsf(DArrow([],C))
  lsf(DArrow([A],C))
  lsf(DArrow([DArrow([A],C), DArrow([A],C)],C))
  lsf(DArrow([DArrow([A],C)],C))
  lsf(DArrow([DArrow([A],C)],DArrow([A],C)))
  lsf(DOf(TypeId(`core, `F), [DArrow([A],C)]))
  lsf(DOf(TypeId(`core, `F), [DOr([A, B, DArrow([A],C)])]))

  lsf(DByte())
  lsf(DInt())
  lsf(DLong())
  lsf(DFloat())
  lsf(DDouble())
  lsf(DUnknown())
  lsf(DPtrT(DByte()))
  lsf(DPtrT(A))
  lsf(DFnT([A], false, B))
  lsf(DFnT([A, B], false, B))
  lsf(DFnT([], false, B))
  lsf(DFnT([A], DPtrT(DByte()), B))
  lsf(DFnT([A, B], DPtrT(DByte()), B))
  lsf(DFnT([], DPtrT(DByte()), B))

  lsf(DFnT([DFnT([A], false, B)], DPtrT(DByte()), B))
  lsf(DFnT([DFnT([A], false, B), DFnT([A], false, B)], DPtrT(DByte()), B))

  lsf(DFnT([DFnT([A], false, B)], false, B))
  lsf(DFnT([A], false, DFnT([A], false, B)))
  lsf(DFnT([A], false, DPtrT(DFnT([A], false, B))))
  lsf(DFnT([DFnT([A], false, B), DFnT([A], false, B)], false, B))

  rf $ ValRec(ValId(`core, `x),
              DOf(TypeId(`core, `F), [DArrow([A],C)])
              true
              false)
  rf $ ValRec(ValId(`core, `x),
              DOf(TypeId(`core, `F), [DArrow([A],C)])
              false
              false)
  rf $ ValRec(ValId(`collections, `y),
              DOf(TypeId(`core, `F), [DArrow([A],C)])
              true
              true)
  rf $ ValRec(ValId(`collections, `y),
              DOf(TypeId(`core, `F), [DArrow([A],C)])
              false
              true)
  rf $ ExternRec(ValId(`core, `x),
                 DOf(TypeId(`core, `F), [DArrow([A],C)]),
                 `x)
  rf $ ExternRec(ValId(`core, `x),
                 DOf(TypeId(`core, `F), [DArrow([A],C)]),
                 `xc)

  val fid1 = FnId(`core, `seq, 0, 0, [DAnd([A,B]), DTuple([A,B,C])])
  val fid2 = FnId(`core, `seq, 1, 1, [DAnd([DTVar(0),B]), DTuple([A,DCap(DTVar(1)),C])])
  for lostanza? in [true, false] do :
    for tail? in [true, false] do :
      rf $ FnRec(fid1,
                 DTuple([A,B]),
                 lostanza?,
                 tail?)
  for lostanza? in [true, false] do :
    for tail? in [true, false] do :
      rf $ FnRec(fid2,
                 DTuple([DTVar(0),B]),
                 lostanza?,
                 tail?)

  rf $ MultiRec(fid1, DTuple([A,B]))
  rf $ ExternFnRec(fid1, DTuple([A,B]), `seq)

  rf $ StructRec(TypeId(`core,`Int), 0, false, [], false)
  rf $ StructRec(TypeId(`core,`Int), 0, DOf(TypeId(`core, `F), [DArrow([A],C)]), [], false)
  rf $ StructRec(TypeId(`core,`Int), 1, DOf(TypeId(`core, `F), [DArrow([A],DTVar(0))]), [], false)
  rf $ StructRec(TypeId(`core,`Int), 0, false, [
    StructField(`a, A)
    StructField(`b, B)],
    false)
  rf $ StructRec(TypeId(`core,`Int), 0, false, [
    StructField(`a, A)
    StructField(`b, B)],
    StructField(`items, DPtrT(A)))

  rf $ TypeRec(TypeId(`core,`Int), 0, false, [])
  rf $ TypeRec(TypeId(`core,`Int), 0, false, [
    Child(TypeId(`core,`String), 1, DOf(TypeId(`core, `Int), [DTVar(0)]))])

  rf $ TypeDecl(TypeId(`core,`Int), 0, false)
  
;  val A = OfT("A", false)
;  val B = OfT("B", false)
;  val C = OfT("C", false)
;  val D = OfT("D", OrT(A, B))
;  println $ format(A)
;  println $ format(B)
;  println $ format(C)
;  println $ format(D)
;  println $ format(FnT(A,B))
;  println $ format(FnT(D,D))
;  println $ format(FnT(A, FnT(B, C)))
;  println $ format(FnT(FnT(A, B), FnT(C, D)))
;  println $ format(OfT("E", AndT(A,B)))
;  println $ format(OfT("E", FnT(A,B)))
;  println $ format(OfT("E", FnT(FnT(A, B), FnT(C, D))))
;  println $ format(OfT("E", AndT(A, FnT(A,B))))
;  println $ format(AndT(A, OrT(B, C)))
;  println $ format(OrT(AndT(A,B), C))