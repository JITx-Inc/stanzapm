defpackage fileinfo :
  import core
  import collections

;============================================================
;============ Constructing the FileInfoTable ================
;============================================================

defstruct FileInfoEntry :
  pc: Int
  info: FileInfo
with:
  printer => true

public deftype FileInfoTable
public defmulti get (t:FileInfoTable, pc:Int) -> FileInfo|False

public defn FileInfoTable () :
  val entries = fileinfo-entries()
  qsort!(pc, entries)
  new FileInfoTable :
    defmethod get (this, pc-key:Int) :
      match(bsearch(pc, entries, pc-key)) :
        (i:Int) : info(entries[i])
        (i:False) : false

public lostanza defn fileinfo-entries () -> ref<Array<FileInfoEntry>> :
  ;Retrieve info table
  readptr = call-prim fileinfo-table()

  ;Create array of entries
  val num-entries = read-long() as int
  val array = Array<FileInfoEntry>(new Int{num-entries})

  ;Begin reading entries
  for (var i:int = 0, i < num-entries, i = i + 1) :
    val pc = read-int()
    val filename = read-string()
    val line = read-int()
    val column = read-int()
    val info = FileInfo(filename, new Int{line}, new Int{column})
    set(array, new Int{i}, FileInfoEntry(new Int{pc}, info))

  ;Return array
  return array

lostanza var readptr:ptr<?>
lostanza defn read-long () -> long :
  val x = [readptr as ptr<long>]
  readptr = readptr + sizeof(long)
  return x
lostanza defn read-int () -> int :
  val x = [readptr as ptr<int>]
  readptr = readptr + sizeof(int)
  return x
lostanza defn read-string () -> ref<String> :
  val n = read-int()
  val s = String(n, readptr)
  readptr = readptr + (n + 3) & -4
  return s

defn bsearch<?T,?S> (key:T -> ?S&Comparable, xs:IndexedCollection<?T>, x:?S&Comparable) -> Int|False :
  ;Compute whether ascending/descending
  val n = length(xs)
  val multiplier =
    if n > 0 :
      if key(xs[0]) < key(xs[n - 1]) : 1
      else : -1
    else : 1
  let loop (start:Int = 0, end:Int = length(xs)) :
    if end > start :
      val center = (start + end) / 2
      val c = compare(x, key(xs[center])) * multiplier
      if c == 0 : center
      else if c < 0 : loop(start, center)
      else : loop(center + 1, end)

;============================================================
;============ Printing the Stack Trace ======================
;============================================================

public lostanza defn print-stack-trace () -> ref<False> :
  val infot = FileInfoTable()
  val co = core/current-coroutine
  co.stack.stack-pointer = call-prim stackframe()  
  print-stack-trace(co, infot)
  return false

public lostanza defn print-stack-trace (co:ref<core/RawCoroutine>, infot:ref<FileInfoTable>) -> ref<False> :
  labels :
    begin :
      goto loop(co)
    loop (co:ref<core/RawCoroutine>) :
      print-stack-trace(co.stack, infot)
      match(co.parent) :
        (p:ref<core/RawCoroutine>) : goto loop(p)
        (p:ref<False>) : ()
  return false

public lostanza defn print-stack-trace (stack:ref<core/Stack>, infot:ref<FileInfoTable>) -> ref<False> :
  ;Create buffer to store return addresses
  val return-buffer:ptr<long> = call-c clib/malloc(stack.size)
  var num-frames:int = 0

  ;Discover return addresses
  val end-sp = stack.stack-pointer
  labels :
    begin : goto loop(stack.frames)      
    loop (sp:ptr<core/StackFrame>) :
      ;Store in return buffer
      return-buffer[num-frames] = sp.return
      num-frames = num-frames + 1
      ;Continue if we're not at the end
      if sp < end-sp :
        val stackmap:ptr<int> = call-prim stack-map(sp.liveness-map)
        val num-slots = stackmap[0]
        val next-frame = addr(sp.slots[num-slots]) as ptr<core/StackFrame>
        goto loop(next-frame)

  ;Print out return buffer
  for (var i:int = num-frames - 1, i >= 0, i = i - 1) :
    val ret = return-buffer[i] as int
    match(get(infot, new Int{ret})) :
      (info:ref<FileInfo>) :
        val name = filename(info)
        val line = line(info)
        val col = column(info)
        call-c clib/printf("  at %s:%d:%d\n", addr!(name.chars), line.value, col.value)
      (info:ref<False>) : ()

  ;Free return buffer
  call-c clib/free(return-buffer)

  return false  
