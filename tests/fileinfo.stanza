defpackage fileinfo :
  import core
  import collections

defstruct FileInfoEntry :
  pc: Int
  entry: FileInfo
with:
  printer => true

deftype FileInfoTable
defmulti get (t:FileInfoTable, pc:Int) -> FileInfo|False
public defn FileInfoTable () :
  val entries = fileinfo-entries()
  println("===== BEFORE SORTING =====")
  do(println, entries)
  println("===== AFTER SORTING =====")
  qsort!(pc, entries)
  do(println, entries)
  new FileInfoTable :
    defmethod get (this, pc:Int) :
      false

public lostanza defn fileinfo-entries () -> ref<Array<FileInfoEntry>> :
  ;Retrieve info table
  readptr = call-prim fileinfo-table()

  ;Create array of entries
  val num-entries = read-long()
  val array = Array<FileInfoEntry>(new Int{num-entries as int})

  ;Begin reading entries
  for (var i:long = 0L, i < num-entries, i = i + 1L) :
    val pc = read-int()
    val filename = read-string()
    val line = read-int()
    val column = read-int()
    val info = FileInfo(filename, new Int{line}, new Int{column})
    set(array, new Int{i as int}, FileInfoEntry(new Int{pc}, info))

  ;Return array
  return array

lostanza var readptr:ptr<?>
lostanza defn read-long () -> long :
  val x = [readptr as ptr<long>]
  readptr = readptr + sizeof(long)
  return x
lostanza defn read-int () -> int :
  val x = [readptr as ptr<int>]
  readptr = readptr + sizeof(int)
  return x
lostanza defn read-string () -> ref<String> :
  val n = read-int()
  val s = String(n, readptr)
  readptr = readptr + (n + 3) & -4
  return s

;Binary search:
;  xs: Sorted array of something (T) (Can be ascending or descending).
;  key: Function for retrieving id of T
;  x: The id to search for
;Returns:
;  The index, i, at which key(xs[i]) is equal to x,
;  or false if there is no such element.
;Example:
;  val names = to-array<String>(["a" "ad" "apple" "acapaca" "apocalyptic"])
;  bsearch(length, names, 5) ;Search for the index of a name with length 5. Returns 2.
;  bsearch(length, names, 6) ;Search for the index of a name with length 6. Returns false.

public defn bsearch<?T,?S> (key:T -> ?S&Comparable, xs:IndexedCollection<?T>, x:?S&Comparable) -> Int|False :
  ;Compute whether ascending/descending
  val n = length(xs)
  val multiplier =
    if n > 0 :
      if key(xs[0]) < key(xs[n - 1]) : 1
      else : -1
    else : 1
  let loop (start:Int = 0, end:Int = length(xs)) :
    if end > start :
      val center = (start + end) / 2
      val c = compare(x, key(xs[center])) * multiplier
      if c == 0 : center
      else if c < 0 : loop(start, center)
      else : loop(center + 1, end)