;============================================================
;===================== Test 0 ===============================
;============================================================
;class 0 ()
;
;func 0 () :
;  def L0 : ref (local 0)
;  def L1 : int (local 1)
;  def L2 : int (local 2)
;  reserve 1, 8
;  L0 = alloc<0> 8
;  L0[0] = 0
;  L0[4] = 1
;  dump (L0)
;  label 0
;    L1 = L0[0]
;    L2 = L0[4]
;    dump (L1, L2)
;    goto 1 when gt L2 10
;    (L1 L2) = call 1 (L1 L2)
;    L0[0] = L1
;    L0[4] = L2
;  goto 0
;  label 1
;  return ()
;
;func 1 (L0 L1) :
;  def L0 : int (local 0)
;  def L1 : int (local 1)
;  L0 = add L0 L1
;  L1 = add L1 1
;  return (L0 L1)
;
;============================================================
;====================== Test 1 ==============================
;============================================================
;
;class 0 ()
;class 1 ()
;class 2 (0, 1)
;class 3 (1)
;class 4 (3)
;
;func 0 () :
;  def L0 : ref (local 0)
;  def L1 : int (local 1)
;  def L2 : int (local 2)
;  def L3 : int (local 3)
;  def L4 : int (local 4)
;  def L5 : int (local 5)
;  reserve 1, 8
;  L0 = alloc<4> 8
;  L1 = instanceof<0> L0
;  L2 = instanceof<1> L0
;  L3 = instanceof<2> L0
;  L4 = instanceof<3> L0
;  L5 = instanceof<4> L0
;  return ()
;
;============================================================
;====================== Test 2 ==============================
;============================================================
;
;class 0 ()
;
;func 0 () :
;  def L0 : ref (local 0)
;  def L1 : int (local 1)
;  reserve 1, 24
;  L0 = alloc<0> 24
;  L0[0] = 1L
;  L0[8] = F1
;  L0[16] = 42L
;  L1 = 40L
;  (L1) = call-closure L0 (L0 L1)
;  dump (L1)
;  return ()
;  
;func 1 (L0 L1) :
;  def L0 : ref (local 0)
;  def L1 : long (local 1)
;  def L2 : long (local 0)
;  L2 = L0[16]
;  L2 = add L2 L1
;  return (L2)
;
;============================================================
;======================== Test 3 ============================
;============================================================

func 0 () :
  def L0 : ref (local 0)
  def L1 : ref (local 1)
  def L2 : int (local 2)
  L0 = new-stack F1
  L1 = current-stack
  (L2) = yield L0 (L1, 42)
  dump (L2)
  return ()

func 1 (L0, L1) :
  def L0 : ref (local 0)
  def L1 : int (local 1)
  label 0
    () = yield L0 (L1)
    L1 = add L1 3
  goto 0
  
  
