;============================================================
;===================== Test 0 ===============================
;============================================================
;class 0 ()
;
;func F0 () :
;  def L0 : ref (local 0)
;  def L1 : double (local 1)
;  def L2 : double (local 2)
;  (L0) = alloc<0> (16)
;  L0[0] = 0.0
;  L0[8] = 1.0
;  dump (L0)
;  label 0
;    L1 = L0[0]
;    L2 = L0[8]
;    dump (L1, L2)
;    goto 1 when gt L2 10.0
;    live (L0)
;    (L1 L2) = call 1 (L1 L2)
;    L0[0] = L1
;    L0[8] = L2
;  goto 0
;  label 1
;  return ()
;
;func F1 (L0 L1) :
;  def L0 : double (local 0)
;  def L1 : double (local 1)
;  L0 = add L0 L1
;  L1 = add L1 1.0
;  return (L0 L1)
;
;============================================================
;====================== Test 1 ==============================
;============================================================
;
;class 0 ()
;class 1 ()
;class 2 (0, 1)
;class 3 (1)
;class 4 (3)
;
;func F0 () :
;  def L0 : ref (local 0)
;  def L1 : long (local 1)
;  def L2 : long (local 2)
;  def L3 : long (local 3)
;  def L4 : long (local 4)
;  def L5 : long (local 5)
;  reserve 1, 8
;  L0 = alloc<4> 8
;  L1 = instanceof<0> L0
;  L2 = instanceof<1> L0
;  L3 = instanceof<2> L0
;  L4 = instanceof<3> L0
;  L5 = instanceof<4> L0
;  dump (L1, L2, L3, L4, L5)
;  return ()
;
;============================================================
;====================== Test 2 ==============================
;============================================================
;
;class 0 ()
;
;func F0 () :
;  def L0 : ref (local 0)
;  def L1 : int (local 1)
;  reserve 1, 24
;  L0 = alloc<0> 24
;  L0[0] = 1L
;  L0[8] = F1
;  L0[16] = 42L
;  L1 = 40L
;  live (L0)
;  (L1) = call-closure L0 (L0 L1)
;  dump (L1)
;  return ()
;  
;func F1 (L0 L1) :
;  def L0 : ref (local 0)
;  def L1 : long (local 1)
;  def L2 : long (local 0)
;  L2 = L0[16]
;  L2 = add L2 L1
;  return (L2)
;
;============================================================
;======================== Test 3 ============================
;============================================================
;
;func F0 () :
;  def L0 : ref (local 0)
;  def L1 : ref (local 1)
;  def L2 : int (local 2)
;  L0 = new-stack F2
;  L1 = current-stack
;  label 0
;    live (L0)
;    (L2) = yield L0 (L1)
;    dump (L2)
;  goto 0
;  return ()
;
;func F2 (L0) :
;  def L0 : ref (local 0)  
;  () = call F1 (L0, 1)
;
;func F1 (L0, L1) :
;  def L0 : ref (local 0)
;  def L1 : int (local 1)
;  def L2 : int (local 1)
;  live (L0)
;  () = yield L0 (L1)
;  L2 = add L1 2
;  () = call F1 (L0, L2)
;
;============================================================
;======================== Test 3 ============================
;============================================================
;
;;Test out Calling C
;
;extern E0 helloworld
;extern E1 squared
;extern E2 myglobal
;
;func F0 () :
;  def L0 : long (local 0)
;  def L1 : long (local 1)
;  def L2 : float (local 2)
;  def L3 : double (local 3)
;  L0 = 42L
;  L1 = 24L
;  (L0) = call-c E0 (L0, L1)
;  dump (L0, L1)
;
;  L3 = E2[0]
;  dump (L3)
;
;  L2 = 49.0f
;  (L2) = call-c E1 (L2)
;
;  L3 = E2[0]
;  dump (L3)
;
;  () = call-c E1 (L2)
;
;  L3 = E2[0]
;  dump (L3)  
;  
;  return ()
;
;============================================================
;========================= Test 4 ===========================
;============================================================
;
;global G0 (size = 8, position = 0)
;global G1 (size = 8, position = 8)
;
;func F0 () :
;  def L0 : long (local 0)
;  G0[0] = 42L
;  G1[0] = 24L
;  L0 = G0[0]
;  dump (L0)
;  L0 = G1[0]
;  dump (L0)
;  return ()
;
;============================================================
;===================== Test 5 ===============================
;============================================================
;class 0 ()
;
;func F0 () :
;  () = call F1 (2, 42L)
;  () = call F1 (3, 42L, 43L)
;  () = call F1 (4, 42L, 43L, 44L, 45L)
;  return ()
;
;multi F1 (0) :
;  2 => func F2 (L0 L1) :
;    def L0 : long (local 0)
;    def L1 : long (local 1)
;    dump (L0, L1)
;    return ()
;  3 => func F3 (L0 L1 L2) :
;    def L0 : long (local 0)
;    def L1 : long (local 1)
;    def L2 : long (local 2)
;    dump (L0, L1, L2)
;    return ()
;

;============================================================
;===================== Test 6 ===============================
;============================================================
;class 0 ()
;global G0 (size = 8, position = 0, roots = ())
;global G1 (size = 8, position = 8, roots = (0))
;
;func F0 () :
;  def L0 : ref (local 0)
;  def L1 : int (local 1)
;  label 0
;    dump (L1)
;    (L0) = alloc<0> (48)
;    L1 = add L1 1
;  goto 0
;  return ()
;
;
;============================================================
;===================== Test 7 ===============================
;============================================================
;class 0 ()
;global G0 (size = 8, position = 0, roots = ())
;global G1 (size = 8, position = 8, roots = (0))
;
;func F0 () :
;  def L0 : ref (local 0)
;  def L1 : double (local 1)
;  def L2 : double (local 2)
;  G0[0] = 42L
;  G1[0] = 43L
;  (L0) = alloc<0> (16)
;  L0[0] = 0.0
;  L0[8] = 1.0
;  dump (L0)
;  label 0
;    L1 = L0[0]
;    L2 = L0[8]
;    dump (L1, L2)
;    goto 1 when gt L2 10.0
;    live (L0)
;    (L1 L2) = call 1 (L1 L2)
;    L0[0] = L1
;    L0[8] = L2
;  goto 0
;  label 1
;  return ()
;
;func F1 (L0 L1) :
;  def L0 : double (local 0)
;  def L1 : double (local 1)
;  L0 = add L0 L1
;  L1 = add L1 1.0
;  live ()
;  () = call F2 ()
;  return (L0 L1)
;
;func F2 () :
;  def L0 : ref (local 0)
;  def L1 : int (local 1)
;  live (L0)
;  label 0
;    dump (L0)
;    dump (L1)
;    (L0) = alloc<0> (48)
;    L1 = add L1 1
;  goto 0
;  return ()

;============================================================
;======================= Test 8 =============================
;============================================================
;
;class 0 ()
;class 1 () (size = 32, roots = ()) ;STACK
;class 2 () (size = 8, roots = ())
;class 3 () (size = 16, roots = (0, 1))
;class 4 () (base-size = 8, item-size = 8, base-roots = (), item-roots = ())
;
;func F0 () :
;  def L0:ref (local 0)
;  live ()
;  (L0) = call F2 ()
;  live (L0)
;  () = call F1 ()
;  () = call F3 (L0)
;  return ()
;
;;Blow out the heap
;func F1 () :
;  def L0 : ref (local 0)
;  def L1 : int (local 1)
;  live ()
;  L1 = 0
;  label 0
;    goto 1 when ge L1 10
;    (L0) = alloc<4> (1024)
;    L0[0] = 127L
;    L1 = add L1 1
;  goto 0
;  label 1  
;  return ()
;
;;Construct tree
;func F2 () :
;  def L0:ref (local 0)
;  def L1:ref (local 1)
;  def L2:ref (local 2)
;  def L3:ref (local 3)
;  def L4:ref (local 4)
;  live ()
;  (L0, L1, L2, L3, L4) = alloc<3,3,2,2,2> (16, 16, 8, 8, 8)
;  L2[0] = 42L
;  L3[0] = 43L
;  L4[0] = 44L
;  L1[0] = L2
;  L1[8] = L3
;  L0[0] = L1
;  L0[8] = L4
;  return (L0)
;
;;Dump tree
;func F3 (L0) :
;  def L0:ref (local 0)
;  def L1:ref (local 1)
;  def L2:ref (local 2)
;  live ()
;  L1 = L0[8]
;  () = call F4 (L1)
;  L0 = L0[0]
;  L1 = L0[0]
;  L2 = L0[8]
;  live (L1, L2)
;  () = call F4 (L1)
;  () = call F4 (L2)
;  return ()
;  
;;Dump unit
;func F4 (L0) :
;  def L0:ref (local 0)
;  def L1:long (local 0)
;  L1 = L0[0]
;  dump (L1)
;  return ()

;============================================================
;================= Coroutine Allocation =====================
;============================================================

class 0 ()
class 1 () (size = 32, roots = ()) ;STACK
class 2 () (size = 8, roots = ())
class 3 () (size = 16, roots = (0, 1))
class 4 () (base-size = 8, item-size = 8, base-roots = (), item-roots = ())

func F0 () :
  def L0:ref (local 0)
  def L1:ref (local 1)
  def L2:long (local 2)
  live ()
  L0 = new-stack F5
  L1 = current-stack
  live (L0, L1)
  label 0  
    (L2) = yield L0 (L1)
    dump (L2)
  goto 0
  return ()

;Blow out the heap
func F1 () :
  def L0 : ref (local 0)
  def L1 : int (local 1)
  live ()
  L1 = 0
  label 0
    goto 1 when ge L1 10
    (L0) = alloc<4> (1024)
    L0[0] = 127L
    L1 = add L1 1
  goto 0
  label 1  
  return ()

;Construct tree
func F2 () :
  def L0:ref (local 0)
  def L1:ref (local 1)
  def L2:ref (local 2)
  def L3:ref (local 3)
  def L4:ref (local 4)
  live ()
  (L0, L1, L2, L3, L4) = alloc<3,3,2,2,2> (16, 16, 8, 8, 8)
  L2[0] = 42L
  L3[0] = 43L
  L4[0] = 44L
  L1[0] = L2
  L1[8] = L3
  L0[0] = L1
  L0[8] = L4
  return (L0)

;Dump tree
func F3 (L0) :
  def L0:ref (local 0)
  def L1:ref (local 1)
  def L2:ref (local 2)
  live ()
  L1 = L0[8]
  () = call F4 (L1)
  L0 = L0[0]
  L1 = L0[0]
  L2 = L0[8]
  live (L1, L2)
  () = call F4 (L1)
  () = call F4 (L2)
  return ()
  
;Dump unit
func F4 (L0) :
  def L0:ref (local 0)
  def L1:long (local 0)
  L1 = L0[0]
  dump (L1)
  return ()

func F5 (L0) :
  def L0 : ref (local 0)
  live ()
  () = call F6 (L0, 1)

func F6 (L0, L1) :
  def L0 : ref (local 0)
  def L1 : int (local 1)
  def L2 : int (local 1)
  def L3 : ref (local 2)
  live (L0)
  (L3) = call F2 ()
  live (L0 L3)
  () = yield L0 (L1)
  () = call F3 (L3) 
  L2 = add L1 2
  () = call F6 (L0, L2)