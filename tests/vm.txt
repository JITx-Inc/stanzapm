;============================================================
;===================== Test 0 ===============================
;============================================================
class 0 ()

func 0 () :
  def L0 : ref (local 0)
  def L1 : float (local 1)
  def L2 : float (local 2)
  reserve 1, 8
  L0 = alloc<0> 8
  L0[0] = 0.0f
  L0[4] = 1.0f
  dump (L0)
  label 0
    L1 = L0[0]
    L2 = L0[4]
    dump (L1, L2)
    goto 1 when gt L2 10.0f
    (L1 L2) = call 1 (L1 L2)
    L0[0] = L1
    L0[4] = L2
  goto 0
  label 1
  return ()

func 1 (L0 L1) :
  def L0 : float (local 0)
  def L1 : float (local 1)
  L0 = add L0 L1
  L1 = add L1 1.0f
  return (L0 L1)

;============================================================
;====================== Test 1 ==============================
;============================================================
;
;class 0 ()
;class 1 ()
;class 2 (0, 1)
;class 3 (1)
;class 4 (3)
;
;func 0 () :
;  def L0 : ref (local 0)
;  def L1 : long (local 1)
;  def L2 : long (local 2)
;  def L3 : long (local 3)
;  def L4 : long (local 4)
;  def L5 : long (local 5)
;  reserve 1, 8
;  L0 = alloc<4> 8
;  L1 = instanceof<0> L0
;  L2 = instanceof<1> L0
;  L3 = instanceof<2> L0
;  L4 = instanceof<3> L0
;  L5 = instanceof<4> L0
;  dump (L1, L2, L3, L4, L5)
;  return ()
;
;============================================================
;====================== Test 2 ==============================
;============================================================
;
;class 0 ()
;
;func 0 () :
;  def L0 : ref (local 0)
;  def L1 : int (local 1)
;  reserve 1, 24
;  L0 = alloc<0> 24
;  L0[0] = 1L
;  L0[8] = F1
;  L0[16] = 42L
;  L1 = 40L
;  (L1) = call-closure L0 (L0 L1)
;  dump (L1)
;  return ()
;  
;func 1 (L0 L1) :
;  def L0 : ref (local 0)
;  def L1 : long (local 1)
;  def L2 : long (local 0)
;  L2 = L0[16]
;  L2 = add L2 L1
;  return (L2)
;
;============================================================
;======================== Test 3 ============================
;============================================================
;
;func 0 () :
;  def L0 : ref (local 0)
;  def L1 : ref (local 1)
;  def L2 : int (local 2)
;  L0 = new-stack F2
;  L1 = current-stack
;  label 0
;    (L2) = yield L0 (L1)
;    dump (L2)
;  goto 0
;  return ()
;
;func 2 (L0) :
;  def L0 : ref (local 0)
;  () = call F1 (L0, 1)
;
;func 1 (L0, L1) :
;  def L0 : ref (local 0)
;  def L1 : int (local 1)
;  def L2 : int (local 1)
;  () = yield L0 (L1)
;  L2 = add L1 2
;  () = call F1 (L0, L2)
