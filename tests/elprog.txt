;<COMMENT>
deftype MyType
defmulti increment (t:MyType) -> Int

public defn MyType (i:Int) :
  var start:Int = i
  new MyType :
    defmethod increment (this) :
      val s = start
      start = start + 1
      s

let :
  val x = MyType(0)
  increment(x)
;<COMMENT>

;<COMMENT>
USE THE FOLLOWING IDS:
  Int is T3
  MyType is T40
  increment is V40
  i is V41
  start is V42
  s is V43
  this is V44
  MyType is V45
  x is V46
  ret is V47
  new MyType is O0  
;<COMMENT>

package A : ()
package A :
  ;deftype MyType
  deftype T40 ()
  
  ;defmulti increment (t:MyType) -> Int
  defmulti V40<> (ref<T40>) -> ref<T3>

  ;defn MyType (i:Int) -> MyType
  defn V45 fn<> (V41:ref<T3>) -> ref<T40> :
    ;var start:Int
    defvar V42:ref<T3>
    ;val ret:MyType
    defval V47:ref<T40>
    ;object O0 <: MyType
    defobj O0 <: ref<T40> :
      defmethod V40<> (this = V44) fn<> (V44:ref<T40>) -> ref<T3> :
        defval V43:ref<T3>
        defval V45:ref<T3>
        V43 = V42
        V45 = prim int-add(V42, V{1})
        store V42 = V45
        return V43
    V42 = V41
    V47 = new O0
    return V47

  init :
    defval V46:ref<T40>
    defval V48:ref<T3>
    V46 = check-do V45(V{0}:ref<T3>)
    V48 = check-do V40(V46:ref<T40>)
    
  
  ;defn F100 fn<> () -> ref<T100> :
  ;  defvar V104:ref<T100>
  ;  V100:ref<T101> = check-do V101(V102:ref<T101>, V104:ref<T102>)
  ;  V104 = V102


  ;defmethod V0<TV1,TV0> (id = V1) fn<TV0,TV1> () -> int :
  ;  V2:TV0 = load V1
  ;  V3:TV1 = load V2
  ;
  ;defn V6 fn<> (V4:byte, V8:ref<T11>) -> int : ()
  ;defn V7 fn<> (V4:long, V9:ref<T12>) -> long : ()
  ;  
  ;
  ;defn V1 fn<> (V4:byte, V6:long) -> int :
  ;  V2 = mix(V1<>, V6<>, V7<>)
  ;  V2 = V3
  ;  do V1(V4, V5)
