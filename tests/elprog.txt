;<COMMENT>
deftype MyType
defmulti increment (t:MyType) -> Int

public defn MyType (i:Int) :
  var start:Int = i
  new MyType :
    defmethod increment (this) :
      val s = start
      start = start + 1
      s

let :
  val x = MyType(0)
  increment(x)
;<COMMENT>

;<COMMENT>
USE THE FOLLOWING IDS:
  Int is T3
  Box is T4
  cast-error is V100

  MyType is T40
  increment is V49
  i is V41
  start is V42
  s is V43
  this is V44
  MyType is V45
  x is V46
  ret is V47
  new MyType is O0  
;<COMMENT>



package core : (
  export 4 struct T(core,Box)<0> : (top)
  export 3 struct T(core,Int)<0> : (int)
  export 100 lsfn(F<0>(core,cast-error,[]) -> int)
)

package core :
  ;deftype Box
  defstruct T4 :
    top

  ;deftype Int
  defstruct T3 :
    int

  ;cast-error
  defn V100 fn<> () -> int :
    return LV{0}

  ;deftype MyType
  deftype T40 ()
  
  ;defmulti increment (t:MyType) -> Int
  defmulti V49<> (ref<T40>) -> ref<T3>

  ;defn MyType (i:Int) -> MyType
  defn V45 fn<> (V41:ref<T3>) -> ref<T40> :
    ;var start:Int
    defvar V42:ref<T3>
    ;val ret:MyType
    defval V47:ref<T40>
    ;object O0 <: MyType
    defobj O0 <: ref<T40> :
      defmethod V49<> (this = V44) fn<> (V44:ref<T40>) -> ref<T3> :
        defval V43:ref<T3>
        defval V45:ref<T3>
        V43 = V42
        V45 = prim int-add(V42, V{1})
        store V42 = V45
        return V43
    V42 = V41
    V47 = new O0
    return V47

  init :
    defval V46:ref<T40>
    defval V48:ref<T3>
    V46 = check-do V45(V{0}:ref<T3>)
    V48 = check-do V49(V46:ref<T40>)
    
  
