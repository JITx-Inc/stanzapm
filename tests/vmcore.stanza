;Phases to be handled
;- booting
;- core library

;################################################################################
;############################## C Library #######################################
;################################################################################

;================================================================================
;================================ Boot Sequence =================================
;================================================================================

defpackage clib

protected extern printf: (ptr<byte>, ? ...) -> int
protected extern memcpy: (ptr<?>, ptr<?>, long) -> int
protected extern exit: int -> int

;################################################################################
;############################## Core Library ####################################
;################################################################################

;================================================================================
;=============================== Boot Sequence ==================================
;================================================================================

defpackage core

;============================================================
;===================== Internal Types =======================
;============================================================

lostanza deftype Fn :
   length: long
   code: ptr<?>
   free: ref<?> ...
lostanza deftype Box :
   item: ref<?>
lostanza deftype Type :
   length: long
   code: ptr<?>
   free: ref<?> ...
lostanza deftype Frame :
  return: long
  liveness-map: long
  slots: long ...
lostanza deftype Stack :
  size: long
  frames: ptr<Frame>
  stack-pointer: ptr<Frame>
  pc: int

;============================================================
;================== Internal Callbacks ======================
;============================================================

lostanza defn halt-system () -> ref<Void> :
  call-c clib/printf("HALT\n")
  call-c clib/exit(-1)
  return 0L as ref<Void>

lostanza defn unreachable-error () -> ref<Void> :
  return halt-system()

lostanza defn fatal (msg:ptr<byte>) -> ref<Void> :
  call-c clib/printf("%s\n", msg)
  return halt-system()

;============================================================
;======================= Core Types =========================
;============================================================

public lostanza deftype Byte :
  value: byte
  
public lostanza deftype Char :
  value: byte

public lostanza deftype Int :
  value: int

public lostanza deftype Long :
  value: long

public lostanza deftype Float :
  value: float

public lostanza deftype Double :
  value: double

public lostanza deftype String :
  length: long
  hash: int
  chars: byte ...

public deftype Symbol
public lostanza deftype StringSymbol <: Symbol :
  name: ref<String>

public lostanza deftype True
public lostanza deftype False

public lostanza deftype Tuple<T> :
  length: long
  items: ref<T> ...

public deftype List<T>
public lostanza deftype FullList<T> <: List<T> :
  head: ref<T>
  tail: ref<List<T>>
public lostanza deftype NilList <: List<Void>

;============================================================
;================ Constant Initialization ===================
;============================================================

lostanza var const-ptr:ptr<?>
lostanza val BYTE-CONST-TAG : int = 0
lostanza val CHAR-CONST-TAG : int = 1
lostanza val INT-CONST-TAG : int = 2
lostanza val LONG-CONST-TAG : int = 3
lostanza val FLOAT-CONST-TAG : int = 4
lostanza val DOUBLE-CONST-TAG : int = 5
lostanza val TRUE-CONST-TAG : int = 6
lostanza val FALSE-CONST-TAG : int = 7
lostanza val LIST-CONST-TAG : int = 8
lostanza val STRING-CONST-TAG : int = 9
lostanza val SYMBOL-CONST-TAG : int = 10
lostanza val TYPE-CONST-TAG : int = 11
lostanza val FN-CONST-TAG : int = 12

lostanza defn initialize-constants () -> ref<False> :
  ;Initialize read pointer to beginning of the constant table
  ;[num, constants ...]
  const-ptr = call-prim consts-data()
  val n-consts = read-const-int()

  ;First n-consts entries in the global table are for constants
  var cs:ptr<ref<?>> = call-prim consts()
  for (var i:int = 0, i < n-consts, i = i + 1) :
    cs[i] = read-const()

  return false

lostanza defn read-const () -> ref<?> :
  val tag = read-const-int()
  if tag == BYTE-CONST-TAG :
    return new Byte{read-const-byte()}
  else if tag == CHAR-CONST-TAG :
    return new Char{read-const-byte()}
  else if tag == INT-CONST-TAG :
    return new Int{read-const-int()}
  else if tag == LONG-CONST-TAG :
    return new Long{read-const-long()}
  else if tag == FLOAT-CONST-TAG :
    return new Float{read-const-float()}
  else if tag == DOUBLE-CONST-TAG :
    return new Double{read-const-double()}
  else if tag == TRUE-CONST-TAG :
    return true
  else if tag == FALSE-CONST-TAG :
    return false
  else if tag == LIST-CONST-TAG :
    val len = read-const-int()
    return read-const-list(len)
  else if tag == STRING-CONST-TAG :
    val len = read-const-int()
    val chars = read-const-chars(len)
    return String(len, chars)
  else if tag == SYMBOL-CONST-TAG :
    val len = read-const-int()
    val chars = read-const-chars(len)
    return new StringSymbol{String(len, chars)}
  else if tag == TYPE-CONST-TAG :
    val code = read-const-long() as ptr<?>
    return new Type{0, code}
  else if tag == FN-CONST-TAG :
    val code = read-const-long() as ptr<?>
    return new Fn{0, code}
  else :
    call-c clib/printf("Unknown constant tag: %d\n", tag)
    return halt-system()

lostanza defn read-const-list (n:int) -> ref<List> :
  if n == 0 : return new NilList{}
  else : return new FullList{read-const(), read-const-list(n - 1)}

lostanza defn read-const-byte () -> byte :
  val value = [const-ptr as ptr<byte>]
  const-ptr = const-ptr + sizeof(byte)
  return value

lostanza defn read-const-int () -> int :
  val value = [const-ptr as ptr<int>]
  const-ptr = const-ptr + sizeof(int)
  return value

lostanza defn read-const-long () -> long :
  val value = [const-ptr as ptr<long>]
  const-ptr = const-ptr + sizeof(long)
  return value

lostanza defn read-const-float () -> float :
  val value = [const-ptr as ptr<float>]
  const-ptr = const-ptr + sizeof(float)
  return value

lostanza defn read-const-double () -> double :
  val value = [const-ptr as ptr<double>]
  const-ptr = const-ptr + sizeof(double)
  return value

lostanza defn read-const-chars (len:long) -> ptr<byte> :
  val value = const-ptr as ptr<byte>
  ;length chars + 0 character + pad to nearest 4 bytes
  val n = (len + 4) & -4
  const-ptr = (const-ptr + n) as ptr<?>
  return value

initialize-constants()

;============================================================
;==================== Boot Functions ========================
;============================================================

public lostanza defn String (len:long) -> ref<String> :
  return new String{len + 1, 0}

public lostanza defn String (len:long, chars:ptr<byte>) -> ref<String> :
  val s = String(len)
  call-c clib/memcpy(addr!(s.chars), chars, len)
  s.chars[len] = 0 as byte
  return s

;============================================================
;=================== Winders ================================
;============================================================
defstruct Winder :
  in: False|(() -> ?)
  out: False|(? -> ?)
   
var WINDER-STACK:List<Winder> = List()
var NUM-WINDERS = 0

defn pop-winder () :
  val w = head(WINDER-STACK)
  WINDER-STACK = tail(WINDER-STACK)
  NUM-WINDERS = NUM-WINDERS - 1
  w

defn push-winder (w:Winder) :
  WINDER-STACK = cons(w, WINDER-STACK)
  NUM-WINDERS = NUM-WINDERS + 1

defn pop-winders (n:Int) :
  defn pop (n:Int) :
    if n > 0 : cons(pop-winder(), pop(n - 1))
    else : List()
  pop(NUM-WINDERS - n)   

defn push-winders (ws:List<Winder>) :
  if not empty?(ws) :
    push-winders(tail(ws))
    push-winder(head(ws))

defn total-winders (c:False|RawCoroutine) -> Int :
  match(c) :
    (c:False) : 0
    (c:RawCoroutine) : total-winders(parent(c)) + num-winders(c)

defn wind-in (ws:List<Winder>) :
  if not empty?(ws) :
    wind-in(tail(ws))
    call?(in(head(ws)))

defn wind-out (ws:List<Winder>, f:True|False) :
  if not empty?(ws) :
    call?(out(head(ws)), f)
    wind-out(tail(ws), f)

defn* call? (f: False|(() -> ?)) :
  match(f) :
    (f:() -> ?) : f()
    (f:False) : false

defn* call? (f: False|(? -> ?), x: ?) :
  match(f) :
    (f:? -> ?) : f(x)
    (f:False) : false

lostanza defn inc-winders (c:ref<RawCoroutine>, n:ref<Int>) -> ref<False> :
  c.num-winders = c.num-winders + n.value
  return false
      
public defn dynamic-wind<?T> (in:False|(() -> ?),
                              body:() -> ?T,
                              out:False|(True|False -> ?)) -> T :
  call?(in)
  push-winder(Winder(in, out))
  inc-winders(current-coroutine, 1)
  val result = body()
  pop-winder()
  inc-winders(current-coroutine, -1)
  call?(out, true)
  result

;============================================================
;====================== Coroutines ==========================
;============================================================

public deftype Coroutine<I,O>
public defmulti active? (c:Coroutine) -> True|False
public defmulti open? (c:Coroutine) -> True|False
public defmulti resume<?I,?O> (c:Coroutine<?I,?O>, x:I) -> O
public defmulti suspend<?I,?O> (c:Coroutine<?I,?O>, x:O) -> I
public defmulti break<?O> (c:Coroutine<?,?O>, x:O) -> Void
public defmulti close (c:Coroutine) -> False

public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O> :
  RawCoroutine(enter)

lostanza deftype RawCoroutine <: Coroutine :
  stack: ref<Stack>
  parent: ref<False|RawCoroutine>
  status: ref<Int>
  num-winders: int

lostanza deftype CoroutineParams :
  parent-stack: ref<Stack>
  coroutine: ref<RawCoroutine>
  enter: ref<((RawCoroutine, ?) -> ?)>

val COROUTINE-ACTIVE = 0
val COROUTINE-CLOSED = 1
val COROUTINE-SUSPENDED = 2
val COROUTINE-OPEN = 3

lostanza var current-coroutine:ref<RawCoroutine> =
  new RawCoroutine{call-prim stack(), false, COROUTINE-ACTIVE, 0}

public lostanza defn RawCoroutine (enter:ref<((RawCoroutine, ?) -> ?)>) -> ref<RawCoroutine> :
  val current-stack = call-prim stack()
  val stack = call-prim new-stack(addr(setup-coroutine))
  val c = new RawCoroutine{stack, false, COROUTINE-OPEN, 0}
  call-prim enter-stack(stack, new CoroutineParams{current-stack, c, enter})
  return c

lostanza defmethod active? (c:ref<RawCoroutine>) -> ref<True|False> :
  if c.status == COROUTINE-ACTIVE : return true
  else : return false

lostanza defmethod open? (c:ref<RawCoroutine>) -> ref<True|False> :
  if c.status == COROUTINE-OPEN : return true
  else : return false

lostanza defn* setup-coroutine (params:ref<CoroutineParams>) -> ref<?> :
  val x0 = call-prim yield(params.parent-stack, false)
  val enter = params.enter
  return break(params.coroutine, [enter](params.coroutine, x0))  

lostanza defmethod resume (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
  ;Ensure coroutine is re-entrant
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot resume coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-ACTIVE :
    return fatal("Cannot resume coroutine. Coroutine is already active.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot resume coroutine. Coroutine's parent is suspended.")  

  ;Adjust state
  attach-coroutine(c)

  ;Begin execution
  return call-prim yield(current-coroutine.stack, x)

lostanza defmethod* suspend (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
  ;Ensure coroutine is active
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot suspend coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-OPEN :
    return fatal("Cannot suspend coroutine. Coroutine is already suspended.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot suspend coroutine. Coroutine is already suspended.")

  ;Set target winder environment and wind out
  val winders = pop-winders(total-winders(c.parent))
  wind-out(winders, false)

  ;Detach coroutine
  detach-coroutine(c)

  ;Return to resume
  val result = call-prim yield(current-coroutine.stack, x)

  ;Wind in and restore original winder environment
  wind-in(winders)
  push-winders(winders)

  ;Return execution
  return result

lostanza defmethod close (c:ref<RawCoroutine>) -> ref<False> :
  ;Ensure coroutine is re-entrant
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot close coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-ACTIVE :
    return fatal("Cannot close coroutine. Coroutine is active.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot close coroutine. Coroutine's parent is suspended.")
  free-coroutine(c)
  return false

lostanza defmethod break (c:ref<RawCoroutine>, x:ref<?>) -> ref<Void> :
  ;Ensure coroutine is active
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot break from coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-OPEN :
    return fatal("Cannot break from coroutine. Coroutine is already suspended.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot break from coroutine. Coroutine is already suspended.")

  ;Set target winder environment and wind out
  val winders = pop-winders(total-winders(c.parent))
  wind-out(winders, false)

  ;Adjust state
  detach-coroutine(c)
  free-coroutine(c)
  
  ;Begin execution
  return call-prim yield(current-coroutine.stack, x)

lostanza defn free-coroutine (c:ref<RawCoroutine>) -> int :
  labels :
    begin :
      goto loop(c)
    loop (c:ref<RawCoroutine>) :
      val parent = c.parent
      c.parent = false
      c.status = COROUTINE-CLOSED
      ;free-stacks(top(c), bottom(c))
      match(parent) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : return 0  

lostanza defn attach-coroutine (c:ref<RawCoroutine>) -> int :
  labels :
    begin :
      goto loop(c)
    loop (c:ref<RawCoroutine>) :
      val p = c.parent
      c.parent = current-coroutine
      c.status = COROUTINE-ACTIVE
      current-coroutine = c
      match(p) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : return 0

lostanza defn detach-coroutine (c:ref<RawCoroutine>) -> int :
  labels :
    begin :
      goto loop(false)
    loop (tail:ref<RawCoroutine|False>) :
      val cc = current-coroutine
      val ccp = current-coroutine.parent as ref<RawCoroutine>
      cc.parent = tail
      current-coroutine = ccp
      if cc == c :
        cc.status = COROUTINE-OPEN
        return 0
      else :
        cc.status = COROUTINE-SUSPENDED
        goto loop(cc)

;============================================================
;======================== Core Primitives ===================
;============================================================

;################################################################################
;################################## Scratchpad ##################################
;################################################################################

;defpackage scratchpad :
;  import core

public defn plus (a:Int, b:Int) -> Int :
  ($prim add a b)

lostanza defn println-num (x:ref<Int>) -> ref<False> :
  call-c clib/printf("%d\n", x.value)
  return false

lostanza defn println-str (x:ref<String>) -> ref<False> :
  call-c clib/printf("%s\n", addr!(x.chars))
  return false

defn main () :
  val c = Coroutine<Int,Int> $ fn (co, x0) :
    println-str("x0 = ")
    println-num(x0)
    val x1 = suspend(co, 42)
    println-str("x1 = ")
    println-num(x1)
    val x2 = suspend(co, 43)
    println-str("x2 = ")
    println-num(x2)
    44
  println-str("enter")
  val y0 = resume(c, -42)
  println-str("y0 = ")
  println-num(y0)
  val y1 = resume(c, -43)
  println-str("y1 = ")
  println-num(y1)
  val y2 = resume(c, -44)
  println-str("y2 = ")
  println-num(y2)

main()