;################################################################################
;############################## C Library #######################################
;################################################################################

;================================================================================
;================================ Boot Sequence =================================
;================================================================================

defpackage clib

protected extern memcpy: (ptr<?>, ptr<?>, long) -> int
protected extern remove: (ptr<byte>) -> int
protected extern ftell: (ptr<?>) -> long
protected extern fclose: (ptr<?>) -> int
protected extern fflush: (ptr<?>) -> int
protected extern fopen: (ptr<byte>, ptr<byte>) -> ptr<?>
protected extern fputs: (ptr<byte>, ptr<?>) -> int
protected extern fputc: (byte, ptr<?>) -> int
protected extern fgetc: (ptr<?>) -> int
protected extern ferror: (ptr<?>) -> int
protected extern fprintf: (ptr<?>, ptr<byte>, ? ...) -> int
protected extern sprintf: (ptr<byte>, ptr<byte>, ? ...) -> int
protected extern sscanf: (ptr<byte>, ptr<byte>, ptr<?> ...) -> int
protected extern printf: (ptr<byte>, ? ...) -> int
protected extern malloc: long -> ptr<?>
protected extern free: ptr<?> -> int
protected extern exit: int -> int
protected extern get_stdout: () -> ptr<?>
protected extern get_stderr: () -> ptr<?>
protected extern get_stdin: () -> ptr<?>
protected extern get_eof: () -> int
protected extern input_argc: int
protected extern input_argv: ptr<ptr<byte>>
protected extern strlen: ptr<byte> -> int
protected extern current_time_us: () -> long
protected extern current_time_ms: () -> long
protected extern getenv: (ptr<byte>) -> ptr<byte>
protected extern setenv: (ptr<byte>, ptr<byte>, int) -> int
protected extern unsetenv: (ptr<byte>) -> int
protected extern system: (ptr<byte>) -> int
protected extern strerror: (int) -> ptr<byte>
protected extern get_errno: () -> int
protected extern resolve_path: (ptr<byte>) -> ptr<byte>
protected extern get_file_size: ptr<?> -> long
protected extern file_set_length: (ptr<?>, long) -> int
protected extern file_seek: (ptr<?>, long) -> int
protected extern file_skip: (ptr<?>, long) -> int
protected extern file_read_block: (ptr<?>, ptr<byte>, long) -> long
protected extern file_write_block: (ptr<?>, ptr<byte>, long) -> long
protected extern file_time_modified: ptr<byte> -> long

;Process libraries
protected extern launch_process: (ptr<byte>, ptr<ptr<byte>>, int, int, int, ptr<?>) -> int
protected extern retrieve_process_state: (long, ptr<?>) -> int
protected extern initialize_launcher_process: () -> int

;Math libraries
protected extern exp: double -> double
protected extern log: double -> double
protected extern log10: double -> double
protected extern sqrt: double -> double
protected extern pow: (double, double) -> double
protected extern sin: double -> double
protected extern cos: double -> double
protected extern tan: double -> double
protected extern asin: double -> double
protected extern acos: double -> double
protected extern atan: double -> double
protected extern atan2: (double, double) -> double
protected extern sinh: double -> double
protected extern cosh: double -> double
protected extern tanh: double -> double
protected extern ceil: double -> double
protected extern floor: double -> double
protected extern round: double -> double

;################################################################################
;############################## Core Library ####################################
;################################################################################

;================================================================================
;=============================== Boot Sequence ==================================
;================================================================================

defpackage core

;============================================================
;===================== Internal Types =======================
;============================================================

lostanza deftype Fn :
   length: long
   code: ptr<?>
   free: ref<?> ...
lostanza deftype Box :
   item: ref<?>
lostanza deftype Type :
   length: long
   code: ptr<?>
   free: ref<?> ...
lostanza deftype Frame :
  return: long
  liveness-map: long
  slots: long ...
lostanza deftype Stack :
  size: long
  frames: ptr<Frame>
  stack-pointer: ptr<Frame>
  pc: int

;============================================================
;================== Internal Callbacks ======================
;============================================================

lostanza defn halt-system () -> ref<Void> :
  call-c clib/printf("HALT\n")
  call-c clib/exit(-1)
  return 0L as ref<Void>

lostanza defn unreachable-error () -> ref<Void> :
  return halt-system()

lostanza defn fatal (msg:ptr<byte>) -> ref<Void> :
  call-c clib/printf("%s\n", msg)
  return halt-system()

lostanza defn fatal (msg:ref<String>) -> ref<Void> :
  call-c clib/printf("%s\n", addr!(msg.chars))
  return halt-system()

;============================================================
;======================= Core Types =========================
;============================================================

public lostanza deftype Byte :
  value: byte
  
public lostanza deftype Char :
  value: byte

public lostanza deftype Int :
  value: int

public lostanza deftype Long :
  value: long

public lostanza deftype Float :
  value: float

public lostanza deftype Double :
  value: double

public lostanza deftype String :
  length: long
  hash: int
  chars: byte ...

public deftype Symbol
public lostanza deftype StringSymbol <: Symbol :
  name: ref<String>

public lostanza deftype True
public lostanza deftype False

public lostanza deftype Tuple<T> :
  length: long
  items: ref<T> ...

public deftype List<T>
lostanza deftype FullList<T> <: List<T> :
  head: ref<T>
  tail: ref<List<T>>
lostanza deftype NilList <: List<Void>

public deftype Coroutine<I,O>

;============================================================
;============== Standard Streams ============================
;============================================================

lostanza val stdout:ptr<?> = call-c clib/get_stdout()
lostanza val stderr:ptr<?> = call-c clib/get_stderr()
lostanza val stdin:ptr<?> = call-c clib/get_stdin()
lostanza val EOF:int = call-c clib/get_eof()

;============================================================
;================ Constant Initialization ===================
;============================================================

lostanza var const-ptr:ptr<?>
lostanza val BYTE-CONST-TAG : int = 0
lostanza val CHAR-CONST-TAG : int = 1
lostanza val INT-CONST-TAG : int = 2
lostanza val LONG-CONST-TAG : int = 3
lostanza val FLOAT-CONST-TAG : int = 4
lostanza val DOUBLE-CONST-TAG : int = 5
lostanza val TRUE-CONST-TAG : int = 6
lostanza val FALSE-CONST-TAG : int = 7
lostanza val LIST-CONST-TAG : int = 8
lostanza val STRING-CONST-TAG : int = 9
lostanza val SYMBOL-CONST-TAG : int = 10
lostanza val TYPE-CONST-TAG : int = 11
lostanza val FN-CONST-TAG : int = 12

lostanza defn initialize-constants () -> ref<False> :
  ;Initialize read pointer to beginning of the constant table
  ;[num, constants ...]
  const-ptr = call-prim consts-data()
  val n-consts = read-const-int()

  ;First n-consts entries in the global table are for constants
  var cs:ptr<ref<?>> = call-prim consts()
  for (var i:int = 0, i < n-consts, i = i + 1) :
    cs[i] = read-const()

  return false

lostanza defn read-const () -> ref<?> :
  val tag = read-const-int()
  if tag == BYTE-CONST-TAG :
    return new Byte{read-const-byte()}
  else if tag == CHAR-CONST-TAG :
    return new Char{read-const-byte()}
  else if tag == INT-CONST-TAG :
    return new Int{read-const-int()}
  else if tag == LONG-CONST-TAG :
    return new Long{read-const-long()}
  else if tag == FLOAT-CONST-TAG :
    return new Float{read-const-float()}
  else if tag == DOUBLE-CONST-TAG :
    return new Double{read-const-double()}
  else if tag == TRUE-CONST-TAG :
    return true
  else if tag == FALSE-CONST-TAG :
    return false
  else if tag == LIST-CONST-TAG :
    val len = read-const-int()
    return read-const-list(len)
  else if tag == STRING-CONST-TAG :
    val len = read-const-int()
    val chars = read-const-chars(len)
    return String(len, chars)
  else if tag == SYMBOL-CONST-TAG :
    val len = read-const-int()
    val chars = read-const-chars(len)
    return new StringSymbol{String(len, chars)}
  else if tag == TYPE-CONST-TAG :
    val code = read-const-long() as ptr<?>
    return new Type{0, code}
  else if tag == FN-CONST-TAG :
    val code = read-const-long() as ptr<?>
    return new Fn{0, code}
  else :
    call-c clib/printf("Unknown constant tag: %d\n", tag)
    return halt-system()

lostanza defn read-const-list (n:int) -> ref<List> :
  if n == 0 : return new NilList{}
  else : return new FullList{read-const(), read-const-list(n - 1)}

lostanza defn read-const-byte () -> byte :
  val value = [const-ptr as ptr<byte>]
  const-ptr = const-ptr + sizeof(byte)
  return value

lostanza defn read-const-int () -> int :
  val value = [const-ptr as ptr<int>]
  const-ptr = const-ptr + sizeof(int)
  return value

lostanza defn read-const-long () -> long :
  val value = [const-ptr as ptr<long>]
  const-ptr = const-ptr + sizeof(long)
  return value

lostanza defn read-const-float () -> float :
  val value = [const-ptr as ptr<float>]
  const-ptr = const-ptr + sizeof(float)
  return value

lostanza defn read-const-double () -> double :
  val value = [const-ptr as ptr<double>]
  const-ptr = const-ptr + sizeof(double)
  return value

lostanza defn read-const-chars (len:long) -> ptr<byte> :
  val value = const-ptr as ptr<byte>
  ;length chars + pad to nearest 4 bytes
  val n = (len + 3) & -4
  const-ptr = (const-ptr + n) as ptr<?>
  return value

initialize-constants()

;============================================================
;======================= Bytes ==============================
;============================================================

public lostanza defn shift-left (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value << b.value}

public lostanza defn shift-right (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value >> b.value}

public lostanza defn bit-or (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value | b.value}

public lostanza defn bit-xor (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value ^ b.value}

public lostanza defn bit-and (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value & b.value}

public lostanza defn bit-not (a:ref<Byte>) -> ref<Byte> :
  return new Byte{(~ a.value)}

public lostanza defn plus (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value + b.value}

public lostanza defn minus (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value - b.value}

public lostanza defn times (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value * b.value}

public lostanza defn divide (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  ensure-divide-non-zero(b)
  return new Byte{a.value / b.value}

public lostanza defn modulo (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  ensure-divide-non-zero(b)
  return new Byte{a.value % b.value}

;============================================================
;====================== Integers ============================
;============================================================

public defn shift-left (a:Int, b:Int) -> Int :
  ($prim shl a b)

public defn shift-right (a:Int, b:Int) -> Int :
  ($prim shr a b)

public defn arithmetic-shift-right (a:Int, b:Int) -> Int :
  ($prim ashr a b)

public defn bit-or (a:Int, b:Int) -> Int :
  ($prim or a b)

public defn bit-and (a:Int, b:Int) -> Int :
  ($prim and a b)

public defn bit-xor (a:Int, b:Int) -> Int :
  ($prim xor a b)

public defn bit-not (a:Int) -> Int :
  ($prim not a)

public defn negate (a:Int) -> Int :
  ($prim neg a)

public defn abs (a:Int) -> Int :
  (- a) when a < 0 else a

public defn plus (a:Int, b:Int) -> Int :
  ($prim add a b)

public defn minus (a:Int, b:Int) -> Int :
  ($prim sub a b)

public defn times (a:Int, b:Int) -> Int :
  ($prim mul a b)

public defn divide (a:Int, b:Int) -> Int :
  ensure-divide-non-zero(b)
  ($prim div a b)

public defn modulo (a:Int, b:Int) -> Int :
  ensure-divide-non-zero(b)
  ($prim mod a b)

;============================================================
;======================== Longs =============================
;============================================================

public lostanza defn shift-left (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value << b.value}

public lostanza defn shift-right (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value >> b.value}

public lostanza defn arithmetic-shift-right (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value >>> b.value}

public lostanza defn bit-or (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value | b.value}

public lostanza defn bit-xor (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value ^ b.value}

public lostanza defn bit-and (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value & b.value}

public lostanza defn bit-not (a:ref<Long>) -> ref<Long> :
  return new Long{(~ a.value)}

public lostanza defn negate (a:ref<Long>) -> ref<Long> :
  return new Long{(- a.value)}

public defn abs (a:Long) -> Long :
  (- a) when a < 0L else a

public lostanza defn plus (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value + b.value}

public lostanza defn minus (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value - b.value}

public lostanza defn times (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value * b.value}

public lostanza defn divide (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  ensure-divide-non-zero(b)
  return new Long{a.value / b.value}

public lostanza defn modulo (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  ensure-divide-non-zero(b)
  return new Long{a.value % b.value}

;============================================================
;======================= Floats =============================
;============================================================

public lostanza defn negate (a:ref<Float>) -> ref<Float> :
  return new Float{(- a.value)}

public defn abs (a:Float) -> Float :
  (- a) when a < 0.0f else a

public lostanza defn plus (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value + b.value}

public lostanza defn minus (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value - b.value}

public lostanza defn times (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value * b.value}

public lostanza defn divide (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value / b.value}

public lostanza defn nan? (x:ref<Float>) -> ref<True|False> :
  val v = x.value
  if v != v : return true
  else : return false

;============================================================
;======================= Doubles ============================
;============================================================

public lostanza defn negate (a:ref<Double>) -> ref<Double> :
  return new Double{(- a.value)}

public defn abs (a:Double) -> Double :
  (- a) when a < 0.0 else a

public lostanza defn plus (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value + b.value}

public lostanza defn minus (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value - b.value}

public lostanza defn times (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value * b.value}

public lostanza defn divide (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value / b.value}

public lostanza defn nan? (x:ref<Double>) -> ref<True|False> :
  val v = x.value
  if v != v : return true
  else : return false

;============================================================
;======================== Strings ===========================
;============================================================

public lostanza defn String (len:long) -> ref<String> :
  return new String{len + 1, 0}

public lostanza defn String (len:long, chars:ptr<byte>) -> ref<String> :
  val s = String(len)
  call-c clib/memcpy(addr!(s.chars), chars, len)
  s.chars[len] = 0 as byte
  return s

;============================================================
;======================= Lists ==============================
;============================================================

public lostanza defn List () -> ref<List> :
  return new NilList{}

public lostanza defn cons<?T> (x:ref<?T>, t:ref<List<?T>>) -> ref<List<T>> :
  return new FullList<T>{x, t}

public defmulti head<?T> (x:List<?T>) -> T
public defmulti tail<?T> (x:List<?T>) -> List<T>
public defmulti empty? (x:List) -> True|False

defmethod head (x:NilList) : fatal("Cannot retrieve head of empty list.")
defmethod tail (x:NilList) : fatal("Cannot retrieve tail of empty list.")
defmethod empty? (x:NilList) : true
lostanza defmethod head (x:ref<FullList>) -> ref<?> : return x.head
lostanza defmethod tail (x:ref<FullList>) -> ref<?> : return x.tail
defmethod empty? (x:FullList) : false

;============================================================
;======================= Booleans ===========================
;============================================================

public defn complement (a:True|False) -> True|False :
  if a : false
  else : true

;============================================================
;====================== Comparable ==========================
;============================================================

public deftype Comparable<T> :
  Char <: Comparable<Char>
  Byte <: Comparable<Byte>
  Int <: Comparable<Int>
  Long <: Comparable<Long>
  Float <: Comparable<Float>
  Double <: Comparable<Double>
  Tuple<T> <: Comparable<Tuple<T>>
  String <: Comparable<String>
  List<T> <: Comparable<List<T>>

public defmulti compare<?T> (a:Comparable<?T>, b:T) -> Int
public defmulti less?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti greater?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti less-eq?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti greater-eq?<?T> (a:Comparable<?T>, b:T) -> True|False

defmethod less?<?T> (a:Comparable<?T>, b:T) : compare(a, b) < 0
defmethod greater?<?T> (a:Comparable<?T>, b:T) : compare(a, b) > 0
defmethod less-eq?<?T> (a:Comparable<?T>, b:T) : compare(a, b) <= 0
defmethod greater-eq?<?T> (a:Comparable<?T>, b:T) : compare(a, b) >= 0

lostanza defmethod compare (a:ref<Char>, b:ref<Char>) -> ref<Int> :
  return new Int{(a.value as int) - (b.value as int)}

lostanza defmethod less? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Byte>, b:ref<Byte>) -> ref<Int> :
  return new Int{(a.value as int) - (b.value as int)}

lostanza defmethod less? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

defmethod compare (a:Int, b:Int) -> Int :
  if a < b : -1
  else if a > b : 1
  else : 0

defmethod less? (a:Int, b:Int) -> True|False :
  ($prim lt a b)

defmethod less-eq? (a:Int, b:Int) -> True|False :
  ($prim le a b)

defmethod greater? (a:Int, b:Int) -> True|False :
  ($prim gt a b)

defmethod greater-eq? (a:Int, b:Int) -> True|False :
  ($prim ge a b)

lostanza defmethod compare (a:ref<Long>, b:ref<Long>) -> ref<Int> :
  if a.value < b.value : return new Int{-1}
  else if a.value > b.value : return new Int{1}
  else : return new Int{0}

lostanza defmethod less? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Float>, b:ref<Float>) -> ref<Int> :
  if a.value < b.value : return new Int{-1}
  else if a.value > b.value : return new Int{1}
  else : return new Int{0}

lostanza defmethod less? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Double>, b:ref<Double>) -> ref<Int> :
  if a.value < b.value : return new Int{-1}
  else if a.value > b.value : return new Int{1}
  else : return new Int{0}

lostanza defmethod less? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Tuple<Comparable>>, b:ref<Tuple<Comparable>>) -> ref<Int> :
  val la = a.length
  val lb = b.length
  labels :
    begin :
      goto loop(0)
    loop (i:long) :
      if i < la and i < lb :
        val c = compare(a.items[i], b.items[i])
        if c.value : goto loop(i + 1)
        else : return c
      else :
        return compare(new Int{la as int}, new Int{lb as int})

lostanza defmethod compare (a:ref<String>, b:ref<String>) -> ref<Int> :
  val na = strlen(a)
  val nb = strlen(b)
  labels :
    begin :
      goto loop(0)
    loop (i:long) :
      if (i == na) and (i == nb) :
        return new Int{0}
      else if i == na :
        return new Int{-1}
      else if i == nb :
        return new Int{1}
      else :
        val ac = a.chars[i]
        val bc = b.chars[i]
        if ac < bc : return new Int{-1}
        else if ac > bc : return new Int{1}
        else : goto loop(i + 1)

defmethod compare (xs:List<Comparable>, ys:List<Comparable>) -> Int :
  defn* loop (xs:List<Comparable>, ys:List<Comparable>) :
    match(empty?(xs), empty?(ys)) :
      (ex:True, ey:True) : 0
      (ex:True, ey:False) : -1
      (ex:False, ey:True) : 1
      (ex:False, ey:False) :
        val c = compare(head(xs), head(ys))
        if c == 0 : loop(tail(xs), tail(ys))
        else : c
  loop(xs, ys)

;============================================================
;======================== Equalable =========================
;============================================================

public deftype Equalable :
  Char <: Equalable
  Byte <: Equalable
  Int <: Equalable
  Long <: Equalable
  Float <: Equalable
  Double <: Equalable
  Tuple<T> <: Equalable
  String <: Equalable
  List<T> <: Equalable
  True <: Equalable
  False <: Equalable

public defmulti equal? (a:Equalable, b:Equalable) -> True|False
defmethod equal? (a:Equalable, b:Equalable) : false

public defn not-equal? (a:Equalable, b:Equalable) -> True|False :
  not equal?(a, b)

defmethod equal? (a:Char, b:Char) -> True|False :
  ($prim identical? a b)

defmethod equal? (a:Byte, b:Byte) -> True|False :
  ($prim identical? a b)

defmethod equal? (a:Int, b:Int) -> True|False :
  ($prim eq a b)

lostanza defmethod equal? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value == b.value : return true
  else : return false

lostanza defmethod equal? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value == b.value : return true
  else : return false

lostanza defmethod equal? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value == b.value : return true
  else : return false

defmethod equal? (a:True|False, b:True|False) -> True|False :
  ($prim identical? a b)

lostanza defmethod equal? (x:ref<Tuple>, y:ref<Tuple>) -> ref<True|False> :
  val n = x.length
  if n != y.length : return false
  for (var i:long = 0, i < n, i = i + 1) :
    if equal?(x.items[i], y.items[i]) == false :
      return false
  return true

lostanza defmethod equal? (a:ref<String>, b:ref<String>) -> ref<True|False> :
  val n = strlen(a)
  if n == strlen(b) :
    for (var i:long = 0, i < n, i = i + 1) :
      if a.chars[i] != b.chars[i] :
        return false
    return true
  else :
    return false

defmethod equal? (a:List, b:List) -> True|False :
  defn* loop (a:List, b:List) :
    match(empty?(a), empty?(b)) :
      (ea:True, eb:True) : true
      (ea:False, eb:False) :
        if head(a) == head(b) :
          loop(tail(a), tail(b))
      (ea, eb) : false
  loop(a, b)

;============================================================
;====================== Lengthable ==========================
;============================================================

public deftype Lengthable :
  String <: Lengthable
  Tuple<T> <: Lengthable
  List<T> <: Lengthable

public defmulti length (l:Lengthable) -> Int

lostanza defmethod length (x:ref<Tuple>) -> ref<Int> :
  return new Int{x.length as int}

lostanza defmethod length (s:ref<String>) -> ref<Int> :
  return new Int{s.length as int - 1}

defmethod length (x:List) :
  defn* loop (x:List, n:Int) :
    if empty?(x) : n
    else : loop(tail(x), n + 1)
  loop(x, 0)

;============================================================
;=================== Winders ================================
;============================================================
defstruct Winder :
  in: False|(() -> ?)
  out: False|(? -> ?)
   
var WINDER-STACK:List<Winder> = List()
var NUM-WINDERS = 0

defn pop-winder () :
  val w = head(WINDER-STACK)
  WINDER-STACK = tail(WINDER-STACK)
  NUM-WINDERS = NUM-WINDERS - 1
  w

defn push-winder (w:Winder) :
  WINDER-STACK = cons(w, WINDER-STACK)
  NUM-WINDERS = NUM-WINDERS + 1

defn pop-winders (n:Int) :
  defn pop (n:Int) :
    if n > 0 : cons(pop-winder(), pop(n - 1))
    else : List()
  pop(NUM-WINDERS - n)   

defn push-winders (ws:List<Winder>) :
  if not empty?(ws) :
    push-winders(tail(ws))
    push-winder(head(ws))

defn total-winders (c:False|RawCoroutine) -> Int :
  match(c) :
    (c:False) : 0
    (c:RawCoroutine) : total-winders(parent(c)) + num-winders(c)

defn wind-in (ws:List<Winder>) :
  if not empty?(ws) :
    wind-in(tail(ws))
    call?(in(head(ws)))

defn wind-out (ws:List<Winder>, f:True|False) :
  if not empty?(ws) :
    call?(out(head(ws)), f)
    wind-out(tail(ws), f)

defn* call? (f: False|(() -> ?)) :
  match(f) :
    (f:() -> ?) : f()
    (f:False) : false

defn* call? (f: False|(? -> ?), x: ?) :
  match(f) :
    (f:? -> ?) : f(x)
    (f:False) : false

lostanza defn inc-winders (c:ref<RawCoroutine>, n:ref<Int>) -> ref<False> :
  c.num-winders = c.num-winders + n.value
  return false

lostanza defn num-winders (c:ref<RawCoroutine>) -> ref<Int> :
  return new Int{c.num-winders}
      
public defn dynamic-wind<?T> (in:False|(() -> ?),
                              body:() -> ?T,
                              out:False|(True|False -> ?)) -> T :
  call?(in)
  push-winder(Winder(in, out))
  inc-winders(current-coroutine, 1)
  val result = body()
  pop-winder()
  inc-winders(current-coroutine, -1)
  call?(out, true)
  result

;============================================================
;====================== Coroutines ==========================
;============================================================

public defmulti active? (c:Coroutine) -> True|False
public defmulti open? (c:Coroutine) -> True|False
public defmulti resume<?I,?O> (c:Coroutine<?I,?O>, x:I) -> O
public defmulti suspend<?I,?O> (c:Coroutine<?I,?O>, x:O) -> I
public defmulti break<?O> (c:Coroutine<?,?O>, x:O) -> Void
public defmulti close (c:Coroutine) -> False

;                  Wrapped Coroutines
;                  ==================

#if-defined(OPTIMIZE) :

  public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O> :
    RawCoroutine(enter)

#else :

  deftype WrappedCoroutine<I,O> <: Coroutine<I,O>
  defmulti raw (c:WrappedCoroutine) -> RawCoroutine

  public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O> :
    var rc
    val c = new WrappedCoroutine<I,O> :
      defmethod active? (this) : active?(rc)
      defmethod open? (this) : open?(rc)
      defmethod resume (this, x:I) : resume(rc, x)
      defmethod suspend (this, x:O) : suspend(rc, x)
      defmethod break (this, x:O) : break(rc, x)
      defmethod close (this) : close(rc)
      defmethod raw (this) : rc
    rc = RawCoroutine $ fn (rc, x0) :
      enter(c, x0)
    c

lostanza deftype RawCoroutine <: Coroutine :
  id: long
  stack: ref<Stack>
  parent: ref<False|RawCoroutine>
  status: ref<Int>
  num-winders: int

lostanza deftype CoroutineParams :
  parent-stack: ref<Stack>
  coroutine: ref<RawCoroutine>
  enter: ref<((RawCoroutine, ?) -> ?)>

val COROUTINE-ACTIVE = 0
val COROUTINE-CLOSED = 1
val COROUTINE-SUSPENDED = 2
val COROUTINE-OPEN = 3

lostanza var current-coroutine:ref<RawCoroutine> =
  new RawCoroutine{0L, call-prim stack(), false, COROUTINE-ACTIVE, 0}

lostanza var COROUTINE-COUNTER:long = 1L
public lostanza defn RawCoroutine (enter:ref<((RawCoroutine, ?) -> ?)>) -> ref<RawCoroutine> :
  val current-stack = call-prim stack()
  val stack = call-prim new-stack(addr(setup-coroutine))
  val c = new RawCoroutine{COROUTINE-COUNTER, stack, false, COROUTINE-OPEN, 0}
  COROUTINE-COUNTER = COROUTINE-COUNTER + 1L
  call-prim enter-stack(stack, new CoroutineParams{current-stack, c, enter})
  return c

lostanza defn parent (c:ref<RawCoroutine>) -> ref<False|RawCoroutine> :
  return c.parent

lostanza defmethod active? (c:ref<RawCoroutine>) -> ref<True|False> :
  if c.status == COROUTINE-ACTIVE : return true
  else : return false

lostanza defmethod open? (c:ref<RawCoroutine>) -> ref<True|False> :
  if c.status == COROUTINE-OPEN : return true
  else : return false

lostanza defn* setup-coroutine (params:ref<CoroutineParams>) -> ref<?> :
  val x0 = call-prim yield(params.parent-stack, false)
  val enter = params.enter
  return break(params.coroutine, [enter](params.coroutine, x0))  

lostanza defmethod resume (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
  ;Ensure coroutine is re-entrant
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot resume coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-ACTIVE :
    return fatal("Cannot resume coroutine. Coroutine is already active.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot resume coroutine. Coroutine's parent is suspended.")  

  ;Adjust state
  attach-coroutine(c)

  ;Begin execution
  return call-prim yield(current-coroutine.stack, x)

lostanza defmethod* suspend (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
  ;Ensure coroutine is active
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot suspend coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-OPEN :
    return fatal("Cannot suspend coroutine. Coroutine is already suspended.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot suspend coroutine. Coroutine is already suspended.")

  ;Set target winder environment and wind out
  val winders = pop-winders(total-winders(c.parent))
  wind-out(winders, false)

  ;Detach coroutine
  detach-coroutine(c)

  ;Return to resume
  val result = call-prim yield(current-coroutine.stack, x)

  ;Wind in and restore original winder environment
  wind-in(winders)
  push-winders(winders)

  ;Return execution
  return result

lostanza defmethod close (c:ref<RawCoroutine>) -> ref<False> :
  ;Ensure coroutine is re-entrant
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot close coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-ACTIVE :
    return fatal("Cannot close coroutine. Coroutine is active.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot close coroutine. Coroutine's parent is suspended.")
  free-coroutine(c)
  return false

lostanza defmethod break (c:ref<RawCoroutine>, x:ref<?>) -> ref<Void> :
  ;Ensure coroutine is active
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot break from coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-OPEN :
    return fatal("Cannot break from coroutine. Coroutine is already suspended.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot break from coroutine. Coroutine is already suspended.")

  ;Set target winder environment and wind out
  val winders = pop-winders(total-winders(c.parent))
  wind-out(winders, false)

  ;Adjust state
  detach-coroutine(c)
  free-coroutine(c)
  
  ;Begin execution
  return call-prim yield(current-coroutine.stack, x)

lostanza defn free-coroutine (c:ref<RawCoroutine>) -> int :
  labels :
    begin :
      goto loop(c)
    loop (c:ref<RawCoroutine>) :
      val parent = c.parent
      c.parent = false
      c.status = COROUTINE-CLOSED
      ;free-stacks(top(c), bottom(c))
      match(parent) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : return 0  

lostanza defn attach-coroutine (c:ref<RawCoroutine>) -> int :
  labels :
    begin :
      goto loop(c)
    loop (c:ref<RawCoroutine>) :
      val p = c.parent
      c.parent = current-coroutine
      c.status = COROUTINE-ACTIVE
      current-coroutine = c
      match(p) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : return 0

lostanza defn detach-coroutine (c:ref<RawCoroutine>) -> int :
  labels :
    begin :
      goto loop(false)
    loop (tail:ref<RawCoroutine|False>) :
      val cc = current-coroutine
      val ccp = current-coroutine.parent as ref<RawCoroutine>
      cc.parent = tail
      current-coroutine = ccp
      if cc == c :
        cc.status = COROUTINE-OPEN
        return 0
      else :
        cc.status = COROUTINE-SUSPENDED
        goto loop(cc)

;================================================================================
;============================== End of Boot Sequence ============================
;================================================================================

;============================================================
;===================== Utilities ============================
;============================================================

public lostanza val null:ptr<?> = 0L as ptr<?>

#if-defined(PLATFORM-WINDOWS) :
  lostanza val LS-NL:ptr<?> = "\r\n"
  val NL = "\r\n"
#else :  
  lostanza val LS-NL:ptr<?> = "\n"
  val NL = "\n"

lostanza deftype Sentinel
lostanza val sentinel:ref<Sentinel> = new Sentinel{}

protected lostanza defn linux-error-msg () -> ref<String> :
  val s = call-c clib/strerror(call-c clib/get_errno())
  return String(s)

;============================================================
;====================== Error Preconditions =================
;============================================================

defn ensure-divide-non-zero (i:Byte) :
  #if-defined(OPTIMIZE) : (false)
  #else : (fatal("Cannot divide by zero.") when i == 0Y)
defn ensure-divide-non-zero (i:Int) :
  #if-defined(OPTIMIZE) : (false)
  #else : (fatal("Cannot divide by zero.") when i == 0)
defn ensure-divide-non-zero (i:Long) :
  #if-defined(OPTIMIZE) : (false)
  #else : (fatal("Cannot divide by zero.") when i == 0L)

protected defn ensure-index-in-bounds (xs:Lengthable, i:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if i < 0 or i >= length(xs) :
      fatal("Index (%_) out of bounds." % [i])

protected defn ensure-length-in-bounds (xs:Lengthable, i:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if i < 0 or i > length(xs) :
      fatal("Index (%_) out of bounds." % [i])

defn ensure-start-before-end (s:Int, e:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if e < s :
      fatal("Given end index (%_) is smaller than start index (%_)." % [e, s])

protected defn ensure-non-negative (quantity:String, n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if n < 0 :
      fatal("Given %_ (%_) is negative." % [quantity, n])

protected defn ensure-positive (quantity:String, n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if n <= 0 :
      fatal("Given %_ (%_) is not positive." % [quantity, n])

protected defn ensure-non-negative-length (n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    ensure-non-negative("length", n)

protected defn ensure-index-range (xs:Lengthable, r:Range) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if step(r) != 1 :
      fatal("Given index range (%_) does not have a step of 1." % [r])
    val s = start(r)
    match(end(r), inclusive?(r)) :
      (e:Int, inc?:True) :
        ensure-index-in-bounds(xs, s)
        ensure-index-in-bounds(xs, e)
        ensure-start-before-end(s, e)
      (e:Int, inc?:False) :
        ensure-length-in-bounds(xs, s)
        ensure-length-in-bounds(xs, e)
        ensure-start-before-end(s, e)
      (e:False, inc?) :
        ensure-length-in-bounds(xs, s)

protected defn range-bound (s:Lengthable, r:Range) -> [Int, Int] :
  match(end(r), inclusive?(r)) :
    (e:Int, i:True) : [start(r), e + 1]
    (e:Int, i:False) : [start(r), e]
    (e:False, i) : [start(r), length(s)]

;============================================================
;===================== OutputStream =========================
;============================================================

;                   General Interface
;                   =================

public defmulti print (o:OutputStream, x) -> False
public defmulti print-all (o:OutputStream, xs:Seqable) -> False
public defmulti put (o:OutputStream, x) -> False

;                Default Implementations
;                =======================

lostanza val CONVERSION-BUFFER: ptr<byte> = call-c clib/malloc(64)

lostanza defn print-conversion-buffer-float (o:ref<OutputStream>, n:int) -> ref<False> :
  labels :
    begin :
      goto loop(0)
    loop (i:int) :
      if i < n :
        val c = CONVERSION-BUFFER[i]
        if c == '.' : goto rest(i)
        else if c == 'e' : goto add-dot(i)
        else :
          print(o, new Char{c})
          goto loop(i + 1)
      else : goto add-dot(i)
    add-dot (i:int) :
      print(o, new Char{'.'})
      print(o, new Char{'0'})
      goto rest(i)
    rest (i:int) :
      if i < n :
        print(o, new Char{CONVERSION-BUFFER[i]})
        goto rest(i + 1)        
  return false

lostanza defn print-conversion-buffer-float (o:ptr<?>, n:int) -> ref<False> :
  labels :
    begin :
      goto loop(0)
    loop (i:int) :
      if i < n :
        val c = CONVERSION-BUFFER[i]
        if c == '.' : goto rest(i)
        else if c == 'e' : goto add-dot(i)
        else :
          call-c clib/fputc(c, o)
          goto loop(i + 1)
      else : goto add-dot(i)
    add-dot (i:int) :
      call-c clib/fputc('.', o)
      call-c clib/fputc('0', o)
      goto rest(i)
    rest (i:int) :
      if i < n :
        call-c clib/fputc(CONVERSION-BUFFER[i], o)
        goto rest(i + 1)        
  return false

lostanza defn print-conversion-buffer (o:ref<OutputStream>, n:int) -> ref<False> :
   for (var i:int = 0, i < n, i = i + 1) :
      print(o, new Char{CONVERSION-BUFFER[i]})
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Byte>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%d", x.value as int)
   print-conversion-buffer(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Int>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%d", x.value)
   print-conversion-buffer(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Long>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%lld", x.value)
   print-conversion-buffer(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Float>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.6g", x.value as double)
   print-conversion-buffer-float(o, n)
   return false

lostanza defmethod print (o:ref<OutputStream>, x:ref<Double>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.15g", x.value)
   print-conversion-buffer-float(o, n)
   return false

defmethod print (o:OutputStream, x:True) :
   print(o, "true")

defmethod print (o:OutputStream, x:False) :
   print(o, "false")

defmethod print (o:OutputStream, x:String) :
   print-all(o, x)

defmethod print (o:OutputStream, x) :
   print(o, "[%_ object]" % [object-type(x)])

defmethod print-all (o:OutputStream, xs:Seqable) :
   do(print{o, _}, xs)

;                 Convenience Functions
;                 =====================

public defn println (o:OutputStream, x) :
   print(o, x)
   print(o, NL)

public defn println-all (o:OutputStream, xs:Seqable) :
   print-all(o, xs)
   print(o, NL)

;============================================================
;=================== FileOutputStream =======================
;============================================================

;TODO: Files and Directories.
;FileOutputStream streams are obtained from files.

public lostanza defn FileOutputStream (filename:ref<String>, append?:ref<True|False>) -> ref<FileOutputStream> :
   var file : ptr<?>
   if append? == true : file = call-c clib/fopen(addr!(filename.chars), "ab")
   else : file = call-c clib/fopen(addr!(filename.chars), "wb")
   if file == null : throw(FileOpenException(filename, linux-error-msg()))
   return new FileOutputStream{file, 1}

public defn FileOutputStream (filename:String) :
   FileOutputStream(filename, false)

public lostanza defn close (o:ref<FileOutputStream>) -> ref<False> :
   if o.closable? :
      val err = call-c clib/fclose(o.file)
      if err != 0 : throw(FileCloseException(linux-error-msg()))
   else : fatal("System OutputStream is not closable.")
   return false

public lostanza defn flush (o:ref<FileOutputStream>) -> ref<False> :
  val err = call-c clib/fflush(o.file)
  if err != 0 : throw(FileFlushException(linux-error-msg()))
  return false

lostanza defmethod put (o:ref<FileOutputStream>, x:ref<Byte>) -> ref<False> :
   val r = call-c clib/fputc(x.value, o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod put (o:ref<FileOutputStream>, x:ref<Char>) -> ref<False> :
   val r = call-c clib/fputc(x.value, o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

defmethod put (o:OutputStream, c:Char) -> False :
   put(o, to-byte(c))

defmethod put (o:OutputStream, i:Int) -> False :
   put(o, to-byte(i))
   put(o, to-byte(i >> 8))
   put(o, to-byte(i >> 16))
   put(o, to-byte(i >> 24))

defmethod put (o:OutputStream, i:Long) -> False :
   put(o, to-byte(i))
   put(o, to-byte(i >> 8L))
   put(o, to-byte(i >> 16L))
   put(o, to-byte(i >> 24L))
   put(o, to-byte(i >> 32L))
   put(o, to-byte(i >> 40L))
   put(o, to-byte(i >> 48L))
   put(o, to-byte(i >> 56L))

defmethod put (o:OutputStream, i:Float) -> False :
   put(o, bits(i))

defmethod put (o:OutputStream, i:Double) -> False :
   put(o, bits(i))

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<String>) -> ref<False> :
   val r = call-c clib/fputs(addr!(x.chars), o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Byte>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%d", x.value as int)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Char>) -> ref<False> :
   val r = call-c clib/fputc(x.value, o.file)
   if r == EOF : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Int>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%d", x.value)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Long>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "%lld", x.value)
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Float>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.6g", x.value as double)
   print-conversion-buffer-float(o.file, n)
   if call-c clib/ferror(o.file) != 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<Double>) -> ref<False> :
   val n = call-c clib/sprintf(CONVERSION-BUFFER, "%.15g", x.value)
   print-conversion-buffer-float(o.file, n)
   if call-c clib/ferror(o.file) != 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<True>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "true")
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

lostanza defmethod print (o:ref<FileOutputStream>, x:ref<False>) -> ref<False> :
   val r = call-c clib/fprintf(o.file, "false")
   if r < 0 : throw(FileWriteException(linux-error-msg()))
   return false

public defn with-output-file<?T> (file:FileOutputStream, f: () -> ?T) -> T :
   try : with-output-stream(file, f)
   finally : close(file)

public defn spit (filename:String, x) -> False :
   val o = FileOutputStream(filename, false)
   try : print(o, x)
   finally : close(o)

;============================================================
;================ System Output Streams =====================
;============================================================

;                 System Output Streams
;                 =====================

public lostanza val STANDARD-OUTPUT-STREAM : ref<OutputStream> =
   new FileOutputStream{stdout, 0}

public lostanza val STANDARD-ERROR-STREAM : ref<OutputStream> =
   new FileOutputStream{stderr, 0}

public lostanza val STANDARD-INPUT-STREAM : ref<InputStream> =
   new FileInputStream{stdin, 0}

;                 Current Output Stream
;                 =====================

var CURRENT-OUTPUT-STREAM : OutputStream = STANDARD-OUTPUT-STREAM

public defn with-output-stream<?T> (o:OutputStream, f: () -> ?T) -> T :
   let-var CURRENT-OUTPUT-STREAM = o :
      f()

public defn current-output-stream () :
   CURRENT-OUTPUT-STREAM

public defn set-current-output-stream (o:OutputStream) :
  CURRENT-OUTPUT-STREAM = o

public defn print (x) :
   print(CURRENT-OUTPUT-STREAM, x)

public defn println (x) :
   println(CURRENT-OUTPUT-STREAM, x)

public defn print-all (xs:Seqable) :
   do(print, xs)

public defn println-all (xs:Seqable) :
   println-all(CURRENT-OUTPUT-STREAM, xs)

;============================================================
;=================== Input Streams ==========================
;============================================================

;                      Interface
;                      =========

public defmulti get-char (i:InputStream) -> Char|False
public defmulti get-byte (i:InputStream) -> Byte|False
public defmulti fill (xs:CharArray, r:Range, i:InputStream) -> Int

;                Abstract Implementations
;                ========================

defmethod fill (xs:CharArray, r:Range, s:InputStream) -> Int :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   defn* loop (i:Int) :
      if i < e :
         match(get-char(s)) :
            (c:Char) :
               xs[i] = c
               loop(i + 1)
            (c:False) : i - b
      else : i - b
   loop(b)

;============================================================
;=============== Buffered Input Streams =====================
;============================================================

;                      Interface
;                      =========

public defmulti peek? (i:BufferedInputStream, n:Int) -> Char|False
public defmulti peek-fill (xs:CharArray, r:Range, i:BufferedInputStream) -> Int

;                Abstract Implementations
;                ========================

public defn peek? (i:BufferedInputStream) -> Char|False :
   peek?(i, 0)

;                     Creation
;                     ========

deftype CharQueue <: Lengthable
defmulti peek (c:CharQueue, i:Int) -> Char
defmulti pop (c:CharQueue) -> Char
defmulti peek-fill (xs:CharArray, b:Int, e:Int, c:CharQueue) -> Int
defmulti pop-fill (xs:CharArray, b:Int, e:Int, c:CharQueue) -> Int
defmulti fill (xs:CharQueue, stream:InputStream) -> False

defn CharQueue (cap:Int) :
   val array = CharArray(cap)
   var start:Int = 0
   var len:Int = 0
   
   defn wrap (i:Int) :
      val idx = start + i
      idx when idx < cap else idx - cap

   defn copy (xs:CharArray, b:Int, e:Int) :
      val n = e - b
      val n1 = cap - start
      val n2 = n - n1
      if n <= n1 :
         block-copy(n, xs, b, array, start)
      else :
         block-copy(n1, xs, b, array, start)
         block-copy(n2, xs, b + n1, array, 0)

   new CharQueue :
      defmethod length (this) :
         len         
      defmethod peek (this, i:Int) :
         array[wrap(i)]         
      defmethod pop (this) :
         val c = array[start]
         start = wrap(1)
         len = len - 1
         c
      defmethod peek-fill (xs:CharArray, b:Int, e:Int, this) -> Int :
         val n = min(e - b, len)   
         copy(xs, b, b + n)
         n         
      defmethod pop-fill (xs:CharArray, b:Int, e:Int, this) -> Int :
         val n = peek-fill(xs, b, e, this)
         start = wrap(n)
         len = len - n
         n
      defmethod fill (this, stream:InputStream) -> False :
         val pos = wrap(len)
         val total-read =
            if len == 0 :
               start = 0
               fill(array, 0 to cap, stream)
            else if start < pos :
               val n1 = cap - pos
               val n1* = fill(array, pos to cap, stream)
               if n1* < n1 : n1*
               else : n1* + fill(array, 0 to start, stream)
            else :
               fill(array, pos to start, stream)
         len = len + total-read

public defn BufferedInputStream (i:InputStream) -> BufferedInputStream :
   BufferedInputStream(i, 1024)

public defn BufferedInputStream (stream:InputStream, size:Int) -> BufferedInputStream :
   ensure-positive("buffer size", size)
      
   val buffer = CharQueue(size)
   
   new BufferedInputStream :
      defmethod peek? (this, i:Int) -> False|Char :
         #if-not-defined(OPTIMIZE) :
            if i < 0 :
               fatal("Cannot peek? into a BufferedInputStream at a negative index.")
            if i >= size :
               fatal("Cannot peek? %_ chars ahead into BufferedInputStream with buffer size %_." % [i, size])
         if length(buffer) > i :
            peek(buffer, i)
         else :
            fill(buffer, stream)
            peek(buffer, i) when length(buffer) > i

      defmethod peek-fill (xs:CharArray, r:Range, this) -> Int :
         val [b, e] = range-bound(xs, r)
         val n = e - b
         #if-not-defined(OPTIMIZE) :
            if n > size :
               fatal("Cannot peek more characters (%_) than capacity of buffer (%_)." % [n, size])
         fill(buffer, stream) when length(buffer) < n
         peek-fill(xs, b, e, buffer)
         
      defmethod fill (xs:CharArray, r:Range, this) -> Int :
         val [b, e] = range-bound(xs, r)
         val n = e - b
         if n < size :
            fill(buffer, stream) when length(buffer) < n
            pop-fill(xs, b, e, buffer)
         else :
            val n1 = pop-fill(xs, b, e, buffer)
            if n1 < n : n1 + fill(xs, (b + n1) to e, stream)
            else : n1

      defmethod get-char (this) -> False|Char :
         fill(buffer, stream) when length(buffer) == 0
         pop(buffer) when length(buffer) > 0
         
      defmethod get-byte (this) :
         match(get-char(this)) :
            (c:Char) : to-byte(c)
            (c:False) : false

;============================================================
;================= File Input Streams =======================
;============================================================

public lostanza defn FileInputStream (filename:ref<String>) -> ref<FileInputStream> :
   val file = call-c clib/fopen(addr!(filename.chars), "rb")
   if file == null : throw(FileOpenException(filename, linux-error-msg()))
   return new FileInputStream{file, 1}

public lostanza defn close (i:ref<FileInputStream>) -> ref<False> :
   if i.closable? :
      val err = call-c clib/fclose(i.file)
      if err != 0 : throw(FileCloseException(linux-error-msg()))
   else : fatal("System Input Stream is not closable.")
   return false

lostanza defmethod get-char (i:ref<FileInputStream>) -> ref<Char|False> :
   val c = call-c clib/fgetc(i.file)
   if c == EOF :
      val err = call-c clib/ferror(i.file)
      if err != 0 : throw(FileReadException(linux-error-msg()))
      return false
   else :
      return new Char{c as byte}

lostanza defmethod get-byte (i:ref<FileInputStream>) -> ref<Byte|False> :
   val c = call-c clib/fgetc(i.file)
   if c == EOF :
      val err = call-c clib/ferror(i.file)
      if err != 0 : throw(FileReadException(linux-error-msg()))
      return false
   else :
      return new Byte{c as byte}

public defn get-int (i:InputStream) -> False|Int :
   defn get-byte! (i:InputStream) :
      match(get-byte(i)) :
         (b:Byte) : b
         (b:False) : fail()
   attempt :
      val b0 = to-int(get-byte!(i))
      val b1 = to-int(get-byte!(i))
      val b2 = to-int(get-byte!(i))
      val b3 = to-int(get-byte!(i))
      (b0) |
      (b1 << 8) |
      (b2 << 16) |
      (b3 << 24)

public defn get-long (i:InputStream) -> False|Long :
   defn get-int! (i:InputStream) :
      match(get-int(i)) :
         (x:Int) : x
         (x:False) : fail()
   attempt :
      val w0 = to-long(get-int!(i))
      val w1 = to-long(get-int!(i))
      (w0 & 0xFFFFFFFFL) |
      (w1 << 32L)

public defn get-float (i:InputStream) -> False|Float :
   match(get-int(i)) :
      (x:Int) : bits-as-float(x)
      (x:False) : false

public defn get-double (i:InputStream) -> False|Double :
   match(get-long(i)) :
      (x:Long) : bits-as-double(x)
      (x:False) : false

public defn slurp (filename:String) :
   val s = FileInputStream(filename)
   try :
      val buffer = StringBuffer()
      defn* loop () :
         match(get-char(s)) :
            (c:Char) :
               add(buffer, c)
               loop()
            (c:False) : false
      loop()
      to-string(buffer)
   finally : close(s)

public defn file-exists? (filename:String) :
   try :
      close(FileInputStream(filename))
      true
   catch (e:Exception) :
      false

;============================================================
;===================== Tuples ===============================
;============================================================

lostanza defn void-tuple (n:long) -> ref<Tuple> :
  val x = new Tuple{n}
  for (var i:long = 0, i < n, i = i + 1) :
    x.items[i] = sentinel
  return x   

public lostanza defn Tuple<?T> (n:ref<Int>, x:ref<?T>) -> ref<Tuple<T>> :
   ensure-non-negative-length(n)
   val len = n.value
   val t = new Tuple<T>{len}
   for (var i:long = 0, i < len, i = i + 1) :
      t.items[i] = x
   return t

lostanza defn set<?T> (x:ref<Tuple<?T>>, i:ref<Int>, v:ref<T>) -> ref<False> :
   ensure-index-in-bounds(x, i)
   x.items[i.value] = v
   return false

public lostanza defn get<?T> (x:ref<Tuple<?T>>, i:ref<Int>) -> ref<T> :
   ensure-index-in-bounds(x, i)
   return x.items[i.value]

public defn get<?T> (xs:Tuple<?T>, r:Range) -> Tuple<T> :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   to-tuple(for i in b to e seq : xs[i])

public defn empty? (t:Tuple) :
   length(t) == 0

;============================================================
;===================== Strings ==============================
;============================================================

public lostanza defn String (chars:ptr<byte>) -> ref<String> :
  val len = call-c clib/strlen(chars)
  return String(len, chars)

public lostanza defn String (len:long, c:byte) -> ref<String> :
  val s = String(len)
  for (var i:long = 0, i < len, i = i + 1) :
    s.chars[i] = c
  s.chars[len] = 0 as byte
  return s

public lostanza defn String (len:ref<Int>, c:ref<Char>) -> ref<String> :
  ensure-non-negative-length(len)
  return String(len.value, c.value)

lostanza defn strlen (s:ref<String>) -> long :
  return s.length - 1

public defn get (s:String, i:Int) -> Char :
  ensure-index-in-bounds(s, i)
  ($prim string-get s i)

lostanza defn set (s:ref<String>, i:ref<Int>, c:ref<Char>) -> ref<False> :
  ensure-index-in-bounds(s, i)
  s.chars[i.value] = c.value
  return false

;============================================================
;======================= Lists ==============================
;============================================================

public defn cons<?T> (x:?T, y:?T, t:List<?T>) -> List<T> :
   cons(x, cons(y, t))

public defn cons<?T> (x:?T, y:?T, z:?T, t:List<?T>) -> List<T> :
   cons(x, cons(y, cons(z, t)))

public defn List<?T> (x:?T) -> List<T> :
   cons(x, List())

public defn List<?T> (x:?T, y:?T) -> List<T> :
   cons(x, cons(y, List()))

public defn List<?T> (x:?T, y:?T, z:?T) -> List<T> :
   cons(x, cons(y, cons(z, List())))

public defn List<?T> (w:?T, x:?T, y:?T, z:?T) -> List<T> :
   cons(w, cons(x, cons(y, cons(z, List()))))

;============================================================
;====================== Formatting ==========================
;============================================================

public deftype Printable

public defn modulo (format:String, args:Seqable) -> Printable :
   new Printable :
      defmethod* print (o:OutputStream, this) :
         val seq = to-seq(args)
         defn next-arg () :
           #if-not-defined(OPTIMIZE) :
             fatal("Format string %~ is expecting more arguments." % [format]) when empty?(seq)
           next(seq)
         defn next-seq () :
           val x = next-arg()
           #if-not-defined(OPTIMIZE) :
             if x is-not Seqable :
               fatal("Format string %~ is expecting a sequence, but received: %~." % [format, x])
           x

         val n = length(format)
         defn* loop (i:Int) :
            if i < n :
               val c = format[i]
               if c == '%' :
                  if i + 1 < n :
                     val modifier = format[i + 1]
                     switch {modifier == _} :
                        '_' : print(o, next-arg())
                        '*' : print-all(o, next-seq())
                        ',' : print-all(o, join(next-seq(), ", "))
                        's' : print-all(o, join(next-seq(), " "))
                        'n' : print-all(o, join(next-seq(), "\n"))
                        '~' : write(o, next-arg())
                        '@' : write-all(o, next-seq())
                        '%' : print(o, c)
                        else : fatal("Invalid argument specifier %~ in format string %~." % [modifier, format])
                     loop(i + 2)
                  else :
                     fatal("Incomplete argument specifier %% at end of format string %~." % [format])
               else :
                  print(o, c)
                  loop(i + 1)
            else :
               if not empty?(seq) :
                  fatal("Unexpected end of format string %~. More arguments remaining." % [format])
         loop(0)

;============================================================
;=================== Indented Streams =======================
;============================================================

public deftype IndentedStream <: OutputStream
public defmulti stream (s:IndentedStream) -> OutputStream
public defmulti indent (s:IndentedStream) -> Int

public defn IndentedStream (o:OutputStream) :
  IndentedStream(o, 2)

public defn IndentedStream (o:OutputStream, n:Int) :
   match(o) :
      (o:IndentedStream) :
         IndentedStream(stream(o), n + indent(o))
      (o) :
         var start-of-line? = true
         val spaces = String(n, ' ')
         defn put (c:Char) :
            if start-of-line? :
               print(o, spaces)
               start-of-line? = false
            print(o, c)
            if c == '\n' :
               start-of-line? = true

         new IndentedStream :
            defmethod stream (this) : o
            defmethod indent (this) : n
            defmethod print (this, c:Char) : put(c)

public defn do-indented<?T> (f: IndentedStream -> ?T, o:OutputStream) :
   f(IndentedStream(o))

public defn indented<?T> (f: () -> ?T) :
   let-var CURRENT-OUTPUT-STREAM = IndentedStream(CURRENT-OUTPUT-STREAM) :
      f()

;============================================================
;===================== Generators ===========================
;============================================================

public defn Generator<T> (thunk : (T -> False, (T -> Void) & (() -> Void)) -> ?) -> Seq<T> :
   ;State
   var item = sentinel

   ;Generator Coroutine
   val co = Coroutine<False, T|Sentinel> $ fn (co, x0) :
      defn co-yield (x:T) :
         suspend(co, x)
      val co-break = multifn :
         (x:T) : break(co, x)
         () : break(co, sentinel)
      thunk(co-yield, co-break)
      sentinel

   ;Fill state: Returns whether empty
   defn fill () :
      if (item is Sentinel) and open?(co) :
         item = resume(co, false)
      item is Sentinel

   ;Peek
   defn peek () :
      if item is Sentinel :
         fatal("Empty Sequence")
      item as T

   ;Empty bucket
   defn empty () :
      val x = peek()
      item = sentinel
      x

   new Seq<T> :
      defmethod next (this) :
         fill()
         empty()
      defmethod peek (this) :
         fill()
         peek()
      defmethod empty? (this) :
         fill()
      defmethod free (this) :
         close(co) when open?(co)

;============================================================
;====================== Labels ==============================
;============================================================

public defn* LabeledScope<T> (thunk: (T -> Void) -> T) -> T :
   val c = Coroutine<False,T> $ fn* (c, x0) :
      thunk(break{c, _})
   resume(c, false)

public defn* LabeledScope* (thunk: (() -> Void) -> ?) -> False :
   val c = Coroutine<False,False> $ fn* (c, x0) :
      thunk(fn () : break(c, false))
      false
   resume(c, false)   

;============================================================
;=================== IndexedCollections =====================
;============================================================

;                       Interface
;                       =========

public defmulti get<?T> (a:IndexedCollection<?T>, i:Int) -> T
public defmulti set<?T> (a:IndexedCollection<?T>, i:Int, v:T) -> False
public defmulti get<?T> (a:IndexedCollection<?T>, r:Range) -> Collection<T>
public defmulti set<?T> (a:IndexedCollection<?T>, r:Range, vs:Seqable<T>) -> False
public defmulti set-all<?T> (a:IndexedCollection<?T>, r:Range, v:T) -> False
public defmulti map!<?T> (f: T -> T, xs:IndexedCollection<?T>) -> False

;                 Abstract Implementations
;                 ========================

public defn empty? (v:IndexedCollection) :
   length(v) == 0

defmethod print (o:OutputStream, a:IndexedCollection) -> False :
   print(o, "[%@]" % [a])

defmethod map!<?T> (f: T -> T, xs:IndexedCollection<?T>) -> False :
   for i in 0 to length(xs) do :
      xs[i] = f(xs[i])

defmethod get<?T> (xs:IndexedCollection<?T>, r:Range) -> Tuple<T> :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   to-tuple(for i in b to e seq : xs[i])

defmethod set<?T> (xs:IndexedCollection<?T>, r:Range, vs:Seqable<T>) -> False :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   val vs-seq = to-seq(vs)
   for i in b to e do : xs[i] = next(vs-seq)

defmethod set-all<?T> (xs:IndexedCollection<?T>, r:Range, v:T) -> False :
   ensure-index-range(xs, r)
   val [b,e] = range-bound(xs, r)
   for i in b to e do : xs[i] = v

defmethod to-seq<?T> (xs:IndexedCollection<?T>) -> Seq<T> :
   seq({xs[_]}, 0 to length(xs))

public defn reverse!<?T> (xs:IndexedCollection<?T>) -> False :
   val n = length(xs)
   for i in 0 to n / 2 do :
      val j = n - 1 - i
      val xi = xs[i]
      val xj = xs[j]
      xs[i] = xj
      xs[j] = xi

defmethod in-reverse<?T> (xs:IndexedCollection<?T>) :
  val n = length(xs)
  for i in (n - 1) through 0 by -1 seq :
    xs[i]

;                       Sorting
;                       =======

public defn qsort!<?T> (xs:IndexedCollection<?T>, is-less?:(T,T) -> True|False) -> False :
   ;Random
   val rand = Random(0L)
   
   ;Swap element i with element j
   defn swap (i:Int, j:Int) :
      if i != j :
         val xi = xs[i]
         val xj = xs[j]
         xs[i] = xj
         xs[j] = xi

   ;Rearrange elements from b to e, such that the first elements is less than pivot.
   ;Returns a s.t. all elements from b to a are less than pivot.
   defn partition (b:Int, e:Int, pivot:T) :
      defn* loop (a:Int, b:Int) -> Int :
         if b < e :
            val xb = xs[b]
            if is-less?(xb, pivot) :
               swap(a, b)
               loop(a + 1, b + 1)
            else : loop(a, b + 1)
         else : a
      loop(b, b)

   ;Driver
   defn* sort (b:Int, e:Int) :
      val n = e - b
      if n > 2 :
         swap(next-int(rand,b to e), e - 1) when n > 10
         val e1 = partition(b, e - 1, xs[e - 1])
         swap(e1, e - 1)
         sort(b, e1)
         sort(e1 + 1, e)
      else if n == 2 :
         swap(b, b + 1) when is-less?(xs[b + 1], xs[b])

   sort(0, length(xs))

public defn qsort!<?T> (xs:IndexedCollection<?T>, cmp:(T,T) -> Int) -> False :
   ;Random
   val rand = Random(0L)
   
   ;Swap element i with element j
   defn swap (i:Int, j:Int) :
      if i != j :
         val xi = xs[i]
         val xj = xs[j]
         xs[i] = xj
         xs[j] = xi

   ;Rearrange elements from b to e, such that:
   ;   b to lt is less than v
   ;   lt to gt is equal to v
   ;   gt to e is greater than v
   ;Returns [lt, gt]
   defn partition (b:Int, e:Int, pivot:T) -> [Int, Int] :      
      defn* loop (lt:Int, gt:Int, i:Int) :         
         if i < gt :
            val c = cmp(xs[i], pivot)
            if c < 0 :
               swap(i, lt)
               loop(lt + 1, gt, i + 1)
            else if c > 0 :
               swap(i, gt - 1)
               loop(lt, gt - 1, i)
            else :
               loop(lt, gt, i + 1)
         else :
            [lt, gt]            
      loop(b, e, b)      

   ;Driver
   defn* sort (b:Int, e:Int) :
      val n = e - b
      if n > 2 :
         val [lt, gt] = partition(b, e, xs[next-int(rand, b to e)])
         sort(b, lt)
         sort(gt, e)
      else if n == 2 :
         swap(b, b + 1) when cmp(xs[b + 1], xs[b]) < 0

   sort(0, length(xs))

public defn qsort!<?T> (xs:IndexedCollection<?T&Comparable<T>>) -> False :
   qsort!(xs, compare)

public defn qsort!<?T,?S> (key:T -> ?S&Comparable<S>, xs:IndexedCollection<?T>) -> False :
   qsort!(xs, compare{key(_), key(_)})

;                        Non-Destructive Sorting
;                        =======================

val SORT-BUFFER = Vector<?>()
defn clear-sort-buffer () :
  val ret = to-tuple(SORT-BUFFER)
  clear(SORT-BUFFER)
  ret

public defn qsort<?T> (coll:Seqable<?T>, is-less?:(T,T) -> True|False) -> Tuple<T> :
  add-all(SORT-BUFFER, coll)
  qsort!(SORT-BUFFER, is-less?)
  clear-sort-buffer()

public defn qsort<?T> (coll:Seqable<?T>, cmp:(T,T) -> Int) -> Tuple<T> :
  add-all(SORT-BUFFER, coll)
  qsort!(SORT-BUFFER, cmp)
  clear-sort-buffer()

public defn qsort<?T> (coll:Seqable<?T&Comparable<T>>) -> Tuple<T> :
  add-all(SORT-BUFFER, coll)
  qsort!(SORT-BUFFER)
  clear-sort-buffer()

public defn qsort<?T,?S> (key:T -> ?S&Comparable<S>, coll:Seqable<?T>) -> Tuple<T> :
  add-all(SORT-BUFFER, coll)
  qsort!(key as ? -> ?, SORT-BUFFER)
  clear-sort-buffer()  

;                       Lazy Sorting
;                       ============

public defn lazy-qsort<?T> (coll:Seqable<?T>, is-less?:(T,T) -> True|False) -> Collection<T> & Lengthable :
   ;Random
   val rand = Random(0L)

   ;Convert to a vector
   val xs = to-vector<T>(coll)

   ;Sort Progress
   defn sort-progress () :
      generate<Int> :
         ;Swap element i with element j
         defn swap (i:Int, j:Int) :
            if i != j :
               val xi = xs[i]
               val xj = xs[j]
               xs[i] = xj
               xs[j] = xi

         ;Rearrange elements from b to e, such that the first elements is less than pivot.
         ;Returns a s.t. all elements from b to a are less than pivot.
         defn partition (b:Int, e:Int, pivot:T) :
            defn* loop (a:Int, b:Int) -> Int :
               if b < e :
                  val xb = xs[b]
                  if is-less?(xb, pivot) :
                     swap(a, b)
                     loop(a + 1, b + 1)
                  else : loop(a, b + 1)
               else : a
            loop(b, b)

         ;Driver
         defn* sort (b:Int, e:Int) :
            val n = e - b
            if n > 2 :
               swap(next-int(rand, b to e), e - 1) when n > 10
               val e1 = partition(b, e - 1, xs[e - 1])
               swap(e1, e - 1)
               sort(b, e1)
               yield(e1 + 1)
               sort(e1 + 1, e)
            else if n == 2 :
               swap(b, b + 1) when is-less?(xs[b + 1], xs[b])

         sort(0, length(xs))
         break(length(xs))

   ;Ensuring Progress
   var sorted = 0
   val sorter = sort-progress()
   defn* ensure-sorted (n:Int) :
      if sorted < n :
         sorted = next(sorter)
         ensure-sorted(n)

   ;Return object
   new Collection<T> & Lengthable :
      defmethod length (this) :
         length(xs)
      defmethod to-seq (this) :
         for i in 0 to length(xs) seq :
            ensure-sorted(i + 1)
            xs[i]


public defn lazy-qsort<?T> (coll:Seqable<?T>, cmp:(T,T) -> Int) -> Collection<T> & Lengthable :
   ;Random
   val rand = Random(0L)
   
   ;Convert to a vector
   val xs = to-vector<T>(coll)

   ;Sort Progress
   defn sort-progress () :
      generate<Int> :
         ;Swap element i with element j
         defn swap (i:Int, j:Int) :
            if i != j :
               val xi = xs[i]
               val xj = xs[j]
               xs[i] = xj
               xs[j] = xi

         ;Rearrange elements from b to e, such that:
         ;   b to lt is less than v
         ;   lt to gt is equal to v
         ;   gt to e is greater than v
         ;Returns [lt, gt]
         defn partition (b:Int, e:Int, pivot:T) -> [Int, Int] :      
            defn* loop (lt:Int, gt:Int, i:Int) :         
               if i < gt :
                  val c = cmp(xs[i], pivot)
                  if c < 0 :
                     swap(i, lt)
                     loop(lt + 1, gt, i + 1)
                  else if c > 0 :
                     swap(i, gt - 1)
                     loop(lt, gt - 1, i)
                  else :
                     loop(lt, gt, i + 1)
               else :
                  [lt, gt]            
            loop(b, e, b)      

         ;Driver
         defn* sort (b:Int, e:Int) :
            val n = e - b
            if n > 2 :
               val [lt, gt] = partition(b, e, xs[next-int(rand,b to e)])
               sort(b, lt)
               yield(gt)
               sort(gt, e)
            else if n == 2 :
               swap(b, b + 1) when cmp(xs[b + 1], xs[b]) < 0

         sort(0, length(xs))
         break(length(xs))

   ;Ensuring Progress
   var sorted = 0
   val sorter = sort-progress()
   defn* ensure-sorted (n:Int) :
      if sorted < n :
         sorted = next(sorter)
         ensure-sorted(n)

   ;Return object
   new Collection<T> & Lengthable :
      defmethod length (this) :
         length(xs)
      defmethod to-seq (this) :
         for i in 0 to length(xs) seq :
            ensure-sorted(i + 1)
            xs[i]

public defn lazy-qsort<?T> (coll:Seqable<?T&Comparable<T>>) :
   lazy-qsort(coll, compare)

public defn lazy-qsort<?T,?S> (key:T -> ?S&Comparable<S>, coll:Seqable<?T>) :
   lazy-qsort(coll, compare{key(_), key(_)})

;============================================================
;======================= Arrays =============================
;============================================================

;                     Implementation
;                     ==============

lostanza deftype RawArray <: Array :
   length: long
   items: ref<?> ...

lostanza defn RawArray (n:ref<Int>, x:ref<?>) -> ref<RawArray> :
   val l = n.value
   val a = new RawArray{l}
   for (var i:long = 0, i < l, i = i + 1) :
      a.items[i] = x
   return a

defmethod get (a:RawArray, i:Int) -> ? :
   ($prim aget a i)

defmethod set (a:RawArray, i:Int, v) -> False :
   ($prim aset a i v)

lostanza defmethod set-all (xs:ref<RawArray>, r:ref<Range>, v:ref<?>) -> ref<False> :
   val range = range-bound(xs, r) as ref<Tuple<Int>>
   val b = range.items[0].value
   val e = range.items[1].value
   for (var i:long = b, i < e, i = i + 1) :
      xs.items[i] = v
   return false

defmethod length (a:RawArray) -> Int :
   ($prim alen a)

defmethod print (o:OutputStream, a:RawArray) -> False :
   print(o, "[%@]" % [a])

defmethod equal? (a:RawArray, b:RawArray) :
   ($prim identical? a b)

;                     Wrapping
;                     ========

#if-defined(OPTIMIZE) :

   public defn Array<T> (n:Int) -> Array<T> :
      RawArray(n, sentinel)

   public defn Array<T> (n:Int, x:T) -> Array<T> :
      RawArray(n, x)

#else :

   deftype WrappedArray<T> <: Array<T>
   defmulti raw (a:WrappedArray) -> RawArray

   public defn Array<T> (n:Int) -> Array<T> :
      ensure-non-negative("length", n)
      Array<T>(RawArray(n, sentinel))

   public defn Array<T> (n:Int, x:T) -> Array<T> :
      ensure-non-negative("length", n)
      Array<T>(RawArray(n, x))

   defn Array<T> (a:RawArray) -> Array<T> :
      new WrappedArray<T> :
         defmethod raw (this) : a
         defmethod get (this, i:Int) :
            ensure-index-in-bounds(a, i)
            match(a[i]) :
               (v:Sentinel) : fatal("Index (%_) is uninitialized." % [i])
               (v) : v
         defmethod set (this, i:Int, v:T) :
            ensure-index-in-bounds(a, i)
            a[i] = v
         defmethod set-all (this, r:Range, v:T) :
            ensure-index-range(a, r)
            set-all(a, r, v)
         defmethod length (this) :
            length(a)
         defmethod print (o:OutputStream, this) :
            print(o, a)
         defmethod equal? (this, x:WrappedArray) :
            a == raw(x)



;============================================================
;==================== CharArrays ============================
;============================================================

;                     Implementation
;                     ==============

public lostanza defn CharArray (n:ref<Int>, x:ref<Char>) -> ref<CharArray> :
   ensure-non-negative-length(n)
   val l = n.value
   val a = new CharArray{l}
   val c = x.value
   for (var i:long = 0, i < l, i = i + 1) :
      a.chars[i] = c
   return a

public defn CharArray (n:Int) -> CharArray :
   CharArray(n, ' ')

defmethod get (a:CharArray, i:Int) -> Char :
   ensure-index-in-bounds(a, i)
   ($prim char-aget a i)

defmethod set (a:CharArray, i:Int, c:Char) -> False :
   ensure-index-in-bounds(a, i)
   ($prim char-aset a i c)

defmethod length (a:CharArray) -> Int :
   ($prim alen a)

lostanza defn substring! (a:ref<CharArray>, b:ref<Int>, e:ref<Int>) -> ref<String> :
   val len = e.value - b.value
   val start = b.value
   val s = String(len)
   for (var i:long = 0, i < len, i = i + 1) :
      s.chars[i] = a.chars[i + start]
   s.chars[len] = 0 as byte
   return s

defmethod get (a:CharArray, r:Range) -> String :
   ensure-index-range(a, r)
   val [b, e] = range-bound(a, r)
   substring!(a, b, e)

;                     Looping
;                     =======

defmethod do (f: Char -> ?, xs:CharArray) :
   defn* loop (i:Int, n:Int) :
      if n > 0 :
         f(xs[i])
         loop(i + 1, n - 1)
   loop(0, length(xs))

;============================================================
;==================== Block Copying =========================
;============================================================

public defmulti block-copy<?T> (n:Int, dst:IndexedCollection<?T>, di:Int, src:IndexedCollection<T>, si:Int) -> False

defmethod block-copy<?T> (n:Int, dst:IndexedCollection<?T>, di:Int, src:IndexedCollection<T>, si:Int) :
   #if-not-defined(OPTIMIZE) :
      ensure-non-negative("number of elements", n)
      ensure-non-negative("destination index", di)
      ensure-non-negative("source index", si)
      if length(dst) < di + n : fatal("Attempt to write past bounds of destination collection.")
      if length(src) < si + n : fatal("Attempt to write past bounds of source collection.")      
   for i in 0 to n do :
      dst[di + i] = src[si + i]

;============================================================
;==================== Conversions ===========================
;============================================================

;                 Numeric Conversions
;                 ===================

public lostanza defn to-byte (b:ref<Byte>) -> ref<Byte> : return b
public lostanza defn to-byte (c:ref<Char>) -> ref<Byte> : return new Byte{c.value}
public lostanza defn to-byte (i:ref<Int>) -> ref<Byte> : return new Byte{i.value as byte}
public lostanza defn to-byte (l:ref<Long>) -> ref<Byte> : return new Byte{l.value as byte}
public lostanza defn to-byte (f:ref<Float>) -> ref<Byte> : return new Byte{f.value as byte}
public lostanza defn to-byte (d:ref<Double>) -> ref<Byte> : return new Byte{d.value as byte}
public lostanza defn to-char (b:ref<Byte>) -> ref<Char> : return new Char{b.value}
public lostanza defn to-char (c:ref<Char>) -> ref<Char> : return c
public lostanza defn to-char (i:ref<Int>) -> ref<Char> : return new Char{i.value as byte}
public lostanza defn to-int (b:ref<Byte>) -> ref<Int> : return new Int{b.value}
public lostanza defn to-int (c:ref<Char>) -> ref<Int> : return new Int{c.value}
public lostanza defn to-int (i:ref<Int>) -> ref<Int> : return i
public lostanza defn to-int (l:ref<Long>) -> ref<Int> : return new Int{l.value as int}
public lostanza defn to-int (f:ref<Float>) -> ref<Int> : return new Int{f.value as int}
public lostanza defn to-int (d:ref<Double>) -> ref<Int> : return new Int{d.value as int}
public lostanza defn to-long (b:ref<Byte>) -> ref<Long> : return new Long{b.value}
public lostanza defn to-long (i:ref<Int>) -> ref<Long> : return new Long{i.value}
public lostanza defn to-long (l:ref<Long>) -> ref<Long> : return l
public lostanza defn to-long (f:ref<Float>) -> ref<Long> : return new Long{f.value as long}
public lostanza defn to-long (d:ref<Double>) -> ref<Long> : return new Long{d.value as long}
public lostanza defn to-float (b:ref<Byte>) -> ref<Float> : return new Float{b.value as float}
public lostanza defn to-float (i:ref<Int>) -> ref<Float> : return new Float{i.value as float}
public lostanza defn to-float (l:ref<Long>) -> ref<Float> : return new Float{l.value as float}
public lostanza defn to-float (f:ref<Float>) -> ref<Float> : return f
public lostanza defn to-float (d:ref<Double>) -> ref<Float> : return new Float{d.value as float}
public lostanza defn to-double (b:ref<Byte>) -> ref<Double> : return new Double{b.value as double}
public lostanza defn to-double (i:ref<Int>) -> ref<Double> : return new Double{i.value as double}
public lostanza defn to-double (l:ref<Long>) -> ref<Double> : return new Double{l.value as double}
public lostanza defn to-double (f:ref<Float>) -> ref<Double> : return new Double{f.value}
public lostanza defn to-double (d:ref<Double>) -> ref<Double> : return d

;                Numeric Reinterpretations
;                =========================

public lostanza defn bits (f:ref<Float>) -> ref<Int> :
  val v = f.value
  return new Int{($ls-prim bits v)}

public lostanza defn bits (d:ref<Double>) -> ref<Long> :
  val v = d.value
  return new Long{($ls-prim bits v)}

public lostanza defn bits-as-float (i:ref<Int>) -> ref<Float> :
  val v = i.value
  return new Float{($ls-prim fnum v)}

public lostanza defn bits-as-double (i:ref<Long>) -> ref<Double> :
  val v = i.value
  return new Double{($ls-prim fnum v)}

;============================================================
;==================== Number Parsing ========================
;============================================================

;                     Error Checking
;                     ==============

#for (to-value! in [to-byte! to-int! to-long! to-float! to-double!]
      to-value in [to-byte to-int to-long to-float to-double]
      Value in [Byte Int Long Float Double]
      name in ["byte" "int" "long" "float" "double"]) :
  public defn to-value! (s:String) -> Value :
    #if-defined(OPTIMIZE) :
      to-value(s) as Value
    #else :
      match(to-value(s)) :
        (v:Value) : v
        (v:False) : fatal("String %~ cannot be converted to a %_." % [s, name])

;                        Drivers
;                        =======

public defn to-byte (s:String) -> False|Byte :
  match(to-int(s)) :
    (i:Int) : to-byte(i) when i >= 0 and i <= 255
    (i:False) : false

public lostanza defn to-int (s:ref<String>) -> ref<False|Int> :
  if prefix?(s, "-") :
    return neg-to-int(s, 1, 10)
  else if prefix?(s, "0x") :
    return bits-to-int(s, 2, 16, 4)
  else if prefix?(s, "0o") :
    return bits-to-int(s, 2, 8, 3)
  else if prefix?(s, "0b") :
    return bits-to-int(s, 2, 2, 1)
  else :
    return pos-to-int(s, 0, 10)

public lostanza defn to-long (s:ref<String>) -> ref<False|Long> :
  if prefix?(s, "-") :
    return neg-to-long(s, 1, 10)
  else if prefix?(s, "0x") :
    return bits-to-long(s, 2, 16, 4)
  else if prefix?(s, "0o") :
    return bits-to-long(s, 2, 8, 3)
  else if prefix?(s, "0b") :
    return bits-to-long(s, 2, 2, 1)
  else :
    return pos-to-long(s, 0, 10)

;TODO: This is necessary because addresses of local variables don't work yet.
lostanza var DOUBLE-BUFFER : double
lostanza var CHAR-BUFFER : byte
public lostanza defn to-double (s:ref<String>) -> ref<False|Double> :
  val n = call-c clib/sscanf(addr!(s.chars), "%lf%c", addr(DOUBLE-BUFFER), addr(CHAR-BUFFER))
  if n != 1 : return false
  else : return new Double{DOUBLE-BUFFER}

lostanza var FLOAT-BUFFER : float
public lostanza defn to-float (s:ref<String>) -> ref<False|Float> :
  val n = call-c clib/sscanf(addr!(s.chars), "%f%c", addr(FLOAT-BUFFER), addr(CHAR-BUFFER))
  if n != 1 : return false
  else : return new Float{FLOAT-BUFFER}

;                        Utilities
;                        =========

lostanza defn prefix? (str:ref<String>, prefix:ptr<byte>) -> int :
  for (var i:long = 0, 1, i = i + 1) :
    if prefix[i] == 0 : return 1
    else if str.chars[i] == 0 : return 0
    else if prefix[i] != str.chars[i] : return 0
  return 0

lostanza defn digit (c:byte, radix:int) -> int :
  var d:int
  if c >= '0' and c <= '9' : d = c - '0'
  else if c >= 'a' and c <= 'f' : d = c - 'a' + 10
  else if c >= 'A' and c <= 'F' : d = c - 'A' + 10
  else : return -1
  if d < radix : return d
  else : return -1

;                        Parsing Integers
;                        ================

lostanza defn pos-to-int (s:ref<String>, start:int, radix:int) -> ref<False|Int> :
  var n:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Int{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix + d
        if n < 0 : return false
  fatal("Unreachable")
  return false

lostanza defn neg-to-int (s:ref<String>, start:int, radix:int) -> ref<False|Int> :
  var n:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Int{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix - d
        if n > 0 : return false
  fatal("Unreachable")
  return false

lostanza defn bits-to-int (s:ref<String>, start:int, radix:int, bits:int) -> ref<False|Int> :
  var n:int = 0
  var nbits:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Int{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = (n << bits) | d
        nbits = nbits + bits
        if nbits >= 32 + bits : return false
  fatal("Unreachable")
  return false

;                        Parsing Longs
;                        =============

lostanza defn pos-to-long (s:ref<String>, start:int, radix:int) -> ref<False|Long> :
  var n:long = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Long{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix + d
        if n < 0 : return false
  fatal("Unreachable")
  return false

lostanza defn neg-to-long (s:ref<String>, start:int, radix:int) -> ref<False|Long> :
  var n:long = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Long{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = n * radix - d
        if n > 0 : return false
  fatal("Unreachable")
  return false

lostanza defn bits-to-long (s:ref<String>, start:int, radix:int, bits:int) -> ref<False|Long> :
  var n:long = 0
  var nbits:int = 0
  for (var i:long = start, 1, i = i + 1) :
    if s.chars[i] == 0 :
      return new Long{n}
    else :
      val d = digit(s.chars[i], radix)
      if d < 0 :
        return false
      else :
        n = (n << bits) | d
        nbits = nbits + bits
        if nbits >= 64 + bits : return false
  fatal("Unreachable")
  return false

;============================================================
;==================== Arithmetic ============================
;============================================================

public defn max<?T,?S> (a:?S&Comparable<?T>, b:T) -> S|T :
  b when a < b else a

public defn min<?T,?S> (a:?S&Comparable<?T>, b:T) -> S|T :
  a when a < b else b

public defn minimum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, xs} $ fn (x, y) :
    if x < y : x
    else : y

public defn minimum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, x0, xs} $ fn (x, y) :
    if x < y : x
    else : y

public defn maximum<?T> (xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, xs} $ fn (x, y) :
    if x < y : y
    else : x

public defn maximum<?T> (x0:T, xs:Seqable<?T>, less?: (T, T) -> True|False) -> T :
  reduce{_, x0, xs} $ fn (x, y) :
    if x < y : y
    else : x

public defn minimum<?T> (xs:Seqable<?T&Comparable>) -> T : minimum(xs, less?)
public defn maximum<?T> (xs:Seqable<?T&Comparable>) -> T : maximum(xs, less?)

public defn minimum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T : minimum(x0, xs, less?)
public defn maximum<?T> (x0:T&Comparable, xs:Seqable<?T&Comparable>) -> T : maximum(x0, xs, less?)

public defn minimum<?T> (key: T -> Comparable, xs:Seqable<?T>) -> T : minimum(xs, {key(_) < key(_)})
public defn maximum<?T> (key: T -> Comparable, xs:Seqable<?T>) -> T : maximum(xs, {key(_) < key(_)})

public defn ceil-log2 (i:Int) -> Int :
  defn* loop (n:Int, l:Int) :
    if i > n :
      if l == 30 : l + 1
      else : loop(n << 1, l + 1)
    else : l
  fatal("Log of non-positive number!") when i <= 0
  loop(1, 0)

public defn floor-log2 (i:Int) -> Int :
  defn* loop (n:Int, l:Int) :
    if i == n : l
    else if i < n : l - 1
    else if l == 30 : l
    else : loop(n << 1, l + 1)
  fatal("Log of non-positive number!") when i <= 0
  loop(1, 0)

public defn ceil-log2 (i:Long) -> Int :
  defn* loop (n:Long, l:Int) :
    if i > n :
      if l == 62 : l + 1
      else : loop(n << to-long(1), l + 1)
    else : l
  fatal("Log of non-positive number!") when i <= to-long(0)
  loop(to-long(1), 0)

public defn floor-log2 (i:Long) -> Int :
  defn* loop (n:Long, l:Int) :
    if n == i : l
    else if i < n : l - 1
    else if l == 62 : l
    else : loop(n << to-long(1), l + 1)
  fatal("Log of non-positive number!") when i <= to-long(0)
  loop(to-long(1), 0)

public defn next-pow2 (i:Int) -> Int :
  ensure-non-negative("value", i)
  if i == 0 :
    i
  else :
    val n = ceil-log2(i)
    if n <= 30 : 1 << n
    else : fatal("Overflow")

public defn prev-pow2 (i:Int) -> Int :
  ensure-non-negative("value", i)
  if i == 0 :
    i
  else :
    1 << floor-log2(i)

public defn next-pow2 (i:Long) -> Long :
  val n = ceil-log2(i)
  if n <= 62 : to-long(1) << to-long(n)
  else : fatal("Overflow")

public defn prev-pow2 (i:Long) -> Long :
  to-long(1) << to-long(floor-log2(i))

public defn sum (xs: Seqable<Int>) -> Int : reduce(plus, 0, xs)
public defn sum (xs: Seqable<Long>) -> Long : reduce(plus, 0L, xs)
public defn sum (xs: Seqable<Float>) -> Float : reduce(plus, 0.0f, xs)
public defn sum (xs: Seqable<Double>) -> Double : reduce(plus, 0.0, xs)

public defn product (xs: Seqable<Int>) -> Int : reduce(times, 1, xs)
public defn product (xs: Seqable<Long>) -> Long : reduce(times, 1L, xs)
public defn product (xs: Seqable<Float>) -> Float : reduce(times, 1.0f, xs)
public defn product (xs: Seqable<Double>) -> Double : reduce(times, 1.0, xs)

;============================================================
;====================== Maybe ===============================
;============================================================

;                      Interface
;                      =========

public defmulti value<?T> (x:One<?T>) -> T

;                     Constructors
;                     ============

public defn None () :
   new None

public defn One<?T> (x:?T) :
   new One<T> :
      defmethod value (this) : x

;                     Printers
;                     ========

defmethod print (o:OutputStream, x:None) :
   print(o, "None")
defmethod print (o:OutputStream, x:One) :
   print(o, "One(%~)" % [value(x)])

;                   Implementation
;                   ==============

public defn value!<?T> (x:Maybe<?T>) -> T :
   match(x) :
      (x:One<T>) : value(x)
      (x:None) : fatal("Object of type None has no value.")

public defn value?<?T> (x:Maybe<?T>, default:?T) -> T :
   match(x) :
      (x:One<T>) : value(x)
      (x:None) : default

public defn value?<?T> (x:Maybe<?T>) -> T|False :
   value?(x, false)

public defn empty? (x:Maybe) :
   x is None

defmethod equal? (a:None, b:None) :
   true

defmethod equal? (a:One, b:One) :
   value(a) == value(b)

defmethod hash (a:None) :
  1817

defmethod hash (a:One) :
  hash(value(a)) * 17

;                   Comparisons
;                   ===========

defmethod* compare<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : 0
      (x:None, y:One<T>) : -1
      (x:One<T>, y:None) : 1
      (x:One<T&Comparable<T>>, y:One<T>) : compare(value(x), value(y))

defmethod less?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : false
      (x:None, y:One<T>) : true
      (x:One<T>, y:None) : false
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) < value(y)

defmethod less-eq?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : true
      (x:None, y:One<T>) : true
      (x:One<T>, y:None) : false
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) <= value(y)

defmethod greater?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : false
      (x:None, y:One<T>) : false
      (x:One<T>, y:None) : true
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) > value(y)

defmethod greater-eq?<?T> (x:Maybe<?T>, y:Maybe<T>) :
   match(x, y) :
      (x:None, y:None) : true
      (x:None, y:One<T>) : false
      (x:One<T>, y:None) : true
      (x:One<T&Comparable<T>>, y:One<T>) : value(x) >= value(y)

;============================================================
;====================== Ranges ==============================
;============================================================

;                      Interface
;                      =========

public defmulti start (r:Range) -> Int
public defmulti end (r:Range) -> Int|False
public defmulti step (r:Range) -> Int
public defmulti inclusive? (r:Range) -> True|False

;                     Constructor
;                     ===========

public defn Range (start:Int, end:Int|False, step:Int, inclusive?:True|False) :
   ;Compute the length of the range
   val length = match(end, inclusive?) :
      (end:Int, inc:False) :
         if step == 0 :
            if start == end : 0
            else : false
         else if step == 1 :
            end - start
         else if step == -1 :
            start - end
         else if step > 0 :
            (end - start + step - 1) / step
         else :
            (end - start + step + 1) / step
      (end:Int, inc:True) :
         if step == 0 :
            false
         else if step == 1 :
            end - start + 1
         else if step == -1 :
            start - end + 1
         else :
            (end - start + step) / step
      (end:False, inc) :
         false

   match(length) :
      (length:Int) :
         new Range & Lengthable :
            defmethod start (this) : start
            defmethod end (this) : end
            defmethod step (this) : step
            defmethod inclusive? (this) : inclusive?
            defmethod length (this) : max(length, 0)
      (length:False) :
         new Range :
            defmethod start (this) : start
            defmethod end (this) : end
            defmethod step (this) : step
            defmethod inclusive? (this) : inclusive?

;                Conversion to Sequence
;                ======================

defmethod to-seq (r:Range) :
  match(r) :
    (r:Range & Lengthable) :
      var i = start(r)
      var n = length(r)
      new Seq<Int> & Lengthable :
        defmethod next (this) :
          val i* = peek(this)
          i = i + step(r)
          n = n - 1
          i*
        defmethod peek (this) :
          fatal("Empty Sequence") when empty?(this)
          i
        defmethod empty? (this) :
          n == 0
        defmethod length (this) :
          n
    (r:Range) :
      var i = start(r)
      new Seq<Int> :
        defmethod next (this) :
          val i* = i
          i = i + step(r)
          i*
        defmethod peek (this) :
          i
        defmethod empty? (this) :
          false

;             Reverse
;             =======
public defn reverse (r:Range) :
  ;Fields
  val start = start(r)
  val end = end(r)
  val step = step(r)
  val inc = inclusive?(r)

  ;Cases
  defn* empty-range () :
    Range(end as Int, start, (- step), inc)
  defn* reverse-range (last:Int) :
    last through start by (- step)
  defn* infinite-range () :
    start through start by 0
  defn* no-last-element () :
    fatal("Range %_ cannot be reversed." % [r])

  if step == 0 :
    match(start == end, inc) :
      (eq:False, inc) : infinite-range()
      (eq:True, inc:True) : infinite-range()
      (eq:True, inc:False) : empty-range()
  else if end is False :
    no-last-element()
  else :
    val end = end as Int    
    match(step > 0, end > start) :
      (r1:True, r2:False) :
        empty-range()
      (r1:False, r2:True) :
        empty-range()
      (r1, r2) :
        val sgn-step = 1 when r1 else -1
        val n = if inc : (end - start + step) / step
                else : (end - start + step - sgn-step) / step
        reverse-range(start + (n - 1) * step)       

defmethod in-reverse (r:Range) :
  to-seq(reverse(r))

;             Looping
;             =======

defmethod do (f: Int -> ?, r:Range&Lengthable) :
   val s = step(r)
   defn* loop (i:Int, n:Int) :
      if n > 0 :
         f(i)
         loop(i + s, n - 1)
   loop(start(r), length(r))

defmethod do (f: Int -> ?, r:Range) :
   val s = step(r)
   defn* loop (i:Int) :
      f(i)
      loop(i + s)
   loop(start(r))

;                  Inclusion
;                  =========

defmethod contains? (r:Range, x:Int) :
  val start = start(r)
  val step = step(r)
  match(end(r), inclusive?(r)) :
    (end:Int, inc:False) :
      if step == 0 :
        if start == end : false
        else : start == x
      else if step == 1 :
        x >= start and x < end
      else if step == -1 :
        x <= start and x > end
      else if step > 0 :
        x >= start and x < end and ((x - start) % step == 0)
      else :
        x <= start and x > end and ((x - start) % step == 0)
    (end:Int, inc:True) :
      if step == 0 :
        start == x
      else if step == 1 :
        x >= start and x <= end
      else if step == -1 :
        x <= start and x >= end
      else if step > 0 :
        x >= start and x <= end and ((x - start) % step == 0)
      else :
        x <= start and x >= end and ((x - start) % step == 0)
    (end:False, inc) :
      if step == 0 :
        start == x
      else if step == 1 :
        x >= start
      else if step == -1 :
        x <= start
      else if step > 0 :
        x >= start and ((x - start) % step == 0)
      else :
        x <= start and ((x - start) % step == 0)

;                 Comparison
;                 ==========

defmethod equal? (a:Range, b:Range) :
   start(a) == start(b) and
   end(a) == end(b) and
   step(a) == step(b) and
   inclusive?(a) == inclusive?(b)

;                  Printing
;                  ========

defmethod print (o:OutputStream, x:Range) :
   val op = "through" when inclusive?(x) else "to"
   if step(x) == 1 : print(o, "%_ %_ %_" % [start(x), op, end(x)])
   else : print(o, "%_ %_ %_ by %_" % [start(x), op, end(x), step(x)])

;                  Mapping
;                  =======

public defn map<?R> (f: Int -> ?R, r:Range) -> List<R> :
   fatal("Infinite Range") when r is-not Range&Lengthable
   to-list(seq(f, r))

;============================================================
;================== Sequence Library ========================
;============================================================

public deftype Seqable<T>
public deftype Seq<T> <: Seqable<T>
public deftype Collection<T> <: Seqable<T>

public defmulti do<?T> (f:T -> ?, xs:Seqable<?T>) -> False
public defmulti do<?T,?S> (f:(T,S) -> ?, xs:Seqable<?T>, ys:Seqable<?S>) -> False
public defmulti do<?T,?S,?U> (f:(T,S,U) -> ?, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> False

defmethod do<?T> (f:T -> ?, xs:Seqable<?T>) -> False :
   for xs-seq in xs do-seq :
      while not empty?(xs-seq) :
         f(next(xs-seq))

defmethod do<?T,?S> (f:(T,S) -> ?, xs:Seqable<?T>, ys:Seqable<?S>) -> False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         while (not empty?(xs-seq)) and (not empty?(ys-seq)) :
            f(next(xs-seq), next(ys-seq))

defmethod do<?T,?S,?U> (f:(T,S,U) -> ?, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         for zs-seq in zs do-seq :
            while (not empty?(xs-seq)) and (not empty?(ys-seq)) and (not empty?(zs-seq)) :
               f(next(xs-seq), next(ys-seq), next(zs-seq))

defn wrap-length<?T> (xs:Seq<?T>, length:() -> Int) :
  new Seq<T> & Lengthable :
    defmethod next (this) : next(xs)
    defmethod peek (this) : peek(xs)
    defmethod empty? (this) : empty?(xs)
    defmethod length (this) : length()

public defn seq<?T,?S> (f:T -> ?S, xs:Seqable<?T>) -> Seq<S> :
  val xs-seq = to-seq(xs)
  val rs = repeat-while $ fn () :
    if empty?(xs-seq) : None()
    else : One(f(next(xs-seq)))
  match(xs-seq) :
    (xs:Seq&Lengthable) :
      wrap-length(rs, {cached(rs) + length(xs)})
    (xs) : rs

public defn seq<?T,?S,?R> (f:(T,S) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
  val xs-seq = to-seq(xs)
  val ys-seq = to-seq(ys)
  val rs = repeat-while $ fn () :
    if empty?(xs-seq) or empty?(ys-seq) : None()
    else : One(f(next(xs-seq), next(ys-seq)))
  match(xs-seq, ys-seq) :
    (xs:Seq&Lengthable, ys:Seq&Lengthable) :
      wrap-length(rs, {cached(rs) + min(length(xs), length(ys))})
    (xs, ys) : rs

public defn seq<?T,?S,?U,?R> (f:(T,S,U) -> ?R, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
  val xs-seq = to-seq(xs)
  val ys-seq = to-seq(ys)
  val zs-seq = to-seq(zs)
  val rs = repeat-while $ fn () :
    if empty?(xs-seq) or empty?(ys-seq) or empty?(zs-seq) : None()
    else : One(f(next(xs-seq), next(ys-seq), next(zs-seq)))
  match(xs-seq, ys-seq, zs-seq) :
    (xs:Seq&Lengthable, ys:Seq&Lengthable, zs:Seq&Lengthable) :
      wrap-length(rs, {cached(rs) + min(length(xs), min(length(ys), length(zs)))})
    (xs, ys, zs) : rs

public defmulti in-reverse<?T> (xs:Seqable<?T>) -> Seq<T>
defmethod in-reverse<?T> (xs:Seqable<?T>) :
  in-reverse(to-vector<T>(xs))

public defmulti contains? (xs:Seqable<Equalable>, y:Equalable) -> True|False
defmethod contains? (xs:Seqable<Equalable>, y:Equalable) -> True|False :
   label<False|True> return :
      for x in xs do :
         return(true) when x == y

public defn find<?T> (f: T -> True|False, xs:Seqable<?T>) -> T|False :
   label<False|T> return :
      for x in xs do :
         return(x) when f(x)

public defn find<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> T|False :
   label<False|T> return :
      for (x in xs, y in ys) do :
         return(x) when f(x, y)

public defn find!<?T> (f: T -> True|False, xs:Seqable<?T>) : find(f, xs) as T
public defn find!<?T, ?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) : find(f, xs, ys) as T

public defn first<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Maybe<R> :
   label<Maybe<R>> return :
      for x in xs do :
         match(f(x)) :
            (r:One<R>) : return(r)
            (r:None) : false
      None()

public defn first<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Maybe<R> :
   label<Maybe<R>> return :
      for (x in xs, y in ys) do :
         match(f(x, y)) :
            (r:One<R>) : return(r)
            (r:None) : false
      None()

public defn first!<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) : value!(first(f, xs))
public defn first!<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) : value!(first(f, xs, ys))

public defn seq?<?T,?R> (f: T -> Maybe<?R>, xs:Seqable<?T>) -> Seq<R> :
   generate<R> :
      for x in xs do :
         match(f(x)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn seq?<?T,?S,?R> (f: (T,S) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
   generate<R> :
      for (x in xs, y in ys) do :
         match(f(x, y)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn seq?<?T,?S,?U,?R> (f: (T,S,U) -> Maybe<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
   generate<R> :
      for (x in xs, y in ys, z in zs) do :
         match(f(x, y, z)) :
            (r:One<R>) : yield(value(r))
            (r:None) : false

public defn filter<?T> (f: T -> True|False, xs:Seqable<?T>) -> Seq<T> :
   generate<T> :
      for x in xs do :
         yield(x) when f(x)

public defn filter<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<T> :
   generate<T> :
      for (x in xs, y in ys) do :
         yield(x) when f(x, y)

public defn filter<?T> (xs:Seqable<?T>, sel:Seqable<True|False>) -> Seq<T> :
   for (x in xs, s in sel) filter : s

public defn index-of (xs:Seqable<Equalable>, y:Equalable) -> Int|False :
   label<Int|False> return :
      for (x in xs, i in 0 to false) do :
         return(i) when x == y

public defn index-of! (xs:Seqable<Equalable>, y:Equalable) : index-of(xs, y) as Int

public defn index-when<?T> (f: T -> True|False, xs:Seqable<?T>) -> Int|False :
   label<Int|False> return :
      for (x in xs, i in 0 to false) do :
         return(i) when f(x)

public defn index-when<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> Int|False :
   label<Int|False> return :
      for (x in xs, y in ys, i in 0 to false) do :
         return(i) when f(x, y)

public defn index-when!<?T> (f: T -> True|False, xs:Seqable<?T>) : index-when(f, xs) as Int
public defn index-when!<?T,?S> (f: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) : index-when(f, xs, ys) as Int

public defn split!<?T> (f: T -> True|False, xs: Seqable<?T>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable] :
   val true-xs = Vector<T>()
   val false-xs = Vector<T>()
   for x in xs do :
      add{_, x} $
         if f(x) : true-xs
         else : false-xs
   [true-xs, false-xs]

public defn split!<?T,?S> (f: (T, S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable] :
  val true-xs = Vector<T>()
  val false-xs = Vector<T>()
  for (x in xs, y in ys) do :
    add{_, x} $
      if f(x, y) : true-xs
      else : false-xs
  [true-xs, false-xs]

public defn split!<?T> (xs:Seqable<?T>, ss:Seqable<True|False>) -> [Collection<T>&Lengthable, Collection<T>&Lengthable] :
   val true-xs = Vector<T>()
   val false-xs = Vector<T>()
   for (x in xs, s in ss) do :
      add{_, x} $
         if s : true-xs
         else : false-xs
   [true-xs, false-xs]

public defn split<?T> (f:T -> True|False, xs-items:Seqable<?T>) -> [Seq<T>, Seq<T>] :
  val xs = to-seq(xs-items)
  val a-items = Queue<T>()
  val b-items = Queue<T>()

  ;Pull next item onto queues
  defn pull () :
    val x = next(xs)
    if f(x) : add(a-items, x)
    else : add(b-items, x)

  ;Try to fill a queue, returns true if filled
  defn* fill (items:Queue<T>) -> True|False :
    if empty?(items) :
      if not empty?(xs) :
        pull()
        fill(items)
    else :
      true

  ;Create seq from queue
  defn queue-seq (items:Queue<T>) :
    new Seq<T> :
      defmethod next (this) :
        if fill(items) : pop(items)
        else : fatal("No more items")
      defmethod peek (this) :
        if fill(items) : peek(items)
        else : fatal("No more items")
      defmethod empty? (this) :
        not fill(items)

  [queue-seq(a-items), queue-seq(b-items)]

public defn fork<?T> (xs-items:Seqable<?T>) -> [Seq<T>, Seq<T>] :
  val xs = to-seq(xs-items)
  val a-items = Queue<T>()
  val b-items = Queue<T>()
  
  defn queue-seq (items:Queue<T>, other:Queue<T>) :
    new Seq<T> :
      defmethod next (this) :
        if empty?(items) :
          val x = next(xs)
          add(other, x)
          x
        else :
          pop(items)
      defmethod peek (this) :
        if empty?(items) : peek(xs)
        else : peek(items)
      defmethod empty? (this) :
        empty?(items) and empty?(xs)

  [queue-seq(a-items, b-items),
   queue-seq(b-items, a-items)]

public defn fork<?T> (xs-items:Seqable<?T>, n:Int) -> Tuple<Seq<T>> :
  val xs = to-seq(xs-items)
  val items = to-tuple(repeatedly(Queue<T>{}, n))

  ;Pull next item all queues except queue n
  defn pull (n:Int) :
    val x = next(xs)
    for (q in items, i in 0 to false) do :
      add(q, x) when i != n
    x

  to-tuple $ for i in 0 to n seq :
    val items = items[i]
    new Seq<T> :
      defmethod next (this) :
        if empty?(items) : pull(i)
        else : pop(items)
      defmethod peek (this) :
        if empty?(items) : peek(xs)
        else : peek(items)
      defmethod empty? (this) :
        empty?(items) and empty?(xs)

public defn take-while<?T> (f: T -> True|False, xs:Seqable<?T>) :
   generate<T> :
      for xs-seq in xs do-seq :
         defn* loop () :
            if not empty?(xs-seq) :
               val x = peek(xs-seq)
               if f(x) :
                  next(xs-seq)
                  yield(x)
                  loop()
         loop()

public defn take-until<?T> (f: T -> True|False, xs:Seqable<?T>) :
   generate<T> :
      for xs-seq in xs do-seq :
         defn* loop () :
            if not empty?(xs-seq) :
               val x = next(xs-seq)
               yield(x)
               loop() when not f(x)
         loop()

public defn take-n<?T> (n:Int, xs:Seqable<?T>) :
   ensure-non-negative("length", n)
   var len = n
   val xs-seq = to-seq(xs)
   new Seq<T> & Lengthable :
      defmethod next (this) :
         val v = peek(this)
         next(xs-seq)
         len = len - 1
         v
      defmethod peek (this) :
         fatal("Empty Sequence") when len == 0
         peek(xs-seq)
      defmethod empty? (this) :
         len == 0
      defmethod length (this) :
         len
      defmethod free (this) :
         free(xs-seq)

public defn take-up-to-n<?T> (n:Int, xs:Seqable<?T>) :
   ensure-non-negative("length", n)
   var len = n
   val xs-seq = to-seq(xs)
   new Seq<T> :
      defmethod next (this) :
         val v = peek(this)
         next(xs-seq)
         len = len - 1
         v
      defmethod peek (this) :
         fatal("Empty Sequence") when empty?(this)
         peek(xs-seq)
      defmethod empty? (this) :
         (len == 0) or empty?(xs-seq)
      defmethod free (this) :
         free(xs-seq)

public defn cat<?T> (a:Seqable<?T>, b:Seqable<?T>) -> Seq<T> :
   cat-all([a, b])

public defn cat-all<?T> (xss: Seqable<Seqable<?T>>) -> Seq<T> :
   generate<T> :
      for xs in xss do :
         do(yield, xs)

public defn seq-cat<?T,?R> (f:T -> Seqable<?R>, xs:Seqable<?T>) -> Seq<R> :
   cat-all(seq(f, xs))

public defn seq-cat<?T,?S,?R> (f:(T,S) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<R> :
   cat-all(seq(f, xs, ys))

public defn seq-cat<?T,?S,?U,?R> (f:(T,S,U) -> Seqable<?R>, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<R> :
   cat-all(seq(f, xs, ys, zs))

public defn all?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   for xs-seq in xs do-seq :
      defn* loop () :
         if empty?(xs-seq) : true
         else : pred?(next(xs-seq)) and loop()
      loop()

public defn all?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         defn* loop () :
            if empty?(xs-seq) or empty?(ys-seq) : true
            else : pred?(next(xs-seq), next(ys-seq)) and loop()
         loop()

public defn all?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   for xs-seq in xs do-seq :
      for ys-seq in ys do-seq :
         for zs-seq in zs do-seq :
            defn* loop () :
               if empty?(xs-seq) or empty?(ys-seq) or empty?(zs-seq) : true
               else : pred?(next(xs-seq), next(ys-seq), next(zs-seq)) and loop()
            loop()

public defn none?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   defn notp (x) : not pred?(x)
   all?(notp, xs)

public defn none?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   defn notp (x1, x2) : not pred?(x1, x2)
   all?(notp, xs, ys)

public defn none?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   defn notp (x1, x2, x3) : not pred?(x1, x2, x3)
   all?(notp, xs, ys, zs)

public defn any?<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> True|False :
   not none?(pred?, xs)

public defn any?<?T,?S> (pred?: (T,S) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>) -> True|False :
   not none?(pred?, xs, ys)

public defn any?<?T,?S,?U> (pred?: (T,S,U) -> True|False, xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> True|False :
   not none?(pred?, xs, ys, zs)

public defn count (xs:Seqable) -> Int :
   match(xs) :
      (xs:Seqable & Lengthable) :
         length(xs)
       (xs) :
         var accum:Int = 0
         for x in xs do :
            accum = accum + 1
         accum

public defn count<?T> (pred?: T -> True|False, xs:Seqable<?T>) -> Int :
   var accum:Int = 0
   for x in xs do :
      if pred?(x) : accum = accum + 1
   accum

public defn join<?T,?S> (xs0:Seqable<?T>, y:?S) -> Seq<T|S> :
  val xs = to-seq(xs0)
  var join? = false
  val rs = new Seq<T|S> :
    defmethod next (this) :
      fatal("Empty Sequence") when empty?(xs)
      val result = y when join? else next(xs)
      join? = not join?
      result
    defmethod peek (this) :
      fatal("Empty Sequence") when empty?(xs)
      y when join? else peek(xs)
    defmethod empty? (this) :
      empty?(xs)
  match(xs) :
    (xs:Seq<T> & Lengthable) :
      defn rs-length () :
        if join? : length(xs) * 2
        else : length(xs) * 2 - 1
      wrap-length(rs, rs-length)
    (xs) : rs

public defn interleave<?T,?S> (xs0:Seqable<?T>, ys0:Seqable<?S>) -> Seq<T|S> :
  val xs = to-seq(xs0)
  val ys = to-seq(ys0)
  var yield-x? = true
  val rs = new Seq<T|S> :
    defmethod next (this) :
      fatal("Empty Sequence") when empty?(this)
      val result = next(xs) when yield-x? else next(ys)
      yield-x? = not yield-x?
      result
    defmethod peek (this) :
      fatal("Empty Sequence") when empty?(this)
      peek(xs) when yield-x? else peek(ys)
    defmethod empty? (this) :
      empty?(xs) when yield-x? else empty?(ys)
  match(xs, ys) :
    (xs:Seq<T> & Lengthable, ys:Seq<S> & Lengthable) :
      defn rs-length () :
        if yield-x? : 2 * min(length(xs), length(ys))
        else : 1 + 2 * min(length(xs), length(ys) - 1)
      wrap-length(rs, rs-length)
    (xs, ys) : rs

public defn reduce<?T,?S> (f: (T, S) -> ?T, x0: ?T, xs:Seqable<?S>) -> T :
   var accum = x0
   for x in xs do :
      accum = f(accum, x)
   accum

public defn reduce<?T,?S> (f: (T|S, T) -> ?S, xs:Seqable<?T>) -> T|S :
   for xs-seq in xs do-seq :
      reduce(f, next(xs-seq), xs-seq)

public defn reduce-right<?T,?S> (f: (S, T) -> ?T, xs:Seqable<?S>, xn:?T) -> T :
   for xs-seq in xs do-seq :
      defn loop () :
         if empty?(xs-seq) : xn
         else : f(next(xs-seq), loop())
      loop()

public defn reduce-right<?T,?S> (f: (T, T|S) -> ?S, xs:Seqable<?T>) -> T|S :
   for xs-seq in xs do-seq :
      defn loop (x:T) :
         if empty?(xs-seq) : x
         else : f(x, loop(next(xs-seq)))
      loop(next(xs-seq))

public defn repeat<?T> (x:?T) -> Seq<T> :
   new Seq<T> :
      defmethod next (this) : x
      defmethod peek (this) : x
      defmethod empty? (this) : false

public defn repeat<?T> (x:?T, n:Int) :
   ensure-non-negative("length", n)
   var len = n
   new Seq<T> & Lengthable :
      defmethod next (this) :
         fatal("Empty Sequence") when len == 0
         len = len - 1
         x
      defmethod peek (this) :
         fatal("Empty Sequence") when len == 0
         x
      defmethod empty? (this) :
         len == 0
      defmethod length (this) :
         len

deftype RepeatWhileSeq<T> <: Seq<T>
defmulti cached (s:RepeatWhileSeq) -> Int

public defn repeat-while<?T> (f: () -> Maybe<?T>) -> RepeatWhileSeq<T> :
  var item = sentinel
  defn fill () : (item = f()) when item is Sentinel
  
  new RepeatWhileSeq<T> :
    defmethod next (this) :
      val x = peek(this)
      item = sentinel
      x
    defmethod peek (this) :
      fatal("Empty Sequence") when empty?(this)
      value(item as One<T>)
    defmethod empty? (this) :
      fill()
      item is None
    defmethod cached (this) :
      1 when item is One else 0

public defn repeatedly<?T> (f:() -> ?T) -> Seq<T> :
   var item = sentinel
   defn fill () : (item = f()) when item is Sentinel

   defn empty () :
      val x = item as T
      item = sentinel
      x

   new Seq<T> :
      defmethod next (this) :
         fill()
         empty()
      defmethod peek (this) :
         fill()
         item as T
      defmethod empty? (this) :
         false

public defn repeatedly<?T> (f:() -> ?T, n:Int) :
   take-n(n, repeatedly(f))

public defn zip<?T,?S> (xs:Seqable<?T>, ys:Seqable<?S>) -> Seq<[T,S]> :
   for (x in xs, y in ys) seq : [x, y]

public defn zip<?T,?S,?U> (xs:Seqable<?T>, ys:Seqable<?S>, zs:Seqable<?U>) -> Seq<[T,S,U]> :
   for (x in xs, y in ys, z in zs) seq : [x, y, z]

public defn zip-all<?T> (xs:Seqable<Seqable<?T>>) :
   val seqs = to-tuple(seq(to-seq, xs))
   fatal("No Sequences Given") when empty?(seqs)
   val ret-seq = new Seq<Tuple<T>> :
      defmethod next (this) :
         map(next, seqs)
      defmethod peek (this) :
         map(peek, seqs)
      defmethod empty? (this) :
         any?(empty?, seqs)
   if all?({_ is Lengthable&Seq}, seqs) :
      val len = minimum{seq(length{_ as Lengthable&Seq}, seqs)}
      wrap-length(ret-seq, len)
   else :
      ret-seq

public defn unique<?T> (xs:Seqable<?T&Equalable>) -> List<T> :
   ;Manage Visited Set
   val table = HashTable<Hashable,True|False>()
   val accum = Vector<Equalable>()

   defn add-to-unique-set (x:T&Equalable) :
      match(x) :
         (x:T&Equalable&Hashable) : table[x] = true
         (x:T&Equalable) : add(accum, x)
   defn visited? (x:T&Equalable) :
      match(x) :
         (x:T&Equalable&Hashable) : key?(table, x)
         (x:T&Equalable) : contains?(accum, x)

   ;Filter
   to-list $ for x in xs filter :
      if not visited?(x) :
         add-to-unique-set(x)
         true

public defn lookup?<?K,?V,?D> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable, default:?D) -> D|V :
   label<V|D> return :
      for e in xs do :
         return(value(e)) when key(e) == k
      default

public defn lookup?<?K,?V> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable) -> False|V :
   lookup?(xs, k, false)

public defn lookup<?K,?V> (xs: Seqable<KeyValue<?K&Equalable,?V>>, k:K&Equalable) -> V :
   label<V> return :
      for e in xs do :
         return(value(e)) when key(e) == k
      fatal("Key %~ not found in entries." % [k])

public defn fork-on-seq<?T,?X,?Y> (xs:Seqable<?T>, f:Seq<T> -> ?X, g:Seq<T> -> ?Y) -> [X,Y] :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val fco = make-co(f)
   val gco = make-co(g)

   ;Store function results
   var fresult = resume(fco, None())
   var gresult = resume(gco, None())

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         if fresult is None :
            fresult = resume(fco, v)
         if gresult is None :
            gresult = resume(gco, v)
         (fresult is None) or
         (gresult is None)
      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   [value!(fresult),
    value!(gresult)]

public defn fork-on-seq<?T,?X,?Y,?Z> (xs:Seqable<?T>, f:Seq<T> -> ?X, g:Seq<T> -> ?Y, h:Seq<T> -> ?Z) -> [X,Y,Z] :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val fco = make-co(f)
   val gco = make-co(g)
   val hco = make-co(h)

   ;Store function results
   var fresult = resume(fco, None())
   var gresult = resume(gco, None())
   var hresult = resume(hco, None())

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         if fresult is None :
            fresult = resume(fco, v)
         if gresult is None :
            gresult = resume(gco, v)
         if hresult is None :
            hresult = resume(hco, v)
         (fresult is None) or
         (gresult is None) or
         (hresult is None)
      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   [value!(fresult),
    value!(gresult),
    value!(hresult)]

public defn fork-on-seq<?T,?S> (xs:Seqable<?T>, fs:Seqable<(Seq<T> -> ?S)>) -> Tuple<S> :
   ;Create function coroutines
   defn make-co<?S> (f:Seq<T> -> ?S) :
      Coroutine<Maybe<T>, Maybe<S>> $ fn (co, _) :
         val xs = repeat-while $ fn () :
            suspend(co, None())
         One(f(xs))
   val cos = to-tuple(seq(make-co, fs))

   ;Store function results
   val results = to-array<Maybe<S>>(seq(resume{_, None()}, cos))

   ;Start sequence
   val seq-xs = to-seq(xs)
   defn* loop () :
      defn run-fns (v:Maybe<T>) :
         var more? = false
         for (co in cos, i in 0 to false) do :
            if results[i] is None :
               val r = resume(co, v)
               results[i] = r
               more? = more? or (r is None)
         more?

      if empty?(seq-xs) :
         run-fns(None())
      else if run-fns(One(next(seq-xs))) :
         loop()
   loop()

   ;Return results
   to-tuple(seq(value!, results))

;============================================================
;===================== Random Numbers =======================
;============================================================

public lostanza deftype Random :
  state: long
lostanza defn next-state (s0:long) -> long :
  return (s0 * 0x5deece66dL + 0xbL) & 0xFFFFFFFFFFFFL
lostanza defn extract-bits (s:long, n:int) -> int :
  return (s >>> (48 - n)) as int
lostanza defn next-bits (r:ref<Random>, n:int) -> int :
  val s = next-state(r.state)
  r.state = s
  return extract-bits(s, n)

public lostanza defn Random (state:ref<Long>) -> ref<Random> :
  return new Random{next-state(state.value)}

public lostanza defn state (r:ref<Random>) -> ref<Long> :
  return new Long{r.state}

public lostanza defn set-state (r:ref<Random>, state:ref<Long>) -> ref<False> :
  r.state = state.value
  return false

public defn Random () :
  Random(current-time-us())

public lostanza defn next-int (r:ref<Random>) -> ref<Int> :
  return new Int{next-bits(r, 31)}

public lostanza defn next-signed-int (r:ref<Random>) -> ref<Int> :
  return new Int{next-bits(r, 32)}

val LIMIT-STR = String("limit")
public lostanza defn next-int (r:ref<Random>, n0:ref<Int>) -> ref<Int> :
  ensure-positive(LIMIT-STR, n0)

  ;Extract lostanza values
  val n = n0.value

  ;Power of 2
  if n & (- n) == n :
    val bits = next-bits(r, 31) as long
    return new Int{((n * bits) >> 31) as int}

  ;Otherwise
  labels :
    loop :
      val bits = next-bits(r, 31)
      val v = bits % n
      if bits - v + (n - 1) < 0 : goto loop
      else : return new Int{v}

public lostanza defn next-bytes (r:ref<Random>, bs:ref<ByteArray>) -> ref<False> :
  val n = bs.length
  labels :
    begin: goto loop(r.state, 0)
    loop (s:long, i:long) :
      if i + 4 < n :
        val s* = next-state(s)
        [addr!(bs.data[i]) as ptr<int>] = extract-bits(s*, 32)
        goto loop(s*, i + 4)
      else : goto end(s, i)
    end (s:long, i:long) :
      if i < n :
        val s* = next-state(s)
        bs.data[i] = extract-bits(s*, 8) as byte
        goto end(s*, i + 1)
      else :
        r.state = s
        return false

public defn next-int (rand:Random, r:Range) :
  ;Returns an integer between lo and hi inclusive
  defn from-interval (lo:Int, hi:Int) :
    val spread = hi - lo + 1
    if spread < 0 :
      let loop () :
        val r = next-int(rand)
        if r >= lo and r <= hi : r
        else : loop()
    else :
      lo + next-int(rand, spread)

  ;Check
  #if-not-defined(OPTIMIZE) :
    if step(r) != 1 :
      fatal("Ranges with step sizes other than 1 not supported.")      
  val s = start(r)
  match(end(r), inclusive?(r)) :
    (e:Int, inc:True) :
      ensure-start-before-end(s, e)      
      from-interval(s, e)
    (e:Int, inc:False) :
      #if-not-defined(OPTIMIZE) :
        if e == s : fatal("Empty range.")
        else : ensure-start-before-end(s, e)
      from-interval(s, e - 1)
    (e:False, inc) :
      from-interval(s, INT-MAX)     

public lostanza defn next-long (rand:ref<Random>) -> ref<Long> :
  val x0 = next-bits(rand, 31) as long
  val x1 = next-bits(rand, 32) as long & 0xFFFFFFFFL
  val r0 = (x0 << 32L)
  return new Long{x0 << 32L | x1}

public lostanza defn next-signed-long (rand:ref<Random>) -> ref<Long> :
  val x0 = next-bits(rand, 32) as long
  val x1 = next-bits(rand, 32) as long & 0xFFFFFFFFL
  return new Long{x0 << 32L | x1}

public lostanza defn next-float (rand:ref<Random>) -> ref<Float> :
  return new Float{next-bits(rand,24) as float / (1 << 24) as float}

public lostanza defn next-double (rand:ref<Random>) -> ref<Double> :
  val num = ((next-bits(rand, 26) as long) << 27) + next-bits(rand, 27)
  val den = (1L << 53L) as double
  return new Double{num as double / den}

val RANDOM = Random(current-time-us())
public defn current-random () : RANDOM
public defn srand (n:Long) : set-state(RANDOM, n)
public defn rand () : next-int(RANDOM)
public defn rand-long () : next-long(RANDOM)
public defn rand-float () : next-float(RANDOM)
public defn rand-double () : next-double(RANDOM)
public defn rand (n:Int) : next-int(RANDOM, n)
public defn rand (r:Range) : next-int(RANDOM, r)

;############################################################
;################## Math Package ############################
;############################################################

defpackage math :
   import core

public lostanza val PI:ref<Double> = new Double{3.141592653589793}
public lostanza val PI-F:ref<Float> = new Float{3.1415927f}

public lostanza defn exp (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/exp(x.value)}
public lostanza defn exp (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/exp(x.value) as float}

public lostanza defn log (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/log(x.value)}
public lostanza defn log (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/log(x.value) as float}

public lostanza defn log10 (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/log10(x.value)}
public lostanza defn log10 (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/log10(x.value) as float}

public lostanza defn sqrt (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sqrt(x.value)}
public lostanza defn sqrt (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sqrt(x.value) as float}

public lostanza defn pow (x:ref<Double>, y:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/pow(x.value, y.value)}
public lostanza defn pow (x:ref<Float>, y:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/pow(x.value, y.value) as float}

public lostanza defn sin (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sin(x.value)}
public lostanza defn sin (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sin(x.value) as float}

public lostanza defn cos (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/cos(x.value)}
public lostanza defn cos (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/cos(x.value) as float}

public lostanza defn tan (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/tan(x.value)}
public lostanza defn tan (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/tan(x.value) as float}

public lostanza defn asin (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/asin(x.value)}
public lostanza defn asin (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/asin(x.value) as float}

public lostanza defn acos (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/acos(x.value)}
public lostanza defn acos (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/acos(x.value) as float}

public lostanza defn atan (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/atan(x.value)}
public lostanza defn atan (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/atan(x.value) as float}

public lostanza defn atan2 (y:ref<Double>, x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/atan2(y.value, x.value)}
public lostanza defn atan2 (y:ref<Float>, x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/atan2(y.value, x.value) as float}

public lostanza defn sinh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sinh(x.value)}
public lostanza defn sinh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sinh(x.value) as float}

public lostanza defn cosh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/cosh(x.value)}
public lostanza defn cosh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/cosh(x.value) as float}

public lostanza defn tanh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/tanh(x.value)}
public lostanza defn tanh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/tanh(x.value) as float}

public lostanza defn ceil (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/ceil(x.value)}
public lostanza defn ceil (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/ceil(x.value) as float}

public lostanza defn floor (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/floor(x.value)}
public lostanza defn floor (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/floor(x.value) as float}

public lostanza defn round (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/round(x.value)}
public lostanza defn round (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/round(x.value) as float}

public lostanza defn to-radians (degrees:ref<Double>) -> ref<Double> :
   val pi = 3.141592653589793
   return new Double{degrees.value * pi / 180.0}

public lostanza defn to-degrees (radians:ref<Double>) -> ref<Double> :
   val pi = 3.141592653589793
   return new Double{radians.value * 180.0 / pi}

;################################################################################
;################################## Scratchpad ##################################
;################################################################################

defpackage scratchpad :
  import core


lostanza defn println-num (x:ref<Int>) -> ref<False> :
  call-c clib/printf("%d\n", x.value)
  return false

lostanza defn println-str (x:ref<String>) -> ref<False> :
  call-c clib/printf("%s\n", addr!(x.chars))
  return false
  
defn blow-gc () :
  let loop (n:Int = 0) :
    if n < 1000 :
      String(256, 'A')
      loop(n + 1)

defn main () :
  val c = Coroutine<Int,Int> $ fn (co, x0) :
    var i:Int = 0
    dynamic-wind(
      fn () :
        println-str("Entering winder")
        blow-gc()
        println-num(i)
        i = i + 1
      fn () :
        println-str("x0 = ")
        println-num(x0)
        val x1 = suspend(co, 42)
        println-str("x1 = ")
        println-num(x1)
        val x2 = suspend(co, 43)
        println-str("x2 = ")
        println-num(x2)
        44
      fn (f) :
        println-str("Exiting winder"))

  println-str("enter")
  val y0 = resume(c, -42)
  println-str("y0 = ")
  println-num(y0)
  val y1 = resume(c, -43)
  println-str("y1 = ")
  println-num(y1)
  val y2 = resume(c, -44)
  println-str("y2 = ")
  println-num(y2)

main()

;defn main2 () :
;  val f = (multifn :
;    (x:Int) :
;      println-str("One Argument")
;    (x:Int, y:Int) :
;      println-str("Two Arguments")
;    (x:Int, y:Int, z:Int) :
;      println-str("Three Arguments")) as ?
;  f(10)
;  f(11, 12)
;  f(11, 12, 13)
;  f(11, 12, 13, 14)
;
;main2()
  

