;################################################################################
;############################## C Library #######################################
;################################################################################

;================================================================================
;================================ Boot Sequence =================================
;================================================================================

defpackage clib

protected extern memcpy: (ptr<?>, ptr<?>, long) -> int
protected extern remove: (ptr<byte>) -> int
protected extern ftell: (ptr<?>) -> long
protected extern fclose: (ptr<?>) -> int
protected extern fflush: (ptr<?>) -> int
protected extern fopen: (ptr<byte>, ptr<byte>) -> ptr<?>
protected extern fputs: (ptr<byte>, ptr<?>) -> int
protected extern fputc: (byte, ptr<?>) -> int
protected extern fgetc: (ptr<?>) -> int
protected extern ferror: (ptr<?>) -> int
protected extern fprintf: (ptr<?>, ptr<byte>, ? ...) -> int
protected extern sprintf: (ptr<byte>, ptr<byte>, ? ...) -> int
protected extern sscanf: (ptr<byte>, ptr<byte>, ptr<?> ...) -> int
protected extern printf: (ptr<byte>, ? ...) -> int
protected extern malloc: long -> ptr<?>
protected extern free: ptr<?> -> int
protected extern exit: int -> int
protected extern get_stdout: () -> ptr<?>
protected extern get_stderr: () -> ptr<?>
protected extern get_stdin: () -> ptr<?>
protected extern get_eof: () -> int
protected extern input_argc: int
protected extern input_argv: ptr<ptr<byte>>
protected extern strlen: ptr<byte> -> int
protected extern current_time_us: () -> long
protected extern current_time_ms: () -> long
protected extern getenv: (ptr<byte>) -> ptr<byte>
protected extern setenv: (ptr<byte>, ptr<byte>, int) -> int
protected extern unsetenv: (ptr<byte>) -> int
protected extern system: (ptr<byte>) -> int
protected extern strerror: (int) -> ptr<byte>
protected extern get_errno: () -> int
protected extern resolve_path: (ptr<byte>) -> ptr<byte>
protected extern get_file_size: ptr<?> -> long
protected extern file_set_length: (ptr<?>, long) -> int
protected extern file_seek: (ptr<?>, long) -> int
protected extern file_skip: (ptr<?>, long) -> int
protected extern file_read_block: (ptr<?>, ptr<byte>, long) -> long
protected extern file_write_block: (ptr<?>, ptr<byte>, long) -> long
protected extern file_time_modified: ptr<byte> -> long

;Process libraries
protected extern launch_process: (ptr<byte>, ptr<ptr<byte>>, int, int, int, ptr<?>) -> int
protected extern retrieve_process_state: (long, ptr<?>) -> int
protected extern initialize_launcher_process: () -> int

;Math libraries
protected extern exp: double -> double
protected extern log: double -> double
protected extern log10: double -> double
protected extern sqrt: double -> double
protected extern pow: (double, double) -> double
protected extern sin: double -> double
protected extern cos: double -> double
protected extern tan: double -> double
protected extern asin: double -> double
protected extern acos: double -> double
protected extern atan: double -> double
protected extern atan2: (double, double) -> double
protected extern sinh: double -> double
protected extern cosh: double -> double
protected extern tanh: double -> double
protected extern ceil: double -> double
protected extern floor: double -> double
protected extern round: double -> double

;################################################################################
;############################## Core Library ####################################
;################################################################################

;================================================================================
;=============================== Boot Sequence ==================================
;================================================================================

defpackage core

;============================================================
;===================== Internal Types =======================
;============================================================

lostanza deftype Fn :
   length: long
   code: ptr<?>
   free: ref<?> ...
lostanza deftype Box :
   item: ref<?>
lostanza deftype Type :
   length: long
   code: ptr<?>
   free: ref<?> ...
lostanza deftype Frame :
  return: long
  liveness-map: long
  slots: long ...
lostanza deftype Stack :
  size: long
  frames: ptr<Frame>
  stack-pointer: ptr<Frame>
  pc: int

;============================================================
;================== Internal Callbacks ======================
;============================================================

lostanza defn halt-system () -> ref<Void> :
  call-c clib/printf("HALT\n")
  call-c clib/exit(-1)
  return 0L as ref<Void>

lostanza defn unreachable-error () -> ref<Void> :
  return halt-system()

lostanza defn fatal (msg:ptr<byte>) -> ref<Void> :
  call-c clib/printf("%s\n", msg)
  return halt-system()

lostanza defn fatal (msg:ref<String>) -> ref<Void> :
  call-c clib/printf("%s\n", addr!(msg.chars))
  return halt-system()

;============================================================
;======================= Core Types =========================
;============================================================

public lostanza deftype Byte :
  value: byte
  
public lostanza deftype Char :
  value: byte

public lostanza deftype Int :
  value: int

public lostanza deftype Long :
  value: long

public lostanza deftype Float :
  value: float

public lostanza deftype Double :
  value: double

public lostanza deftype String :
  length: long
  hash: int
  chars: byte ...

public deftype Symbol
public lostanza deftype StringSymbol <: Symbol :
  name: ref<String>

public lostanza deftype True
public lostanza deftype False

public lostanza deftype Tuple<T> :
  length: long
  items: ref<T> ...

public deftype List<T>
lostanza deftype FullList<T> <: List<T> :
  head: ref<T>
  tail: ref<List<T>>
lostanza deftype NilList <: List<Void>

public deftype Coroutine<I,O>

;============================================================
;============== Standard Streams ============================
;============================================================

lostanza val stdout:ptr<?> = call-c clib/get_stdout()
lostanza val stderr:ptr<?> = call-c clib/get_stderr()
lostanza val stdin:ptr<?> = call-c clib/get_stdin()
lostanza val EOF:int = call-c clib/get_eof()

;============================================================
;================ Constant Initialization ===================
;============================================================

lostanza var const-ptr:ptr<?>
lostanza val BYTE-CONST-TAG : int = 0
lostanza val CHAR-CONST-TAG : int = 1
lostanza val INT-CONST-TAG : int = 2
lostanza val LONG-CONST-TAG : int = 3
lostanza val FLOAT-CONST-TAG : int = 4
lostanza val DOUBLE-CONST-TAG : int = 5
lostanza val TRUE-CONST-TAG : int = 6
lostanza val FALSE-CONST-TAG : int = 7
lostanza val LIST-CONST-TAG : int = 8
lostanza val STRING-CONST-TAG : int = 9
lostanza val SYMBOL-CONST-TAG : int = 10
lostanza val TYPE-CONST-TAG : int = 11
lostanza val FN-CONST-TAG : int = 12

lostanza defn initialize-constants () -> ref<False> :
  ;Initialize read pointer to beginning of the constant table
  ;[num, constants ...]
  const-ptr = call-prim consts-data()
  val n-consts = read-const-int()

  ;First n-consts entries in the global table are for constants
  var cs:ptr<ref<?>> = call-prim consts()
  for (var i:int = 0, i < n-consts, i = i + 1) :
    cs[i] = read-const()

  return false

lostanza defn read-const () -> ref<?> :
  val tag = read-const-int()
  if tag == BYTE-CONST-TAG :
    return new Byte{read-const-byte()}
  else if tag == CHAR-CONST-TAG :
    return new Char{read-const-byte()}
  else if tag == INT-CONST-TAG :
    return new Int{read-const-int()}
  else if tag == LONG-CONST-TAG :
    return new Long{read-const-long()}
  else if tag == FLOAT-CONST-TAG :
    return new Float{read-const-float()}
  else if tag == DOUBLE-CONST-TAG :
    return new Double{read-const-double()}
  else if tag == TRUE-CONST-TAG :
    return true
  else if tag == FALSE-CONST-TAG :
    return false
  else if tag == LIST-CONST-TAG :
    val len = read-const-int()
    return read-const-list(len)
  else if tag == STRING-CONST-TAG :
    val len = read-const-int()
    val chars = read-const-chars(len)
    return String(len, chars)
  else if tag == SYMBOL-CONST-TAG :
    val len = read-const-int()
    val chars = read-const-chars(len)
    return new StringSymbol{String(len, chars)}
  else if tag == TYPE-CONST-TAG :
    val code = read-const-long() as ptr<?>
    return new Type{0, code}
  else if tag == FN-CONST-TAG :
    val code = read-const-long() as ptr<?>
    return new Fn{0, code}
  else :
    call-c clib/printf("Unknown constant tag: %d\n", tag)
    return halt-system()

lostanza defn read-const-list (n:int) -> ref<List> :
  if n == 0 : return new NilList{}
  else : return new FullList{read-const(), read-const-list(n - 1)}

lostanza defn read-const-byte () -> byte :
  val value = [const-ptr as ptr<byte>]
  const-ptr = const-ptr + sizeof(byte)
  return value

lostanza defn read-const-int () -> int :
  val value = [const-ptr as ptr<int>]
  const-ptr = const-ptr + sizeof(int)
  return value

lostanza defn read-const-long () -> long :
  val value = [const-ptr as ptr<long>]
  const-ptr = const-ptr + sizeof(long)
  return value

lostanza defn read-const-float () -> float :
  val value = [const-ptr as ptr<float>]
  const-ptr = const-ptr + sizeof(float)
  return value

lostanza defn read-const-double () -> double :
  val value = [const-ptr as ptr<double>]
  const-ptr = const-ptr + sizeof(double)
  return value

lostanza defn read-const-chars (len:long) -> ptr<byte> :
  val value = const-ptr as ptr<byte>
  ;length chars + pad to nearest 4 bytes
  val n = (len + 3) & -4
  const-ptr = (const-ptr + n) as ptr<?>
  return value

initialize-constants()

;============================================================
;======================= Bytes ==============================
;============================================================

public lostanza defn shift-left (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value << b.value}

public lostanza defn shift-right (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value >> b.value}

public lostanza defn bit-or (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value | b.value}

public lostanza defn bit-xor (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value ^ b.value}

public lostanza defn bit-and (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value & b.value}

public lostanza defn bit-not (a:ref<Byte>) -> ref<Byte> :
  return new Byte{(~ a.value)}

public lostanza defn plus (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value + b.value}

public lostanza defn minus (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value - b.value}

public lostanza defn times (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  return new Byte{a.value * b.value}

public lostanza defn divide (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  ensure-divide-non-zero(b)
  return new Byte{a.value / b.value}

public lostanza defn modulo (a:ref<Byte>, b:ref<Byte>) -> ref<Byte> :
  ensure-divide-non-zero(b)
  return new Byte{a.value % b.value}

;============================================================
;====================== Integers ============================
;============================================================

public defn shift-left (a:Int, b:Int) -> Int :
  ($prim shl a b)

public defn shift-right (a:Int, b:Int) -> Int :
  ($prim shr a b)

public defn arithmetic-shift-right (a:Int, b:Int) -> Int :
  ($prim ashr a b)

public defn bit-or (a:Int, b:Int) -> Int :
  ($prim or a b)

public defn bit-and (a:Int, b:Int) -> Int :
  ($prim and a b)

public defn bit-xor (a:Int, b:Int) -> Int :
  ($prim xor a b)

public defn bit-not (a:Int) -> Int :
  ($prim not a)

public defn negate (a:Int) -> Int :
  ($prim neg a)

public defn abs (a:Int) -> Int :
  (- a) when a < 0 else a

public defn plus (a:Int, b:Int) -> Int :
  ($prim add a b)

public defn minus (a:Int, b:Int) -> Int :
  ($prim sub a b)

public defn times (a:Int, b:Int) -> Int :
  ($prim mul a b)

public defn divide (a:Int, b:Int) -> Int :
  ensure-divide-non-zero(b)
  ($prim div a b)

public defn modulo (a:Int, b:Int) -> Int :
  ensure-divide-non-zero(b)
  ($prim mod a b)

;============================================================
;======================== Longs =============================
;============================================================

public lostanza defn shift-left (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value << b.value}

public lostanza defn shift-right (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value >> b.value}

public lostanza defn arithmetic-shift-right (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value >>> b.value}

public lostanza defn bit-or (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value | b.value}

public lostanza defn bit-xor (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value ^ b.value}

public lostanza defn bit-and (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value & b.value}

public lostanza defn bit-not (a:ref<Long>) -> ref<Long> :
  return new Long{(~ a.value)}

public lostanza defn negate (a:ref<Long>) -> ref<Long> :
  return new Long{(- a.value)}

public defn abs (a:Long) -> Long :
  (- a) when a < 0L else a

public lostanza defn plus (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value + b.value}

public lostanza defn minus (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value - b.value}

public lostanza defn times (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  return new Long{a.value * b.value}

public lostanza defn divide (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  ensure-divide-non-zero(b)
  return new Long{a.value / b.value}

public lostanza defn modulo (a:ref<Long>, b:ref<Long>) -> ref<Long> :
  ensure-divide-non-zero(b)
  return new Long{a.value % b.value}

;============================================================
;======================= Floats =============================
;============================================================

public lostanza defn negate (a:ref<Float>) -> ref<Float> :
  return new Float{(- a.value)}

public defn abs (a:Float) -> Float :
  (- a) when a < 0.0f else a

public lostanza defn plus (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value + b.value}

public lostanza defn minus (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value - b.value}

public lostanza defn times (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value * b.value}

public lostanza defn divide (a:ref<Float>, b:ref<Float>) -> ref<Float> :
  return new Float{a.value / b.value}

public lostanza defn nan? (x:ref<Float>) -> ref<True|False> :
  val v = x.value
  if v != v : return true
  else : return false

;============================================================
;======================= Doubles ============================
;============================================================

public lostanza defn negate (a:ref<Double>) -> ref<Double> :
  return new Double{(- a.value)}

public defn abs (a:Double) -> Double :
  (- a) when a < 0.0 else a

public lostanza defn plus (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value + b.value}

public lostanza defn minus (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value - b.value}

public lostanza defn times (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value * b.value}

public lostanza defn divide (a:ref<Double>, b:ref<Double>) -> ref<Double> :
  return new Double{a.value / b.value}

public lostanza defn nan? (x:ref<Double>) -> ref<True|False> :
  val v = x.value
  if v != v : return true
  else : return false

;============================================================
;======================== Strings ===========================
;============================================================

public lostanza defn String (len:long) -> ref<String> :
  return new String{len + 1, 0}

public lostanza defn String (len:long, chars:ptr<byte>) -> ref<String> :
  val s = String(len)
  call-c clib/memcpy(addr!(s.chars), chars, len)
  s.chars[len] = 0 as byte
  return s

;============================================================
;======================= Lists ==============================
;============================================================

public lostanza defn List () -> ref<List> :
  return new NilList{}

public lostanza defn cons<?T> (x:ref<?T>, t:ref<List<?T>>) -> ref<List<T>> :
  return new FullList<T>{x, t}

public defmulti head<?T> (x:List<?T>) -> T
public defmulti tail<?T> (x:List<?T>) -> List<T>
public defmulti empty? (x:List) -> True|False

defmethod head (x:NilList) : fatal("Cannot retrieve head of empty list.")
defmethod tail (x:NilList) : fatal("Cannot retrieve tail of empty list.")
defmethod empty? (x:NilList) : true
lostanza defmethod head (x:ref<FullList>) -> ref<?> : return x.head
lostanza defmethod tail (x:ref<FullList>) -> ref<?> : return x.tail
defmethod empty? (x:FullList) : false

;============================================================
;======================= Booleans ===========================
;============================================================

public defn complement (a:True|False) -> True|False :
  if a : false
  else : true

;============================================================
;====================== Comparable ==========================
;============================================================

public deftype Comparable<T> :
  Char <: Comparable<Char>
  Byte <: Comparable<Byte>
  Int <: Comparable<Int>
  Long <: Comparable<Long>
  Float <: Comparable<Float>
  Double <: Comparable<Double>
  Tuple<T> <: Comparable<Tuple<T>>
  String <: Comparable<String>
  List<T> <: Comparable<List<T>>

public defmulti compare<?T> (a:Comparable<?T>, b:T) -> Int
public defmulti less?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti greater?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti less-eq?<?T> (a:Comparable<?T>, b:T) -> True|False
public defmulti greater-eq?<?T> (a:Comparable<?T>, b:T) -> True|False

defmethod less?<?T> (a:Comparable<?T>, b:T) : compare(a, b) < 0
defmethod greater?<?T> (a:Comparable<?T>, b:T) : compare(a, b) > 0
defmethod less-eq?<?T> (a:Comparable<?T>, b:T) : compare(a, b) <= 0
defmethod greater-eq?<?T> (a:Comparable<?T>, b:T) : compare(a, b) >= 0

lostanza defmethod compare (a:ref<Char>, b:ref<Char>) -> ref<Int> :
  return new Int{(a.value as int) - (b.value as int)}

lostanza defmethod less? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Char>, b:ref<Char>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Byte>, b:ref<Byte>) -> ref<Int> :
  return new Int{(a.value as int) - (b.value as int)}

lostanza defmethod less? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Byte>, b:ref<Byte>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

defmethod compare (a:Int, b:Int) -> Int :
  if a < b : -1
  else if a > b : 1
  else : 0

defmethod less? (a:Int, b:Int) -> True|False :
  ($prim lt a b)

defmethod less-eq? (a:Int, b:Int) -> True|False :
  ($prim le a b)

defmethod greater? (a:Int, b:Int) -> True|False :
  ($prim gt a b)

defmethod greater-eq? (a:Int, b:Int) -> True|False :
  ($prim ge a b)

lostanza defmethod compare (a:ref<Long>, b:ref<Long>) -> ref<Int> :
  if a.value < b.value : return new Int{-1}
  else if a.value > b.value : return new Int{1}
  else : return new Int{0}

lostanza defmethod less? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Float>, b:ref<Float>) -> ref<Int> :
  if a.value < b.value : return new Int{-1}
  else if a.value > b.value : return new Int{1}
  else : return new Int{0}

lostanza defmethod less? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Double>, b:ref<Double>) -> ref<Int> :
  if a.value < b.value : return new Int{-1}
  else if a.value > b.value : return new Int{1}
  else : return new Int{0}

lostanza defmethod less? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value < b.value : return true
  else : return false

lostanza defmethod less-eq? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value <= b.value : return true
  else : return false

lostanza defmethod greater? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value > b.value : return true
  else : return false

lostanza defmethod greater-eq? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value >= b.value : return true
  else : return false

lostanza defmethod compare (a:ref<Tuple<Comparable>>, b:ref<Tuple<Comparable>>) -> ref<Int> :
  val la = a.length
  val lb = b.length
  labels :
    begin :
      goto loop(0)
    loop (i:long) :
      if i < la and i < lb :
        val c = compare(a.items[i], b.items[i])
        if c.value : goto loop(i + 1)
        else : return c
      else :
        return compare(new Int{la as int}, new Int{lb as int})

lostanza defmethod compare (a:ref<String>, b:ref<String>) -> ref<Int> :
  val na = strlen(a)
  val nb = strlen(b)
  labels :
    begin :
      goto loop(0)
    loop (i:long) :
      if (i == na) and (i == nb) :
        return new Int{0}
      else if i == na :
        return new Int{-1}
      else if i == nb :
        return new Int{1}
      else :
        val ac = a.chars[i]
        val bc = b.chars[i]
        if ac < bc : return new Int{-1}
        else if ac > bc : return new Int{1}
        else : goto loop(i + 1)

defmethod compare (xs:List<Comparable>, ys:List<Comparable>) -> Int :
  defn* loop (xs:List<Comparable>, ys:List<Comparable>) :
    match(empty?(xs), empty?(ys)) :
      (ex:True, ey:True) : 0
      (ex:True, ey:False) : -1
      (ex:False, ey:True) : 1
      (ex:False, ey:False) :
        val c = compare(head(xs), head(ys))
        if c == 0 : loop(tail(xs), tail(ys))
        else : c
  loop(xs, ys)

;============================================================
;======================== Equalable =========================
;============================================================

public deftype Equalable :
  Char <: Equalable
  Byte <: Equalable
  Int <: Equalable
  Long <: Equalable
  Float <: Equalable
  Double <: Equalable
  Tuple<T> <: Equalable
  String <: Equalable
  List<T> <: Equalable
  True <: Equalable
  False <: Equalable

public defmulti equal? (a:Equalable, b:Equalable) -> True|False
defmethod equal? (a:Equalable, b:Equalable) : false

public defn not-equal? (a:Equalable, b:Equalable) -> True|False :
  not equal?(a, b)

defmethod equal? (a:Char, b:Char) -> True|False :
  ($prim identical? a b)

defmethod equal? (a:Byte, b:Byte) -> True|False :
  ($prim identical? a b)

defmethod equal? (a:Int, b:Int) -> True|False :
  ($prim eq a b)

lostanza defmethod equal? (a:ref<Long>, b:ref<Long>) -> ref<True|False> :
  if a.value == b.value : return true
  else : return false

lostanza defmethod equal? (a:ref<Float>, b:ref<Float>) -> ref<True|False> :
  if a.value == b.value : return true
  else : return false

lostanza defmethod equal? (a:ref<Double>, b:ref<Double>) -> ref<True|False> :
  if a.value == b.value : return true
  else : return false

defmethod equal? (a:True|False, b:True|False) -> True|False :
  ($prim identical? a b)

lostanza defmethod equal? (x:ref<Tuple>, y:ref<Tuple>) -> ref<True|False> :
  val n = x.length
  if n != y.length : return false
  for (var i:long = 0, i < n, i = i + 1) :
    if equal?(x.items[i], y.items[i]) == false :
      return false
  return true

lostanza defmethod equal? (a:ref<String>, b:ref<String>) -> ref<True|False> :
  val n = strlen(a)
  if n == strlen(b) :
    for (var i:long = 0, i < n, i = i + 1) :
      if a.chars[i] != b.chars[i] :
        return false
    return true
  else :
    return false

defmethod equal? (a:List, b:List) -> True|False :
  defn* loop (a:List, b:List) :
    match(empty?(a), empty?(b)) :
      (ea:True, eb:True) : true
      (ea:False, eb:False) :
        if head(a) == head(b) :
          loop(tail(a), tail(b))
      (ea, eb) : false
  loop(a, b)

;============================================================
;====================== Lengthable ==========================
;============================================================

public deftype Lengthable :
  String <: Lengthable
  Tuple<T> <: Lengthable
  List<T> <: Lengthable

public defmulti length (l:Lengthable) -> Int

lostanza defmethod length (x:ref<Tuple>) -> ref<Int> :
  return new Int{x.length as int}

lostanza defmethod length (s:ref<String>) -> ref<Int> :
  return new Int{s.length as int - 1}

defmethod length (x:List) :
  defn* loop (x:List, n:Int) :
    if empty?(x) : n
    else : loop(tail(x), n + 1)
  loop(x, 0)

;============================================================
;=================== Winders ================================
;============================================================
defstruct Winder :
  in: False|(() -> ?)
  out: False|(? -> ?)
   
var WINDER-STACK:List<Winder> = List()
var NUM-WINDERS = 0

defn pop-winder () :
  val w = head(WINDER-STACK)
  WINDER-STACK = tail(WINDER-STACK)
  NUM-WINDERS = NUM-WINDERS - 1
  w

defn push-winder (w:Winder) :
  WINDER-STACK = cons(w, WINDER-STACK)
  NUM-WINDERS = NUM-WINDERS + 1

defn pop-winders (n:Int) :
  defn pop (n:Int) :
    if n > 0 : cons(pop-winder(), pop(n - 1))
    else : List()
  pop(NUM-WINDERS - n)   

defn push-winders (ws:List<Winder>) :
  if not empty?(ws) :
    push-winders(tail(ws))
    push-winder(head(ws))

defn total-winders (c:False|RawCoroutine) -> Int :
  match(c) :
    (c:False) : 0
    (c:RawCoroutine) : total-winders(parent(c)) + num-winders(c)

defn wind-in (ws:List<Winder>) :
  if not empty?(ws) :
    wind-in(tail(ws))
    call?(in(head(ws)))

defn wind-out (ws:List<Winder>, f:True|False) :
  if not empty?(ws) :
    call?(out(head(ws)), f)
    wind-out(tail(ws), f)

defn* call? (f: False|(() -> ?)) :
  match(f) :
    (f:() -> ?) : f()
    (f:False) : false

defn* call? (f: False|(? -> ?), x: ?) :
  match(f) :
    (f:? -> ?) : f(x)
    (f:False) : false

lostanza defn inc-winders (c:ref<RawCoroutine>, n:ref<Int>) -> ref<False> :
  c.num-winders = c.num-winders + n.value
  return false

lostanza defn num-winders (c:ref<RawCoroutine>) -> ref<Int> :
  return new Int{c.num-winders}
      
public defn dynamic-wind<?T> (in:False|(() -> ?),
                              body:() -> ?T,
                              out:False|(True|False -> ?)) -> T :
  call?(in)
  push-winder(Winder(in, out))
  inc-winders(current-coroutine, 1)
  val result = body()
  pop-winder()
  inc-winders(current-coroutine, -1)
  call?(out, true)
  result

;============================================================
;====================== Coroutines ==========================
;============================================================

public defmulti active? (c:Coroutine) -> True|False
public defmulti open? (c:Coroutine) -> True|False
public defmulti resume<?I,?O> (c:Coroutine<?I,?O>, x:I) -> O
public defmulti suspend<?I,?O> (c:Coroutine<?I,?O>, x:O) -> I
public defmulti break<?O> (c:Coroutine<?,?O>, x:O) -> Void
public defmulti close (c:Coroutine) -> False

;                  Wrapped Coroutines
;                  ==================

#if-defined(OPTIMIZE) :

  public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O> :
    RawCoroutine(enter)

#else :

  deftype WrappedCoroutine<I,O> <: Coroutine<I,O>
  defmulti raw (c:WrappedCoroutine) -> RawCoroutine

  public defn Coroutine<I,O> (enter: (Coroutine<I,O>, I) -> O) -> Coroutine<I,O> :
    var rc
    val c = new WrappedCoroutine<I,O> :
      defmethod active? (this) : active?(rc)
      defmethod open? (this) : open?(rc)
      defmethod resume (this, x:I) : resume(rc, x)
      defmethod suspend (this, x:O) : suspend(rc, x)
      defmethod break (this, x:O) : break(rc, x)
      defmethod close (this) : close(rc)
      defmethod raw (this) : rc
    rc = RawCoroutine $ fn (rc, x0) :
      enter(c, x0)
    c

lostanza deftype RawCoroutine <: Coroutine :
  id: long
  stack: ref<Stack>
  parent: ref<False|RawCoroutine>
  status: ref<Int>
  num-winders: int

lostanza deftype CoroutineParams :
  parent-stack: ref<Stack>
  coroutine: ref<RawCoroutine>
  enter: ref<((RawCoroutine, ?) -> ?)>

val COROUTINE-ACTIVE = 0
val COROUTINE-CLOSED = 1
val COROUTINE-SUSPENDED = 2
val COROUTINE-OPEN = 3

lostanza var current-coroutine:ref<RawCoroutine> =
  new RawCoroutine{0L, call-prim stack(), false, COROUTINE-ACTIVE, 0}

lostanza var COROUTINE-COUNTER:long = 1L
public lostanza defn RawCoroutine (enter:ref<((RawCoroutine, ?) -> ?)>) -> ref<RawCoroutine> :
  val current-stack = call-prim stack()
  val stack = call-prim new-stack(addr(setup-coroutine))
  val c = new RawCoroutine{COROUTINE-COUNTER, stack, false, COROUTINE-OPEN, 0}
  COROUTINE-COUNTER = COROUTINE-COUNTER + 1L
  call-prim enter-stack(stack, new CoroutineParams{current-stack, c, enter})
  return c

lostanza defn parent (c:ref<RawCoroutine>) -> ref<False|RawCoroutine> :
  return c.parent

lostanza defmethod active? (c:ref<RawCoroutine>) -> ref<True|False> :
  if c.status == COROUTINE-ACTIVE : return true
  else : return false

lostanza defmethod open? (c:ref<RawCoroutine>) -> ref<True|False> :
  if c.status == COROUTINE-OPEN : return true
  else : return false

lostanza defn* setup-coroutine (params:ref<CoroutineParams>) -> ref<?> :
  val x0 = call-prim yield(params.parent-stack, false)
  val enter = params.enter
  return break(params.coroutine, [enter](params.coroutine, x0))  

lostanza defmethod resume (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
  ;Ensure coroutine is re-entrant
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot resume coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-ACTIVE :
    return fatal("Cannot resume coroutine. Coroutine is already active.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot resume coroutine. Coroutine's parent is suspended.")  

  ;Adjust state
  attach-coroutine(c)

  ;Begin execution
  return call-prim yield(current-coroutine.stack, x)

lostanza defmethod* suspend (c:ref<RawCoroutine>, x:ref<?>) -> ref<?> :
  ;Ensure coroutine is active
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot suspend coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-OPEN :
    return fatal("Cannot suspend coroutine. Coroutine is already suspended.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot suspend coroutine. Coroutine is already suspended.")

  ;Set target winder environment and wind out
  val winders = pop-winders(total-winders(c.parent))
  wind-out(winders, false)

  ;Detach coroutine
  detach-coroutine(c)

  ;Return to resume
  val result = call-prim yield(current-coroutine.stack, x)

  ;Wind in and restore original winder environment
  wind-in(winders)
  push-winders(winders)

  ;Return execution
  return result

lostanza defmethod close (c:ref<RawCoroutine>) -> ref<False> :
  ;Ensure coroutine is re-entrant
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot close coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-ACTIVE :
    return fatal("Cannot close coroutine. Coroutine is active.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot close coroutine. Coroutine's parent is suspended.")
  free-coroutine(c)
  return false

lostanza defmethod break (c:ref<RawCoroutine>, x:ref<?>) -> ref<Void> :
  ;Ensure coroutine is active
  if c.status == COROUTINE-CLOSED :
    return fatal("Cannot break from coroutine. Coroutine is already closed.")
  else if c.status == COROUTINE-OPEN :
    return fatal("Cannot break from coroutine. Coroutine is already suspended.")
  else if c.status == COROUTINE-SUSPENDED :
    return fatal("Cannot break from coroutine. Coroutine is already suspended.")

  ;Set target winder environment and wind out
  val winders = pop-winders(total-winders(c.parent))
  wind-out(winders, false)

  ;Adjust state
  detach-coroutine(c)
  free-coroutine(c)
  
  ;Begin execution
  return call-prim yield(current-coroutine.stack, x)

lostanza defn free-coroutine (c:ref<RawCoroutine>) -> int :
  labels :
    begin :
      goto loop(c)
    loop (c:ref<RawCoroutine>) :
      val parent = c.parent
      c.parent = false
      c.status = COROUTINE-CLOSED
      ;free-stacks(top(c), bottom(c))
      match(parent) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : return 0  

lostanza defn attach-coroutine (c:ref<RawCoroutine>) -> int :
  labels :
    begin :
      goto loop(c)
    loop (c:ref<RawCoroutine>) :
      val p = c.parent
      c.parent = current-coroutine
      c.status = COROUTINE-ACTIVE
      current-coroutine = c
      match(p) :
        (p:ref<RawCoroutine>) : goto loop(p)
        (p:ref<False>) : return 0

lostanza defn detach-coroutine (c:ref<RawCoroutine>) -> int :
  labels :
    begin :
      goto loop(false)
    loop (tail:ref<RawCoroutine|False>) :
      val cc = current-coroutine
      val ccp = current-coroutine.parent as ref<RawCoroutine>
      cc.parent = tail
      current-coroutine = ccp
      if cc == c :
        cc.status = COROUTINE-OPEN
        return 0
      else :
        cc.status = COROUTINE-SUSPENDED
        goto loop(cc)

;================================================================================
;============================== End of Boot Sequence ============================
;================================================================================

;============================================================
;===================== Utilities ============================
;============================================================

public lostanza val null:ptr<?> = 0L as ptr<?>

#if-defined(PLATFORM-WINDOWS) :
  lostanza val LS-NL:ptr<?> = "\r\n"
  val NL = "\r\n"
#else :  
  lostanza val LS-NL:ptr<?> = "\n"
  val NL = "\n"

lostanza deftype Sentinel
lostanza val sentinel:ref<Sentinel> = new Sentinel{}

protected lostanza defn linux-error-msg () -> ref<String> :
  val s = call-c clib/strerror(call-c clib/get_errno())
  return String(s)

;============================================================
;====================== Error Preconditions =================
;============================================================

defn ensure-divide-non-zero (i:Byte) :
  #if-defined(OPTIMIZE) : (false)
  #else : (fatal("Cannot divide by zero.") when i == 0Y)
defn ensure-divide-non-zero (i:Int) :
  #if-defined(OPTIMIZE) : (false)
  #else : (fatal("Cannot divide by zero.") when i == 0)
defn ensure-divide-non-zero (i:Long) :
  #if-defined(OPTIMIZE) : (false)
  #else : (fatal("Cannot divide by zero.") when i == 0L)

protected defn ensure-index-in-bounds (xs:Lengthable, i:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if i < 0 or i >= length(xs) :
      fatal("Index (%_) out of bounds." % [i])

protected defn ensure-length-in-bounds (xs:Lengthable, i:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if i < 0 or i > length(xs) :
      fatal("Index (%_) out of bounds." % [i])

defn ensure-start-before-end (s:Int, e:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if e < s :
      fatal("Given end index (%_) is smaller than start index (%_)." % [e, s])

protected defn ensure-non-negative (quantity:String, n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if n < 0 :
      fatal("Given %_ (%_) is negative." % [quantity, n])

protected defn ensure-positive (quantity:String, n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if n <= 0 :
      fatal("Given %_ (%_) is not positive." % [quantity, n])

protected defn ensure-non-negative-length (n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    ensure-non-negative("length", n)

;protected defn ensure-index-range (xs:Lengthable, r:Range) :
;  #if-defined(OPTIMIZE) :
;    false
;  #else :
;    if step(r) != 1 :
;      fatal("Given index range (%_) does not have a step of 1." % [r])
;    val s = start(r)
;    match(end(r), inclusive?(r)) :
;      (e:Int, inc?:True) :
;        ensure-index-in-bounds(xs, s)
;        ensure-index-in-bounds(xs, e)
;        ensure-start-before-end(s, e)
;      (e:Int, inc?:False) :
;        ensure-length-in-bounds(xs, s)
;        ensure-length-in-bounds(xs, e)
;        ensure-start-before-end(s, e)
;      (e:False, inc?) :
;        ensure-length-in-bounds(xs, s)
;
;protected defn range-bound (s:Lengthable, r:Range) -> [Int, Int] :
;  match(end(r), inclusive?(r)) :
;    (e:Int, i:True) : [start(r), e + 1]
;    (e:Int, i:False) : [start(r), e]
;    (e:False, i) : [start(r), length(s)]

;============================================================
;===================== Tuples ===============================
;============================================================

lostanza defn void-tuple (n:long) -> ref<Tuple> :
  val x = new Tuple{n}
  for (var i:long = 0, i < n, i = i + 1) :
    x.items[i] = sentinel
  return x   

;============================================================
;===================== Strings ==============================
;============================================================

public lostanza defn String (chars:ptr<byte>) -> ref<String> :
  val len = call-c clib/strlen(chars)
  return String(len, chars)

public lostanza defn String (len:long, c:byte) -> ref<String> :
  val s = String(len)
  for (var i:long = 0, i < len, i = i + 1) :
    s.chars[i] = c
  s.chars[len] = 0 as byte
  return s

public lostanza defn String (len:ref<Int>, c:ref<Char>) -> ref<String> :
  ensure-non-negative-length(len)
  return String(len.value, c.value)

lostanza defn strlen (s:ref<String>) -> long :
  return s.length - 1

lostanza defn set (s:ref<String>, i:ref<Int>, c:ref<Char>) -> ref<False> :
  ensure-index-in-bounds(s, i)
  s.chars[i.value] = c.value
  return false

;============================================================
;====================== Formatting ==========================
;============================================================

public defn modulo (format:String, args) :
  fatal("Not yet implemented")

;############################################################
;################## Math Package ############################
;############################################################

defpackage math :
   import core

public lostanza val PI:ref<Double> = new Double{3.141592653589793}
public lostanza val PI-F:ref<Float> = new Float{3.1415927f}

public lostanza defn exp (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/exp(x.value)}
public lostanza defn exp (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/exp(x.value) as float}

public lostanza defn log (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/log(x.value)}
public lostanza defn log (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/log(x.value) as float}

public lostanza defn log10 (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/log10(x.value)}
public lostanza defn log10 (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/log10(x.value) as float}

public lostanza defn sqrt (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sqrt(x.value)}
public lostanza defn sqrt (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sqrt(x.value) as float}

public lostanza defn pow (x:ref<Double>, y:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/pow(x.value, y.value)}
public lostanza defn pow (x:ref<Float>, y:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/pow(x.value, y.value) as float}

public lostanza defn sin (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sin(x.value)}
public lostanza defn sin (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sin(x.value) as float}

public lostanza defn cos (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/cos(x.value)}
public lostanza defn cos (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/cos(x.value) as float}

public lostanza defn tan (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/tan(x.value)}
public lostanza defn tan (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/tan(x.value) as float}

public lostanza defn asin (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/asin(x.value)}
public lostanza defn asin (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/asin(x.value) as float}

public lostanza defn acos (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/acos(x.value)}
public lostanza defn acos (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/acos(x.value) as float}

public lostanza defn atan (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/atan(x.value)}
public lostanza defn atan (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/atan(x.value) as float}

public lostanza defn atan2 (y:ref<Double>, x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/atan2(y.value, x.value)}
public lostanza defn atan2 (y:ref<Float>, x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/atan2(y.value, x.value) as float}

public lostanza defn sinh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/sinh(x.value)}
public lostanza defn sinh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/sinh(x.value) as float}

public lostanza defn cosh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/cosh(x.value)}
public lostanza defn cosh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/cosh(x.value) as float}

public lostanza defn tanh (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/tanh(x.value)}
public lostanza defn tanh (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/tanh(x.value) as float}

public lostanza defn ceil (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/ceil(x.value)}
public lostanza defn ceil (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/ceil(x.value) as float}

public lostanza defn floor (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/floor(x.value)}
public lostanza defn floor (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/floor(x.value) as float}

public lostanza defn round (x:ref<Double>) -> ref<Double> :
   return new Double{call-c clib/round(x.value)}
public lostanza defn round (x:ref<Float>) -> ref<Float> :
   return new Float{call-c clib/round(x.value) as float}

public lostanza defn to-radians (degrees:ref<Double>) -> ref<Double> :
   val pi = 3.141592653589793
   return new Double{degrees.value * pi / 180.0}

public lostanza defn to-degrees (radians:ref<Double>) -> ref<Double> :
   val pi = 3.141592653589793
   return new Double{radians.value * 180.0 / pi}

;################################################################################
;################################## Scratchpad ##################################
;################################################################################

defpackage scratchpad :
  import core


lostanza defn println-num (x:ref<Int>) -> ref<False> :
  call-c clib/printf("%d\n", x.value)
  return false

lostanza defn println-str (x:ref<String>) -> ref<False> :
  call-c clib/printf("%s\n", addr!(x.chars))
  return false
  
defn blow-gc () :
  let loop (n:Int = 0) :
    if n < 1000 :
      String(256, 'A')
      loop(n + 1)

defn main () :
  val c = Coroutine<Int,Int> $ fn (co, x0) :
    var i:Int = 0
    dynamic-wind(
      fn () :
        println-str("Entering winder")
        blow-gc()
        println-num(i)
        i = i + 1
      fn () :
        println-str("x0 = ")
        println-num(x0)
        val x1 = suspend(co, 42)
        println-str("x1 = ")
        println-num(x1)
        val x2 = suspend(co, 43)
        println-str("x2 = ")
        println-num(x2)
        44
      fn (f) :
        println-str("Exiting winder"))

  println-str("enter")
  val y0 = resume(c, -42)
  println-str("y0 = ")
  println-num(y0)
  val y1 = resume(c, -43)
  println-str("y1 = ")
  println-num(y1)
  val y2 = resume(c, -44)
  println-str("y2 = ")
  println-num(y2)

main()

;defn main2 () :
;  val f = (multifn :
;    (x:Int) :
;      println-str("One Argument")
;    (x:Int, y:Int) :
;      println-str("Two Arguments")
;    (x:Int, y:Int, z:Int) :
;      println-str("Three Arguments")) as ?
;  f(10)
;  f(11, 12)
;  f(11, 12, 13)
;  f(11, 12, 13, 14)
;
;main2()
  

