defpackage dup :
  import core
  import collections

protected extern launch_process: (ptr<byte>, ptr<ptr<byte>>, int, int, int, ptr<?>) -> int

defpackage process :
  import core
  import collections

;TODO
lostanza val null:ptr<?> = 0L as ptr<?>
  
public lostanza deftype Process :
  pid: long
  input: ptr<?>
  output: ptr<?>
  error: ptr<?>
  
public defmulti wait (p:Process) -> ProcessState
public defmulti input-stream (p:Process) -> InputStream
public defmulti output-stream (p:Process) -> OutputStream
public defmulti error-stream (p:Process) -> OutputStream

public deftype ProcessState
public defstruct ProcessRunning <: ProcessState
public defstruct ProcessDone <: ProcessState : (value:Int)
public defstruct ProcessTerminated <: ProcessState : (signal:Int)
public defstruct ProcessStopped <: ProcessState : (signal:Int)

public defstruct StreamSpecifier : (value:Int)
public val STANDARD-IN = StreamSpecifier(0)
public val STANDARD-OUT = StreamSpecifier(1)
public val PROCESS-IN = StreamSpecifier(2)
public val PROCESS-OUT = StreamSpecifier(3)
public val STANDARD-ERR = StreamSpecifier(4)
public val PROCESS-ERR = StreamSpecifier(5)

public lostanza defn Process (filename:ref<String>,
                              args:ref<Tuple<String>>,
                              input:ref<StreamSpecifier>,
                              output:ref<StreamSpecifier>,
                              error:ref<StreamSpecifier>) -> ref<Process> :
  val proc = new Process{0, null, null, null}
  val input_v = value(input).value
  val output_v = value(output).value
  val error_v = value(error).value
  val nargs = args.length
  val argvs:ptr<ptr<byte>> = call-c clib/malloc((nargs + 1) * sizeof(ptr<?>))
  argvs[nargs] = null
  for (var i:long = 0, i < nargs, i = i + 1) :
    argvs[i] = addr!(args.items[i].chars)
  call-c dup/launch_process(addr!(filename.chars), argvs, input_v, output_v, error_v, addr!([proc]))
  return proc

public lostanza defmethod input-stream (p:ref<Process>) -> ref<InputStream> :
  return new FileInputStream{p.input, 0}
public lostanza defmethod output-stream (p:ref<Process>) -> ref<OutputStream> :
  return new FileOutputStream{p.output, 0}
public lostanza defmethod error-stream (p:ref<Process>) -> ref<OutputStream> :
  return new FileOutputStream{p.error, 0}
  

;TESTING
let :
  val p = Process("ls", ["ls"], STANDARD-IN, STANDARD-OUT, STANDARD-ERR)
  println("FINISHED PROGRAM")