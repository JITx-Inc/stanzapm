defpackage stz/bindings-to-vm :
  import core
  import collections
  import stz/bindings
  import stz/vm-ir

;<doc>=======================================================
;=================== VM Extern Defns ========================
;============================================================

To convert extern defn bindings into a VMFunc we need the following
things:

  args: Tuple<Local|VMType>
  defs: Tuple<VMDef>
  ins: Tuple<VMIns>

For the arguments, we need the arguments to match against the expected
types of the C function. So first we need to create temporary locals
for each of the arguments. The types are already given in binding.

For the defs, we need:

  reg-array: VMLong
  result: return type

For the instructions, we need to:

  Load the VM registers array into a local.
  Store false in reg-array[0] to indicate no closure.
  Store number of arguments in reg-array[1] to indicate the arity.
  Store each of the following arguments in reg-array[2 ...].
  Call the stanza function stz/vm/call-extern with the desired extern index.
  Load the return value into the result local.
  Return the result local.

;============================================================
;=======================================================<doc>

public defn to-vmpackage (bindings:Bindings) :
  for (f in extern-defns(bindings), i in 0 to false) do :
    to-vmfunc(f, i)

public defn collapse (bindings:Seqable<Bindings>) -> Bindings :
  val bindings-seq = to-seq(bindings)
  if empty?(bindings-seq) : Bindings([], [])
  else : next(bindings-seq)

defn to-vmfunc (f:ExternDefnBinding, index:Int) :
  println("Convert to func with index %_:" % [index])
  println(f)
  ;val ins = [
  ;  LoadIns(arg-regs, global-arg-regs, 0)
  ;  
  ;  ]
  ;VMFunc(
  ;  args: Tuple<Local|VMType>
  ;  defs: Tuple<VMDef> with: (updater => sub-defs)
  ;  ins: Tuple<VMIns> with: (updater => sub-ins))
