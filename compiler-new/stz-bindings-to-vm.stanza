defpackage stz/bindings-to-vm :
  import core
  import collections
  import stz/bindings
  import stz/vm-ir

public defn collapse (bindings:Seqable<Bindings>) -> Bindings :
  val bindings-seq = to-seq(bindings)
  if empty?(bindings-seq) : Bindings([], [])
  else : next(bindings-seq)

;<doc>=======================================================
;=================== VM Extern Defns ========================
;============================================================

To convert extern defn bindings into a VMFunc we need the following
things:

  args: Tuple<Local|VMType>
  defs: Tuple<VMDef>
  ins: Tuple<VMIns>

For the arguments, we need the arguments to match against the expected
types of the C function. So first we need to create temporary locals
for each of the arguments. The types are already given in binding.

For the defs, we need:

  reg-array: VMLong
  result: return type

For the instructions, we need to:

  Load the VM registers array into a local.
  Store false in reg-array[0] to indicate no closure.
  Store number of arguments in reg-array[1] to indicate the arity.
  Store each of the following arguments in reg-array[2 ...].
  Call the stanza function stz/vm/call-extern with the desired extern index.
  Load the return value into the result local.
  Return the result local.

;============================================================
;=======================================================<doc>

public defn to-vmpackage (bindings:Bindings) :
  val ids = new BindingIds :
    defmethod registers-array (this) : GlobalId(-1)
    defmethod call-extern (this) : CodeId(-1)
    
  for (f in extern-defns(bindings), i in 0 to false) do :
    val f* = to-vmfunc(f, i, ids)
    println(f*)

deftype BindingIds
defmulti registers-array (ids:BindingIds) -> GlobalId
defmulti call-extern (ids:BindingIds) -> CodeId

defn to-vmfunc (f:ExternDefnBinding, extern-index:Int, ids:BindingIds) :  
  ;Generate locals for function
  val local-counter = to-seq(0 to false)
  val arg-locals = map(Local{next(local-counter)}, a1(f))

  ;Generate defs
  val reg-array = Local(next(local-counter))
  val result-local = Local(next(local-counter))
  val defs = Vector<VMDef>()
  for (l in arg-locals, t in a1(f)) do :
    add(defs, VMDef(index(l), t))
  add(defs, VMDef(index(reg-array), VMLong()))
  add(defs, VMDef(index(result-local), a2(f)))

  ;Generate instructions
  val ins = Vector<VMIns>()
  defn E (i:VMIns) : add(ins,i)

  ;Store arguments into register array with the proper calling
  ;convention.
  E $ LoadIns(reg-array, registers-array(ids), 0)
  E $ StoreIns(reg-array, 0, NumConst(0L))
  E $ StoreIns(reg-array, 8, NumConst(length(a1(f))))
  for (l in arg-locals, i in 0 to false) do :
    val offset = 8 * (i + 2)
    E $ StoreIns(reg-array, offset, l)

  ;Call the call-extern function with the given index,
  ;and the proper calling convention.
  E $ CallIns([], call-extern(ids), [NumConst(0), NumConst(1), NumConst(extern-index)], false)

  ;Move the result into the result local.
  E $ LoadIns(result-local, reg-array, 0)

  ;Create and return function
  VMFunc(arg-locals,
         to-tuple(defs),
         to-tuple(ins))