defpackage stz/trie :
  import core
  import collections

;============================================================
;==================== Trie Datastructure ====================
;============================================================

public deftype MTrie

public defstruct IfTrie <: MTrie :
  branches: List<KeyValue<ISet, MTrie>>

public defstruct EndTrie <: MTrie :
  target

defmethod print (o:OutputStream, t:MTrie) :
  let loop (t:MTrie = t, indent:Int = 0) :
    match(t) :
      (t:EndTrie) :
        print(o, target(t))
      (t:IfTrie) :
        for (b in branches(t), i in 0 to false) do :
          if i > 0 :
            print(o, '\n')
            do(print{o, ' '}, 0 to indent)          
          val str = match(key(b)) :
            (s:ISubset) : to-string("(%,) => " % [xs(s)])
            (s:IAll) : "* => "
          print(o, str)
          loop(value(b), indent + length(str))

;============================================================
;================== Int Set Datastructure ===================
;============================================================

public deftype ISet
public defstruct ISubset <: ISet :
  xs: Tuple<Int> with: (ensure => ordered!)
with: (printer => true)

public defstruct IAll <: ISet
with: (printer => true)

public deftype IDispatchBranch
public defstruct IBranch <: IDispatchBranch :
  sets: List<ISet>
  target
with:
  printer => true

public defstruct IAmb <: IDispatchBranch :
  sets: Tuple<Tuple<ISet>>
  target
with:
  printer => true

;============================================================
;==================== Invariants ============================
;============================================================

defn ordered! (description:String, ts:Tuple<Comparable>) :
  val n = length(ts)
  for i in 0 to n - 1 do :
    if ts[i] >= ts[i + 1] :
      fatal("The %_ with value %_ is not strictly ordered." % [description, ts])

;============================================================
;================ Convenient Set Functions ==================
;============================================================

public defn union (a:ISet, b:ISet) -> ISet :
  a-or-b(compare(a,b))
  
public defn intersection (a:ISet, b:ISet) -> ISet :
  a-and-b(compare(a,b))

;============================================================
;================= Comparison between sets ==================
;============================================================

public deftype SetCase
public defstruct ASubset <: SetCase
with: (printer => true)
public defstruct BSubset <: SetCase
with: (printer => true)
public defstruct ABEqual <: SetCase
with: (printer => true)
public defstruct ABDisjoint <: SetCase
with: (printer => true)
public defstruct ABIntersect <: SetCase
with: (printer => true)

public defstruct SetComparison :
  case: SetCase
  a-minus-b: ISet
  b-minus-a: ISet
  a-and-b: ISet
  a-or-b: ISet
with:
  printer => true

public defn compare (a:ISet, b:ISet) :  
  match(a, b) :
    (a:ISubset, b:IAll) :
      SetComparison(ASubset(),
                    ISubset([]),
                    IAll(),
                    a,
                    IAll())
    (a:IAll, b:ISubset) :
      SetComparison(BSubset(),
                    IAll(),
                    ISubset([]),
                    b,
                    IAll())
    (a:IAll, b:IAll) :
      SetComparison(ABEqual(),
                    ISubset([]),
                    ISubset([]),
                    IAll(),
                    IAll())
    (a:ISubset, b:ISubset) :
      val a-only = Vector<Int>()
      val b-only = Vector<Int>()
      val common = Vector<Int>()
      val union = Vector<Int>()
      let loop (i:Int = 0, j:Int = 0) :
        defn get? (xs:Tuple<Int>, i:Int) :
          xs[i] when i < length(xs)
        match(get?(xs(a), i), get?(xs(b), j)) :
          (a:Int, b:Int) :
            switch(compare(a,b)) :
              -1 :
                add(a-only, a)
                add(union, a)
                loop(i + 1, j)
              0 :
                add(common, a)
                add(union, a)
                loop(i + 1, j + 1)
              1 :
                add(b-only, b)
                add(union, b)
                loop(i, j + 1)
          (a:Int, b) :
            add(a-only, a)
            add(union, a)
            loop(i + 1, j)
          (a, b:Int) :
            add(b-only, b)
            add(union, b)
            loop(i, j + 1)
          (a, b) :
            false
      val case = match(empty?(a-only), empty?(b-only), empty?(common)) :
        ;Equal if A and B share all of their types
        (ae:True, be:True, ce:False) : ABEqual()
        ;A is a subset if there are no types that belong only in A
        (ae:True, be, ce) : ASubset()
        ;B is a subset if there are no types that belong only in B
        (ae, be:True, ce) : BSubset()
        ;Disjoint if A and B share no types
        (ae, be, ce:True) : ABDisjoint()
        ;Intersect if A and B share some types
        (ae, be, ce:False) : ABIntersect()
      SetComparison(case,
                    ISubset(to-tuple(a-only)),
                    ISubset(to-tuple(b-only)),
                    ISubset(to-tuple(common)),
                    ISubset(to-tuple(union)))    

;============================================================
;================== Conversion to Trie ======================
;============================================================

public defn to-trie (trie-branches:Seqable<IDispatchBranch>) -> IfTrie :
  defn initial-trie (b:IBranch) :
    if empty?(sets(b)) :
      EndTrie(target(b))
    else :
      IfTrie(List(first-set(b) => initial-trie(tail(b))))

  defn add (t:MTrie, b:IBranch) :
    match(t) :
      (t:IfTrie) : IfTrie(add(branches(t), b))
      (t:EndTrie) : t

  defn add (branches:List<KeyValue<ISet, MTrie>>, b:IBranch) :
    if empty?(first-set(b)) :
      branches
    else if empty?(branches) :
      List(first-set(b) => initial-trie(tail(b)))
    else :
      ;branches has form (A => T, Rs ...)
      val A = key(head(branches))
      val T = value(head(branches))
      val Rs = tail(branches)

      ;Let first set of b be B
      val B = first-set(b)      
      val r = compare(A, B)
      match(case(r)) :
        (c:ABEqual) :
          cons(A => add(T, tail(b)), Rs)
        (c:ASubset) :
          cons(A => add(T, tail(b)),
               add(Rs, sub-first-set(b, b-minus-a(r))))
        (c:BSubset) :
          cons(B => add(T, tail(b)),
               a-minus-b(r) => T,
               Rs)
        (c:ABDisjoint) :
          cons(A => T,
               add(Rs, b))
        (c:ABIntersect) :
          cons(a-minus-b(r) => T,
               a-and-b(r) => add(T, tail(b)),
               add(Rs, sub-first-set(b, b-minus-a(r))))

  val branches = for b in trie-branches seq-cat :
    match(b) :
      (b:IBranch) :
        [b]
      (b:IAmb) :
        for ts in amb-branches(sets(b)) seq :
          IBranch(to-list(ts), target(b))
  reduce(add{_:MTrie, _:IBranch},
        initial-trie(next(branches)),
        branches) as IfTrie
  
defn empty? (s:ISet) :
  match(s:ISubset) :
    empty?(xs(s))
defn first-set (b:IBranch) :
  head(sets(b))
defn sub-first-set (b:IBranch, s:ISet) :
  IBranch(cons(s, tail(sets(b))), target(b))
defn tail (b:IBranch) :
  IBranch(tail(sets(b)), target(b))

;============================================================
;==================== Ambiguity Branches ====================
;============================================================

public defn amb-branches (branches:Tuple<Tuple<ISet>>) :
  ;Single argument case
  if length(branches[0]) == 1 :
    ;Count number of occurrences of each type
    val count-table = IntTable<Int>(0)
    var num-all:Int = 0
    for b in branches do :
      match(b[0]) :
        (s:ISubset) :
          for x in xs(s) do :
            update(count-table, {_ + 1}, x)
        (s:IAll) :
          num-all = num-all + 1
    switch(num-all) :
      0 :
        val xs = qsort(seq(key, filter({value(_) >= 2}, count-table)))
        [[ISubset(xs)]]
      1 : 
        val xs = qsort(seq(key, filter({value(_) >= 1}, count-table)))
        [[ISubset(xs)]]
      else :
        [[IAll()]]
  else :
    ;Compute number of branches and arguments
    val num-branches = length(branches)
    val num-args = length(branches[0])
    
    ;Retrieve all potentially conflicting branches due to
    ;a single argument index.
    defn conflicts (return:(Int, Int) -> False, arg:Int) :
      ;Compute all potentially conflicting ISubset branches,
      ;and all IAll branches.
      val set-table = IntTable<List<Int>>(List())
      val all-list = Vector<Int>()
      val sub-list = Vector<Int>()
      for i in 0 to num-branches do :    
        val s = branches[i][arg]
        ;Add to appropriate category
        match(s) :
          (s:IAll) : add(all-list, i)
          (s:ISubset) : add(sub-list, i)
        ;Add branch to appropriate set
        match(s:ISubset) :
          for x in xs(s) do :
            update(set-table, cons{i, _}, x)
      ;Compute whether already taken
      val visited = IntSet()
      defn return-unique (i:Int, j:Int) :
        val a = min(i,j)
        val b = max(i,j)
        if add(visited, a + num-branches * b) :
          return(a,b)
      ;Return subset conflicts
      for entry in set-table do :
        if length(value(entry)) > 1 :
          within (i,j) = all-pairs(value(entry)) :
            return-unique(i,j)
      within (i,j) = all-pairs(all-list) :
        return-unique(i,j)
      for i in all-list do :
        for j in sub-list do :
          return-unique(i,j)

    ;Retrieve all potentially conflicting branches
    ;after accounting for all argument positions.
    defn conflicts (return:(Int, Int) -> False) :
      val num-conflicts = IntTable<Int>(0)
      defn inc-conflicts (i:Int, j:Int) :
        val k = i + num-branches * j
        val n = update(num-conflicts, {_ + 1}, k)
        return(i,j) when n == num-args
      for arg in 0 to num-args do :
        conflicts(inc-conflicts, arg)

    ;Produce conflicting branches
    val ambs = Vector<Tuple<ISet>>()
    within (i,j) = conflicts() :
      val bi = branches[i]
      val bj = branches[j]
      val b* = for (ti in bi, tj in bj) seq :
        a-and-b(compare(ti,tj))
      add(ambs, to-tuple(b*))
    to-tuple(ambs)

defn all-pairs (f:(Int, Int) -> ?, xs:Vector<Int>) :
  for i in 0 to length(xs) do :
    for j in (i + 1) to length(xs) do :
      f(xs[i], xs[j])

defn all-pairs (f:(Int, Int) -> ?, xs:List<Int>) :
  let loop (xs:List<Int> = xs) :
    if not empty?(xs) :
      val x = head(xs)
      do(f{x, _}, tail(xs))
      loop(tail(xs))

;============================================================
;==================== All Targets ===========================
;============================================================

public defn all-targets (t:IfTrie, args:Tuple<ISet>) -> Vector :
  val targets = Vector<?>()
  defn execute (t:MTrie, index:Int) :
    match(t) :
      ;Reached end trie, add target
      (t:EndTrie) :
        add(targets, target(t))
      ;Try each branch of IfTrie
      (t:IfTrie) :
        val arg = args[index]
        label break :
          for entry in branches(t) do :
            val r = case(compare(arg, key(entry)))
            execute(value(entry), index + 1) when r is-not ABDisjoint              
            break() when r is ASubset|ABEqual
  execute(t, 0)
  targets              

;============================================================
;=================== Properties =============================
;============================================================

;Compute the depth of a trie
public defn depth (t:MTrie) :
  match(t) :
    (t:IfTrie) : depth(value(head(branches(t)))) + 1
    (t:EndTrie) : 0

;============================================================
;============================================================
;============================================================

#if-defined(STANDALONE) :

  defn main () :
    println(compare(ISubset([110 169]), ISubset([15])))


    val bs = [
      IBranch(to-list $ [ISubset([15]) ISubset([15])], 0)
      IBranch(to-list $ [ISubset([110 169]) ISubset([110 169])], 1)
      IBranch(to-list $ [ISubset([15 110 169]) ISubset([15 110 169])], 2)
    ]
    println(to-trie(bs))

  main()