;See License.txt for details about licensing.

defpackage stz/compiler :
  import core
  import collections
  import reader
  import macro-utils
  import stz/params
  import stz/utils
  import stz/algorithms
  import stz/input
  import stz/renamer
  import stz/resolver
  import stz/type
  import stz/il-ir
  import stz/tl-ir
  import stz/namemap
  import stz/core-macros
  import stz/tl-to-el
  import stz/tl-to-dl
  import stz/el-to-vm
  import stz/el
  import stz/el-ir
  import stz/vm-ir
  import stz/dl-ir
  import stz/dl
  import stz/backend
  import stz/reg-alloc with :
    prefix(Ins) => reg-alloc-
  import stz/vm-normalize
  import stz/codegen
  import stz/asm-ir
  import stz/asm-emitter
  import stz/stitcher
  import stz/bindings
  import stz/pkg
  import stz/ids

public defn compile (filenames:List<String>, output:False|String, pkg-dir:False|String, backend:Backend) :
  defn driver () :
    ;Read in all inputs
    val input-packages = Vector<Symbol>()
    val ipackages = Vector<IPackage>()
    val input-pkgs = Vector<Pkg>()
    val bindings = Vector<Bindings>()
    val pkgloader = PkgLoader()

    for filename in filenames do :
      switch(category(filename)) :
        `package :
          val pkg = load-pkg(pkgloader, to-symbol(filename))
          add(input-packages, name(pkg))
          add(input-pkgs, pkg)
        `stanza-file :
          val ipkgs = read-ipackages(filename)
          add-all(input-packages, seq(name,ipkgs))
          add-all(ipackages, ipkgs)
        `pkg-file :
          val pkg = load-pkg(pkgloader, filename)
          add(input-packages, name(pkg))
          add(input-pkgs, pkg)
        `binding-file :
          add(bindings, read-bindings(filename))

    ;Ensure no duplicate packages
    ensure-no-duplicate-packages!(input-packages)

    ;Compile all to EL packages
    val epackages = compile-to-el(ipackages, pkgloader)

    ;Load in dependent packages
    val all-pkgs = all-pkgs-and-dependencies(pkgloader, seq(name,epackages))

    ;Ensure that packageio definitions for packages are consistent.
    ;Return the DEnv for use later in computing the initialization order.
    val denv = ensure-consistent-packageios(to-tuple(cat-all([epackages, all-pkgs])))
    
    ;Save optimized packages if necessary
    do(save-as-fpkg, epackages) when save-optimized-pkgs?()

    ;If we are producing a final asm file
    if compile-to-asm?() :
      val init-order = compute-init-order(denv, input-packages)
      if flag-defined?(`OPTIMIZE) :
        compile-optimized-to-asm(epackages, all-pkgs, bindings, init-order)

    ;Otherwise if we are producing unoptimized pkg files
;    else if save-unoptimized-pkgs?() :
;      do(compile-to-pkg, epackages)

  defn read-ipackages (filename:String) -> Tuple<IPackage> :
    ;Lex the file into s-expressions
    val forms = read-file(filename)
    ;Expand macros
    val expanded = cons(`$begin, parse-syntax[core / #exps!](forms))
    ;Convert to IPackage using standard imports
    val core-imports = [IImport(`core), IImport(`collections)]
    to-ipackages(expanded, core-imports)

  defn ensure-no-duplicate-packages! (packages:Seqable<Symbol>) :
    val pset = HashSet<Symbol>()
    for p in packages do :
      if not add(pset,p) :
        throw(DuplicatePackage(p))

  defn compile-to-el (ipackages:Collection<IPackage>, pkgloader:PkgLoader) :
    ;First rename the binders
    val renamed = match(rename-il(to-tuple(ipackages))) :
      (renamed:Tuple<IPackage>) : renamed
      (e:RenameErrors) : throw(e)
      
    ;Create the table holding the package exports
    ;The exports have their identifiers renamed so that they do not conflict
    ;with fresh-id().
    val package-exports-table = HashTable<Symbol,PackageExports|False>()
    defn package-exports (name:Symbol) :
      within update?(package-exports-table, name) :
        try :
          val pkg = load-pkg(pkgloader, name)
          val pexs = to-package-exports(packageio(pkg))
          defn rename-id (e:Export) : sub-n(e, fresh-id())
          sub-exports(pexs, map(rename-id, exports(pexs)))
        catch (e:NoPackageException) :
          false

    ;Create the resolution and typing environment
    val env = new stz/resolver/Env & stz/type/Env :
      defmethod stz/resolver/exports (this, package:Symbol) :
        package-exports(package)
      defmethod stz/type/exports (this, package:Symbol) :
        package-exports(package) as PackageExports    

    ;Resolve the binders
    val resolved = match(resolve-il(renamed, env, false)) :
      (e:ResolveErrors) : throw(e)
      (e:Tuple<IPackage>) : e

    ;Typecheck the program
    val typed = match(type-program(resolved, env)) :
      (e:TProg) : e
      (e:TypeErrors) : throw(e)

    ;Compile to EL
    to-el(typed, false)
    
  defn ensure-consistent-packageios (pkgs:Collection<EPackage|Pkg>) -> DEnv :
    val denv = DEnv()
    val result = load(denv, to-collection(seq{packageio,pkgs}), [])
    match(result:LoadErrors) : throw(result)
    denv

  defn save-optimized-pkgs? () :
    pkg-dir is String and flag-defined?(`OPTIMIZE)

  defn save-unoptimized-pkgs? () :
    pkg-dir is String and not flag-defined?(`OPTIMIZE)

  defn save-as-fpkg (p:EPackage) :
    val pkg = FastPkg(packageio(p), exps(p))
    save-package(pkg-dir as String, pkg)

  defn compile-to-asm? () :
    output is String

  defn compute-init-order (denv:DEnv, inputs:Collection<Symbol>) :
    initialization-order(package-dependency-graph(denv), inputs, {false})

  defn compile-optimized-to-asm (epackages:Tuple<EPackage>, pkgs:Tuple<Pkg>, bindings:Vector<Bindings>, init-order:Collection<Symbol>) :
    ;Lower to a single VMPackage
    val package-table = to-hashtable(name, cat(epackages, pkgs))
    defn get-epackage (name:Symbol) :
      match(package-table[name]) :
        (p:FastPkg) : EPackage(packageio(p), exps(p))
        (p:EPackage) : p
    val vmpackage = compile(lower-optimized(to-tuple(seq(get-epackage, init-order))))
    compile-vmpackage(vmpackage, bindings)

  defn file-emitter () :
    new CodeEmitter :
      defmethod emit (this, i:Ins) :
        println(i)
        
  defn empty-emitter () :
    new CodeEmitter :
      defmethod emit (this, i:Ins) :
        false

  ;Compile a single vmpackage directly to file.
  defn compile-vmpackage (vmpackage:VMPackage, bindings:Vector<Bindings>) :
    val npkg = collapse(normalize(vmpackage, backend))
    val stubs = AsmStubs(backend)
    val stitcher = Stitcher([npkg], bindings, stubs)
    val file-emitter = file-emitter()
    val emitter = emitter(stitcher, package(vmpackage), file-emitter)
    with-output-file(FileOutputStream(output as String), fn () :
      for f in funcs(npkg) do :
        emit(emitter, LinkLabel(id(f)))
        allocate-registers(func(f), emitter, backend, stubs, false)
      emit-tables(stitcher, file-emitter)
      emit-stubs(stitcher, file-emitter)
      compile-runtime-stubs(file-emitter, stubs))

  ;Compile multiple vmpackages directly to file
  defn compile-vmpackages (pkgs:Tuple<VMPackage|StdPkg>, bindings:Vector<Bindings>, init-order:Tuple<Symbol>) :
    fatal("Not yet implemented")
    ;;Reorder pkgs according to initialization order
    ;val pkg-table = to-hashtable(name, pkgs)
    ;val ordered-pkgs = for p in init-order map : pkg-table[p]
    ;;Normalize the packages
    ;val npkgs = for pkg in ordered-pkgs map :
    ;  match(pkg:VMPackage) : normalize(pkg, backend)
    ;  else : pkg as StdPkg
    ;;Create stubs
    ;val stubs = AsmStubs(backend)
    ;;Create stitcher
    ;val stitcher = Stitcher(map(collapse,npkgs), bindings, stubs)
    ;with-output-file(FileOutputStream(output as String), fn () :
    ;  val file-emitter = file-emitter()
    ;  val stitching-emitter = emitter(stitcher, package(vmpackage), file-emitter)
    ;  for (pkg in ordered-pkgs, npkg in npkgs) do :
    ;    defn allocate-registers (emitter:CodeEmitter) :
    ;      match(npkg:NormVMPackage) :
    ;        for f in funcs(vmpackage(npkg)) do :
    ;          emit(emitter, LinkLabel(id(f)))
    ;          allocate-registers(func(f), emitter, backend, stubs, false)
    ;    defn allocate-and-save-pkg (dir:String) :
    ;      val pkg-maker = PkgMaker(pkg as VMPackage, datas(npkg as NormVMPackage))          
    ;      val emitter = emitter(stitching-emitter, pkg-maker)
    ;      allocate-registers(emitter)
    ;      save-package(dir, /pkg(pkg-maker))
    ;    ;Unoptimized packages should be saved if we are compiling in
    ;    ;unoptimized mode, and a pkg output directory has been specified,
    ;    ;and pkg is a VMPackage.
    ;    val save-unoptimized-pkg? = pkg is VMPackage and pkg-dir is String
    ;    if save-unoptimized-pkg? :
    ;      allocate-and-save-pkg(pkg-dir as String)
    ;    else :
    ;      allocate-registers(stitching-emitter)
    ;  ;Emit stitched tables
    ;  emit-tables(stitcher, file-emitter)
    ;  emit-stubs(stitcher, file-emitter)
    ;  compile-runtime-stubs(file-emitter, stubs))

  ;Compile to unoptimized pkgs
  defn compile-to-pkg (vmpackage:VMPackage) :
    fatal("Not yet implemented")
    ;val npkg = normalize(vmpackage, backend)
    ;val pkg-maker = PkgMaker(pkg as VMPackage, datas(npkg as NormVMPackage))
    ;val emitter = emitter(empty-emitter(), pkg-maker)
    ;for f in funcs(vmpackage(npkg)) do :
    ;  allocate-registers(func(f), emitter, backend, stubs, false)

  driver()

;<doc>=======================================================
;==================== Categorization ========================
;============================================================

Classifies the incoming files into four types:
  myfile.stanza
  myfile.pkg
  myfile.vmbindings
  mypackage

Returns either:
  `package
  `stanza-file
  `pkg-file
  `binding-file

;============================================================
;=======================================================<doc>

defn category (name:String) -> Symbol :
  defn has-extension? (s:String) :
    index-of-char(s, '.') is Int
  if not has-extension?(name) :
    `package
  else :
    switch suffix?{name, _} :
      ".stanza" : `stanza-file
      ".pkg" : `pkg-file
      ".vmbindings" : `binding-file
      else : throw(InvalidExtensionError(name))

;============================================================
;================= File to Package Mapping ==================
;============================================================

deftype InputPackageTable
defmulti register (ipt:InputPackageTable, file:String, packages:Tuple<Symbol>) -> False
defmulti packages (ipt:InputPackageTable, file:String) -> Tuple<Symbol>
defn InputPackageTable () :
  val table = HashTable<String,Tuple<Symbol>>()
  new InputPackageTable :
    defmethod register (this, file:String, packages:Tuple<Symbol>) :
      table[file] = packages
    defmethod packages (this, file:String) :
      table[file]

;============================================================
;============= Collapsing a Normalized Package ==============
;============================================================

defn collapse (p:NormVMPackage|StdPkg) :
  val [vmp, asm-datas] = match(p) :
    (p:NormVMPackage) : [vmpackage(p), datas(p)]
    (p:StdPkg) : [vmp(p), datas(p)]
  new VMPackage :
    defmethod packageio (this) : packageio(vmp)
    defmethod init (this) : init(vmp)
    defmethod globals (this) : globals(vmp)
    defmethod datas (this) : to-tuple(cat(datas(vmp), asm-datas))
    defmethod consts (this) : consts(vmp)
    defmethod classes (this) : classes(vmp)
    defmethod funcs (this) : funcs(vmp)
    defmethod methods (this) : methods(vmp)
    defmethod externs (this) : externs(vmp)
    defmethod extern-defns (this) : extern-defns(vmp)

;============================================================
;==================== PkgMaker ==============================
;============================================================

deftype PkgMaker
defmulti pkg (m:PkgMaker) -> Pkg
defmulti emitter (emitter:CodeEmitter, m:PkgMaker) -> CodeEmitter

defn PkgMaker (vmp:VMPackage, asm-datas:Tuple<VMData>) :
  val buffer = Vector<Ins>()
  new PkgMaker :
    defmethod pkg (this) :
      StdPkg(vmp, to-tuple(buffer), asm-datas)
    defmethod emitter (emitter:CodeEmitter, this) :
      new CodeEmitter :
        defmethod emit (this, i:Ins) :
          add(buffer, i)
          emit(emitter, i)

;============================================================
;===================== Errors ===============================
;============================================================

defn InvalidExtensionError (filename:String) :
  new Exception :
    defmethod print (o:OutputStream, this) :
      print(o, "File %_ does not have a valid Stanza file extension." % [filename])

defn DuplicatePackage (name:Symbol) :
  Exception("The package %~ is loaded multiple times." % [name])
    