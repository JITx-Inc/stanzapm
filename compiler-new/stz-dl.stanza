defpackage stz/dl :
  import core
  import collections
  import stz/dl-ir
  import stz/utils

;<doc>=======================================================
;====================== Documentation =======================
;============================================================

# Fundamental State #

  packages:Vector<PackageIO>

# Retrieving a PackageIO #

  packageio (e:DEnv, name:Symbol) -> PackageIO|False

Used to represent the environment for the REPL during resolving and
typechecking.

# Retrieving all PackageIOs #

  packageios (e:DEnv) -> Collection<PackageIO>

Useful function to be able to calculate the package dependency graph.
The packages are also ordered according to when they are first added
to the environment.

# Loading new packages #

  load (e:DEnv, ps:Collection<PackageIO>, live-recs:Tuple<Rec>) -> LoadResult

Loads the given packages into the environment. The operation succeeds
and returns LoadSuccess only if the new packages are consistent with
the definitions of the existing environment. Otherwise, the operation
returns LoadErrors.

The live-recs argument holds all the records that the currently live
objects depend upon. This prevents the user from changing the type
signature of a function that is still in active use.

# Updating existing packages #

  update (e:DEnv, ps:Collection<PackageIO>, live-recs:Tuple<Rec>) -> LoadResult
  
Updates the given packages in the environment. This is meant to be
used to update code definitions in the environment without
re-evaluating the top-level expressions. The operation behaves very
similarly to load except that it additionally enforces two checks. The
given packages must already exist in the environment, and the packages
cannot change the type of any global variable.

# Convenience: Compute the package dependency graph #

  package-dependency-graph (env:DEnv) -> HashTable<Symbol, List<Symbol>>

Computes the package dependency graph of all loaded packages.

;============================================================
;=======================================================<doc>

;============================================================
;======================= Interface ==========================
;============================================================

public :
  deftype DEnv
  defmulti packageios (e:DEnv) -> Collection<PackageIO>
  defmulti packageio (e:DEnv, name:Symbol) -> PackageIO|False
  defmulti load (e:DEnv, ps:Collection<PackageIO>, live-recs:Tuple<Rec>) -> LoadResult
  defmulti update (e:DEnv, ps:Collection<PackageIO>, live-recs:Tuple<Rec>) -> LoadResult

  deftype LoadResult
  defstruct LoadErrors <: LoadResult&Exception : (errors: Tuple<LoadError>)
  defstruct LoadSuccess <: LoadResult

  deftype LoadError <: Exception
  defmulti source (e:LoadError) -> DependencySource
  defstruct MissingDependency <: LoadError :
    source:DependencySource with: (as-method => true)
    expected:Rec
  defstruct MismatchedDependency <: LoadError :
    source:DependencySource with: (as-method => true)
    expected:Rec
    actual:Rec
  defstruct ChangedGlobal <: LoadError :
    source:DependencySource with: (as-method => true)
    expected:Rec
    actual:Rec

  deftype DependencySource
  defstruct LoadedPackage <: DependencySource : (package:Symbol)
  defstruct LiveObject <: DependencySource

;============================================================
;=============== Descriptor Environment =====================
;============================================================

public defn DEnv () :
  ;Initialize package table and live set
  val packages = Vector<PackageIO>()
  val package-indices = HashTable<Symbol,Int>()

  ;Packages
  defn add-package (p:PackageIO) :
    match(get?(package-indices,package(p))) :
      (i:Int) :
        packages[i] = p
      (_:False) :
        val i = length(packages)
        add(packages, p)
        package-indices[package(p)] = i

  ;============================
  ;==== Ensure Consistency ====
  ;============================
  ;Sanity consistency check
  defn ensure-consistency () :
    #if-not-defined(OPTIMIZE) :
      ;Ensure that all imported records match the exported records exactly.
      val rec-table = to-hashtable<RecId,Rec> $
        seq-cat(exported-entries, packages)
      for import in seq-cat(imports,packages) do :
        if not transient?(import) :
          val r = rec(import)
          match(get?(rec-table, id(r))) :
            (r2:Rec) : fatal("Mismatched dependency: %_ != %_" % [r, r2]) when not match?(r, r2)
            (r2:False) : fatal("Missing dependency: %_" % [id(r)])
    false

  ;<doc>===========================
  ;==== Error Checking Utility ====
  ;================================
  For anything that may create errors, call it like this:

    within check-for-errors() :
      my-body()
      if there-is-error? :
        error!()

  And the block above will return a LoadResult.
  ;================================
  ;===========================<doc>

  ;Accumulate any detected errors in buffer
  val error-accum = Vector<LoadError>()
  defn error! (e:LoadError) : add(error-accum, e)
  defn check-for-errors (f:() -> False) -> LoadResult :
    f()
    if empty?(error-accum) :
      LoadSuccess()
    else :
      val e = LoadErrors(to-tuple(error-accum))
      clear(error-accum)
      e

  ;<doc>=============================
  ;=== Check For Changed Globals ====
  ;==================================
  When updating packages, we preserve the state of the existing global
  variables, and thus we cannot change their type signature. This pass
  ensures that we do not change the type signatures of any global in
  the given packages.
  
  Since this is used during updating, it is assumed that these
  packages all have been loaded before.
  ;==================================
  ;=============================<doc>

  ;Check whether globals have been redefined.
  ;During updating, globals are not allowed to change their types.
  defn check-for-changed-globals (packageios:Collection<PackageIO>) :
    ;Retrieve all exported global records in packageio
    defn global-recs (io:PackageIO) :
      for e in exports(io) seq? :
        match(id(rec(e))) :
          (id:ValId) : One(rec(e))
          (id) : None()

    ;Check against previous definitions
    for new-io in packageios do :
      ;Get old IO
      val index = package-indices[package(new-io)]
      val old-io = packages[index]
      
      ;Create a table to quickly lookup the new definition by id.
      val new-rec-table = to-hashtable(id, global-recs(new-io))

      ;Compare the old globals to the new globals
      val src = LoadedPackage(package(new-io))
      for old-r in global-recs(old-io) do :
        match(get?(new-rec-table, id(old-r))) :
          ;Case: The global is no longer defined. That is okay.
          (_:False) : false
          ;Case: The global is defined. Ensure that it matches.
          (new-r:Rec) :
            if not match?(new-r, old-r) :
              error! $ ChangedGlobal(src, old-r, new-r)

  ;<doc>=========================================
  ;=== Check New Exports Against Old Imports ====
  ;==============================================
  Check loading packages into the environment.
  
  We assume that the packages to load have successfully passed the typechecker.
  This indicates two things:
  1. The packages are internally consistent. All imports/exports
     from/to packages to be reloaded are guaranteed to be consistent by
     the typechecker.
  2. The package imports are consistent. The typechecker imports the existing
     definitions from the environment and ensures that the code is consistent
     with these definitions.
  Therefore there is only one thing left to check. Whether the new
  exports from the reloaded packages are consistent with the imports
  from the existing context.
  ;==============================================
  ;=========================================<doc>

  defn check-new-exports-against-old-imports (ps:Collection<PackageIO>, live-recs:Tuple<Rec>) :
    ;These are the packages to be reloaded
    val reloaded-packages = to-hashset<Symbol>(seq(package, ps))

    ;Here are the new exported entries from the reloaded packages
    val export-table = to-hashtable<RecId,Rec> $
      seq-cat(exported-entries, ps)

    ;Check whether the imported record, imported, from 'src'
    ;is satisfied by the reloaded-packages.
    defn check-dependency (src:DependencySource, imported:Rec) :
      val rid = id(imported)
      if reloaded-packages[package(rid)] :
        match(get?(export-table, rid)) :
          (exported:Rec) :
            if not match?(imported, exported) :
              error! $ MismatchedDependency(src, imported, exported)
          (_:False) :
            error! $ MissingDependency(src, imported)

    ;Return true if the given package p may possibly be affected by the
    ;given reload set, ie. if it imports a package that is to be reloaded,
    ;but it is not itself a package to be reloaded.
    defn affected? (p:PackageIO) :
      if not reloaded-packages[package(p)] :
        any?({reloaded-packages[_]}, imported-packages(p))

    ;Check all the (non-transient) dependencies from affected packages
    for p in filter(affected?, packages) do :
      val src = LoadedPackage(package(p))
      for import in imports(p) do :
        check-dependency(src, rec(import)) when not transient?(import)
        
    ;Check all the dependencies from the live objects
    do(check-dependency{LiveObject(), _}, live-recs)

  ;================================
  ;==== Return new Environment ====
  ;================================
  new DEnv :
    defmethod packageios (this) :
      packages
    defmethod packageio (this, name:Symbol) :
      val i = get?(package-indices, name)
      match(i:Int) : packages[i]
    defmethod load (this, pkgs:Collection<PackageIO>, live-recs:Tuple<Rec>) :
      val load-result = within check-for-errors() :
        check-new-exports-against-old-imports(pkgs, live-recs)
      match(load-result:LoadSuccess) :
        do(add-package, pkgs)
        ensure-consistency()
      load-result
    defmethod update (this, pkgs:Collection<PackageIO>, live-recs:Tuple<Rec>) :
      val load-result = within check-for-errors() :
        check-for-changed-globals(pkgs)
        check-new-exports-against-old-imports(pkgs, live-recs)
      match(load-result:LoadSuccess) :
        do(add-package, pkgs)
        ensure-consistency()
      load-result

;============================================================
;======================= Utilities ==========================
;============================================================

public defn package-dependency-graph (env:DEnv) :
  to-hashtable<Symbol,List<Symbol>> $
    for io in packageios(env) seq :
      package(io) => to-list(imported-packages(io))

;Retrieve all exported entries from packageio
defn exported-entries (p:PackageIO) :
  for e in exports(p) seq :
    val r = rec(e)
    id(r) => r

;============================================================
;===================== Printers =============================
;============================================================

defn source-str (s:DependencySource) :
  match(s) :
    (s:LoadedPackage) : "The package %~ requires" % [package(s)]
    (s:LiveObject) : "There is a live object that requires"

defmethod print (o:OutputStream, e:MissingDependency) :
  print(o, "Missing definition: %_ the following definition:" % [source-str(source(e))])
  val o2 = IndentedStream(o)
  lnprint(o2, format(expected(e)))
  
defmethod print (o:OutputStream, e:MismatchedDependency) :
  val o2 = IndentedStream(o)
  print(o, "Inconsistent definition: %_ the following definition:" % [source-str(source(e))])
  lnprint(o2, format(expected(e)))
  lnprint(o, "but it has been replaced with:")
  lnprint(o2, format(actual(e)))

defmethod print (o:OutputStream, e:ChangedGlobal) :
  val o2 = IndentedStream(o)
  print(o, "Globals are not allowed to be redefined during code update. %_ the following definition:" % [
    source-str(source(e))])
  lnprint(o2, format(expected(e)))
  lnprint(o, "but it has been replaced with:")
  lnprint(o2, format(actual(e)))

defmethod print (o:OutputStream, e:LoadErrors) :
  print(o, "%n" % [errors(e)])
    