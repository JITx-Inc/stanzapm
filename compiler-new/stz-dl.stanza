defpackage stz/dl :
  import core
  import collections
  import stz/dl-ir
  import stz/utils

;<doc>=======================================================
;====================== Documentation =======================
;============================================================

# Fundamental State #

  package-table:HashTable<Symbol,PackageIO>

# Retrieving a PackageIO #

  packageio (e:DEnv, name:Symbol) -> PackageIO|False

Used to represent the environment for the REPL during resolving and
typechecking.

# Retrieving all PackageIOs #

  packageios (e:DEnv) -> Seqable<PackageIO>

Useful function to be able to calculate the package dependency graph.

# Loading new packages #

  load (e:DEnv, ps:Seqable<PackageIO>) -> LoadResult

Loads the given packages into the environment. The operation succeeds
and returns LoadSuccess only if the new packages are consistent with
the definitions of the existing environment. Otherwise, the operation
returns LoadErrors.

# Updating existing packages #

  update (e:DEnv, ps:Seqable<PackageIO>) -> LoadResult
  
Updates the given packages in the environment. This is meant to be
used to update code definitions in the environment without
re-evaluating the top-level expressions. The operation behaves very
similarly to load except that it additionally enforces two checks. The
given packages must already exist in the environment, and the packages
cannot change the type of any global variable.

;============================================================
;=======================================================<doc>

;============================================================
;======================= Interface ==========================
;============================================================

public :
  deftype DEnv
  defmulti packageios (e:DEnv) -> Seqable<PackageIO>
  defmulti packageio (e:DEnv, name:Symbol) -> PackageIO|False
  defmulti check-exports (e:DEnv, ps:Tuple<PackageIO>, live-recs:Tuple<Rec>) -> LoadResult
  defmulti check-globals (e:DEnv, packages:Tuple<PackageIO>) -> LoadResult
  defmulti load (e:DEnv, ps:Seqable<PackageIO>) -> False

  deftype LoadResult
  defstruct LoadErrors <: LoadResult : (errors: Tuple<LoadError>)
  with: (printer => true)
  defstruct LoadSuccess <: LoadResult
  with: (printer => true)

  deftype LoadError
  defmulti source (e:LoadError) -> DependencySource
  defstruct MissingDependency <: LoadError :
    source:DependencySource with: (as-method => true)
    expected:Rec
  defstruct MismatchedDependency <: LoadError :
    source:DependencySource with: (as-method => true)
    expected:Rec
    actual:Rec
  defstruct ChangedGlobal <: LoadError :
    source:DependencySource with: (as-method => true)
    expected:Rec
    actual:Rec

  deftype DependencySource
  defstruct LoadedPackage <: DependencySource : (package:Symbol)
  defstruct LiveObject <: DependencySource

;============================================================
;=============== Descriptor Environment =====================
;============================================================

public defn DEnv () :
  ;Initialize package table and live set
  val packages = HashTable<Symbol,PackageIO>()
  val package-ordering = Vector<Symbol>()

  ;Packages
  defn add-package (p:PackageIO) :
    if not key?(packages, package(p)) :
      add(package-ordering, package(p))
    packages[package(p)] = p

  ;Sanity consistency check
  defn ensure-consistency () :
    #if-not-defined(OPTIMIZE) :
      ;Ensure that all imported records match the exported records exactly.
      val rec-table = to-hashtable<RecId,Rec> $
        seq-cat(exported-entries, values(packages))      
      for import in seq-cat(imports,values(packages)) do :
        if not transient?(import) :
          val r = rec(import)
          match(get?(rec-table, id(r))) :
            (r2:Rec) : fatal("Mismatched dependency: %_ != %_" % [r, r2]) when not match?(r, r2)
            (r2:False) : fatal("Missing dependency: %_" % [id(r)])
    #else :
      false

  ;Return true if the given package p may possible by affected the
  ;given reload set.
  defn affected? (p:PackageIO, reloaded:Set<Symbol>) :
    (not reloaded[package(p)]) and
    any?({reloaded[_]}, imported-packages(p))

  ;Accumulate any detected errors in buffer
  val error-accum = Vector<LoadError>()
  defn error! (e:LoadError) : add(error-accum, e)
  defn check-for-errors (f:() -> False) -> LoadResult :
    f()
    if empty?(error-accum) :
      LoadSuccess()
    else :
      val e = LoadErrors(to-tuple(error-accum))
      clear(error-accum)
      e

  ;Check whether globals have been redefined.
  ;During updating, globals are not allowed to change their types.
  defn check-globals (packageios:Tuple<PackageIO>) :
    ;Retrieve all exported global records in packageio
    defn global-recs (io:PackageIO) :
      for e in exports(io) seq? :
        match(id(rec(e))) :
          (id:ValId) : One(rec(e))
          (id) : None()

    ;Check against previous definitions
    val errors = Vector<LoadError>()
    for io1 in packageios do :
      ;If this package previously existed
      val io0 = get?(packages, package(io1))
      match(io0:PackageIO) :
        ;Create a table to quickly lookup
        ;the new definition by id.
        val new-rec-table = to-hashtable<RecId,Rec> $
          for r in global-recs(io1) seq :
            id(r) => r

        ;Compare the old globals to the new globals
        val src = LoadedPackage(package(io1))
        for r0 in global-recs(io0) do :
          match(get?(new-rec-table, id(r0))) :
            ;Case: The global is no longer defined. That is okay.
            (_:False) : false
            ;Case: The global is defined. Ensure that it matches.
            (r1:Rec) :
              if not match?(r1, r0) :
                add(errors, ChangedGlobal(src, r0, r1))

    ;Check against previous definitions
    if empty?(errors) : LoadSuccess()
    else : LoadErrors(to-tuple(errors))          


  ;Check loading packages into environment. Return an error report
  ;indicating what will fail, or success otherwise.
  ;We assume that the packages to load have successfully passed the typechecker.
  ;This indicates two things:
  ;1. The packages are internally consistent. All imports/exports
  ;   from/to packages to be reloaded are guaranteed to be consistent by
  ;   the typechecker.
  ;2. The package imports are consistent. The typechecker imports the existing
  ;   definitions from the environment and ensures that the code is consistent
  ;   with these definitions.
  ;Therefore there is only one thing to check. Whether the new exports
  ;from the reloaded packages are consistent with the context.
  defn check-exports (ps:Tuple<PackageIO>, live-recs:Tuple<Rec>) :
    ;These are the packages to be reloaded
    val reloaded-packages = to-hashset<Symbol>(seq(package, ps))

    ;Here are the new exported entries from the reloaded packages
    val export-table = to-hashtable<RecId,Rec> $
      seq-cat(exported-entries, ps)

    ;Check whether the imported record, imported, from 'src-package'
    ;is satisfied by the reloaded-packages.
    val errors = Vector<LoadError>()
    defn check-dependency (src:DependencySource, imported:Rec) :
      val rid = id(imported)
      if reloaded-packages[package(rid)] :
        match(get?(export-table, rid)) :
          (exported:Rec) :
            if not match?(imported, exported) :
              add(errors, MismatchedDependency(src, imported, exported))
          (_:False) :
            add(errors, MissingDependency(src, imported))

    ;Check all the dependencies from existing packages
    for p in values(packages) do :
      val src = LoadedPackage(package(p))
      if affected?(p, reloaded-packages) :
        for import in imports(p) do :
          check-dependency(src, rec(import)) when not transient?(import)
    ;Check all the dependencies from the live objects
    do(check-dependency{LiveObject(), _}, live-recs)

    ;Return result
    if empty?(errors) : LoadSuccess()
    else : LoadErrors(to-tuple(errors))      

  ;Return new environment
  new DEnv :
    defmethod packageios (this) :
      for p in package-ordering seq : packages[p]
    defmethod packageio (this, name:Symbol) :
      get?(packages, name)      
    defmethod check-exports (this, packages:Tuple<PackageIO>, live-recs:Tuple<Rec>) :
      check-exports(packages, live-recs)
    defmethod check-globals (this, packages:Tuple<PackageIO>) :
      check-globals(packages)
    defmethod load (this, pkgs:Seqable<PackageIO>) :
      do(add-package, pkgs)
      ensure-consistency()

public defn package-exports (denv:DEnv, name:Symbol) :
  match(packageio(denv, name)) :
    (io:PackageIO) : PackageExports(package(io), imported-packages(io), exports(io))
    (_:False) : false

;============================================================
;======================= Utilities ==========================
;============================================================

;Utilities
defn exported-entries (p:PackageIO) :
  for e in exports(p) seq :
    val r = rec(e)
    id(r) => r

;============================================================
;===================== Printers =============================
;============================================================

defn source-str (s:DependencySource) :
  match(s) :
    (s:LoadedPackage) : "The package %~ requires" % [package(s)]
    (s:LiveObject) : "There is a live object that requires"

defmethod print (o:OutputStream, e:MissingDependency) :
  print(o, "Missing definition: %_ the following definition:" % [source-str(source(e))])
  val o2 = IndentedStream(o)
  lnprint(o2, format(expected(e)))
  
defmethod print (o:OutputStream, e:MismatchedDependency) :
  val o2 = IndentedStream(o)
  print(o, "Inconsistent definition: %_ the following definition:" % [source-str(source(e))])
  lnprint(o2, format(expected(e)))
  lnprint(o, "but it has been replaced with:")
  lnprint(o2, format(actual(e)))

defmethod print (o:OutputStream, e:ChangedGlobal) :
  val o2 = IndentedStream(o)
  print(o, "Globals are not allowed to be redefined during code update. %_ the following definition:" % [
    source-str(source(e))])
  lnprint(o2, format(expected(e)))
  lnprint(o, "but it has been replaced with:")
  lnprint(o2, format(actual(e)))