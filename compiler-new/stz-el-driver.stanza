defpackage stz/el-driver :
  import core
  import collections
  import stz/el-ir
  import stz/dl-ir
  import stz/vm-ir
  import stz/el
  import stz/el-to-vm
  import stz/dl
  import stz/vm

defstruct LoadStage :
  init?: True|False
  epackages: Tuple<EPackage>
  
defsyntax el-driver :
  import epackage from el-ir

  defproduction loadstage : LoadStage
  defrule loadstage = (load : (?eps:#epackage ...)) : LoadStage(true, to-tuple(eps))
  defrule loadstage = (update : (?eps:#epackage ...)) : LoadStage(false, to-tuple(eps))

  public defproduction prog : Tuple<LoadStage>
  defrule prog = (?ss:#loadstage ...) : to-tuple(ss) 

defn read-stages () :
  val filename = command-line-arguments()[1]
  val forms = reader/read-file(filename)
  parse-syntax[el-driver / #prog](forms)

defn main () :
  if contains?(command-line-arguments(), "-vmir") :
    val filename = command-line-arguments()[1]
    val forms = reader/read-file(filename)    
    val vmps = to-tuple(parse-syntax[vmcode / #vmpackage ...](forms))
    val vm = VirtualMachine()
    load(vm, vmps)
    do(init-package{vm, package(_)}, vmps)
    val liveset = compute-live(vm, [])
    println("Live set: %," % [liveset])
    
  else :
    ;Read in stages
    val stages = read-stages()

    ;Create virtual machine
    val vm = VirtualMachine()
    val denv = DEnv()

    for stage in stages do :
      load-into-denv() where :

        ;Begin by trying to load the descriptors into the DEnv.
        ;If successful, go on to compiling the packages.
        ;Fail otherwise.
        defn* load-into-denv () :
          val ios = map(packageio, epackages(stage))
          val live =
            if init?(stage) : compute-live(vm, seq(package, ios))
            else : compute-live(vm, [])
          match(load(denv, ios, live)) :
            (result:LoadSuccess) :
              compile-packages()
            (result:LoadErrors) :
              do(println, errors(result))
              
        defn* compile-packages () :
          ;Compile VM packages
          val vmps = for ep in epackages(stage) map :
            compile(lower(ep))

          ;Debugging
          val filename* = string-join([command-line-arguments()[1], ".vm"])
          spit(filename*, "%n" % [vmps])

          ;If initializers requested
          if init?(stage) :
            load(vm, vmps)
            initialize(vmps)
          else :
            val vmps* = map(remove-existing-globals, vmps)
            load(vm, vmps*)            

        defn remove-existing-globals (vmp:VMPackage) :
          val existing = to-intset(existing-exports(denv, packageio(vmp)))
          val globals* = to-tuple $
            for g in globals(vmp) filter :
              not existing[id(g)]
          sub-globals(vmp, globals*)

        defn* initialize (vmps:Tuple<VMPackage>) :
          for vmp in vmps do :
            init-package(vm, package(vmp))
              
main()

