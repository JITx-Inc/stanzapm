defpackage stz/repl :
  import core
  import collections
  import reader
  import parser
  import macro-utils
  import stz/utils
  import stz/il-ir
  import lang/check
  import stz/dl-ir with:
    prefix(Import) => DL
  import stz/tl-ir
  import stz/el-ir
  import stz/vm-ir
  import stz/vm
  import stz/core-macros
  import stz/input
  import stz/renamer
  import stz/resolver
  import stz/type
  import stz/tl-to-el
  import stz/dl
  import stz/el
  import stz/el-to-vm
  import stz/algorithms
  import line-noise/prompter
  import stz/pkg
  import stz/ids

;<algorithm>=================================================
;====================== Algorithms ==========================
;============================================================

Loading files:

The input is a sequence of file and package names:

  e.g. "mypackage.stanza", "support.pkg", mylib, "mypackage2.stanza"

Now load, rename, and type them and their dependencies. Grab the
dependencies from either the currently defined environment, or from a
loaded .pkg file if none exists.

Then check that their definitions can be loaded into the current
environment.

If we get to this point successfully, then everything is fine, and the
code is ready to be loaded into the virtual machine. So load it, and
run the package initializers.

;============================================================
;=================================================<algorithm>

;============================================================
;===================== REPL Language ========================
;============================================================

deftype RExp
defstruct LoadVMP <: RExp :
  inputs: Tuple<String>
with:
  printer => true
defstruct Load <: RExp :
  inputs: Tuple<String|Symbol>
with:
  printer => true
defstruct Update <: RExp
with:
  printer => true
defstruct Reload <: RExp
with:
  printer => true
defstruct Clear <: RExp
with:
  printer => true
defstruct Import <: RExp :
  import: IImport
with:
  printer => true
defstruct Inside <: RExp :
  package: Symbol|False
with:
  printer => true
defstruct Unimport <: RExp :
  package: Symbol
with:
  printer => true
defstruct Eval <: RExp :
  form
with:
  printer => true
defstruct NoOp <: RExp
with:
  printer => true

defstruct ReplSyntaxError <: Exception :
  info: FileInfo|False
  message: String
defmethod print (o:OutputStream, e:ReplSyntaxError) :
  val infostr = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [infostr, message(e)])

defsyntax repl :
  public defproduction rexp : RExp
  defrule rexp = (?x:#@rexp #E) : x

  defproduction E : False
  defrule E != (_)
  defrule E = () : false

  public defproduction @rexp : RExp
  defrule @rexp = (load ?input0:#input ?inputs:#input! ...) :
    Load(to-tuple(cons(input0, inputs)))
  defrule @rexp = (loadvm ?input0:#string ?inputs:#string! ...) :
    LoadVMP(to-tuple(cons(input0, inputs)))
  defrule @rexp = (?e:#import-clause #E) :
    Import(e)
  defrule @rexp = (inside - #E) :
    Inside(false)
  defrule @rexp = (inside ?p:#symbol) :
    Inside(p)
  defrule @rexp = (unimport ?name:#symbol) :
    Unimport(name)
  defrule @rexp = (update #E) :
    Update()
  defrule @rexp = (reload #E) :
    Reload()
  defrule @rexp = (clear #E) :
    Clear()
  defrule @rexp = (?forms ...) :
    if empty?(forms) : NoOp()
    else : Eval(forms)

  ;===== Inputs =====
  defproduction input : String|Symbol
  defrule input = (?file:#string) : file
  defrule input = (?pkg:#symbol) : pkg

  defproduction input! : String|Symbol
  defrule input! = (?i:#input) : i
  fail-if input! = () : ReplSyntaxError(closest-info(), "Input must be either a string or a symbol.")

  ;===== Imports =====
  defproduction prefix-clause! : IPrefix
  defrule prefix-clause! = (prefix => ?p:#symbol!) :
    IPrefix(false, to-string(p))
  defrule prefix-clause! = (prefix(?names:#symbol! ...) => ?p:#symbol!) :
    IPrefix(to-tuple(names), to-string(p))
  fail-if prefix-clause! = () :
    ReplSyntaxError(closest-info(), "Expected a prefix clause here.")

  defproduction prefix-clauses : Tuple<IPrefix>
  defrule prefix-clauses = (with #:! (?ps:#prefix-clause! ...)) : to-tuple(ps)
  defrule prefix-clauses = () : []

  defproduction import-clause : IImport
  defrule import-clause = (import ?package:#symbol ?ps:#prefix-clauses) :
    IImport(package, ps)

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction byte : Byte
  defrule byte = (?x) when unwrap-token(x) is Byte : unwrap-token(x)

  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

  defproduction string! : String
  defrule string! = (?x:#string) : x
  fail-if string! = () : ReplSyntaxError(closest-info(), "Expected a string here.")

  defproduction symbol! : Symbol
  defrule symbol! = (?x:#symbol) : x
  fail-if symbol! = () : ReplSyntaxError(closest-info(), "Expected a symbol here.")

  defproduction :!
  defrule :! = (?x: ~ :) : x
  fail-if :! = () : ReplSyntaxError(closest-info(), "Colon expected here.")

defn read-repl-exp (read-line:() -> List<Token>|False) -> RExp|False :
  try :
    let loop () :
      match(read-line()) :
        (forms:List) :
          match(parse-syntax[repl / #rexp](forms)) :
            (e:NoOp) : loop()
            (e) : e
        (forms:False) :
          false
  catch (e:LexerException) :
    throw(ReplErrors([e]))
  catch (e:NoMatchException) :
    throw(ReplErrors(causes(e)))

defn read-repl-exp (inputstream:InputStream) :
  defn read-input-line () : /read-line(inputstream)
  read-repl-exp(read-input-line)

defn read-repl-exp () :
  defn read-input-line () :
    read-line(LineNoisePrompter("stanza> ", "      > "))
  read-repl-exp(read-input-line)

;============================================================
;======================= Package Ordering ===================
;============================================================
;<debug>
defn initialization-order (packages:Seqable<Symbol>, denv:DEnv) -> Collection<Symbol> :
  ;Create import graph
  val import-graph = to-hashtable<Symbol, List<Symbol>> $
    for io in packageios(denv) seq :
      package(io) => to-list(imported-packages(io))

  ;Compute initialization ordering
  initialization-order(import-graph, to-tuple(packages))
;<debug>

;============================================================
;=================== Default Imports ========================
;============================================================

defn core-imports () :
  [IImport(`core), IImport(`collections)]

;============================================================
;======================= Loading ============================
;============================================================

deftype REPL
defmulti load-files (repl:REPL, inputs:Tuple<String|Symbol>) -> False
defmulti load-vmp (repl:REPL, inputs:Tuple<String>) -> False
defmulti update-files (repl:REPL) -> False
defmulti reload (repl:REPL) -> False
defmulti load-repl (repl:REPL, form) -> False
defmulti import (repl:REPL, import:IImport) -> False
defmulti unimport (repl:REPL, package:Symbol) -> False
defmulti inside (repl:REPL, package:Symbol|False) -> False
defmulti clear (repl:REPL) -> False

defn REPL () :
  ;============================================================
  ;===================== REPL State ===========================
  ;============================================================
  val vm = VirtualMachine()
  val denv = DEnv()
  val repl-env = REPLEnv()
  val file-env = FileEnv()

  ;============================================================
  ;===================== File Loading =========================
  ;============================================================
  ;Load files
  defn load-files (inputs:Tuple<String|Symbol>) :
    try :
      ;Load in packages and inputs
      val input-packages = Vector<Symbol>()
      val input-pkgs = Vector<Pkg>()
      val ipackages = Vector<IPackage>()
      val pkgloader = PkgLoader()
      for input in inputs do :
        switch(category(input)) :
          `package :
            val pkg-name = input as Symbol
            if packageio(denv,pkg-name) is-not False :
              add(input-packages, pkg-name)
            else :
              val pkg = load-pkg(pkgloader, pkg-name)
              add(input-packages, name(pkg))
              add(input-pkgs, pkg)
          `stanza-file :
            val ipkgs = read-ipackages(input as String)
            add-all(input-packages, seq(name,ipkgs))
            add-all(ipackages, ipkgs)
          `pkg-file :
            val pkg = load-pkg(pkgloader, input as String)
            add(input-packages, name(pkg))
            add(input-pkgs, pkg)
      ensure-no-duplicate-packages!(input-packages)
            
      ;Compile all to EL packages
      val [epackages, all-pkgs] = compile-to-el(ipackages, pkgloader)

      ;Ensure that packageio definitions for packages are consistent.
      load-into-denv(to-tuple(cat(epackages, all-pkgs)))

      ;Compile to vmpackages
      val vmpackages = compile-vmpackages(cat(epackages,all-pkgs))

      ;Load packages into virtual machine
      load(vm, vmpackages, false)

      ;Run package in initialization order
      run-in-init-order(vmpackages, input-packages)

    ;Report the following exceptions to the REPL
    catch (e:IOException) : throw(ReplErrors([e]))
    catch (e:LexerException) : throw(ReplErrors([e]))
    catch (e:CheckErrors) : throw(ReplErrors([e]))
    catch (e:PkgException) : throw(ReplErrors([e]))

  ;DEBUGGING
;  defn load-vmps (inputs:Tuple<String>) :
;    val vmpkgs = map(read-vm-package, inputs)
;    load(denv, seq(packageio, vmpkgs))
;    load(vm, vmpkgs, false)
;    run-vm!(seq(package, vmpkgs))
;
;  ;Clear all repl definitions
;  defn clear-repl () :
;    ;Compute what live repl records are required
;    val live = compute-live(vm, repl-packages(repl-env))
;    val empty-ios = to-tuple $
;      for p in repl-packages(repl-env) seq :
;        PackageIO(p, [], [], [])
;    match(check-exports(denv, empty-ios, live)) :
;      (e:LoadErrors) : throw(ReplErrors(errors(e)))
;      (e:LoadSuccess) : false
;    ;Now clear the repl packages
;    val empty-vmpkgs = for io in empty-ios map :
;      VMPackage(io, false, [], [], [], [], [], [], [], [])
;    load(denv, empty-ios)
;    load(vm, empty-vmpkgs, false)
;    clear(repl-env)
;
;  ;update changed files
;  defn changed-tprog (return:TProg|False -> ?, live:Tuple<Rec>) :
;    ;Compute the changed files
;    val changed-files = changed-files(file-env)
;    if empty?(changed-files) :
;      return(false)
;    else :
;      ;Track the files to reload.
;      ;Initialize them with the set of all changed files.
;      val reload-files = to-hashset<String>(changed-files)
;      let loop () :
;        val done? = label<True|False> break :
;          let :
;            val filenames = to-tuple(reload-files)
;            val expanded = map({macroexpand! $ read! $ _}, filenames)
;            val [input, file-pkgs] = to-ipackages! $ expanded
;            check-load-errors!(check-types-exist(input, live))
;            val typed = type! $ resolve! $ rename! $ input
;            check-load-errors!(check-load(typed, live))
;            return(typed)
;            save-to-file-env!(file-pkgs)
;            true
;          where :
;            defn check-load-errors! (e:LoadResult) :
;              match(e:LoadErrors) :
;                ;Some errors can be recovered from by including their source
;                ;files during the recompilation. Other errors are unrecoverable.
;                ;Classify these errors now.
;                val recovery-actions = Vector<(() -> ?)>()
;                val unrecoverable-errors = Vector<LoadError>()
;                for e in errors(e) do :
;                  match(source(e)) :
;                    (src:LoadedPackage) :
;                      if source-file?(file-env, package(src)) :
;                        add(recovery-actions, fn () :
;                          add(reload-files, source-file(file-env, package(src))))
;                      else : add(unrecoverable-errors, e)
;                    (src:LiveObject) : add(unrecoverable-errors, e)
;                ;If there are unrecoverable errors, then throw the error
;                if not empty?(unrecoverable-errors) :
;                  throw(ReplErrors(unrecoverable-errors))
;                ;Otherwise run the recovery actions and try again
;                for f in recovery-actions do : f()
;                break(false)
;        loop() when not done?
;
;  ;Update files
;  defn update-files () :
;    val live = compute-live(vm, [])
;    within typed = changed-tprog(live) :
;      match(typed:TProg) :
;        check-globals!(typed)
;        update-vm!(typed)
;      else :
;        throw $ ReplErrors $ [NoChangedFiles()]
;
;  ;Reload
;  defn reload () :
;    within typed = changed-tprog([]) :
;      match(typed:TProg) :
;        load-vm!(typed)
;
;    ;Clear all REPL definitions
;    val empty-ios = to-tuple $
;      for p in repl-packages(repl-env) seq :
;        PackageIO(p, [], [], [])
;    val empty-vmpkgs = for io in empty-ios map :
;      VMPackage(io, false, [], [], [], [], [], [], [], [])
;    load(denv, empty-ios)
;    load(vm, empty-vmpkgs, false)
;    clear(repl-env)
;
;    ;Clear all definitions and rerun
;    clear-globals(vm)
;    run-vm!(loaded-packages())
;
;  ;Load from repl
;  defn load-repl (form) :
;    val typed = type! $ resolve-repl! $ rename! $ to-repl-ipackage! $ macroexpand! $ form
;    register(repl-env, packageio(packages(typed)[0]))
;    load-vm!(typed)
;    run-vm!([name(packages(typed)[0])])

  ;============================================================
  ;==================== Stages of Loading =====================
  ;============================================================
  defn read-ipackages (filename:String) -> Tuple<IPackage> :
    val forms = read-file(filename)
    val expanded = try : cons(`$begin, parse-syntax[core / #exps!](forms))
                   catch (e:NoMatchException) : throw(ReplErrors(causes(e)))
                   catch (e:Exception) : throw(ReplErrors([e]))
    val core-imports = [IImport(`core), IImport(`collections)]
    to-ipackages(expanded, core-imports)

  defn ensure-no-duplicate-packages! (packages:Seqable<Symbol>) :
    val pset = HashSet<Symbol>()
    for p in packages do :
      if not add(pset,p) :
        throw(ReplErrors([DuplicatePackage(p)]))

  defn compile-to-el (ipackages:Collection<IPackage>, pkgloader:PkgLoader) :
    ;First rename the binders
    val renamed = match(rename-il(to-tuple(ipackages))) :
      (renamed:Tuple<IPackage>) : renamed
      (e:RenameErrors) : throw(ReplErrors(errors(e)))
      
    ;Create the table holding the package exports
    ;The exports have their identifiers renamed so that they do not conflict
    ;with fresh-id().
    val package-exports-table = HashTable<Symbol,PackageExports|False>()
    defn package-exports (name:Symbol) :
      within update?(package-exports-table, name) :
        label<PackageExports|False> return :
          defn to-package-exports (io:PackageIO) -> PackageExports :
            defn rename-id (e:Export) : sub-n(e, fresh-id())
            val pexs = /to-package-exports(io)
            sub-exports(pexs, map(rename-id, exports(pexs)))

          ;First look in DEnv
          match(packageio(denv,name)) :
            (io:PackageIO) : return(to-package-exports(io))
            (_:False) : false            
            
          ;Then try loading the pkg
          try :
            val pkg = load-pkg(pkgloader, name)
            return(to-package-exports(packageio(pkg)))
          catch (e:NoPackageException) :
            false

    ;Create the resolution and typing environment
    val env = new stz/resolver/Env & stz/type/Env :
      defmethod stz/resolver/exports (this, package:Symbol) :
        package-exports(package)
      defmethod stz/type/exports (this, package:Symbol) :
        package-exports(package) as PackageExports    

    ;Resolve the binders
    val resolved = match(resolve-il(renamed, env, false)) :
      (e:ResolveErrors) : throw(ReplErrors(errors(e)))
      (e:Tuple<IPackage>) : e

    ;Retrieve all dependencies and pkgs
    val already-loaded = cat(seq(name,resolved), seq(package,packageios(denv)))
    val all-pkgs = all-pkgs-and-dependencies(pkgloader, already-loaded)

    ;Typecheck the program
    val typed = match(type-program(resolved, env)) :
      (e:TProg) : e
      (e:TypeErrors) : throw(ReplErrors(messages(e)))

    ;Compile to EL
    [to-el(typed, false), all-pkgs]

  defn load-into-denv (pkgs:Collection<EPackage|Pkg>) :
    val live-recs = compute-live(vm, seq(name,pkgs))
    val result = load(denv, to-collection(seq{packageio,pkgs}), live-recs)
    match(result:LoadErrors) : throw(ReplErrors(errors(result)))

  defn compile-vmpackages (packages:Seqable<EPackage|Pkg>) -> Tuple<VMPackage> :
    to-tuple $ for p in packages seq :
      match(p) :
        (p:EPackage) : compile(lower-unoptimized(p))
        (p:StdPkg) : vmp(p)

  defn run-in-init-order (vmpackages:Seqable<VMPackage>, input:Collection<Symbol>) :
    val load-set = to-hashset<Symbol>(cat(seq(name,vmpackages), input))
    val ordering = initialization-order(package-dependency-graph(denv), input, {not load-set[_]})
    do(init-package{vm, _}, ordering)

;  ;============================================================
;  ;====================== Loaded Packages =====================
;  ;============================================================
;  defn loaded-packages () :
;    for p in packageios(denv) seq? :
;      if repl-package?(repl-env, package(p)) : None()
;      else : One(package(p))
;
;  defn loaded-package? (name:Symbol) :
;    packageio(denv, name) is-not False
;
;  ;============================================================
;  ;================== Stages of Loading =======================
;  ;============================================================
;  ;Read from file
;  defn read! (filename:String) -> FileForm :
;    try :
;      val timestamp = time-modified(filename)
;      FileForm(filename, timestamp, read-file(filename))
;    catch (e:IOException) : throw(ReplErrors([e]))
;    catch (e:LexerException) : throw(ReplErrors([e]))
;
;  ;Macroexpansion
;  defn macroexpand! (x) -> ? :
;    match(x:FileForm) :
;      sub-form(x, macroexpand!(form(x)))
;    else :
;      try : cons(`$begin, parse-syntax[core / #exps!](x))
;      catch (e:NoMatchException) : throw(ReplErrors(causes(e)))
;      catch (e:Exception) : throw(ReplErrors([e]))
;
;  ;Conversion to IL IR
;  defn to-ipackages! (expanded:Tuple<FileForm>) -> [Tuple<IPackage>, Tuple<FileAssoc>] :
;    val check-errors = Vector<CheckError>()
;    val ipackages = Vector<IPackage>()
;    val file-assocs = Vector<FileAssoc>()
;    for e in expanded do :
;      try :
;        val pkgs = to-ipackages(form(e), core-imports())
;        add(file-assocs, FileAssoc(filename(e), timestamp(e), map(name,pkgs)))
;        add-all(ipackages, pkgs)
;      catch (e:CheckErrors) :
;        add-all(check-errors, errors(e))
;    throw(ReplErrors(check-errors)) when not empty?(check-errors)
;    [to-tuple(ipackages), to-tuple(file-assocs)]
;  defn to-repl-ipackage! (expanded) -> IPackage :
;    try : ReplPackage(repl-env, to-il(expanded))
;    catch (e:CheckErrors) : throw(ReplErrors(errors(e)))
;
;  ;Renaming
;  defn rename! (ipkgs:Tuple<IPackage>) :
;    match(rename-il(ipkgs)) :
;      (renamed:Tuple<IPackage>) : renamed
;      (e:RenameErrors) : throw(ReplErrors(errors(e)))
;  defn rename! (ipkg:IPackage) :
;    rename!([ipkg])[0]
;
;  ;Renaming and Resolving environment
;  defn pkg-env (pkgloader:PkgLoader) :
;    new stz/resolver/Env & stz/type/Env :
;      defmethod stz/resolver/exports (this, package:Symbol) :
;        match(package-exports(denv, package)) :
;          (exs:PackageExports) : exs
;          (_:False) : package-exports(pkgloader, package)
;      defmethod stz/type/exports (this, package:Symbol) :
;        stz/resolver/exports(this,package) as PackageExports
;
;  ;Resolve
;  defn resolve! (pkgloader:PkgLoader, ipkgs:Tuple<IPackage>, priority:False|(Symbol -> Int)) :
;    try :
;      match(resolve-il(ipkgs, pkg-env(pkgloader), priority)) :
;        (e:ResolveErrors) : throw(ReplErrors(errors(e)))
;        (e:Tuple<IPackage>) : e
;    catch (e:PkgException) :
;      throw(ReplErrors([e]))
;  defn resolve! (pkgloader:PkgLoader, ipkgs:Tuple<IPackage>) :
;    resolve!(pkgloader, ipkgs, false)
;;  defn resolve-repl! (ipkg:IPackage) :
;;    resolve!([ipkg], package-priority{repl-env, name(ipkg), _})
;;
;  ;Type Checking
;  defn type! (pkgloader:PkgLoader, ipkgs:Tuple<IPackage>) :
;    match(type-program(ipkgs, pkg-env(pkgloader))) :
;      (e:TProg) : e
;      (e:TypeErrors) : throw(ReplErrors(messages(e)))
;
;;  ;Check whether any globals have been redefined to be a different type
;;  defn check-globals! (tprog:TProg) :
;;    val ios = map(packageio, packages(tprog))
;;    match(check-globals(denv, ios)) :
;;      (result:LoadErrors) : throw(ReplErrors(errors(result)))
;;      (result:LoadSuccess) : false
;;
;  ;Check packages can be loaded into existing environment
;  defn check-load (ios:Tuple<PackageIO>, live:Tuple<Rec>) :
;    check-exports(denv, ios, live)
;  defn check-load! (ios:Tuple<PackageIO>, live:Tuple<Rec>) :
;    match(check-load(ios, live)) :
;      (result:LoadErrors) : throw(ReplErrors(errors(result)))
;      (result:LoadSuccess) : false
;
;  ;Save associations to file environment
;  defn save-to-file-env! (file-assocs:Tuple<FileAssoc>) :
;    do(register{file-env, _}, file-assocs)
;
;  ;Conversion to VMPackages
;  defn to-vmpackages! (tprog:TProg, pkgloader:PkgLoader, transient?:True|False) -> Tuple<VMPackage> :
;    val epkgs = to-el(tprog, transient?)
;    to-tuple(cat(lowered-pkgs, external-pkgs)) where :
;      val lowered-pkgs = seq(compile{lower-unoptimized(_)}, epkgs)
;      val external-pkgs = seq(vmp{_ as StdPkg}, pkgs(pkgloader))
;
;  ;Compute input ordering based upon order of inputs
;  defn input-ordering (inputs:Tuple<String|Symbol>, file-mapping:Seqable<KeyValue<String,Symbol>>) :
;    val mapping-table = to-hashtable<String,Symbol>(file-mapping)
;    to-tuple $ for input in inputs seq-cat :
;      match(input) :
;        (input:String) :
;          if key?(mapping-table, input) : [mapping-table[input]]
;          else : packages(file-env, input)
;        (input:Symbol) :
;          [input]
;          
;  ;Order packages by dependency
;  defn init-order (vmps:Seqable<VMPackage>, input-ordering:Tuple<Symbol>) :
;    val import-graph = to-hashtable<Symbol,List<Symbol>> $ for p in packageios(denv) seq :
;      package(p) => to-list(imported-packages(p))
;
;    ;val import-graph = to-hashtable<Symbol,List<Symbol>> $ for p in vmps seq :
;    ;  val io = packageio(p)
;    ;  package(io) => to-list(imported-packages(io))
;    val vmp-table = to-hashtable(package, vmps)
;    val ordering = initialization-order(import-graph, input-ordering, {not key?(vmp-table, _)})
;    to-tuple $ for p in ordering seq : vmp-table[p]    
;
;  ;Load into DEnv
;  defn load-in-denv (vmpkgs:Collection<VMPackage>) :
;    load(denv, seq(packageio, vmpkgs))
;
;  ;Load into Virtual Machine
;  defn load-and-run! (vmpkgs:Collection<VMPackage>) :
;    load(denv, seq(packageio, vmpkgs))
;    load(vm, vmpkgs, false)  
;    for p in vmpkgs do : init-package(vm, package(p))
;
;  ;Run the given packages in the virtual machine
;;  defn run-vm! (packages:Seqable<Symbol>) :
;;    for p in initialization-order(packages, denv) do :
;;      init-package(vm, p)
;
;;  ;Load into virtual machine without initialization
;;  defn update-vm! (tprog:TProg) :
;;    val epkgs = to-el(tprog, true)
;;    val vmpkgs = map(compile{lower-unoptimized(_)}, epkgs)
;;    load(denv, seq(packageio, vmpkgs))
;;    load(vm, vmpkgs, true)
;;

  ;============================================================
  ;===================== REPL Structure =======================
  ;============================================================
  new REPL :
    defmethod load-files (this, inputs:Tuple<String|Symbol>) :
      load-files(inputs)
;    defmethod load-vmp (this, inputs:Tuple<String>) :
;      load-vmps(inputs)
;    defmethod update-files (this) :
;      update-files()
;    defmethod load-repl (this, form) :
;      load-repl(form)
;    defmethod clear (this) :
;      clear-repl()
;    defmethod reload (this) :
;      reload()
;    defmethod import (this, import:IImport) :
;      if not loaded-package?(package(import)) :
;        throw $ ReplErrors $ [PackageNotLoaded(package(import))]
;      else : /import(repl-env, import)
;    defmethod unimport (this, package:Symbol) :
;      if not unimport(repl-env, package) :
;        throw $ ReplErrors $ [PackageNotImported(package)]
;    defmethod inside (this, package:Symbol) :
;      if not loaded-package?(package) :
;        throw $ ReplErrors $ [PackageNotLoaded(package)]
;      else : inside(repl-env, package)
;    defmethod inside (this, package:False) :
;      if current-inside(repl-env) is False :
;        throw $ ReplErrors $ [NotInsidePackage()]
;      inside(repl-env, false)

defstruct FileForm :
  filename: String
  timestamp: Long
  form with: (updater => sub-form)

;============================================================
;=================== File Environment =======================
;============================================================

deftype FileEnv
defmulti register (e:FileEnv, assoc:FileAssoc) -> False
defmulti changed-files (e:FileEnv) -> Tuple<String>
defmulti source-file (e:FileEnv, package:Symbol) -> String
defmulti source-file? (e:FileEnv, package:Symbol) -> True|False
defmulti packages (e:FileEnv, filename:String) -> Tuple<Symbol>

defstruct FileAssoc :
  filename: String
  timestamp: Long
  packages: Tuple<Symbol>

defn FileEnv () :
  ;Track which source file each package came from
  val source-file-table = HashTable<Symbol,String>()
  val assoc-table = HashTable<String,FileAssoc>()

  new FileEnv :
    defmethod register (this, assoc:FileAssoc) :
      for pkg in packages(assoc) do :
        source-file-table[pkg] = filename(assoc)
      assoc-table[filename(assoc)] = assoc
    defmethod packages (this, filename:String) :
      packages(assoc-table[filename])
    defmethod changed-files (this) :
      to-tuple $ for assoc in values(assoc-table) seq? :
        try :
          val file = filename(assoc)
          val old-timestamp = timestamp(assoc)
          val new-timestamp = time-modified(file)
          if new-timestamp != old-timestamp : One(file)
          else : None()
        catch (e:FileStatException) :
          None()
    defmethod source-file (this, package:Symbol) :
      source-file-table[package]
    defmethod source-file? (this, package:Symbol) :
      key?(source-file-table, package)

;============================================================
;=================== REPL User Environment ==================
;============================================================

deftype REPLEnv

;For registering successfully loaded packages
defmulti register (e:REPLEnv, packageio:PackageIO) -> False

;For import/unimport commands
defmulti import (e:REPLEnv, import:IImport) -> False
defmulti unimport (e:REPLEnv, package:Symbol) -> True|False

;For inside command
defmulti inside (e:REPLEnv, package:Symbol|False) -> False
defmulti current-inside (e:REPLEnv) -> Symbol|False

;For resolution
defmulti package-priority (e:REPLEnv, self:Symbol, package:Symbol) -> Int

;For constructing the IPackage
defmulti ReplPackage (e:REPLEnv, exp:IExp) -> IPackage

;List names of all repl packages
defmulti repl-packages (e:REPLEnv) -> Seqable<Symbol>
defmulti repl-package? (e:REPLEnv, name:Symbol) -> True|False

;Clear repl environment
defmulti clear (e:REPLEnv) -> False

defn REPLEnv () :
  ;Previous repl packages
  val previous-packages = Vector<PackageIO>()
  val package-index = HashTable<Symbol,Int>()
  ;Current desired imports
  val imports = HashTable<Symbol, IImport>()
  ;Currently inside package
  var inside-package:Symbol|False = false

  ;Initialize imports
  defn reset () :
    clear(previous-packages)
    clear(package-index)
    clear(imports)
    inside-package = false
    for i in core-imports() do :
      imports[package(i)] = i
  reset()

  ;Construct IPackage
  defn make-repl-package (exp:IExp) :
    ;First ensure legitimacy
    ensure-repl-expression(exp)

    ;Next create import list
    val package-imports = Vector<IImport>()
    ;Import all previous repl packages
    for p in previous-packages do :
      add(package-imports, IImport(package(p), [], false, true))
    ;Import all current imports
    for i in values(imports) do :
      if package(i) != inside-package :
        add(package-imports, i)
    ;Import the current 'inside' package
    match(inside-package:Symbol) :
      add(package-imports, IImport(inside-package, [], false, true))

    ;Create IPackage
    IPackage(gensym(`repl), to-tuple(package-imports), List(exp), info(exp))

  ;Resolution priority of IPackage
  defn package-priority (self:Symbol, p:Symbol) -> Int :
    if p == inside-package : 1
    else if p == self : INT-MAX
    else if key?(package-index, p) : package-index[p] + 2
    else : 0

  ;Construct environment object
  new REPLEnv :
    defmethod import (this, import:IImport) :
      imports[package(import)] = import
    defmethod unimport (this, package:Symbol) -> True|False :
      remove(imports, package)
    defmethod inside (this, package:Symbol|False) :
      inside-package = package
    defmethod current-inside (this) :
      inside-package
    defmethod register (this, packageio:PackageIO) :
      add(previous-packages, packageio)
      package-index[package(packageio)] = length(previous-packages) - 1
    defmethod package-priority (this, self:Symbol, package:Symbol) -> Int :
      package-priority(self, package)
    defmethod ReplPackage (this, exp:IExp) :
      make-repl-package(exp)
    defmethod repl-packages (this) :
      seq(package, previous-packages)
    defmethod repl-package? (this, name:Symbol) :
      key?(package-index, name)
    defmethod clear (this) :
      reset()

defn ensure-repl-expression (expression:IExp) :
  ;Detect illegal expressions
  val errors = Vector<Exception>()
  defn not-allowed! (e:IExp) :
    val type-str = match(e) :
      (e:IDefPackage) : "defpackage"
      (e:IDefType) : "deftype"
      (e:IDefmulti) : "defmulti"
      (e:IDefmethod) : "defmethod"
      (e:ILSDefType) : "lostanza deftype"
      (e:ILSDefmethod) : "lostanza defmethod"
      (e:ILSExternFn) : "externfn"
    add(errors, InvalidExp(type-str))

  ;Sweep through expressions and detect invalid expressions
  let loop (e:IExp = expression) :
    match(e) :
      (e:IBegin) : do(loop, exps(e))
      (e:IVisibility) : loop(exp(e))
      (e:IDefPackage|IDefType|IDefmulti|IDefmethod|
         ILSDefType|ILSDefmethod|ILSExternFn) : not-allowed!(e)
      (e) : false

  ;Throw errors if there are any
  throw(ReplErrors(errors)) when not empty?(errors)

;============================================================
;==================== Categorization ========================
;============================================================

;Classifies the incoming files into four types:
;  myfile.stanza
;  myfile.pkg
;  mypackage
;
;Returns either:
;  `package
;  `stanza-file
;  `pkg-file

defn category (name:String|Symbol) -> Symbol :
  match(name) :
    (name:Symbol) :
      `package
    (name:String) :
      switch suffix?{name, _} :
        ".stanza" : `stanza-file
        ".pkg" : `pkg-file
        else : throw(ReplErrors([InvalidExtension(name)]))

;============================================================
;======================== Errors ============================
;============================================================

defstruct ReplErrors <: Exception :
  messages: Collection

defn DuplicatePackage (name:Symbol) :
  Exception $ "Attempt to load package %~ multiple times." % [name]

defn PackageNotLoaded (package:Symbol) :
  Exception $ "Could not import package %~. Package has not been loaded." % [package]

defn PackageNotImported (package:Symbol) :
  Exception $ "Could not unimport package %~. Package is not yet imported." % [package]

;;An error when the loaded package already exists.
;public defstruct PackageAlreadyLoadedException <: PkgException :
;  filename: String|False with: (default => false)
;  name: Symbol
;defmethod print (o:OutputStream, e:PackageAlreadyLoadedException) :
;  match(filename(e):String) :
;    print(o, "Error when loading %_, package %_ has already been loaded." % [filename(e), name(e)])
;  else :
;    print(o, "Package %_ has already been loaded." % [name(e)])

defn NotInsidePackage () :
  Exception $ "Not currently inside any package."

defn NoChangedFiles () :
  Exception $ "No changes detected in any loaded file."

defn InvalidExtension (file:String) :
  Exception $ "File %~ does not have a valid Stanza file extension." % [file]

defn InvalidExp (exp-type:String) :
  Exception $ "The interactive REPL does not support %_ statements." % [exp-type]

defn LoadMultipleScripts (script:String) :
  Exception $ "Invalid attempt to load script %~ alongside other files. Scripts must be loaded by themselves." % [script]

;============================================================
;======================== REPL Loop =========================
;============================================================

defn script? (exp:Load) -> String|False :
  defn script? (s:String|Symbol) :
    match(s:String) : suffix?(s, ".repl")
  val s = find(script?, inputs(exp))
  match(s:String) :
    if length(inputs(exp)) > 1 :
      throw(ReplErrors([LoadMultipleScripts(s)]))
    s

defn eval-exp (repl:REPL, exp:RExp) :
  match(exp) :
    (exp:Load) :
      match(script?(exp)) :
        (file:String) : run-script(repl, file)
        (_:False) : load-files(repl, inputs(exp))
    (exp:LoadVMP) : load-vmp(repl, inputs(exp))
    (exp:Eval) : load-repl(repl, form(exp))
    (exp:Import) : import(repl, import(exp))
    (exp:Unimport) : unimport(repl, package(exp))
    (exp:Inside) : inside(repl, package(exp))
    (exp:Update) : update-files(repl)
    (exp:Reload) : reload(repl)
    (exp:Clear) : clear(repl)

defn run-script (repl:REPL, s:String) :
  try :
    val file = FileInputStream(s)
    try :
      let loop () :
        val exp = read-repl-exp(file)
        match(exp:RExp) :
          eval-exp(repl, exp)
          loop()
    finally :
      close(file)
  catch (e:IOException) :
    throw(ReplErrors([e]))

public defn repl () :
  val repl = REPL()
  let loop () :
    val exp = read-repl-exp()
    match(exp:RExp) :
      try : eval-exp(repl, exp)
      catch (e:ReplErrors) : do(println, messages(e))
      loop()