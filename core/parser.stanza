defpackage parser :
   import core
   import collections
   import macro-utils
   import stz/algorithms

;============================================================
;==================== Parse Structure =======================
;============================================================

public defstruct DefSyntaxRule :
   name
   exps: List<ExpRule>

public deftype ExpRule
public defstruct StanzaExpressionRule <: ExpRule :
   form
public defstruct ImportRule <: ExpRule :
   names: List
   package
public defstruct DefProductionRule <: ExpRule :
   name
   type
   public?: True|False
public defstruct DefActionRule <: ExpRule :
   production
   pattern
   guard: Maybe
   body
public defstruct DefNotRule <: ExpRule :
   production
   pattern
   guard: Maybe
public defstruct DefFailRule <: ExpRule :
   production
   pattern
   guard: Maybe
   body
public defstruct DefInlineRule <: ExpRule :
   production
   inlined-production

defmethod print (o:OutputStream, r:DefSyntaxRule) :
   print(o, "($defsyntax %_ %@)" % [name(r), exps(r)])

defmethod print (o:OutputStream, r:ExpRule) :
   print{o, _} $ match(r) :
      (r:StanzaExpressionRule) : "($expression %_)" % [form(r)]
      (r:ImportRule) : "($import %@ %_)" % [names(r), package(r)]
      (r:DefProductionRule) : "($production %_ %_ %_)" % [name(r), type(r), public?(r)]
      (r:DefActionRule) : "($action %_ %_ %_ %_)" % [production(r), pattern(r), guard(r), body(r)]
      (r:DefNotRule) : "($not %_ %_ %_)" % [production(r), pattern(r), guard(r)]
      (r:DefFailRule) : "($fail %_ %_ %_ %_)" % [production(r), pattern(r), guard(r), body(r)]
      (r:DefInlineRule) : "($inline %_ %_)" % [production(r), inlined-production]

;============================================================
;==================== Compilation ===========================
;============================================================

deftype SyntaxProperties
defmulti name (p:SyntaxProperties) -> Symbol|Token
defmulti base (p:SyntaxProperties, prod:Symbol|Token) -> Symbol|Token
defmulti imports (p:SyntaxProperties) -> List<ImportRule>
defmulti stanza-expressions (p:SyntaxProperties) -> List<StanzaExpressionRule>
defmulti productions (p:SyntaxProperties) -> List<DefProductionRule>
defmulti rules (p:SyntaxProperties) -> List<DefActionRule|DefNotRule|DefFailRule|DefInlineRule>

defn analyze (r:DefSyntaxRule) -> SyntaxProperties :
   ;Categorize expressions
   val imports = {to-list(_) as List<ImportRule>} $
      filter({_ is ImportRule}, exps(r))
   val productions = {to-list(_) as List<DefProductionRule>} $
      filter({_ is DefProductionRule}, exps(r))
   val stanza-expressions = {to-list(_) as List<StanzaExpressionRule>} $
      filter({_ is StanzaExpressionRule}, exps(r))
   val rules = {to-list(_) as List<DefActionRule|DefNotRule|DefFailRule|DefInlineRule>} $
      filter({_ is DefActionRule|DefNotRule|DefFailRule|DefInlineRule}, exps(r))

   ;Discover all productions and check for duplicates
   val all-productions = HashTable<Symbol,True>()
   val all-names = seq{unwrap-token, _} $ cat(
      seq(name, productions)
      seq-cat(names, imports))
   for name in all-names do :   
      if key?(all-productions, name) :
         throw(PatternException("Duplicate definition of production %_." % [name]))
      all-productions[name] = true
         
   defn ensure-declared-pattern (name) :
      if not key?(all-productions, unwrap-token(name)) :
         throw $ PatternException $
            "Could not resolve production %_." % [name]

   ;Ensure parsable
   defn ensure-parsable (pat) :
      parse-pattern(unwrap-token(pat))

   ;Pattern prechecks
   for rule in rules do :
      ;Verify that production exists
      ensure-declared-pattern(production(rule))
         
      match(rule) :            
         (rule:DefActionRule) :
            val p = parse-pattern(pattern(rule))
            ensure-wellformed-binders(p)
            ensure-resolvable-productions(p, all-productions)
         (rule:DefNotRule) :
            val p = parse-pattern(pattern(rule))
            ensure-resolvable-productions(p, all-productions)
         (rule:DefFailRule) :
            val p = parse-pattern(pattern(rule))
            ensure-wellformed-binders(p)
            ensure-resolvable-productions(p, all-productions)
         (rule:DefInlineRule) :
            val name = subsymbol(inlined-production(rule), 1)
            ensure-declared-pattern(name)   

   ;Package
   val package-table = HashTable<Symbol,Symbol|Token>()
   for import in imports do :
      val p = package(import)
      do({package-table[unwrap-token(_)] = p}, names(import))
   for p in productions do :
      package-table[unwrap-token(name(p))] = name(r)

   ;Return new properties
   new SyntaxProperties :
      defmethod name (this) : name(r)
      defmethod base (this, prod:Symbol|Token) : package-table[unwrap-token(prod)]
      defmethod stanza-expressions (this) : stanza-expressions
      defmethod imports (this) : imports
      defmethod productions (this) : productions
      defmethod rules (this) : rules

public defn compile (syntax-rule:DefSyntaxRule) :
   val props = analyze(syntax-rule)

   ;Compile a pattern
   defn compile-pattern (pattern, guard:Maybe) :
      var form = substitute(`(parse-pattern(`pat)), [
         `pat => pattern])
      if not empty?(guard) :
         form = substitute(`(Guard(guard, pat)), [
            `guard => compile-guard(props, pattern, value!(guard))
            `pat => form])
      form

   ;Compile rules
   defn compile (r:DefActionRule) :
      substitute(`(DefRule(`name, Action(action, pat))), [
         `name => production(r)
         `action => compile-action(props, production(r), pattern(r), body(r))
         `pat => compile-pattern(pattern(r), guard(r))])
   defn compile (r:DefNotRule) :
      substitute(`(DefRule(`name, NotPat(pat))), [
         `name => production(r)
         `pat => compile-pattern(pattern(r), guard(r))])
   defn compile (r:DefFailRule) :
      substitute(`(DefRule(`name, FailPat(action, pat))), [
         `name => production(r)
         `action => compile-fail(props, pattern(r), body(r))
         `pat => compile-pattern(pattern(r), guard(r))])
   defn compile (r:DefInlineRule) :
      substitute(`(DefRule(`name, Inlined(`iname))), [
         `name => production(r)
         `iname => subsymbol(inlined-production(r), 1)])

   ;Compile productions
   defn compile (r:DefProductionRule) :
      substitute(`(DefProduction(`name, public?)), [
         `name => name(r)
         `public? => public?(r)])

   ;Compile imports
   defn compile (r:ImportRule) :
      substitute(`(DefImport(`names, `package)), [
         `names => names(r)
         `package => package(r)])

   ;Compile type-cast-functions
   defn compile-imported-production-type-cast-function (r:ImportRule) :
      for prod in names(r) map :
         substitute(`(public defn name (x) : imported-name(x)), [
            `name => production-type-cast-function(name(props), prod)
            `imported-name => production-type-cast-function(package(r), prod)])   
   defn compile-production-type-cast-function (r:DefProductionRule) :
      substitute(`(public?{public}{} defn name (x) -> (() -> type) : x), [
         `public? => choice(public?(r))
         `name => production-type-cast-function(name(props), name(r))
         `type => type(r)])
   defn compile-return-type-cast-function (r:DefProductionRule) :
      substitute(`(public?{public}{} defn name (x:type) : x), [
         `public? => choice(public?(r))
         `name => return-type-cast-function(name(props), name(r))
         `type => type(r)])

   ;Compile package
   defn compile-all (r:DefSyntaxRule) :
      val template = `((
         imported-production-type-cast-functions
         production-type-cast-functions
         return-type-cast-functions
         let :
            stanza-expressions
            register-syntax-package(SyntaxPackage(
               `name
               to-list([imports])
               to-list([prods])
               to-list([rules])))))
      val bindings = [
         `imported-production-type-cast-functions => map(compile-imported-production-type-cast-function, imports(props))
         `production-type-cast-functions => map(compile-production-type-cast-function, productions(props))
         `return-type-cast-functions => map(compile-return-type-cast-function, productions(props))
         `stanza-expressions => stanza-expressions(props)
         `name => name(r)
         `imports => splice(map(compile, imports(props)))
         `prods => splice(map(compile, productions(props)))
         `rules => splice(map(compile, rules(props)))]
      val imports = deep-prefix(`parser/, `(
         parse-pattern Guard DefRule FailPat Action NotPat FailPat DefProduction DefImport Inlined
         SyntaxPackage register-syntax-package))
      fill-template(template, append-all([bindings, imports]))

   ;Driver
   compile-all(syntax-rule)


;============================================================
;================ Compilation Utilities =====================
;============================================================

defn append-all<?T> (xss:Collection<Collection<?T>>) :
   new Collection<T> :
      defmethod to-seq (this) : cat-all(xss)

defn deep-prefix (prefix:Symbol, names:List<Symbol>) :
   for n in names map :
      n => deep(symbol-join([prefix n]))

defn production-type-cast-function (base, prod) :
   to-symbol("%_-%_ production-type" % [base, prod])   

defn return-type-cast-function (base, prod) :
   to-symbol("%_-%_ return-type" % [base, prod])   

defn compile-bindings (base, bindings:List<Binding>, body, ret-type:Maybe) :
   val template = `(
      fn (#bindings) ret{-> R}{} :
         defn closest-info () : parser/info(#bindings)
         defn closest-info (form) : parser/info(#bindings, form)
         bindings{
            val #x = parser/get(#bindings, i)
            val x = cast-x()
         }
         body)
   substitute(template, [
      `#bindings => gensym(`bindings)
      `bindings => nested $
         for binding in bindings map :
            val #x = gensym(name(binding))
            [`#x => #x
             `i => index(binding)
             `x => name(binding)
             `cast-x => compile-binding-type(base, type(binding), #x)]
      `ret => choice(not empty?(ret-type))
      `R => value?(ret-type)
      `body => body])

defn compile-binding-type (base, t:BindingType, temp:Symbol) :
   defn loop (t:BindingType) :
      match(t) :
         (t:TerminalBinding) :
            substitute(`(temp as () -> T), [
               `temp => temp
               `T => name(t)])
         (t:ProductionBinding) :
            substitute(`(name(temp)), [
               `temp => temp
               `name => production-type-cast-function(base, name(t))])
         (t:UnionBinding) :
            substitute(`(union-type(a, b)), [
               `a => loop(a(t))
               `b => loop(b(t))])
         (t:ListBinding) :
            substitute(`(list-type(x)), [
               `x => loop(type(t))])
   val bindings = [`x => loop(t)]
   val prefixes = deep-prefix(`parser/, `(union-type, list-type))
   fill-template(`x, append-all([bindings prefixes]))

;TODO: Parse Pattern Exceptions
defn compile-action (pkg:SyntaxProperties, production:Symbol|Token, pat:List, body) :
   val bindings = get-bindings(pat)
   val body* = substitute(`(cast(let : body)), [
      `cast => return-type-cast-function(base(pkg, production), production)
      `body => body])
   compile-bindings(name(pkg), bindings, body*, None())

;TODO: Parse Pattern Exceptions
defn compile-fail (pkg:SyntaxProperties, pat:List, body) :
   val bindings = get-bindings(pat)
   compile-bindings(name(pkg), bindings, body, One(`Void))

;TODO: Parse Pattern Exceptions
defn compile-guard (pkg:SyntaxProperties, pat:List, body) :
   val bindings = get-recomputable-bindings(pat)
   compile-bindings(name(pkg), bindings, body, One(`(core/True|core/False)))

;============================================================
;============= MatchSyntax Parse Structures =================
;============================================================

public defstruct MatchSyntaxRule :
   base
   overlays
   form
   patterns: List<MatchPattern>

public defstruct MatchPattern :
   pattern
   guard: Maybe
   body

val MATCH-SYNTAX-COUNTER = to-seq(0 to false)

public defn compile (m:MatchSyntaxRule) :
   ;Prechecks
   val empty-table = HashTable<Symbol,True>()
   for pat in patterns(m) do :
      val p = parse-pattern(pattern(pat))
      ensure-wellformed-binders(p)
      if unwrap-token(base(m)) == `empty :
         ensure-no-productions(p)

   ;Stored action callbacks
   val actions = Vector<?>()

   ;Compile match pattern
   defn compile (p:MatchPattern) :
      ;Parse the binding
      var form = substitute(`(parse-pattern(`pat)), [
         `pat => pattern(p)])
      ;Add guard
      if not empty?(guard(p)) :
         ;Add guard pattern
         val idx = length(actions)
         form = substitute(`(Guard(guard, pat)), [
            `guard => idx
            `pat => form])
         ;Compile guard action
         add(actions, compile-bindings(
            base(m)
            get-recomputable-bindings(pattern(p))
            value!(guard(p))
            One(`(core/True|core/False))))
      ;Add action
      val idx = length(actions)
      form = substitute(`(Action(action, pat)), [
         `action => idx
         `pat => form])
      ;Compile action
      add(actions, compile-bindings(
         base(m)
         get-bindings(pattern(p))
         body(p)
         None()))
      ;Return pattern
      form

   ;Compile match patterns
   defn compile (ps:List<MatchPattern>) :
      substitute(`(Choice{[pats]}), [
         `pats => splice(map(compile, ps))])

   ;Compile all
   defn compile-all (m:MatchSyntaxRule) :
      val template = `(syntax-match(id, `base, `overlays, form, pats, [actions]))
      val bindings = [
         `base => base(m)
         `overlays => overlays(m)
         `form => form(m)
         `id => next(MATCH-SYNTAX-COUNTER)
         `pats => compile(patterns(m))
         `actions => splice(to-list(actions))]
      val prefixes = deep-prefix(`parser/, `(
         syntax-match Choice Action Guard parse-pattern))
      fill-template(template, append-all([bindings, prefixes]))

   ;Driver
   compile-all(m)

;============================================================
;==================== Syntax Packages =======================
;============================================================

protected :
   defstruct SyntaxPackage :
      name: Symbol
      imports: List<DefImport>
      productions: List<DefProduction>
      rules: List<DefRule>

   defstruct DefImport :
      names: List<Symbol>
      package: Symbol

   defstruct DefProduction :
      name: Symbol
      public?: True|False

   defstruct DefRule :
      name: Symbol
      pattern: Pattern

defmethod print (o:OutputStream, p:SyntaxPackage) :
   println(o, "defsyntax %_ :" % [name(p)])
   for io in o do-indented :
      do(println{io, _}, imports(p))
      do(println{io, _}, productions(p))
      do(println{io, _}, rules(p))

defmethod print (o:OutputStream, i:DefImport) :
   print(o, "import %, from %_" % [names(i), package(i)])

defmethod print (o:OutputStream, p:DefProduction) :
   print(o, "%_defproduction %_" % [
      "public " when public?(p) else ""
      name(p)])

defmethod print (o:OutputStream, r:DefRule) :
   print(o, "defrule %_ = %_" % [name(r), pattern(r)])

;============================================================
;================= Public Interface =========================
;============================================================

protected defn register-syntax-package (p:SyntaxPackage) :
   if key?(SYNTAX-PACKAGES, name(p)) :
      fatal("Could not define syntax package %_. There is already a syntax package with that name." % [name(p)])
   SYNTAX-PACKAGES[name(p)] = p

public defn with-syntax<?T> (pkgs:List<Symbol>, f: () -> ?T) :
   let-var CURRENT-OVERLAYS = pkgs :
      let-var CURRENT-OVERLAY-ID = genid() :
         f()

public defn with-added-syntax<?T> (pkgs:List<Symbol>, f: () -> ?T) :
   let-var CURRENT-OVERLAYS = append(reverse(pkgs), CURRENT-OVERLAYS) :
      let-var CURRENT-OVERLAY-ID = genid() :
         f()

protected defn syntax-match<?T> (id:Int,
                                 base:Symbol,
                                 overlays:List<Symbol>,
                                 form:List,                                 
                                 pat:() -> Pattern,
                                 actions:Tuple<(Context -> ?T)>) -> T :
   val cache = cached-match-pattern(id, base, overlays, pat)
   val r = match(pattern(cache)(form, actions)) :
      (r:MResult) : r when empty?(tail(r))
      (r:False) : false
   match(r) :
      (r:MResult) : head(head(r)())
      (r:False) : throw(PatternException("No match."))

;============================================================
;==================== Caching ===============================
;============================================================

;Caching the RuleSet
val CACHED-RULE-SETS = HashTable<List<Symbol>, CachedRuleSet>()

defstruct CachedRuleSet :
   ruleset: RuleSet
   compiled-ruleset: CompiledRuleSet
   
defn cached-rule-set (pkgs:List<SyntaxPackage>) :
   val names = map(name, pkgs)
   match(get?(CACHED-RULE-SETS, names, false)) :
      (rs:CachedRuleSet) :
         rs
      (_:False) :
         val rs = RuleSet(pkgs)
         val crs = compile(rs)
         val cache = CachedRuleSet(rs, crs)
         CACHED-RULE-SETS[names] = cache
         cache

;Caching the match pattern
val CACHED-MATCH-PATTERNS = Vector<False|CachedMatchPattern>()
defn get-cached-match-pattern (i:Int) -> False|CachedMatchPattern :
   if i < length(CACHED-MATCH-PATTERNS) :
      CACHED-MATCH-PATTERNS[i]
defn set-cached-match-pattern (i:Int, p:CachedMatchPattern) :
   if length(CACHED-MATCH-PATTERNS) <= i :
      lengthen(CACHED-MATCH-PATTERNS, i + 1, false)
   CACHED-MATCH-PATTERNS[i] = p   

defstruct CachedMatchPattern :
   pattern: (List, Tuple<(Context -> ?)>) -> MResult|False
   env: False|Int

defn cached-match-pattern (id:Int, base:Symbol, overlays:List<Symbol>, pat:() -> Pattern) :
   defn create-cache () :
      val pkgs = package-list(cons(base, overlays))
      val base-pkg = SYNTAX-PACKAGES[base] when base != `empty
      val cr = cached-rule-set(pkgs)
      val pattern = prepare-match-pattern(pat(), base-pkg, ruleset(cr))
      val cpattern = compile-match-pattern(pattern, compiled-ruleset(cr))
      val env = CURRENT-OVERLAY-ID when contains?(overlays, `current-overlays)
      val cache = CachedMatchPattern(cpattern, CURRENT-OVERLAY-ID)
      set-cached-match-pattern(id, cache)
      cache
      
   defn dirty? (env:False|Int) :
      match(env) :
         (env:Int) : env != CURRENT-OVERLAY-ID
         (env:False) : false         
         
   match(get-cached-match-pattern(id)) :
      (p:CachedMatchPattern) :
         if dirty?(env(p)) : create-cache()
         else : p
      (p:False) :
         create-cache()


;============================================================
;================= Sort by Imports ==========================
;============================================================

defn package-list (names:Collection<Symbol>) -> List<SyntaxPackage> :
   val pkgs = Vector<SyntaxPackage>()
   val included? = HashTable<Symbol,True|False>(false)
   defn import (name:Symbol) :
      if name == `empty :
         false
      else if name == `current-overlays :
         do(import, in-reverse(CURRENT-OVERLAYS))
      else if not included?[name] :
         included?[name] = true
         if not key?(SYNTAX-PACKAGES, name) :
            fatal("Could not resolve syntax package %_." % [name])
         val p = SYNTAX-PACKAGES[name]
         val imported = unique(seq(package, imports(p)))
         do(import, imported)
         add(pkgs, p)
   do(import, names)
   to-list(pkgs)

;============================================================
;===================== Storage ==============================
;============================================================

val SYNTAX-PACKAGES = HashTable<Symbol,SyntaxPackage>()

var CURRENT-OVERLAYS : List<Symbol> = List()
var CURRENT-OVERLAY-ID : Int = genid()

;============================================================
;================== Pattern Definition ======================
;============================================================

protected :
   deftype Pattern
   defstruct SeqPat <: Pattern :
      a: Pattern
      b: Pattern
   with :
      constructor => #SeqPat
   defstruct Choice <: Pattern :
      a: Pattern
      b: Pattern
   with :
      constructor => #Choice
   defstruct Empty <: Pattern
   defstruct Terminal <: Pattern :
      value
   defstruct Action <: Pattern :
      action: Int|(Context -> ?)
      pattern: Pattern
      num-binders: Int
   defstruct FailPat <: Pattern :
      action: Int|(Context -> Void)
      pattern: Pattern
      num-binders: Int
   defstruct NoMatch <: Pattern
   defstruct NotPat <: Pattern :
      pattern: Pattern
   defstruct Form <: Pattern
   defstruct Production <: Pattern :
      name: Symbol
   defstruct Repeat <: Pattern :
      pattern: Pattern
      binders: List<Int>
      num-binders: Int
   defstruct Rest <: Pattern
   defstruct ListPat <: Pattern :
      pattern: Pattern
   defstruct Binder <: Pattern :
      name: Symbol
      pattern: Pattern
      index: Int
   defstruct Guard <: Pattern :
      predicate: Int|(Context -> True|False)
      pattern: Pattern
      binders: List<Int>
      num-binders: Int
   defstruct Inlined <: Pattern :
      name: Symbol

   defn SeqPat (a:Pattern, b:Pattern) :
      match(a, b) :
         (a:Empty, b) : b
         (a, b:Empty) : a
         (a, b) : #SeqPat(a, b)
   defn SeqPat (xs:Seqable<Pattern>) :
      reduce-right(SeqPat, xs, Empty())
   defn Choice (a:Pattern, b:Pattern) :
      match(a, b) :
         (a:NoMatch, b) : b
         (a, b:NoMatch) : a
         (a, b) : #Choice(a, b)
   defn Choice (ps:Seqable<Pattern>) :
      reduce-right(Choice, ps, NoMatch())
   defn Action (action:Int|(Context -> ?), pattern:Pattern) :
      Action(action, pattern, 0)
   defn FailPat (action:Int|(Context -> ?), pattern:Pattern) :
      FailPat(action, pattern, 0)
   defn Repeat (pattern:Pattern) :
      Repeat(pattern, List(), 0)
   defn Binder (name:Symbol, pattern:Pattern) :
      Binder(name, pattern, 0)
   defn Guard (predicate:Int|(Context -> True|False), pattern:Pattern) :
      Guard(predicate, pattern, List(), 0)


defmethod print (o:OutputStream, p:Pattern) :
   print{o, _} $ match(p) :
      (p:SeqPat) : "($seq %@)" % [flatten(p)]
      (p:Choice) : "($or %@)" % [flatten(p)]
      (p:Empty) : "eps"
      (p:Terminal) : value(p)
      (p:Action) : "A{%~ %_}" % [pattern(p), num-binders(p)]
      (p:FailPat) : "($fail %~ %_)" % [pattern(p), num-binders(p)]
      (p:NotPat) : "($not %~)" % [pattern(p)]
      (p:Form) : "_"
      (p:Production) : "#%_" % [name(p)]
      (p:Repeat) : "($repeat %~ {%_|%,})" % [pattern(p), num-binders(p), binders(p)]
      (p:Rest) : "$rest"
      (p:ListPat) : "($list %~)" % [pattern(p)]
      (p:Binder) : "($bind %~(%_) %~)" % [name(p), index(p), pattern(p)]
      (p:Guard) : "($when %~ {%_|%,})" % [pattern(p), num-binders(p), binders(p)]
      (p:NoMatch) : "FAIL"
      (p:Inlined) : "inline #%_" % [name(p)]

;============================================================
;==================== Mappers ===============================
;============================================================

defn map (f:Pattern -> Pattern, p:Pattern) :
   match(p) :
      (p:SeqPat) : SeqPat(f(a(p)), f(b(p)))
      (p:Choice) : Choice(f(a(p)), f(b(p)))
      (p:Empty) : p
      (p:Terminal) : p
      (p:Action) : Action(action(p), f(pattern(p)), num-binders(p))
      (p:FailPat) : FailPat(action(p), f(pattern(p)), num-binders(p))
      (p:NotPat) : NotPat(f(pattern(p)))
      (p:Form) : p
      (p:Production) : p
      (p:Repeat) : Repeat(f(pattern(p)), binders(p), num-binders(p))
      (p:Rest) : p
      (p:ListPat) : ListPat(f(pattern(p)))
      (p:Binder) : Binder(name(p), f(pattern(p)), index(p))
      (p:Guard) : Guard(predicate(p), f(pattern(p)), binders(p), num-binders(p))
      (p:NoMatch) : p
      (p:Inlined) : p

defn do (f:Pattern -> ?, p:Pattern) :
   defn f* (p:Pattern) : (f(p), p)
   map(f*, p)
   false

defn children (p:Pattern) :
   generate<Pattern> : do(yield, p)

defn any? (f:Pattern -> True|False, p:Pattern) :
   any?(f, children(p))

defn all? (f:Pattern -> True|False, p:Pattern) :
   all?(f, children(p))

;============================================================
;================== Type Builders ===========================
;============================================================

protected defn list-type<?T> (f: () -> ?T) :
   f as ? as () -> List<T>
protected defn union-type<?T,?S> (g: () -> ?T, h: () -> ?S) :
   g as ? as () -> T|S

;============================================================
;================== Binding Analysis ========================
;============================================================

deftype BindingType
defstruct ListBinding <: BindingType : (type:BindingType)
defstruct TerminalBinding <: BindingType : (name:Symbol)
defstruct ProductionBinding <: BindingType : (name:Symbol)
defstruct UnionBinding <: BindingType : (a:BindingType, b:BindingType)

defstruct Binding :
   name: Symbol
   index: Int
   type: BindingType
   pattern: Pattern

defn get-bindings (p:List) -> List<Binding> :
   ;Common Types
   defn gradual-type () : TerminalBinding(`?)
   defn void-type () : TerminalBinding(`Void)
   defn literal-type (name:Symbol) :
      UnionBinding(TerminalBinding(name), TerminalBinding(`core/Token))

   ;Type of a literal
   defn primitive-type (v) :
      match(v) :
         (v:Token) : primitive-type(item(v))
         (v:Byte) : literal-type(`core/Byte)
         (v:Int) : literal-type(`core/Int)
         (v:Long) : literal-type(`core/Long)
         (v:Char) : literal-type(`core/Char)
         (v:Float) : literal-type(`core/Float)
         (v:Double) : literal-type(`core/Double)
         (v:String) : literal-type(`core/String)
         (v:Symbol) : literal-type(`core/Symbol)
         (v:List) : literal-type(`core/List)
         (v:True) : literal-type(`core/True)
         (v:False) : literal-type(`core/False)
         (v) : gradual-type()

   ;Compute the type of a pattern at nlists level of nesting
   defn binding-type (p:Pattern, nlists:Int) :
      defn typeof-contents (p:Pattern) :
         match(p) :
            (p:SeqPat) : UnionBinding(typeof(a(p)), typeof(b(p)))
            (p:Choice) : UnionBinding(typeof(a(p)), typeof(b(p)))
            (p:Empty) : void-type()
            (p:Terminal) : primitive-type(value(p))
            (p:NotPat) : void-type()
            (p:Form) : gradual-type()
            (p:Production) : ProductionBinding(name(p))
            (p:Repeat) : typeof-contents(pattern(p))
            (p:Rest) : gradual-type()
            (p:ListPat) : ListBinding(typeof-contents(pattern(p)))
            (p:Binder) : typeof-contents(pattern(p))
      defn typeof (p:Pattern) :
         if single?(p) : typeof-contents(p)
         else : ListBinding(typeof-contents(p))
      defn* wrap-lists (t:BindingType, n:Int) :
         if n == 0 : t
         else : wrap-lists(ListBinding(t), n - 1)
      wrap-lists(typeof(p), nlists)

   ;Compute point-wise union of bindings
   defn merge-bindings (ba:List<Binding>, bb:List<Binding>) :
      val table = HashTable<Symbol,Binding>()
      for b in ba do :
         table[name(b)] = b
      for b in bb map :
         val a = table[name(b)]
         fatal("Unmatched indices!") when index(a) != index(b)
         Binding(name(b),
                 index(b),
                 UnionBinding(type(a), type(b)),
                 Choice(pattern(a), pattern(b)))

   ;Discover bindings
   defn loop (p:Pattern, nlists:Int) -> List<Binding> :
      match(p) :
         (p:Binder) :
            val t = binding-type(pattern(p), nlists)
            val b = Binding(name(p), index(p), t, pattern(p))
            cons(b, loop(pattern(p), nlists))
         (p:Choice) :
            val ba = loop(a(p), nlists)
            val bb = loop(b(p), nlists)
            merge-bindings(ba, bb)
         (p:Repeat) :
            loop(pattern(p), nlists + 1)
         (p:Action|FailPat|Guard) :
            fatal("Unexpected pattern")
         (p) :
            seq-append(loop{_, nlists}, children(p))

   loop(prepare(parse-pattern(p)), 0)

defn get-recomputable-bindings (p:List) -> List<Binding> :
   to-list $ for b in get-bindings(p) filter :
      recomputable?(pattern(b))


;============================================================
;================= Pattern Utilities ========================
;============================================================

defn recomputable? (p:Pattern) :
   match(p) :
      (p:Production) : false
      (p) : all?(recomputable?, p)

defn flatten (p:SeqPat) :
   generate<Pattern> :
      defn loop (p:Pattern) :
         match(p) :
            (p:SeqPat) : do(loop, p)
            (p) : yield(p)
      loop(p)

defn flatten (p:Choice) :
   generate<Pattern> :
      defn loop (p:Pattern) :
         match(p) :
            (p:Choice) : do(loop, p)
            (p) : yield(p)
      loop(p)

defn single? (p:Pattern) :
   match(p) :
      (p:SeqPat|Empty|NotPat|Repeat|Rest) : false
      (p:Terminal|Action|Form|ListPat|Production) : true
      (p:Binder) : single?(pattern(p))
      (p) : fatal("Unexpected pattern: %_" % [p])

;============================================================
;================= Pattern Parser ===========================
;============================================================

defn subsymbol (x:Symbol, n:Int) :
   to-symbol(to-string(x)[n to false])

defn ensure-cap-form (form) -> Symbol :
   val f:List = unwrap-token(form)
   if length(f) != 2 :
      throw $ PatternException $
      "Invalid binding form %~. Cap form should have form (@cap name)." % [form]
   val name = unwrap-token(f[1])
   if name is-not Symbol :
      throw $ PatternException $
      "Invalid binding form %~. Cap form should have form (@cap name)." % [form]
   name

defn ensure-escape-value (form:List) :
   if empty?(form) :
      throw $ PatternException $
      "Expected escaped value, but reached end of list."

defn ensure-splice-list (p:Pattern) :
   match(p) :
      (p:ListPat) :
         pattern(p)
      (p) :
         throw $ PatternException $
         "Splice repeat operator @... requires a list pattern, but found %~." % [p]

public defn parse-pattern (form:List) -> Pattern :
   ;Sequence of forms (without handling | operator)
   defn pseq (f:List) -> [Pattern, List] :
      ;End of sequence
      if empty?(f) :
         [Empty(), f]
      ;Choice operator
      else if tagged-list?(f, `|) :
         [Empty(), f]
      ;Binder
      else if tagged-list?(head(f), `@cap) :
         val name = ensure-cap-form(head(f))
         val [p, rest] = pseq $
            if tagged-list?(tail(f), `:) : tailn(f, 2)
            else : cons(`_, tail(f))
         val p* = match(p) :
            (p:SeqPat) : SeqPat(Binder(name, a(p)), b(p))
            (p) : Binder(name, p)
         [p*, rest]
      ;Escape
      else if tagged-list?(f, `~) :
         ensure-escape-value(tail(f))
         val [p, rest] = pseq(tailn(f, 2))
         [SeqPat(Terminal(unwrap-all(f[1])), p), rest]
      ;Repeat Splice
      else if tagged-list?(tail(f), `@...) :
         val p1 = ensure-splice-list(pp(head(f)))
         val [p2, rest] = pseq(tailn(f, 2))
         [SeqPat(Repeat(p1), p2), rest]
      ;Repeat
      else if tagged-list?(tail(f), `...) :
         val p1 = pp(head(f))
         val [p2, rest] = pseq(tailn(f, 2))
         [SeqPat(Repeat(p1), p2), rest]
      ;Otherwise
      else :
         val p1 = pp(head(f))
         val [p2, rest] = pseq(tail(f))
         [SeqPat(p1, p2), rest]
   ;Sequence of pseq forms (handles | operator)
   defn pexp (f:List) :
      val [p1, rest] = pseq(f)
      if tagged-list?(rest, `|) :
         val p2 = pexp(tail(rest))
         Choice(p1, p2)
      else :
         fatal("Unhandled Pattern: %_" % [form]) when not empty?(rest)
         p1
   ;General Form (handles ! operator)
   defn pform (f:List) :
      if tagged-list?(f, `!) : NotPat(pexp(tail(f)))
      else : pexp(f)

   ;Single Pattern
   defn pp (f) :
      match(f) :
         (f:Token) :
            pp(item(f))
         (f:List) :
            match(pform(f)) :
               (p:Choice|NotPat) : p
               (p) : ListPat(p)
         (f:Symbol) :
            if f == `_ : Form()
            else if prefix?(f, "#") : Production(subsymbol(f, 1))
            else : Terminal(f)
         (f) :
            Terminal(f)

   ;Driver
   pform(form)

;============================================================
;================== Pattern Prechecks =======================
;============================================================

val CHOICE-MSG = "Choice pattern with unbalanced binders. Left side pattern has binders %, and right side pattern has binders %,."

defn ensure-wellformed-binders (p:Pattern) :
   ;Errors on duplicate binders or unbalanced binders
   defn ensure-no-duplicates (names:List<Symbol>) :
      val seen = HashTable<Symbol,True>()
      for name in names do :
         if key?(seen, name) :
            throw $ PatternException $
            "Duplicate declaration of binder %_." % [name]
         seen[name] = true
         
   defn same? (a:List<Symbol>, b:List<Symbol>) :
      if length(a) == length(b) :
         all?(contains?{b, _}, a)
         
   defn binders (p:Pattern) -> List<Symbol> :
      match(p) :
         (p:Binder) :
            cons(name(p), binders(pattern(p)))
         (p:Choice) :
            val ba = binders(a(p))
            val bb = binders(b(p))
            ensure-no-duplicates(ba)
            ensure-no-duplicates(bb)
            if not same?(ba, bb) :
               throw(PatternException(CHOICE-MSG % [ba, bb]))
            ba
         (p) :
            seq-append(binders, children(p))

   ensure-no-duplicates(binders(p))

defn ensure-resolvable-productions (p:Pattern, productions:HashTable<Symbol,True>) :
   defn loop (p:Pattern) :
      match(p) :
         (p:Production) : 
            if not key?(productions, name(p)) :
               throw $ PatternException $
                  "Could not resolve production %_." % [name(p)]
         (p) : do(loop, p)
   loop(p)      

defn ensure-no-binders (p:Pattern) :
   match(p) :
      (p:Binder) :
         throw $ PatternException $
         "Cannot have binder %_ in Not rule." % [name(p)]
      (p) : do(ensure-no-binders, p)   

defn ensure-no-productions (p:Pattern) :
   match(p) :
      (p:Production) :
         throw $ PatternException $
         "Construct match-syntax with no base syntax package cannot use production %_" % [name(p)]
      (p) : do(ensure-no-productions, p)   

;============================================================
;================== Index Binders ===========================
;============================================================

deftype IndexPool
defmulti next (i:IndexPool, name:Symbol) -> Int
defmulti num-indices (i:IndexPool) -> Int
defmulti get (i:IndexPool, name:Symbol) -> Int

defn IndexPool () :
   val indices = to-seq(0 to false)
   val binders = HashTable<Symbol,Int>()
   new IndexPool :
      defmethod next (this, name:Symbol) :
         val i = next(indices)
         binders[name] = i
         i
      defmethod num-indices (this) :
         peek(indices)
      defmethod get (this, name:Symbol) :
         binders[name]

defn bound-indices (p:Pattern) :
   match(p) :
      (p:Action|FailPat|Guard) : List()
      (p:Binder) : cons(index(p), bound-indices(pattern(p)))
      (p) : seq-append(bound-indices, children(p))

defn index-binders (p:Pattern) -> Pattern :
   defn new-index (p:Pattern) -> [Pattern, Int] :
      val indices = IndexPool()
      val p* = new-index(p, indices)
      [p*, num-indices(indices)]
   defn new-index (p:Pattern, indices:IndexPool) :
      match(p) :
         (p:Action) :
            val [p* n] = new-index(pattern(p))
            Action(action(p), p*, n)
         (p:FailPat) :
            val [p* n] = new-index(pattern(p))
            FailPat(action(p), p*, n)
         (p:Binder) :
            val i = next(indices, name(p))
            val p* = new-index(pattern(p), indices)
            Binder(name(p), p*, i)
         (p:Repeat) :
            val p* = new-index(pattern(p), indices)
            val bs = bound-indices(p*)
            val n = maximum(0, bs) + 1
            Repeat(p*, bs, n)
         (p:Guard) :
            val p* = new-index(pattern(p), indices)
            val bs = bound-indices(p*)
            val n = maximum(0, bs) + 1
            Guard(predicate(p), p*, bs, n)
         (p:Choice) :
            val a* = new-index(a(p), indices)
            val b* = assign(b(p), indices)
            Choice(a*, b*)
         (p) :
            map(new-index{_, indices}, p)
   defn assign (p:Pattern, indices:IndexPool) :
      match(p) :
         (p:Action|FailPat|Guard) :
            new-index(p, indices)
         (p:Binder) :
            val i = indices[name(p)]
            val p* = assign(pattern(p), indices)
            Binder(name(p), p*, i)
         (p:Repeat) :
            val p* = assign(pattern(p), indices)
            val bs = bound-indices(p*)
            val n = maximum(0, bs) + 1
            Repeat(p*, bs, n)
         (p:Guard) :
            val p* = assign(pattern(p), indices)
            val bs = bound-indices(p*)
            val n = maximum(0, bs) + 1
            Guard(predicate(p), p*, bs, n)
         (p) :
            map(assign{_, indices}, p)
   new-index(p, IndexPool())

;============================================================
;================= Identify Rests ===========================
;============================================================

defn identify-rests (p:Pattern) -> Pattern :
   defn rest? (p:Pattern) :
      label<True|False> return :
         ;Must be a sequence
         return(false) when p is-not SeqPat
         val pseq = p as SeqPat
         ;Must be a single item sequence
         return(false) when b(pseq) is-not Empty
         ;First item must be form
         a(pseq) is Form
   match(map(identify-rests, p)) :
      (p:Repeat) : Rest() when rest?(pattern(p)) else p
      (p) : p

;============================================================
;=================== Prepare Pattern ========================
;============================================================

defn prepare (p:Pattern) -> Pattern :
   val indexed = index-binders(p)
   identify-rests(indexed)

defn prepare-match-pattern (p:Pattern, base:False|SyntaxPackage, ruleset:RuleSet) :
   match(base) :
      (base:SyntaxPackage) :
         ;Resolve all public productions
         val prod-table = HashTable<Symbol, Symbol>()
         ;All public productions
         for prod in productions(base) do :
            if public?(prod) :
               prod-table[name(prod)] = symbol-join $ [name(base) " " name(prod)]
         ;All imported productions
         for import in imports(base) do :
            for name in names(import) do :
               prod-table[name] = symbol-join $ [package(import) " " name]         
         ;Package qualify the pattern
         defn qualify (p:Pattern) :
            match(p) :
               (p:Production) :
                  if not key?(prod-table, name(p)) :
                     fatal("Could not resolve production %_ in syntax package %_." % [
                        name(p), name(base)])
                  Production(prod-table[name(p)])
               (p) : map(qualify, p)
         ;Ensure proper repetitions
         ensure-no-nullable-repetitions(ruleset, p)
         ;Prepare and qualify
         qualify(prepare(p))
      (base:False) :
         ensure-no-nullable-repetitions(ruleset, p)
         prepare(p)

;============================================================
;====================== RuleSet =============================
;============================================================

deftype RuleSet <: Collection<KeyValue<Symbol,Pattern>>
defmulti get (r:RuleSet, name:Symbol) -> Pattern
defmulti ensure-no-nullable-repetitions (r:RuleSet, p:Pattern) -> False

defstruct Suffix :
   fail?: True|False
   function: (() -> ?) -> ?

defn RuleSet (pkgs:List<SyntaxPackage>) :
   ;Check resolution of imported productions
   val public-productions = HashTable<[Symbol Symbol],True|False>()
   for pkg in pkgs do :
      for prod in productions(pkg) do :
         val key = [name(pkg), name(prod)]
         public-productions[key] = public?(prod)
      for prod in seq-cat(names, imports(pkg)) do :
         val key = [name(pkg), prod]
         public-productions[key] = true
   for pkg in pkgs do :
      for import in imports(pkg) do :
         for prod in names(import) do :
            if not key?(public-productions, [name(pkg), prod]) :
               fatal("Cannot import production %_ from package %_. No such production." % [prod, name(pkg)])
            else if not public-productions[[name(pkg), prod]] :
               fatal("Cannot import production %_ from package %_. Production is not public." % [prod, name(pkg)])

   ;Package qualify all the productions
   defn package-qualify (pkg:SyntaxPackage) :
      val qualified = HashTable<Symbol,Symbol>()
      for import in imports(pkg) do :
         for name in names(import) do :
            qualified[name] = symbol-join $ [package(import) " " name]
      for prod in productions(pkg) do :
         qualified[name(prod)] = symbol-join $ [name(pkg) " " name(prod)]
      defn qualify (p:Pattern) :
         match(p) :
            (p:Production) : Production(qualified[name(p)])
            (p:Inlined) : Inlined(qualified[name(p)])
            (p) : map(qualify, p)
      defn qualify (r:DefProduction) :
         DefProduction(qualified[name(r)], public?(r))
      defn qualify (r:DefRule) :
         DefRule(qualified[name(r)], qualify(pattern(r)))
      SyntaxPackage(
         name(pkg)
         imports(pkg)
         map(qualify,productions(pkg))
         map(qualify,rules(pkg)))
   val qpkgs = map(package-qualify, pkgs)

   ;Accumulate rule table
   val patterns = HashTable<Symbol,Pattern>()
   for qpkg in qpkgs do :
      for prod in productions(qpkg) do :
         patterns[name(prod)] = NoMatch()
   for qpkg in qpkgs do :
      for rule in rules(qpkg) do :
         patterns[name(rule)] = match(pattern(rule)) :
            (p:NotPat) : SeqPat(p, patterns[name(rule)])
            (p) : Choice(p, patterns[name(rule)])
   for entry in patterns do :
      patterns[key(entry)] = prepare(value(entry))

   ;Check for circular inlining
   defn ensure-no-circular-inlining () :
      defn inlined (p:Pattern) -> List<Symbol> :
         match(p) :
            (p:Inlined) : List(name(p))
            (p:Choice) : seq-append(inlined, children(p))
            (p) : List()
      val groups = strong-components $
         for entry in patterns seq :
            key(entry) => inlined(value(entry))
      for group in groups do :
         if group is List :
            fatal("Productions %, circularly inline each other." % [group])

   ;Inline productions
   defn inline-productions (table:HashTable<Symbol,Pattern>) :
      val inlined? = HashTable<Symbol,True|False>(false)
      defn inline (p:Pattern) :
         match(p) :
            (p:Choice) : map(inline, p)
            (p:Inlined) : inline(name(p))
            (p) : p
      defn inline (name:Symbol) :
         if not inlined?[name] :
            table[name] = inline(table[name])
            inlined?[name] = true
         table[name]
      do(inline, keys(table))

   ;Remove left recursion
   defn remove-direct-left-recursion (table:HashTable<Symbol,Pattern>) :
      ;Returns whether an inner pattern is left recursive on prod
      ;Called on branch pattern
      defn direct-left-recursive? (prod:Symbol, p:Pattern) :
         defn loop (p:Pattern, under-binder?:True|False) :
            match(p) :
               (p:SeqPat) : (not under-binder?) and loop(a(p), false)
               (p:Action) : loop(pattern(p), false)
               (p:FailPat) : loop(pattern(p), false)
               (p:Production) : name(p) == prod
               (p:Binder) : loop(pattern(p), true)
               (p:Guard) : loop(pattern(p), false)
               (p) : false
         loop(p, false)
      ;Retrieves remaining pattern after removing left recursive terminal
      ;Called on action pattern
      defn remove-left-recursive-terminal (p:Pattern) :
         match(p) :
            (p:SeqPat) : SeqPat(remove-left-recursive-terminal(a(p)), b(p))
            (p:Production) : Empty()
            (p:Binder) : Empty()
            (p:Guard) : map(remove-left-recursive-terminal, p)
      ;Returns list of all binders bound to left recursive terminal
      ;Called on action pattern
      defn left-recursion-binders (p:Pattern) -> List<Int> :
         match(p) :
            (p:SeqPat) : left-recursion-binders(a(p))
            (p:Production) : List()
            (p:Binder) : cons(index(p), left-recursion-binders(pattern(p)))
            (p:Guard) : left-recursion-binders(pattern(p))

      ;Called on overall pattern
      ;Returns the iteration subpattern of a left recursive production
      defn suffix-subpattern (prod:Symbol, p:Pattern) :
         match(p) :
            (p:Choice) :
               Choice(suffix-subpattern(prod, a(p)), suffix-subpattern(prod, b(p)))
            (p:Action) :
               if direct-left-recursive?(prod, p) :
                  val pat = remove-left-recursive-terminal(pattern(p))
                  val binders = left-recursion-binders(pattern(p))
                  val callback = fn (context:Context) :
                     Suffix{false, _} $ fn* (seed) :
                        do({context[_] = seed}, binders)
                        val f = action(p) as Context -> ?
                        f(context)
                  Action(callback, pat, num-binders(p))
               else : NoMatch()
            (p:FailPat) :
               if direct-left-recursive?(prod, p) :
                  val pat = remove-left-recursive-terminal(pattern(p))
                  val binders = left-recursion-binders(pattern(p))
                  val callback = fn (context:Context) :
                     Suffix{true, _} $ fn* (seed) :
                        do({context[_] = seed}, binders)
                        val f = action(p) as Context -> Void
                        f(context)
                  Action(callback, pat, num-binders(p))
               else : NoMatch()

      ;Called on overall pattern
      ;Returns the seed subpattern of a left recursive production
      defn seed-subpattern (prod:Symbol, p:Pattern) :
         match(p) :
            (p:Choice) :
               Choice(seed-subpattern(prod, a(p)), seed-subpattern(prod, b(p)))
            (p:Action|FailPat) :
               NoMatch() when direct-left-recursive?(prod, p) else p

      ;Returns the iteration pattern given the production for the seed and suffix
      defn iteration-pattern (seed:Symbol, suffix:Symbol) :
         val x = Binder(gensym(), Production(seed), 0)
         val ys = Binder(gensym(), Repeat(Production(suffix), List(), 0), 1)
         val pat = SeqPat(x, ys)
         val callback = fn (context:Context) :
            defn* apply-suffix-ops (seed: () -> ?, suffixes: List<Suffix>) :
               if empty?(suffixes) :
                  seed()
               else :
                  val [suffix, suffixes] = [head(suffixes), tail(suffixes)]
                  if fail?(suffix) : function(suffix)(seed)
                  else : apply-suffix-ops(function(suffix){seed}, suffixes)
            apply-suffix-ops(context[0], context[1]())
         Action(callback, pat, 2)

      ;Determine whether a production is left recursive
      defn left-recursive-production? (prod:Symbol) :
         defn recursive? (p:Pattern) :
            match(p) :
               (p:Choice) : any?(recursive?, p)
               (p) : direct-left-recursive?(prod, p)
         recursive?(table[prod])

      ;Adjust table
      val current-entries = to-list(table)
      for entry in current-entries do :
         val prod = key(entry)
         if left-recursive-production?(prod) :
            val seed-prod = gensym("%_ seed" % [prod])
            val suffix-prod = gensym("%_ suffix" % [prod])
            table[seed-prod] = seed-subpattern(prod, value(entry))
            table[suffix-prod] = suffix-subpattern(prod, value(entry))
            table[prod] = iteration-pattern(seed-prod, suffix-prod)

   ;Compute nullable productions
   ;A nullable production is one that can succeed without consuming any input.
   val nullable-table = HashTable<Symbol,True|False>()
   defn nullable? (p:Pattern, nullable-production?:Symbol -> True|False) -> True|False :
      defn loop (p:Pattern) :
         match(p) :
            (p:Production) : nullable-production?(name(p))
            (p:SeqPat) : loop(a(p)) and loop(b(p))
            (p:Choice) : loop(a(p)) or loop(b(p))
            (p:Empty) : true
            (p:Terminal) : false
            (p:Action) : loop(pattern(p))
            (p:FailPat) : false
            (p:NoMatch) : false
            (p:NotPat) : true
            (p:Form) : false
            (p:Repeat) : true
            (p:Rest) : true
            (p:ListPat) : false
            (p:Binder) : loop(pattern(p))
            (p:Guard) : loop(pattern(p))
      loop(p)   
   defn nullable? (p:Pattern) -> True|False :
      nullable?(p, get?{nullable-table, _, false})
   defn compute-nullables () :   
      fixpoint $ fn (progress) :
         for entry in patterns do :
            if not key?(nullable-table, key(entry)) :
               attempt :
                  nullable-table[key(entry)] = nullable?{value(entry), _} $ fn (name) :
                     if key?(nullable-table, name) : nullable-table[name]
                     else : fail()
                  progress()

   ;Ensure no nullable repetition productions
   defn ensure-no-nullable-repetitions (p:Pattern) :
      match(p) :
         (p:Repeat) :
            if nullable?(pattern(p)) :
               fatal("Repetition pattern %_ contains nullable pattern." % [p])
            else : ensure-no-nullable-repetitions(pattern(p))
         (p) : do(ensure-no-nullable-repetitions, p)
   defn ensure-no-nullable-repetitions () :      
      do(ensure-no-nullable-repetitions, values(patterns))      

   ;Ensure no left recursive productions
   defn first-productions (p:Pattern) -> List<Symbol> :
      match(p) :
         (p:Production) : List(name(p))
         (p:SeqPat) :
            val fa = first-productions(a(p))
            if nullable?(a(p)) : append(fa, first-productions(b(p)))
            else : fa
         (p:Choice) : append(first-productions(a(p)), first-productions(b(p)))
         (p:Empty) : List()
         (p:Terminal) : List()
         (p:Action) : first-productions(pattern(p))
         (p:FailPat) : first-productions(pattern(p))
         (p:NoMatch) : List()
         (p:NotPat) : first-productions(pattern(p))
         (p:Form) : List()
         (p:Repeat) : first-productions(pattern(p))
         (p:Rest) : List()
         (p:ListPat) : List()
         (p:Binder) : first-productions(pattern(p))
         (p:Guard) : first-productions(pattern(p))
   defn ensure-no-left-recursion () :
      val groups = strong-components $
         for entry in patterns seq :
            key(entry) => first-productions(value(entry))
      for group in groups do :
         if group is List :
            fatal("Productions %, are mutually left recursive." % [group])

   ;Launch
   ensure-no-circular-inlining()
   inline-productions(patterns)
   remove-direct-left-recursion(patterns)
   compute-nullables()
   ensure-no-nullable-repetitions()
   ensure-no-left-recursion()
   
   ;Return new rule set
   new RuleSet :
      defmethod get (this, name:Symbol) : patterns[name]
      defmethod to-seq (this) : to-seq(patterns)
      defmethod ensure-no-nullable-repetitions (this, p:Pattern) :
         ensure-no-nullable-repetitions(p)

;============================================================
;=================== Compiled Ruleset =======================
;============================================================

;type-alias CompiledPattern = (form:List, last-info:False|FileInfo, bind:(Int, () -> ?) -> ?) -> MResult|False

deftype CompiledRuleSet
defmulti get (rs:CompiledRuleSet, name:Symbol) -> (List, False|FileInfo, (Int, () -> ?) -> ?) -> MResult|False
defmulti set (rs:CompiledRuleSet, name:Symbol, cr:(List, False|FileInfo, (Int, () -> ?) -> ?) -> MResult|False) -> False

defn CompiledRuleSet () :         
   ;Compiled Ruleset
   val patterns = HashTable<Symbol, ((List, False|FileInfo, (Int, () -> ?) -> ?) -> MResult|False)>()
   val patches = HashTable<Symbol, (((List, False|FileInfo, (Int, () -> ?) -> ?) -> MResult|False) -> False)>()

   new CompiledRuleSet :
      defmethod get (this, name:Symbol) -> (List, False|FileInfo, (Int, () -> ?) -> ?) -> MResult|False :
         if not key?(patterns, name) :
            var f:(List, False|FileInfo, (Int, () -> ?) -> ?) -> MResult|False
            patterns[name] = fn* (form, last-info, bind) :
               f(form, last-info, bind)
            patches[name] = {f = _}               
         patterns[name]   

      defmethod set (this, name:Symbol, cp:(List, False|FileInfo, (Int, () -> ?) -> ?) -> MResult|False) :      
         if key?(patches, name) : patches[name](cp)
         else : patterns[name] = cp
         
;============================================================
;=================== Compiling RuleSet ======================
;============================================================

defn compile (ruleset:RuleSet) -> CompiledRuleSet :
   val compiled-ruleset = CompiledRuleSet()
   for entry in ruleset do :
      compiled-ruleset[key(entry)] = compile(value(entry), compiled-ruleset)
   compiled-ruleset

defn compile (pat:Pattern,
              ruleset:CompiledRuleSet) ->
              (List, False|FileInfo, (Int, () -> ?) -> ?) -> MResult|False :
   ;Farthest info
   defn farthest-info (last-info:False|FileInfo, form) :
      defn loop (form) -> Maybe<FileInfo> :
         match(form) :
            (form:Token) :
               val inf = loop(item(form))
               if empty?(inf) : One(info(form))
               else : inf
            (form:List) :
               first(loop, in-reverse(form))
            (form) :
               None()
      match(loop(form)) :
         (i:One<FileInfo>) : value(i)
         (i:None) : last-info

   ;No delayed callbacks in a ruleset
   defn action (p:Action|FailPat) :
      /action(p) as Context -> ?
   defn predicate (g:Guard) :
      /predicate(g) as Context -> True|False

   ;Compile a single pattern
   defn cp (pat:Pattern) -> (List, False|FileInfo, (Int, () -> ?) -> ?) -> MResult|False :
      match(pat) :
         (pat:SeqPat) :
            val ca = cp(a(pat))
            val cb = cp(b(pat))
            fn* (form, last-info, bind) :
               match(ca(form, last-info, bind)) :
                  (r1:MResult) :
                     match(cb(tail(r1), info(r1), bind)) :
                        (r2:MResult) :
                           val h* = fn* () : append(head(r1)(), head(r2)())
                           MResult(pat, h*, tail(r2), info(r2))
                        (r2:False) :
                           false
                  (r1:False) :
                     false
         (pat:Choice) :
            val ca = cp(a(pat))
            val cb = cp(b(pat))
            fn* (form, last-info, bind) :
               match(ca(form, last-info, bind)) :
                  (r1:MResult) : r1
                  (r1:False) : cb(form, last-info, bind)
         (pat:Empty) :
            fn* (form, last-info, bind) :
               MResult(pat, List, form, last-info)
         (pat:Terminal) :
            fn* (form, last-info, bind) :
               if not empty?(form) :
                  val h = head(form)
                  if unwrap-token(h) == value(pat) :
                     MResult(pat, List{h}, tail(form), farthest-info(last-info, h))
         (pat:Action) :
            val ca = cp(pattern(pat))
            fn* (form, last-info, bind) :
               val bindings = BindingArray(num-binders(pat))
               match(ca(form, last-info, setter(bindings))) :
                  (r1:MResult) :
                     defn head* () : List(action(pat)(Context(bindings, form, last-info)))
                     MResult(pat, head*, tail(r1), info(r1))
                  (r1:False) :
                     false
         (pat:FailPat) :
            val ca = cp(pattern(pat))
            fn* (form, last-info, bind) :
               val bindings = BindingArray(num-binders(pat))
               match(ca(form, last-info, setter(bindings))) :
                  (r1:MResult) : action(pat)(Context(bindings, form, last-info))
                  (r1:False) : false
         (pat:NoMatch) :
            fn* (form, last-info, bind) :
               false
         (pat:NotPat) :
            val ca = cp(pattern(pat))
            fn* (form, last-info, bind) :
               match(ca(form, last-info, bind)) :
                  (r1:MResult) : false
                  (r1:False) : MResult(pat, List, form, last-info)
         (pat:Form) :
            fn* (form, last-info, bind) :
               if not empty?(form) :
                  val h = head(form)
                  MResult(pat, List{h}, tail(form), farthest-info(last-info, h))
         (pat:Production) :
            val ca = ruleset[name(pat)]
            fn* (form, last-info, bind) :
               match(ca(form, last-info, bind)) :
                  (r1:MResult) : MResult(pat, head(r1), tail(r1), info(r1))
                  (r1:False) : false
         (pat:Repeat) :
            val ca = cp(pattern(pat))
            fn* (form, last-info, bind) :
               ;Set up new binding list
               val bindings = BindingArray<List<(() -> ?)>>(num-binders(pat), List())
               val counts = BindingArray<Int>(num-binders(pat), 0)
               defn add-bind (i:Int, v:() -> ?) :
                  counts[i] = counts[i] + 1
                  bindings[i] = cons(v, bindings[i])
               defn call-all (fs:List<(() -> ?)>) :
                  for f in reverse(fs) map :
                     f()
               defn bind-all (binders:List<Int>, n:Int) :
                  for b in binders do :
                     bind(b, call-all{tailn(bindings[b], counts[b] - n)})

               ;Match as much as we can
               defn loop (form:List, last-info:False|FileInfo, n:Int) -> MResult :
                  val r1 = ca(form, last-info, add-bind) when not empty?(form)
                  match(r1) :
                     (r1:MResult) :
                        val r2 = loop(tail(r1), info(r1), n + 1)
                        defn h* () : append(head(r1)(), head(r2)())
                        MResult(pat, h*, tail(r2), info(r2))
                     (r1:False) :
                        bind-all(binders(pat), n)
                        MResult(pat, List, form, last-info)

               ;Launch
               loop(form, last-info, 0)
         (pat:Rest) :
            fn* (form, last-info, bind) :
               MResult(pat, {form}, List(), farthest-info(last-info, form))
         (pat:ListPat) :
            val ca = cp(pattern(pat))
            fn* (form, last-info, bind) :
               if not empty?(form) :
                  val h = unwrap-token(head(form))
                  if h is List :
                     val list-info = match(head(form)) :
                        (t:Token) : info(t)
                        (t) : last-info
                     match(ca(h, list-info, bind)) :
                        (r1:MResult) :
                           if empty?(tail(r1)) :
                              MResult(pat, List{head(r1)()}, tail(form), info(r1))
                        (r1:False) :
                           false
         (pat:Binder) :
            val ca = cp(pattern(pat))
            fn* (form, last-info, bind) :
               match(ca(form, last-info, bind)) :
                  (r1:MResult) :
                     val v =
                        if single?(pattern(r1)) : head{head(r1)()}
                        else : head(r1)
                     bind(index(pat), v)
                     r1
                  (r1:False) :
                     false
         (pat:Guard) :
            val ca = cp(pattern(pat))
            fn* (form, last-info, bind) :
               ;Set up new binding list
               val bindings = BindingArray(num-binders(pat))
               defn bind-all (binders:List<Int>) :
                  for b in binders do : bind(b, bindings[b])

               match(ca(form, last-info, setter(bindings))) :
                  (r1:MResult) :
                     if predicate(pat)(Context(bindings, form, last-info)) :
                        bind-all(binders(pat))
                        r1
                  (r1:False) :
                     false

   ;Launch
   cp(pat)

;type-alias CompiledMatchPattern =
;   (form:List, actions:Tuple<(Context -> ?)>) -> MResult|False
defn compile-match-pattern (pat:Pattern,
                            ruleset:CompiledRuleSet) ->
                            (List, Tuple<(Context -> ?)>) -> MResult|False :
   defn cp (pat:Pattern) -> (List, Tuple<(Context -> ?)>) -> MResult|False :
      match(pat) :
         (pat:Choice) :
            val ca = cp(a(pat))
            val cb = cp(b(pat))
            fn* (form, actions) :
               match(ca(form, actions)) :
                  (r1:MResult) : r1
                  (r1:False) : cb(form, actions)
         (pat:Action) :
            val ca = compile(pattern(pat), ruleset)
            val idx = action(pat) as Int
            fn* (form, actions) :
               val bindings = BindingArray(num-binders(pat))
               match(ca(form, false, setter(bindings))) :
                  (r1:MResult) :
                     defn head* () : List(actions[idx](Context(bindings, form, false)))
                     MResult(pat, head*, tail(r1), info(r1))
                  (r1:False) :
                     false
         (pat) :
            fatal("Unexpected pattern: %_" % [pat])
   ;Launch
   cp(pat)

;============================================================
;====================== Context =============================
;============================================================

deftype Context
protected defmulti set (c:Context, i:Int, v:() -> ?) -> False
protected defmulti get (c:Context, i:Int) -> (() -> ?)
protected defmulti info (c:Context) -> False|FileInfo
protected defmulti info (c:Context, form) -> False|FileInfo

defn Context (bindings:Array<(() -> ?)>, form, current-info:False|FileInfo) :
   defn first-info (form) :
      match(form) :
         (form:Token) :
            info(form)
         (form:List) :
            if empty?(form) : current-info
            else : first-info(head(form))
         (form) : current-info

   defn closest-info (form) -> Maybe<FileInfo> :
      match(form) :
         (form:Token) : One(info(form))
         (form:List) : first(closest-info, form)
         (form) : None()

   new Context :
      defmethod set (this, i:Int, v:() -> ?) :
         bindings[i] = v
      defmethod get (this, i:Int) :
         bindings[i]
      defmethod info (this) :
         match(first-info(form)) :
            (info:FileInfo) : info
            (info:False) : value?(closest-info(form))
      defmethod info (this, subform) :
         val inf = closest-info(subform)
         if empty?(inf) : info(this)
         else : value!(inf)

;============================================================
;================= Pattern Interpreter ======================
;============================================================

defstruct MResult :
   pattern: Pattern
   head: () -> List
   tail: List
   info: False|FileInfo  ;The most update-to-date file information from head

;Empty bindings optimization
val EMPTY-BINDINGS = Array<?>(0)
defn BindingArray (n:Int) :
   if n == 0 : EMPTY-BINDINGS
   else : Array<(() -> ?)>(n)
defn BindingArray<T> (n:Int, v:T) :
   if n == 0 : EMPTY-BINDINGS
   else : Array<T>(n, v)
defn setter (b:Array<(() -> ?)>) :
   set{b, _:Int, _:() -> ?}

defn interpret (pat:Pattern,
                form:List,
                patterns:RuleSet,
                actions:Tuple<(Context -> ?)>) ->
                MResult|False :
   ;Retrieve delayed callbacks
   defn action (p:Action|FailPat) :
      match(/action(p)) :
         (a:Context -> ?) : a
         (a:Int) : actions[a]
   defn predicate (g:Guard) :
      match(/predicate(g)) :
         (g:Context -> True|False) : g
         (g:Int) : actions[g] as Context -> True|False

   ;Pattern Matcher
   defn match-pat (pat:Pattern, form:List, last-info:False|FileInfo, bind:(Int, () -> ?) -> ?) :
      ;Farthest info
      defn farthest-info (form) :
         defn loop (form) -> Maybe<FileInfo> :
            match(form) :
               (form:Token) :
                  val inf = loop(item(form))
                  if empty?(inf) : One(info(form))
                  else : inf
               (form:List) :
                  first(loop, in-reverse(form))
               (form) :
                  None()
         match(loop(form)) :
            (i:One<FileInfo>) : value(i)
            (i:None) : last-info

      match(pat) :
         (pat:Terminal) :
            if not empty?(form) :
               val h = head(form)
               if unwrap-token(h) == value(pat) :
                  MResult(pat, List{h}, tail(form), farthest-info(h))
         (pat:Empty) :
            MResult(pat, List, form, last-info)
         (pat:Form) :
            if not empty?(form) :
               val h = head(form)
               MResult(pat, List{h}, tail(form), farthest-info(h))
         (pat:Production) :
            val p = patterns[name(pat)]
            match(match-pat(p, form, last-info, bind)) :
               (r1:MResult) : MResult(pat, head(r1), tail(r1), info(r1))
               (r1:False) : false
         (pat:SeqPat) :
            match(match-pat(a(pat), form, last-info, bind)) :
               (r1:MResult) :
                  match(match-pat(b(pat), tail(r1), info(r1), bind)) :
                     (r2:MResult) :
                        val h* = fn* () : append(head(r1)(), head(r2)())
                        MResult(pat, h*, tail(r2), info(r2))
                     (r2:False) :
                        false
               (r1:False) :
                  false
         (pat:Choice) :
            match(match-pat(a(pat), form, last-info, bind)) :
               (r1:MResult) : r1
               (r1:False) : match-pat(b(pat), form, last-info, bind)
         (pat:Binder) :
            match(match-pat(pattern(pat), form, last-info, bind)) :
               (r1:MResult) :
                  val v =
                     if single?(pattern(r1)) : head{head(r1)()}
                     else : head(r1)
                  bind(index(pat), v)
                  r1
               (r1:False) :
                  false
         (pat:Action) :
            val bindings = BindingArray(num-binders(pat))
            match(match-pat(pattern(pat), form, last-info, setter(bindings))) :
               (r1:MResult) :
                  defn head* () : List(action(pat)(Context(bindings, form, last-info)))
                  MResult(pat, head*, tail(r1), info(r1))
               (r1:False) :
                  false
         (pat:FailPat) :
            val bindings = BindingArray(num-binders(pat))
            match(match-pat(pattern(pat), form, last-info, setter(bindings))) :
               (r1:MResult) : action(pat)(Context(bindings, form, last-info))
               (r1:False) : false
         (pat:NotPat) :
            match(match-pat(pattern(pat), form, last-info, bind)) :
               (r1:MResult) : false
               (r1:False) : MResult(pat, List, form, last-info)
         (pat:ListPat) :
            if not empty?(form) :
               val h = unwrap-token(head(form))
               if h is List :
                  val list-info = match(head(form)) :
                     (t:Token) : info(t)
                     (t) : last-info
                  match(match-pat(pattern(pat), h, list-info, bind)) :
                     (r1:MResult) :
                        if empty?(tail(r1)) :
                           MResult(pat, List{head(r1)()}, tail(form), info(r1))
                     (r1:False) :
                        false
         (pat:Repeat) :
            ;Set up new binding list
            val bindings = BindingArray<List<(() -> ?)>>(num-binders(pat), List())
            val counts = BindingArray<Int>(num-binders(pat), 0)
            defn add-bind (i:Int, v:() -> ?) :
               counts[i] = counts[i] + 1
               bindings[i] = cons(v, bindings[i])
            defn call-all (fs:List<(() -> ?)>) :
               for f in reverse(fs) map :
                  f()
            ;Match as much as we can
            defn loop (form:List, last-info:False|FileInfo, n:Int) -> MResult :
               val r1 = match-pat(pattern(pat), form, last-info, add-bind) when not empty?(form)
               match(r1) :
                  (r1:MResult) :
                     val r2 = loop(tail(r1), info(r1), n + 1)
                     defn h* () : append(head(r1)(), head(r2)())
                     MResult(pat, h*, tail(r2), info(r2))
                  (r1:False) :
                     ;Bind repeated listp
                     for b in binders(pat) do :
                        val bs = tailn(bindings[b], counts[b] - n)
                        bind(b, call-all{bs})
                     MResult(pat, List, form, last-info)
            ;Driver
            loop(form, last-info, 0)
         (pat:Rest) :
            MResult(pat, {form}, List(), farthest-info(form))
         (pat:Guard) :
            ;Set up new binding list
            val bindings = BindingArray(num-binders(pat))
            match(match-pat(pattern(pat), form, last-info, setter(bindings))) :
               (r1:MResult) :
                  if predicate(pat)(Context(bindings, form, last-info)) :
                     for b in binders(pat) do :
                        bind(b, bindings[b])
                     r1
               (r1:False) :
                  false
         (pat:NoMatch) :
            false
   ;Driver
   defn bad-bind (i:Int, v:() -> ?) : fatal("Unexpected binder")
   match-pat(pat, form, false, bad-bind)


;============================================================
;==================== Exceptions ============================
;============================================================

public deftype PatternException <: Exception

defn PatternException (msg) :
   new PatternException :
      defmethod print (o:OutputStream, this) : print(o, msg)