;See License.txt for details about licensing.

defpackage collections :
  import core

;============================================================
;===================== Utilities ============================
;============================================================

;Sentinel object
deftype Sentinel
defn sentinel () : new Sentinel
defmethod print (o:OutputStream, s:Sentinel) : print(o, "XXX")

;Table Item Structure
defstruct TableItem<K,V> :
  hash: Int
  key: K
  value: V

defmethod print (o:OutputStream, i:TableItem) :
  print(o, "(%_) %~ => %~" % [hash(i), key(i), value(i)])

;Int Item Structure
defstruct IntItem<V> :
  key: Int
  value: V

defmethod print (o:OutputStream, i:IntItem) :
  print(o, "%~ => %~" % [key(i), value(i)])

;Set Item Structure
defstruct SetItem<K> :
  hash: Int
  key: K

defmethod print (o:OutputStream, x:SetItem) :
  print(o, "(%_) %_" % [hash(x), key(x)])

;Binary search
;Returns n such that the first n numbers in xs < v
defn bsearch<?T,?S> (less?: (T, S) -> True|False,
                     xs:Array<?T>,
                     n:Int,
                     v:?S) -> Int :
  ;All items with index less than i are known to be smaller than v.
  ;All items with index (i + n) or greater are known to be greater or equal to v.
  let loop (i:Int = 0, n:Int = n) :
    if n == 0 :
      i
    else :
      val m = n / 2
      if xs[i + m] < v : loop(i + m + 1, n - m - 1)
      else : loop(i, m)

defn bsearch (less?: (Int, Int) -> True|False, xs:IntArray, n:Int, v:Int) -> Int :
  ;All items with index less than i are known to be smaller than v.
  ;All items with index (i + n) or greater are known to be greater or equal to v.
  let loop (i:Int = 0, n:Int = n) :
    if n == 0 :
      i
    else :
      val m = n / 2
      if xs[i + m] < v : loop(i + m + 1, n - m - 1)
      else : loop(i, m)

;============================================================
;===================== Vectors ==============================
;============================================================

;                     Interface
;                     =========

public defstruct Vector<T> <: IndexedCollection<T> :
  size: Int with: (setter => set-size, init => 0)
  array: Array<T> with: (setter => set-array)
with:
  constructor => #Vector

public defn Vector<T> (cap:Int) -> Vector<T> :
  core/ensure-non-negative(String("capacity"), cap)
  #Vector<T>(Array<T>(cap))

public defmulti add<?T> (v:Vector<?T>, value:T) -> False
public defmulti add-all<?T> (v:Vector<?T>, vs:Seqable<T>) -> False
public defmulti clear (v:Vector) -> False
public defmulti clear<?T> (v:Vector<?T>, n:Int, x0:T) -> False
public defmulti pop<?T> (v:Vector<?T>) -> T
public defmulti peek<?T> (v:Vector<?T>) -> T

public defmulti remove<?T> (v:Vector<?T>, i:Int) -> T
public defmulti remove (v:Vector, r:Range) -> False
public defmulti update<?T> (f: T -> Maybe<T>, v:Vector<?T>) -> False
public defmulti remove-item<?T> (v:Vector<?T&Equalable>, x:T&Equalable) -> True|False
public defmulti remove-when<?T> (f: T -> True|False, v:Vector<?T>) -> False
public defmulti trim (v:Vector) -> False
public defmulti shorten (v:Vector, size:Int) -> False
public defmulti lengthen<?T> (v:Vector<?T>, size:Int, x:T) -> False
public defmulti set-length<?T> (v:Vector<?T>, length:Int, x:T) -> False

;                   Implementation
;                   ==============

defn set-capacity<?T> (v:Vector<?T>, c:Int) :
  val new-array = Array<T>(c)
  new-array[0 to size(v)] = array(v)
  set-array(v, new-array)

defn ensure-capacity<?T> (v:Vector<?T>, c:Int) :
  val cur-c = length(array(v))
  set-capacity(v, max(c, 2 * cur-c)) when c > cur-c

defmethod get<?T> (v:Vector<?T>, i:Int) :
  core/ensure-index-in-bounds(v, i)
  array(v)[i]

defmethod set<?T> (v:Vector<?T>, i:Int, value:T) :
  if i == size(v) :
    add(v, value)
  else :
    core/ensure-index-in-bounds(v, i)
    array(v)[i] = value

defmethod set-all<?T> (v:Vector<?T>, r:Range, x:T) :
  core/ensure-index-range(v, r)
  set-all(array(v), r, x)         

defmethod length (v:Vector) :
  size(v)

defmethod trim<?T> (v:Vector<?T>) :
  set-capacity(v, size(v))

defmethod set-length<?T> (v:Vector<?T>, len:Int, value:T) :
  if len > size(v) : lengthen(v, len, value)
  else : shorten(v, len)

defmethod shorten<?T> (v:Vector<?T>, new-size:Int) :
  #if-not-defined(OPTIMIZE) :
    core/ensure-non-negative("size", new-size)
    if new-size > size(v) :
      fatal("Given size (%_) is larger than current size (%_)." % [new-size, size(v)])
  set-size(v, new-size)

defmethod lengthen<?T> (v:Vector<?T>, new-size:Int, x:T) :
  #if-not-defined(OPTIMIZE) :
    if new-size < size(v) :
      fatal("Given size (%_) is smaller than current size (%_)." % [new-size, size(v)])
  ensure-capacity(v, new-size)
  set-all(array(v), size(v) to new-size, x)
  set-size(v, new-size)

defmethod add<?T> (v:Vector<?T>, value:T) :
  val sz = size(v)
  ensure-capacity(v, sz + 1)
  array(v)[sz] = value
  set-size(v, sz + 1)

defmethod add-all<?T> (v:Vector<?T>, vs:Seqable<T>) :
  match(vs) :
    (vs:Seqable<T> & Lengthable) :
      val n = length(vs)
      ensure-capacity(v, size(v) + n)
      array(v)[size(v) to (size(v) + n)] = vs
      set-size(v, size(v) + n)
    (vs) :
      do(add{v, _}, vs)

defmethod pop<?T> (v:Vector<?T>) :
  #if-not-defined(OPTIMIZE) :
    fatal("Empty Vector") when size(v) == 0
  set-size(v, size(v) - 1)
  array(v)[size(v)]

defmethod peek<?T> (v:Vector<?T>) :
  #if-not-defined(OPTIMIZE) :
    fatal("Empty Vector") when size(v) == 0
  array(v)[size(v) - 1]

defmethod clear (v:Vector) :
  set-size(v, 0)

defmethod clear<?T> (v:Vector<?T>, n:Int, x0:T) :
  if length(array(v)) < n :
    val cap = max(n, 2 * length(array(v)))
    set-array(v, Array<T>(cap, x0))
    set-size(v, n)
  else :
    set-all(array(v), 0 to n, x0)
    set-size(v, n)

defmethod remove-when<?T> (f: T -> True|False, v:Vector<?T>) :
  for x in v update :
    if f(x) : None()
    else : One(x)

defmethod remove<?T> (v:Vector<?T>, i:Int) :
  core/ensure-index-in-bounds(v, i)
  val a = array(v)
  val x = a[i]
  for i in i to (size(v) - 1) do :
    a[i] = a[i + 1]
  set-size(v, size(v) - 1)
  x

defmethod remove<?T> (v:Vector<?T>, r:Range) :
  core/ensure-index-range(v, r)
  val [s,e] = core/range-bound(v, r)
  val n = e - s
  val a = array(v)
  val sz = size(v)
  if n > 0 :
    for i in s to (sz - n) do :
      a[i] = a[i + n]
    set-size(v, sz - n)

defmethod remove-item<?T> (v:Vector<?T&Equalable>, x:T&Equalable) :
  match(index-of(v, x)) :
    (i:Int) : (remove(v, i), true)
    (i:False) : false

defmethod update<?T> (f: T -> Maybe<T>, v:Vector<?T>) :
  val a = array(v)
  let loop (dst:Int = 0, src:Int = 0) :
    if src < size(v) :
      match(f(a[src])) :
        (x:One<T>) :
          a[dst] = value(x)
          loop(dst + 1, src + 1)
        (x:None) :
          loop(dst, src + 1)
    else :
      set-size(v, dst)

defmethod do<?T> (f: T -> ?, v:Vector<?T>) :
 val n = size(v)
 val a = array(v)
 let loop (i:Int = 0) :
   if i < n :
     f(a[i])
     loop(i + 1)

public defn update<?T> (v:Vector<?T>, f: T -> Maybe<T>) -> False :
  update(f,v)

public defn remove-when<?T> (v:Vector<?T>, f: T -> True|False) -> False :
  remove-when(f,v)

public defn Vector<T> () -> Vector<T> :
   Vector<T>(8)

public defn to-vector<T> (xs:Seqable<T>) -> Vector<T> :
   val v = Vector<T>()
   add-all(v, xs)
   v

public defn map<R,?T> (v:Vector<?T>, f: T -> R) -> Vector<R> :
  map<R>(f, v)

public defn map<R,?T> (f: T -> R, v:Vector<?T>) -> Vector<R> :
   val ret = Vector<R>(length(v))
   add-all(ret, seq(f, v))
   ret

;==================================
;======== Printer / Writer ========
;==================================

defmethod print (o:OutputStream, v:Vector) :
  print(o, "Vector(%,)" % [seq(written,v)])

;============================================================
;====================== Queues ==============================
;============================================================

;                      Interface
;                      =========

public defmulti add<?T> (q:Queue<?T>, x:T) -> False
public defmulti clear (q:Queue) -> False
public defmulti pop<?T> (q:Queue<?T>) -> T
public defmulti peek<?T> (q:Queue<?T>) -> T

;                    Implementation
;                    ==============

public defstruct Queue<T> <: IndexedCollection<T> :
  cap:Int with: (setter => set-cap)
  array:Array<T> with: (setter => set-array, init => Array<T>(cap))
  begin:Int with: (setter => set-begin, init => 0)
  size:Int with: (setter => set-size, init => 0)
with:
  constructor => #Queue

public defn Queue<T> (initial-cap:Int) -> Queue<T> :
  core/ensure-non-negative("capacity", initial-cap)
  #Queue<T>(next-pow2(initial-cap))

defn ensure-capacity<?T> (q:Queue<?T>, c:Int) :
  defn set-capacity (c:Int) :
    val new-array = Array<T>(c)
    for i in 0 to size(q) do :
      new-array[i] = array(q)[wrapped-index(q, i)]
    set-array(q, new-array)
    set-cap(q, c)
    set-begin(q, 0)
  set-capacity(next-pow2(c)) when c > cap(q)

defn wrapped-index (q:Queue, i:Int) :
  (begin(q) + i) & (cap(q) - 1)

defmethod get<?T> (q:Queue<?T>, i:Int) :
  core/ensure-index-in-bounds(q, i)
  array(q)[wrapped-index(q, i)]

defmethod set<?T> (q:Queue<?T>, i:Int, value:T) :
  if i == -1 :
    add(q, value)
  else :
    core/ensure-index-in-bounds(q, i)
    array(q)[wrapped-index(q, i)] = value

defmethod add<?T> (q:Queue<?T>, x:T) :
  ensure-capacity(q, size(q) + 1)
  set-begin(q, wrapped-index(q, -1 + cap(q)))
  array(q)[begin(q)] = x
  set-size(q, size(q) + 1)

defmethod pop (q:Queue) :
  #if-not-defined(OPTIMIZE) :
    fatal("Empty Queue") when size(q) == 0
  set-size(q, size(q) - 1)
  array(q)[wrapped-index(q, size(q))]

defmethod peek (q:Queue) :
  #if-not-defined(OPTIMIZE) :
    fatal("Empty Queue") when size(q) == 0
  array(q)[wrapped-index(q, size(q) - 1)]

defmethod length (q:Queue) :
  size(q)

defmethod clear (q:Queue) :
  set-size(q, 0)

public defn Queue<T> () -> Queue<T> :
  Queue<T>(8)

;==================================
;======== Printer / Writer ========
;==================================

defmethod print (o:OutputStream, q:Queue) :
  print(o, "Queue(%,)" % [seq(written,q)])

;============================================================
;======================== Tables ============================
;============================================================

;==============================
;==== Mandatory Operations ====
;==============================

public deftype Table<K,V> <: Collection<KeyValue<K,V>> & Lengthable & HasContents
public defmulti set<?K,?V> (t:Table<?K,?V>, k:K, v:V) -> False
public defmulti get?<?K,?V> (t:Table<?K,?V>, k:K, d:?V) -> V
public defmulti default<?K,?V> (t:Table<?K,?V>, k:K) -> V
public defmulti remove<?K> (t:Table<?K,?>, k:K) -> True|False
public defmulti clear (t:Table) -> False

;=============================
;==== Abstract Operations ====
;=============================

public defmulti key?<?K> (t:Table<?K,?>, k:K) -> True|False
public defmulti get<?K,?V> (t:Table<?K,?V>, k:K) -> V
public defmulti update<?K,?V> (t:Table<?K,?V>, f:V -> V, k:K) -> V
public defmulti keys<?K> (t:Table<?K,?>) -> Seqable<K>
public defmulti values<?V> (t:Table<?,?V>) -> Seqable<V>
public defmulti set?<?K,?V> (t:Table<?K,?V>, k:K, f:() -> V) -> V
public defmulti map!<?K,?V> (f:KeyValue<K,V> -> V, t:Table<?K,?V>) -> False

;==================================
;==== Abstract Implementations ====
;==================================
defmethod key?<?K> (t:Table<?K,?>, k:K) :
  get?(t, k, sentinel()) is-not Sentinel
  
defmethod get<?K,?V> (t:Table<?K,?V>, k:K) -> V :
  match(get?(t, k, sentinel())) :
    (v:Sentinel) : default(t, k)
    (v:V) : v

defmethod update<?K,?V> (t:Table<?K,?V>, f:V -> V, k:K) -> V :
  val v* = f(t[k])
  t[k] = v*
  v*

defmethod set?<?K,?V> (t:Table<?K,?V>, k:K, f:() -> V) -> V :
  match(get?(t, k, sentinel())) :
    (v:Sentinel) :
      val v* = f()
      t[k] = v*
      v*
    (v:V) :
      v

defmethod keys<?K> (t:Table<?K,?>) :
  seq(key, t)

defmethod values<?V> (t:Table<?,?V>) :
  seq(value, t)

public defn get?<?K,?V> (t:Table<?K,?V>, k:K) :
  get?(t, k, false)

public defn empty? (t:Table) :
  length(t) == 0

defmethod map!<?K,?V> (f:KeyValue<K,V> -> V, t:Table<?K,?V>) :
  for entry in t do :
    t[key(entry)] = f(entry)

public defn set-all<?K,?V> (t:Table<?K,?V>, ks:Seqable<K>, vs:Seqable<V>) :
  for (k in ks, v in vs) do :
    t[k] = v

defmethod same-contents? (a:Table, b:Table) :
  if length(a) == length(b) :
    for entry in b all? :
      val bkey = key(entry)
      val bval = value(entry)
      if key?(a, bkey) :
        val aval = a[bkey]
        same-contents?(aval, bval)

;============================================================
;====================== HashTables ==========================
;============================================================

public deftype HashTable<K,V> <: Table<K,V>

public defn HashTable<K,V> (cap0:Int
                            key-hash: K -> Int
                            key-equal?: (K,K) -> True|False
                            default: K -> V,
                            create-on-default:True|False) :
  ;=====================
  ;==== Table State ====
  ;=====================
  var cap
  var limit
  var mask
  var slots
  var sizes
  var size

  defn init (c:Int) :
    cap = c
    limit = c * 3 / 4
    mask = cap - 1
    slots = Array<Sentinel|TableItem<K,V>|Array<TableItem<K,V>>>(cap, sentinel())
    sizes = IntArray(cap, 0)
    size = 0

  defn clear () :
    size = 0
    set-all(slots, 0 to false, sentinel())

  init(next-pow2(max(8, cap0)))

  ;===================
  ;==== Utilities ====
  ;===================
  defn loc (h:Int) :
    h & mask

  ;Matching predicate for TableItem
  defn match? (a:TableItem<K,V>, h:Int, k:K) :
    hash(a) == h and
    key-equal?(key(a), k)
  defn match? (a:TableItem<K,V>, b:TableItem<K,V>) :
    match?(a, hash(b), key(b))

  ;Find number of items whose hash is less than h
  defn num-before (xs:Array<TableItem<K,V>>, n:Int, h:Int) :
    bsearch({hash(_) < _}, xs, n, h)

  ;Look for item with given hash and key starting from i
  defn* index-of-item (xs:Array<TableItem<K,V>>, i:Int, n:Int, h:Int, k:K) :
    if i < n :
      val x = xs[i]
      if hash(x) == h :
        if key-equal?(key(x), k) : i
        else : index-of-item(xs, i + 1, n, h, k)

  ;Shift items in xs from i to n right by one element
  defn* shift-right (xs:Array<TableItem<K,V>>, i:Int, n:Int) :
    for j in n to i by -1 do :
      xs[j] = xs[j - 1]

  ;Shift items in xs from (i + 1) to n left by one element
  defn* shift-left (xs:Array<TableItem<K,V>>, i:Int, n:Int) :
    for j in i to (n - 1) do :
      xs[j] = xs[j + 1]    

  ;Copy to new array with hole in position i
  defn* copy-with-hole (xs:Array<TableItem<K,V>>, i:Int, n:Int) :
    val xs* = Array<TableItem<K,V>>(length(xs) * 2)
    xs*[0 to i] = xs[0 to i]
    xs*[(i + 1) to (n + 1)] = xs[i to n]
    xs*

  ;==========================
  ;==== Entry Operations ====
  ;==========================
  defn increment-size () :
    size = size + 1
    increase-capacity() when size >= limit
    
  defn decrement-size () :
    size = size - 1

  defn increase-capacity () :
    val items = sequence({_})
    init(cap * 2)
    do(put, items)

  defn create-bucket (slot:Int, x0:TableItem<K,V>, x1:TableItem<K,V>) :
    val bucket = Array<TableItem<K,V>>(4)
    slots[slot] = bucket
    sizes[slot] = 2
    ;Populate bucket
    if hash(x0) < hash(x1) :
      ;Add in front
      bucket[0] = x0
      bucket[1] = x1
    else :
      ;Add in back
      bucket[0] = x1
      bucket[1] = x0

  defn add-to-bucket (slot:Int, bucket:Array<TableItem<K,V>>, i:Int, n:Int, x:TableItem<K,V>) :
    ;Case 1 of 2: Bucket has space.
    if n + 1 < length(bucket) :
      shift-right(bucket, i, n)
      bucket[i] = x
    ;Case 2 of 2: Bucket is full.
    else :
      val bucket* = copy-with-hole(bucket, i, n)
      slots[slot] = bucket*
      bucket*[i] = x
    sizes[slot] = n + 1

  ;=======================
  ;==== Put Operation ====
  ;=======================
  defn put (x:TableItem<K,V>) :
    val slot = loc(hash(x))
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        ;New Entry
        slots[slot] = x
        increment-size()
      ;Case 2 of 3: Single item bucket
      (s:TableItem<K,V>) :
        ;Case 1 of 2: Item matches
        if match?(s,x) :
          ;Replace Entry
          slots[slot] = x
        ;Case 2 of 2: Add Item
        else :
          create-bucket(slot, s, x)
          increment-size()
      ;Case 3 of 3: Multiple item bucket
      (s:Array<TableItem<K,V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, hash(x))
        match(index-of-item(s, i, n, hash(x), key(x))) :
          ;Case 1 of 2: Item exists in bucket
          (idx:Int) :
            s[idx] = x
          ;Case 2 of 2: Add new item to bucket
          (idx:False) :
            add-to-bucket(slot, s, i, n, x)
            increment-size()

  ;===========================
  ;==== Lookup? Operation ====
  ;===========================
  defn lookup?<?D> (k:K, default:?D) :
    val h = key-hash(k)
    val slot = loc(h)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        default
      ;Case 2 of 3: Single item bucket
      (s:TableItem<K,V>) :
        ;Case 1 of 2: Item matches
        if match?(s,h,k) : value(s)
        else : default
      ;Case 3 of 3: Multiple item bucket
      (s:Array<TableItem<K,V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, h)
        match(index-of-item(s, i, n, h, k)) :
          (idx:Int) : value(s[idx])
          (idx:False) : default

  ;==========================
  ;==== Lookup Operation ====
  ;==========================
  defn lookup (k:K) :
    val h = key-hash(k)
    defn item (v:V) : TableItem<K,V>(h,k,v)
    val slot = loc(h)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        val v = default(k)
        if create-on-default :
          slots[slot] = item(v)
          increment-size()
        v
      ;Case 2 of 3: Single item bucket
      (s:TableItem<K,V>) :
        ;Case 1 of 2: Item matches
        if match?(s,h,k) :
          value(s)
        else :
          val v = default(k)
          if create-on-default :
            create-bucket(slot, s, item(v))
            increment-size()
          v          
      ;Case 3 of 3: Multiple item bucket
      (s:Array<TableItem<K,V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, h)
        match(index-of-item(s, i, n, h, k)) :
          (idx:Int) :
            value(s[idx])
          (idx:False) :
            val v = default(k)
            if create-on-default :
              add-to-bucket(slot, s, i, n, item(v))
              increment-size()
            v

  ;==========================
  ;==== Update Operation ====
  ;==========================
  defn update (f:V -> V, k:K) :
    val h = key-hash(k)
    defn item (v:V) : TableItem<K,V>(h,k,v)
    val slot = loc(h)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        val v = f(default(k))
        slots[slot] = item(v)
        increment-size()
        v
      ;Case 2 of 3: Single item bucket
      (s:TableItem<K,V>) :
        ;Case 1 of 2: Item matches
        if match?(s,h,k) :
          val v = f(value(s))
          slots[slot] = item(v)
          v
        else :
          val v = f(default(k))
          create-bucket(slot, s, item(v))
          increment-size()
          v
      ;Case 3 of 3: Multiple item bucket
      (s:Array<TableItem<K,V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, h)
        match(index-of-item(s, i, n, h, k)) :
          (idx:Int) :
            val v = f(value(s[idx]))
            s[idx] = item(v)
            v
          (idx:False) :
            val v = f(default(k))
            add-to-bucket(slot, s, i, n, item(v))
            increment-size()
            v

  ;========================
  ;==== Key? Operation ====
  ;========================
  defn key? (k:K) :
    val h = key-hash(k)
    val slot = loc(h)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) : false
      ;Case 2 of 3: Single item bucket
      (s:TableItem<K,V>) : match?(s,h,k)
      ;Case 3 of 3: Multiple item bucket
      (s:Array<TableItem<K,V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, h)
        index-of-item(s, i, n, h, k) is Int

  ;==========================
  ;==== Remove Operation ====
  ;==========================
  defn remove (k:K) :
    val h = key-hash(k)
    val slot = loc(h)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        false
      ;Case 2 of 3: Single item bucket
      (s:TableItem<K,V>) :
        if match?(s,h,k) :
          slots[slot] = sentinel()
          decrement-size()
          true
      ;Case 3 of 3: Multiple item bucket
      (s:Array<TableItem<K,V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, h)
        match(index-of-item(s, i, n, h, k)) :
          (idx:False) : false
          (idx:Int) :
            shift-left(s, idx, n)
            sizes[slot] = n - 1
            decrement-size()
            true

  ;========================
  ;==== Map! Operation ====
  ;========================
  defn map! (f:KeyValue<K,V> -> V) :
    for (slot in slots, idx in 0 to false) do :
      match(slot) :
        ;Case 1 of 3: Unoccupied bucket
        (s:Sentinel) :
          false
        ;Case 2 of 3: Single item bucket
        (s:TableItem<K,V>) :
          val v = f(key(s) => value(s))
          slots[idx] = TableItem<K,V>(hash(s), key(s), v)
        ;Case 3 of 3: Multiple item bucket
        (s:Array<TableItem<K,V>>) :
          val n = sizes[idx]
          for i in 0 to n do :
            val x = s[i]
            val v = f(key(x) => value(x))
            s[i] = TableItem<K,V>(hash(x), key(x), v)

  ;=============================
  ;==== Iteration Operation ====
  ;=============================
  defn sequence<?T> (f:TableItem<K,V> -> ?T) :
    val sizes = sizes
    val slots = slots
    generate<T> :
      for idx in 0 to length(slots) do :
        match(slots[idx]) :
          (s:Sentinel) : false
          (s:TableItem<K,V>) : yield(f(s))
          (s:Array<TableItem<K,V>>) : for j in 0 to sizes[idx] do : yield(f(s[j]))

  ;======================
  ;==== Table Object ====
  ;======================
  new HashTable<K,V> :
    defmethod set (this, k:K, v:V) :
      put(TableItem<K,V>(key-hash(k), k, v))
    defmethod get?<?D> (this, k:K, d:?D) :
      lookup?(k, d)
    defmethod get (this, k:K) :
      lookup(k)
    defmethod remove (this, k:K) :
      remove(k)
    defmethod clear (this) :
      clear()
    defmethod key? (this, k:K) :
      key?(k)
    defmethod update (this, f:V -> V, k:K) :
      update(f, k)
    defmethod map! (f:KeyValue<K,V> -> V, this) :
      map!(f)
    defmethod to-seq (this) :
      defn make-entry (x:TableItem<K,V>) : key(x) => value(x)
      sequence(make-entry)
    defmethod keys (this) :
      sequence(key)
    defmethod values (this) :
      sequence(value)
    defmethod length (this) :
      size
    defmethod default (this, k:K) :
      val v = default(k)
      if create-on-default : this[k] = v
      v

;==================================
;==== Convenience Constructors ====
;==================================

;Trivial default function which just throws a RuntimeError.
defn no-such-key (k) -> Void :
  throw(MissingTableKey(k))

public defn HashTable<K,V> (initial-cap:Int, hash: K -> Int, equal?: (K,K) -> True|False) :
  HashTable<K,V>(initial-cap, hash, equal?, no-such-key, false)

public defn HashTable<K,V> (hash: K -> Int, equal?: (K,K) -> True|False) :
  HashTable<K,V>(8, hash, equal?, no-such-key, false)

public defn HashTable<K,V> () -> HashTable<K,V> :
  HashTable<K&Hashable&Equalable,V>(8, hash, equal?, no-such-key, false)

public defn HashTable<K,V> (default:V) -> HashTable<K,V> :
  HashTable<K&Hashable&Equalable,V>(8, hash, equal?, {default}, false)

public defn HashTable<K,V> (hash: K -> Int,
                            equal?: (K,K) -> True|False,
                            default:V) ->
                            HashTable<K,V> :
  HashTable<K,V>(8, hash, equal?, {default}, false)

public defn HashTable-init<K,V> (init: K -> V) -> HashTable<K,V> :
  HashTable<K&Hashable&Equalable,V>(8, hash, equal?, init, true)

public defn HashTable-init<K,V> (hash: K -> Int,
                                 equal?: (K,K) -> True|False,
                                 init: K -> V) ->
                                 HashTable<K,V> :
  HashTable<K,V>(8, hash, equal?, init, true)

public defn to-hashtable<K,V> (es:Seqable<KeyValue<K,V>>) -> HashTable<K,V> :
  val t = HashTable<K,V>()
  for e in es do :
    t[key(e)] = value(e)
  t

public defn to-hashtable<K,V> (ks:Seqable<K>, vs:Seqable<V>) -> HashTable<K,V> :
  val t = HashTable<K,V>()
  set-all(t, ks, vs)
  t

;==================================
;======== Printer / Writer ========
;==================================

defmethod print (o:OutputStream, t:HashTable) :
  print(o, "HashTable(")
  for entry in t do :
    lnprint(o, Indented(entry))
  print(o, ")")

;============================================================
;===================== Int Tables ===========================
;============================================================

public deftype IntTable<V> <: Table<Int,V>

public defn IntTable<V> (cap0:Int
                         default: Int -> V,
                         create-on-default:True|False) :
  ;=====================
  ;==== Table State ====
  ;=====================
  var cap
  var limit
  var mask
  var slots
  var sizes
  var size

  defn init (c:Int) :
    cap = c
    limit = c * 3 / 4
    mask = cap - 1
    slots = Array<Sentinel|IntItem<V>|Array<IntItem<V>>>(cap, sentinel())
    sizes = IntArray(cap, 0)
    size = 0

  defn clear () :
    size = 0
    set-all(slots, 0 to false, sentinel())

  init(next-pow2(max(8, cap0)))

  ;===================
  ;==== Utilities ====
  ;===================
  defn loc (h:Int) :
    h & mask

  ;Matching predicate for IntItem
  defn match? (a:IntItem<V>, k:Int) :
    key(a) == k
  defn match? (a:IntItem<V>, b:IntItem<V>) :
    match?(a, key(b))

  ;Find number of items whose hash is less than h
  defn num-before (xs:Array<IntItem<V>>, n:Int, k:Int) :
    bsearch({key(_) < _}, xs, n, k)

  ;Look for item with given hash and key starting from i
  defn* index-of-item (xs:Array<IntItem<V>>, i:Int, n:Int, k:Int) :
    if i < n :
      val x = xs[i]
      if key(x) == k : i

  ;Shift items in xs from i to n right by one element
  defn* shift-right (xs:Array<IntItem<V>>, i:Int, n:Int) :
    for j in n to i by -1 do :
      xs[j] = xs[j - 1]

  ;Shift items in xs from (i + 1) to n left by one element
  defn* shift-left (xs:Array<IntItem<V>>, i:Int, n:Int) :
    for j in i to (n - 1) do :
      xs[j] = xs[j + 1]    

  ;Copy to new array with hole in position i
  defn* copy-with-hole (xs:Array<IntItem<V>>, i:Int, n:Int) :
    val xs* = Array<IntItem<V>>(length(xs) * 2)
    xs*[0 to i] = xs[0 to i]
    xs*[(i + 1) to (n + 1)] = xs[i to n]
    xs*

  ;==========================
  ;==== Entry Operations ====
  ;==========================
  defn increment-size () :
    size = size + 1
    increase-capacity() when size >= limit
    
  defn decrement-size () :
    size = size - 1

  defn increase-capacity () :
    val items = sequence({_})
    init(cap * 2)
    do(put, items)

  defn create-bucket (slot:Int, x0:IntItem<V>, x1:IntItem<V>) :
    val bucket = Array<IntItem<V>>(4)
    slots[slot] = bucket
    sizes[slot] = 2
    ;Populate bucket
    if key(x0) < key(x1) :
      ;Add in front
      bucket[0] = x0
      bucket[1] = x1
    else :
      ;Add in back
      bucket[0] = x1
      bucket[1] = x0

  defn add-to-bucket (slot:Int, bucket:Array<IntItem<V>>, i:Int, n:Int, x:IntItem<V>) :
    ;Case 1 of 2: Bucket has space.
    if n + 1 < length(bucket) :
      shift-right(bucket, i, n)
      bucket[i] = x
    ;Case 2 of 2: Bucket is full.
    else :
      val bucket* = copy-with-hole(bucket, i, n)
      slots[slot] = bucket*
      bucket*[i] = x
    sizes[slot] = n + 1

  ;=======================
  ;==== Put Operation ====
  ;=======================
  defn put (x:IntItem<V>) :
    val slot = loc(key(x))
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        ;New Entry
        slots[slot] = x
        increment-size()
      ;Case 2 of 3: Single item bucket
      (s:IntItem<V>) :
        ;Case 1 of 2: Item matches
        if match?(s,x) :
          ;Replace Entry
          slots[slot] = x
        ;Case 2 of 2: Add Item
        else :
          create-bucket(slot, s, x)
          increment-size()
      ;Case 3 of 3: Multiple item bucket
      (s:Array<IntItem<V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, key(x))
        match(index-of-item(s, i, n, key(x))) :
          ;Case 1 of 2: Item exists in bucket
          (idx:Int) :
            s[idx] = x
          ;Case 2 of 2: Add new item to bucket
          (idx:False) :
            add-to-bucket(slot, s, i, n, x)
            increment-size()

  ;===========================
  ;==== Lookup? Operation ====
  ;===========================
  defn lookup?<?D> (k:Int, default:?D) :
    val slot = loc(k)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        default
      ;Case 2 of 3: Single item bucket
      (s:IntItem<V>) :
        ;Case 1 of 2: Item matches
        if match?(s,k) : value(s)
        else : default
      ;Case 3 of 3: Multiple item bucket
      (s:Array<IntItem<V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, k)
        match(index-of-item(s, i, n, k)) :
          (idx:Int) : value(s[idx])
          (idx:False) : default

  ;==========================
  ;==== Lookup Operation ====
  ;==========================
  defn lookup (k:Int) :
    defn item (v:V) : IntItem<V>(k,v)
    val slot = loc(k)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        val v = default(k)
        if create-on-default :
          slots[slot] = item(v)
          increment-size()
        v
      ;Case 2 of 3: Single item bucket
      (s:IntItem<V>) :
        ;Case 1 of 2: Item matches
        if match?(s,k) :
          value(s)
        else :
          val v = default(k)
          if create-on-default :
            create-bucket(slot, s, item(v))
            increment-size()
          v          
      ;Case 3 of 3: Multiple item bucket
      (s:Array<IntItem<V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, k)
        match(index-of-item(s, i, n, k)) :
          (idx:Int) :
            value(s[idx])
          (idx:False) :
            val v = default(k)
            if create-on-default :
              add-to-bucket(slot, s, i, n, item(v))
              increment-size()
            v

  ;==========================
  ;==== Update Operation ====
  ;==========================
  defn update (f:V -> V, k:Int) :
    defn item (v:V) : IntItem<V>(k,v)
    val slot = loc(k)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        val v = f(default(k))
        slots[slot] = item(v)
        increment-size()
        v
      ;Case 2 of 3: Single item bucket
      (s:IntItem<V>) :
        ;Case 1 of 2: Item matches
        if match?(s,k) :
          val v = f(value(s))
          slots[slot] = item(v)
          v
        else :
          val v = f(default(k))
          create-bucket(slot, s, item(v))
          increment-size()
          v
      ;Case 3 of 3: Multiple item bucket
      (s:Array<IntItem<V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, k)
        match(index-of-item(s, i, n, k)) :
          (idx:Int) :
            val v = f(value(s[idx]))
            s[idx] = item(v)
            v
          (idx:False) :
            val v = f(default(k))
            add-to-bucket(slot, s, i, n, item(v))
            increment-size()
            v

  ;========================
  ;==== Key? Operation ====
  ;========================
  defn key? (k:Int) :
    val slot = loc(k)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) : false
      ;Case 2 of 3: Single item bucket
      (s:IntItem<V>) : match?(s,k)
      ;Case 3 of 3: Multiple item bucket
      (s:Array<IntItem<V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, k)
        index-of-item(s, i, n, k) is Int

  ;==========================
  ;==== Remove Operation ====
  ;==========================
  defn remove (k:Int) :
    val slot = loc(k)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        false
      ;Case 2 of 3: Single item bucket
      (s:IntItem<V>) :
        if match?(s,k) :
          slots[slot] = sentinel()
          decrement-size()
          true
      ;Case 3 of 3: Multiple item bucket
      (s:Array<IntItem<V>>) :
        val n = sizes[slot]
        val i = num-before(s, n, k)
        match(index-of-item(s, i, n, k)) :
          (idx:False) : false
          (idx:Int) :
            shift-left(s, idx, n)
            sizes[slot] = n - 1
            decrement-size()
            true

  ;========================
  ;==== Map! Operation ====
  ;========================
  defn map! (f:KeyValue<Int,V> -> V) :
    for (slot in slots, idx in 0 to false) do :
      match(slot) :
        ;Case 1 of 3: Unoccupied bucket
        (s:Sentinel) :
          false
        ;Case 2 of 3: Single item bucket
        (s:IntItem<V>) :
          val v = f(key(s) => value(s))
          slots[idx] = IntItem<V>(key(s), v)
        ;Case 3 of 3: Multiple item bucket
        (s:Array<IntItem<V>>) :
          val n = sizes[idx]
          for i in 0 to n do :
            val x = s[i]
            val v = f(key(x) => value(x))
            s[i] = IntItem<V>(key(x), v)

  ;=============================
  ;==== Iteration Operation ====
  ;=============================
  defn sequence<?T> (f:IntItem<V> -> ?T) :
    val sizes = sizes
    val slots = slots
    generate<T> :
      for idx in 0 to length(slots) do :
        match(slots[idx]) :
          (s:Sentinel) : false
          (s:IntItem<V>) : yield(f(s))
          (s:Array<IntItem<V>>) : for j in 0 to sizes[idx] do : yield(f(s[j]))

  ;======================
  ;==== Table Object ====
  ;======================
  new IntTable<V> :
    defmethod set (this, k:Int, v:V) :
      put(IntItem<V>(k, v))
    defmethod get?<?D> (this, k:Int, d:?D) :
      lookup?(k, d)
    defmethod get (this, k:Int) :
      lookup(k)
    defmethod remove (this, k:Int) :
      remove(k)
    defmethod clear (this) :
      clear()
    defmethod key? (this, k:Int) :
      key?(k)
    defmethod update (this, f:V -> V, k:Int) :
      update(f, k)
    defmethod map! (f:KeyValue<Int,V> -> V, this) :
      map!(f)
    defmethod to-seq (this) :
      defn make-entry (x:IntItem<V>) : key(x) => value(x)
      sequence(make-entry)
    defmethod keys (this) :
      sequence(key)
    defmethod values (this) :
      sequence(value)
    defmethod length (this) :
      size
    defmethod default (this, k:Int) :
      val v = default(k)
      if create-on-default : this[k] = v
      v

;==================================
;==== Convenience Constructors ====
;==================================
public defn IntTable<V> () :
  IntTable<V>(8, no-such-key, false)

public defn IntTable<V> (default:V) :
  IntTable<V>(8, {default}, false)

public defn IntTable-init<V> (init: Int -> V) :
  IntTable<V>(8, init, true)

public defn to-inttable<V> (es:Seqable<KeyValue<Int,V>>) -> IntTable<V> :
  val t = IntTable<V>()
  for e in es do :
    t[key(e)] = value(e)
  t

public defn to-inttable<V> (ks:Seqable<Int>, vs:Seqable<V>) -> IntTable<V> :
  val t = IntTable<V>()
  set-all(t, ks, vs)
  t

;==================================
;======== Printer / Writer ========
;==================================

defmethod print (o:OutputStream, t:IntTable) :
  print(o, "IntTable(")
  for entry in t do :
    lnprint(o, Indented(entry))
  print(o, ")")

;============================================================
;======================== Sets ==============================
;============================================================

;==============================
;==== Mandatory Operations ====
;==============================

public deftype Set<K> <: Collection<K> & Lengthable & HasContents
public defmulti add<?K> (s:Set<?K>, k:K) -> True|False
public defmulti remove<?K> (s:Set<?K>, k:K) -> True|False
public defmulti get<?K> (s:Set<?K>, k:K) -> True|False
public defmulti clear (s:Set) -> False

;==================================
;==== Abstract Implementations ====
;==================================
public defn empty? (s:Set) :
  length(s) == 0

public defmulti add-all<?K> (s:Set<?K>, ks:Seqable<K>) -> False
defmethod add-all<?K> (s:Set<?K>, ks:Seqable<K>) :
  for k in ks do : add(s, k)

defmethod same-contents? (a:Set, b:Set) :
  length(a) == length(b) and all?({a[_]}, b)

;============================================================
;====================== HashSets ============================
;============================================================

public deftype HashSet<K> <: Set<K>

public defn HashSet<K> (cap0:Int
                        key-hash: K -> Int
                        key-equal?: (K,K) -> True|False) :
  ;=====================
  ;==== Table State ====
  ;=====================
  var cap
  var limit
  var mask
  var slots
  var sizes
  var size

  defn init (c:Int) :
    cap = c
    limit = c * 3 / 4
    mask = cap - 1
    slots = Array<Sentinel|SetItem<K>|Array<SetItem<K>>>(cap, sentinel())
    sizes = IntArray(cap, 0)
    size = 0

  defn clear () :
    size = 0
    set-all(slots, 0 to false, sentinel())

  init(next-pow2(max(8, cap0)))

  ;===================
  ;==== Utilities ====
  ;===================
  defn set-item (k:K) :
    SetItem<K>(key-hash(k), k)
    
  defn loc (h:Int) :
    h & mask

  ;Matching predicate for TableItem
  defn match? (a:SetItem<K>, b:SetItem<K>) :
    hash(a) == hash(b) and
    key-equal?(key(a), key(b))

  ;Find number of items whose hash is less than h
  defn num-before (xs:Array<SetItem<K>>, n:Int, x:SetItem<K>) :
    bsearch({hash(_) < hash(_)}, xs, n, x)

  ;Look for item with given hash and key starting from i
  defn* index-of-item (xs:Array<SetItem<K>>, i:Int, n:Int, y:SetItem<K>) :
    if i < n :
      val x = xs[i]
      if hash(x) == hash(y) :
        if key-equal?(key(x), key(y)) : i
        else : index-of-item(xs, i + 1, n, y)

  ;Shift items in xs from i to n right by one element
  defn* shift-right (xs:Array<SetItem<K>>, i:Int, n:Int) :
    for j in n to i by -1 do :
      xs[j] = xs[j - 1]

  ;Shift items in xs from (i + 1) to n left by one element
  defn* shift-left (xs:Array<SetItem<K>>, i:Int, n:Int) :
    for j in i to (n - 1) do :
      xs[j] = xs[j + 1]    

  ;Copy to new array with hole in position i
  defn* copy-with-hole (xs:Array<SetItem<K>>, i:Int, n:Int) :
    val xs* = Array<SetItem<K>>(length(xs) * 2)
    xs*[0 to i] = xs[0 to i]
    xs*[(i + 1) to (n + 1)] = xs[i to n]
    xs*

  ;==========================
  ;==== Entry Operations ====
  ;==========================
  defn increment-size () :
    size = size + 1
    increase-capacity() when size >= limit
    
  defn decrement-size () :
    size = size - 1

  defn increase-capacity () :
    val items = sequence({_})
    init(cap * 2)
    do(put, items)

  defn create-bucket (slot:Int, x0:SetItem<K>, x1:SetItem<K>) :
    val bucket = Array<SetItem<K>>(4)
    slots[slot] = bucket
    sizes[slot] = 2
    ;Populate bucket
    if hash(x0) < hash(x1) :
      ;Add in front
      bucket[0] = x0
      bucket[1] = x1
    else :
      ;Add in back
      bucket[0] = x1
      bucket[1] = x0

  defn add-to-bucket (slot:Int, bucket:Array<SetItem<K>>, i:Int, n:Int, x:SetItem<K>) :
    ;Case 1 of 2: Bucket has space.
    if n + 1 < length(bucket) :
      shift-right(bucket, i, n)
      bucket[i] = x
    ;Case 2 of 2: Bucket is full.
    else :
      val bucket* = copy-with-hole(bucket, i, n)
      slots[slot] = bucket*
      bucket*[i] = x
    sizes[slot] = n + 1

  ;=======================
  ;==== Put Operation ====
  ;=======================
  ;Returns true if new item is added
  defn put (x:SetItem<K>) :
    val slot = loc(hash(x))
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        ;New Entry
        slots[slot] = x
        increment-size()
        true
      ;Case 2 of 3: Single item bucket
      (s:SetItem<K>) :
        ;Case 1 of 2: Item matches
        if match?(s,x) :
          false
        ;Case 2 of 2: Add Item
        else :
          create-bucket(slot, s, x)
          increment-size()
          true
      ;Case 3 of 3: Multiple item bucket
      (s:Array<SetItem<K>>) :
        val n = sizes[slot]
        val i = num-before(s, n, x)
        match(index-of-item(s, i, n, x)) :
          ;Case 1 of 2: Item exists in bucket
          (idx:Int) :
            false
          ;Case 2 of 2: Add new item to bucket
          (idx:False) :
            add-to-bucket(slot, s, i, n, x)
            increment-size()
            true

  ;========================
  ;==== Key? Operation ====
  ;========================
  defn exists? (x:SetItem<K>) :
    val slot = loc(hash(x))
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) : false
      ;Case 2 of 3: Single item bucket
      (s:SetItem<K>) : match?(s,x)
      ;Case 3 of 3: Multiple item bucket
      (s:Array<SetItem<K>>) :
        val n = sizes[slot]
        val i = num-before(s, n, x)
        index-of-item(s, i, n, x) is Int

  ;==========================
  ;==== Remove Operation ====
  ;==========================
  ;Returns true if item was removed
  defn remove (x:SetItem<K>) :
    val slot = loc(hash(x))
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        false
      ;Case 2 of 3: Single item bucket
      (s:SetItem<K>) :
        if match?(s,x) :
          slots[slot] = sentinel()
          decrement-size()
          true
      ;Case 3 of 3: Multiple item bucket
      (s:Array<SetItem<K>>) :
        val n = sizes[slot]
        val i = num-before(s, n, x)
        match(index-of-item(s, i, n, x)) :
          (idx:False) : false
          (idx:Int) :
            shift-left(s, idx, n)
            sizes[slot] = n - 1
            decrement-size()
            true

  ;=============================
  ;==== Iteration Operation ====
  ;=============================
  defn sequence<?T> (f:SetItem<K> -> ?T) :
    val sizes = sizes
    val slots = slots
    generate<T> :
      for idx in 0 to length(slots) do :
        match(slots[idx]) :
          (s:Sentinel) : false
          (s:SetItem<K>) : yield(f(s))
          (s:Array<SetItem<K>>) : for j in 0 to sizes[idx] do : yield(f(s[j]))

  ;======================
  ;==== Table Object ====
  ;======================
  new HashSet<K> :
    defmethod add (this, k:K) :
      put(set-item(k))
    defmethod get (this, k:K) :
      exists?(set-item(k))
    defmethod remove (this, k:K) :
      remove(set-item(k))     
    defmethod clear (this) :
      clear()
    defmethod to-seq (this) :
      sequence(key)
    defmethod length (this) :
      size

;==================================
;==== Convenience Constructors ====
;==================================
public defn HashSet<K> (hash: K -> Int, equal?: (K,K) -> True|False) :
  HashSet<K>(8, hash, equal?)

public defn HashSet<K> () -> HashSet<K> :
  HashSet<K&Hashable&Equalable>(8, hash, equal?)

public defn to-hashset<K> (xs:Seqable<K>) -> HashSet<K> :
  val s = HashSet<K>()
  do(add{s, _}, xs)
  s

public defn hashset-union<T> (a:Seqable<T&Equalable&Hashable>, b:Seqable<T&Equalable&Hashable>) -> HashSet<T> :
  to-hashset<T>(cat(a,b))

public defn hashset-intersection<T> (a:Seqable<T&Equalable&Hashable>, b:Seqable<T&Equalable&Hashable>) -> HashSet<T> :
  val aset = to-hashset<T>(a)
  to-hashset<T> $ filter({aset[_]}, b)

;==================================
;======== Printer / Writer ========
;==================================

defmethod print (o:OutputStream, s:HashSet) :
  print(o, "HashSet(%,)" % [seq(written,s)])

;============================================================
;====================== IntSets =============================
;============================================================

public deftype IntSet <: Set<Int>

public defn IntSet (cap0:Int) :
  ;=====================
  ;==== Table State ====
  ;=====================
  var cap
  var limit
  var mask
  var slots
  var sizes
  var size

  defn init (c:Int) :
    cap = c
    limit = c * 3 / 4
    mask = cap - 1
    slots = Array<Sentinel|Int|IntArray>(cap, sentinel())
    sizes = IntArray(cap, 0)
    size = 0

  defn clear () :
    size = 0
    set-all(slots, 0 to false, sentinel())

  init(next-pow2(max(8, cap0)))

  ;===================
  ;==== Utilities ====
  ;===================    
  defn loc (h:Int) :
    h & mask

  ;Find number of items whose hash is less than h
  defn num-before (xs:IntArray, n:Int, x:Int) :
    bsearch(less?, xs, n, x)

  ;Look for item with given hash and key starting from i
  defn* index-of-item (xs:IntArray, i:Int, n:Int, y:Int) :
    if i < n :
      val x = xs[i]
      if x == y : i

  ;Shift items in xs from i to n right by one element
  defn* shift-right (xs:IntArray, i:Int, n:Int) :
    for j in n to i by -1 do :
      xs[j] = xs[j - 1]

  ;Shift items in xs from (i + 1) to n left by one element
  defn* shift-left (xs:IntArray, i:Int, n:Int) :
    for j in i to (n - 1) do :
      xs[j] = xs[j + 1]    

  ;Copy to new array with hole in position i
  defn* copy-with-hole (xs:IntArray, i:Int, n:Int) :
    val xs* = IntArray(length(xs) * 2)
    xs*[0 to i] = xs[0 to i]
    xs*[(i + 1) to (n + 1)] = xs[i to n]
    xs*

  ;==========================
  ;==== Entry Operations ====
  ;==========================
  defn increment-size () :
    size = size + 1
    increase-capacity() when size >= limit
    
  defn decrement-size () :
    size = size - 1

  defn increase-capacity () :
    val items = sequence()
    init(cap * 2)
    do(put, items)

  defn create-bucket (slot:Int, x0:Int, x1:Int) :
    val bucket = IntArray(4)
    slots[slot] = bucket
    sizes[slot] = 2
    ;Populate bucket
    if x0 < x1 :
      ;Add in front
      bucket[0] = x0
      bucket[1] = x1
    else :
      ;Add in back
      bucket[0] = x1
      bucket[1] = x0

  defn add-to-bucket (slot:Int, bucket:IntArray, i:Int, n:Int, x:Int) :
    ;Case 1 of 2: Bucket has space.
    if n + 1 < length(bucket) :
      shift-right(bucket, i, n)
      bucket[i] = x
    ;Case 2 of 2: Bucket is full.
    else :
      val bucket* = copy-with-hole(bucket, i, n)
      slots[slot] = bucket*
      bucket*[i] = x
    sizes[slot] = n + 1

  ;=======================
  ;==== Put Operation ====
  ;=======================
  ;Returns true if new item is added
  defn put (x:Int) :
    val slot = loc(x)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        ;New Entry
        slots[slot] = x
        increment-size()
        true
      ;Case 2 of 3: Single item bucket
      (s:Int) :
        ;Case 1 of 2: Item matches
        if s == x :
          false
        ;Case 2 of 2: Add Item
        else :
          create-bucket(slot, s, x)
          increment-size()
          true
      ;Case 3 of 3: Multiple item bucket
      (s:IntArray) :
        val n = sizes[slot]
        val i = num-before(s, n, x)
        match(index-of-item(s, i, n, x)) :
          ;Case 1 of 2: Item exists in bucket
          (idx:Int) :
            false
          ;Case 2 of 2: Add new item to bucket
          (idx:False) :
            add-to-bucket(slot, s, i, n, x)
            increment-size()
            true

  ;========================
  ;==== Key? Operation ====
  ;========================
  defn exists? (x:Int) :
    val slot = loc(x)
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) : false
      ;Case 2 of 3: Single item bucket
      (s:Int) : s == x
      ;Case 3 of 3: Multiple item bucket
      (s:IntArray) :
        val n = sizes[slot]
        val i = num-before(s, n, x)
        index-of-item(s, i, n, x) is Int

  ;==========================
  ;==== Remove Operation ====
  ;==========================
  ;Returns true if item was removed
  defn remove (x:Int) :
    val slot = loc(hash(x))
    match(slots[slot]) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        false
      ;Case 2 of 3: Single item bucket
      (s:Int) :
        if s == x :
          slots[slot] = sentinel()
          decrement-size()
          true
      ;Case 3 of 3: Multiple item bucket
      (s:IntArray) :
        val n = sizes[slot]
        val i = num-before(s, n, x)
        match(index-of-item(s, i, n, x)) :
          (idx:False) : false
          (idx:Int) :
            shift-left(s, idx, n)
            sizes[slot] = n - 1
            decrement-size()
            true

  ;=============================
  ;==== Iteration Operation ====
  ;=============================
  defn sequence () :
    val sizes = sizes
    val slots = slots
    generate<Int> :
      for idx in 0 to length(slots) do :
        match(slots[idx]) :
          (s:Sentinel) : false
          (s:Int) : yield(s)
          (s:IntArray) : for j in 0 to sizes[idx] do : yield(s[j])

  ;======================
  ;==== Table Object ====
  ;======================
  new IntSet :
    defmethod add (this, k:Int) :
      put(k)
    defmethod get (this, k:Int) :
      exists?(k)
    defmethod remove (this, k:Int) :
      remove(k)     
    defmethod clear (this) :
      clear()
    defmethod to-seq (this) :
      sequence()
    defmethod length (this) :
      size

;==================================
;==== Convenience Constructors ====
;==================================
public defn IntSet () :
  IntSet(8)

public defn to-intset (xs:Seqable<Int>) -> IntSet :
  val s = IntSet()
  do(add{s, _}, xs)
  s

;==================================
;======== Printer / Writer ========
;==================================

defmethod print (o:OutputStream, s:IntSet) :
  print(o, "IntSet(%,)" % [seq(written,s)])
 
;============================================================
;==================== Errors ================================
;============================================================

;Occurs when we try to set/get a missing key in a table.
public defstruct MissingTableKey <: RuntimeError :
  key

defmethod print (o:OutputStream, e:MissingTableKey) :
  print(o, "Key %_ does not exist in table." % [key(e)])