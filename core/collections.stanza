;See License.txt for details about licensing.

defpackage collections :
  import core

;============================================================
;===================== Utilities ============================
;============================================================

;Sentinel object
deftype Sentinel
defn sentinel () : new Sentinel
defmethod print (o:OutputStream, s:Sentinel) : print(o, "XXX")

;Table Item Structure
defstruct TableItem<K,V> :
  hash: Int
  key: K
  value: V

defmethod print (o:OutputStream, i:TableItem) :
  print(o, "(%_) %~ => %~" % [hash(i), key(i), value(i)])

;Int Item Structure
defstruct IntItem<V> :
  key: Int
  value: V

defmethod print (o:OutputStream, i:IntItem) :
  print(o, "%~ => %~" % [key(i), value(i)])

;Set Item Structure
defstruct SetItem<K> :
  hash: Int
  key: K

defmethod print (o:OutputStream, x:SetItem) :
  print(o, "(%_) %_" % [hash(x), key(x)])

;Binary search
;Returns n such that the first n numbers in xs < v
defn bsearch<?T,?S> (less?: (T, S) -> True|False,
                     xs:Array<?T>,
                     n:Int,
                     v:?S) -> Int :
  ;All items with index less than i are known to be smaller than v.
  ;All items with index (i + n) or greater are known to be greater or equal to v.
  let loop (i:Int = 0, n:Int = n) :
    if n == 0 :
      i
    else :
      val m = n / 2
      if xs[i + m] < v : loop(i + m + 1, n - m - 1)
      else : loop(i, m)

defn bsearch (less?: (Int, Int) -> True|False, xs:IntArray, n:Int, v:Int) -> Int :
  ;All items with index less than i are known to be smaller than v.
  ;All items with index (i + n) or greater are known to be greater or equal to v.
  let loop (i:Int = 0, n:Int = n) :
    if n == 0 :
      i
    else :
      val m = n / 2
      if xs[i + m] < v : loop(i + m + 1, n - m - 1)
      else : loop(i, m)

;============================================================
;===================== Vectors ==============================
;============================================================

;                     Interface
;                     =========

public defstruct Vector<T> <: IndexedCollection<T> :
  size: Int with: (setter => set-size, init => 0)
  array: Array<T> with: (setter => set-array)
with:
  constructor => #Vector

public defn Vector<T> (cap:Int) -> Vector<T> :
  core/ensure-non-negative(String("capacity"), cap)
  #Vector<T>(Array<T>(cap))

public defmulti add<?T> (v:Vector<?T>, value:T) -> False
public defmulti add-all<?T> (v:Vector<?T>, vs:Seqable<T>) -> False
public defmulti clear (v:Vector) -> False
public defmulti clear<?T> (v:Vector<?T>, n:Int, x0:T) -> False
public defmulti pop<?T> (v:Vector<?T>) -> T
public defmulti peek<?T> (v:Vector<?T>) -> T

public defmulti remove<?T> (v:Vector<?T>, i:Int) -> T
public defmulti remove (v:Vector, r:Range) -> False
public defmulti update<?T> (f: T -> Maybe<T>, v:Vector<?T>) -> False
public defmulti remove-item<?T> (v:Vector<?T&Equalable>, x:T&Equalable) -> True|False
public defmulti remove-when<?T> (f: T -> True|False, v:Vector<?T>) -> False
public defmulti trim (v:Vector) -> False
public defmulti shorten (v:Vector, size:Int) -> False
public defmulti lengthen<?T> (v:Vector<?T>, size:Int, x:T) -> False
public defmulti set-length<?T> (v:Vector<?T>, length:Int, x:T) -> False

;                   Implementation
;                   ==============

defn set-capacity<?T> (v:Vector<?T>, c:Int) :
  val new-array = Array<T>(c)
  new-array[0 to size(v)] = array(v)
  set-array(v, new-array)

defn ensure-capacity<?T> (v:Vector<?T>, c:Int) :
  val cur-c = length(array(v))
  set-capacity(v, max(c, 2 * cur-c)) when c > cur-c

defmethod get<?T> (v:Vector<?T>, i:Int) :
  core/ensure-index-in-bounds(v, i)
  array(v)[i]

defmethod set<?T> (v:Vector<?T>, i:Int, value:T) :
  if i == size(v) :
    add(v, value)
  else :
    core/ensure-index-in-bounds(v, i)
    array(v)[i] = value

defmethod set-all<?T> (v:Vector<?T>, r:Range, x:T) :
  core/ensure-index-range(v, r)
  set-all(array(v), r, x)         

defmethod length (v:Vector) :
  size(v)

defmethod trim<?T> (v:Vector<?T>) :
  set-capacity(v, size(v))

defmethod set-length<?T> (v:Vector<?T>, len:Int, value:T) :
  if len > size(v) : lengthen(v, len, value)
  else : shorten(v, len)

defmethod shorten<?T> (v:Vector<?T>, new-size:Int) :
  #if-not-defined(OPTIMIZE) :
    core/ensure-non-negative("size", new-size)
    if new-size > size(v) :
      fatal("Given size (%_) is larger than current size (%_)." % [new-size, size(v)])
  set-size(v, new-size)

defmethod lengthen<?T> (v:Vector<?T>, new-size:Int, x:T) :
  #if-not-defined(OPTIMIZE) :
    if new-size < size(v) :
      fatal("Given size (%_) is smaller than current size (%_)." % [new-size, size(v)])
  ensure-capacity(v, new-size)
  set-all(array(v), size(v) to new-size, x)
  set-size(v, new-size)

defmethod add<?T> (v:Vector<?T>, value:T) :
  val sz = size(v)
  ensure-capacity(v, sz + 1)
  array(v)[sz] = value
  set-size(v, sz + 1)

defmethod add-all<?T> (v:Vector<?T>, vs:Seqable<T>) :
  match(vs) :
    (vs:Seqable<T> & Lengthable) :
      val n = length(vs)
      ensure-capacity(v, size(v) + n)
      array(v)[size(v) to (size(v) + n)] = vs
      set-size(v, size(v) + n)
    (vs) :
      do(add{v, _}, vs)

defmethod pop<?T> (v:Vector<?T>) :
  #if-not-defined(OPTIMIZE) :
    fatal("Empty Vector") when size(v) == 0
  set-size(v, size(v) - 1)
  array(v)[size(v)]

defmethod peek<?T> (v:Vector<?T>) :
  #if-not-defined(OPTIMIZE) :
    fatal("Empty Vector") when size(v) == 0
  array(v)[size(v) - 1]

defmethod clear (v:Vector) :
  set-size(v, 0)

defmethod clear<?T> (v:Vector<?T>, n:Int, x0:T) :
  if length(array(v)) < n :
    val cap = max(n, 2 * length(array(v)))
    set-array(v, Array<T>(cap, x0))
    set-size(v, n)
  else :
    set-all(array(v), 0 to n, x0)
    set-size(v, n)

defmethod remove-when<?T> (f: T -> True|False, v:Vector<?T>) :
  for x in v update :
    if f(x) : None()
    else : One(x)

defmethod remove<?T> (v:Vector<?T>, i:Int) :
  core/ensure-index-in-bounds(v, i)
  val a = array(v)
  val x = a[i]
  for i in i to (size(v) - 1) do :
    a[i] = a[i + 1]
  set-size(v, size(v) - 1)
  x

defmethod remove<?T> (v:Vector<?T>, r:Range) :
  core/ensure-index-range(v, r)
  val [s,e] = core/range-bound(v, r)
  val n = e - s
  val a = array(v)
  val sz = size(v)
  if n > 0 :
    for i in s to (sz - n) do :
      a[i] = a[i + n]
    set-size(v, sz - n)

defmethod remove-item<?T> (v:Vector<?T&Equalable>, x:T&Equalable) :
  match(index-of(v, x)) :
    (i:Int) : (remove(v, i), true)
    (i:False) : false

defmethod update<?T> (f: T -> Maybe<T>, v:Vector<?T>) :
  val a = array(v)
  let loop (dst:Int = 0, src:Int = 0) :
    if src < size(v) :
      match(f(a[src])) :
        (x:One<T>) :
          a[dst] = value(x)
          loop(dst + 1, src + 1)
        (x:None) :
          loop(dst, src + 1)
    else :
      set-size(v, dst)

defmethod do<?T> (f: T -> ?, v:Vector<?T>) :
 val n = size(v)
 val a = array(v)
 let loop (i:Int = 0) :
   if i < n :
     f(a[i])
     loop(i + 1)

public defn update<?T> (v:Vector<?T>, f: T -> Maybe<T>) -> False :
  update(f,v)

public defn remove-when<?T> (v:Vector<?T>, f: T -> True|False) -> False :
  remove-when(f,v)

public defn Vector<T> () -> Vector<T> :
   Vector<T>(8)

public defn to-vector<T> (xs:Seqable<T>) -> Vector<T> :
   val v = Vector<T>()
   add-all(v, xs)
   v

public defn map<R,?T> (v:Vector<?T>, f: T -> R) -> Vector<R> :
  map<R>(f, v)

public defn map<R,?T> (f: T -> R, v:Vector<?T>) -> Vector<R> :
   val ret = Vector<R>(length(v))
   add-all(ret, seq(f, v))
   ret

;==================================
;======== Printer / Writer ========
;==================================

defmethod print (o:OutputStream, v:Vector) :
  print(o, "Vector(%,)" % [seq(written,v)])

;============================================================
;====================== Queues ==============================
;============================================================

;                      Interface
;                      =========

public defmulti add<?T> (q:Queue<?T>, x:T) -> False
public defmulti clear (q:Queue) -> False
public defmulti pop<?T> (q:Queue<?T>) -> T
public defmulti peek<?T> (q:Queue<?T>) -> T

;                    Implementation
;                    ==============

public defstruct Queue<T> <: IndexedCollection<T> :
  cap:Int with: (setter => set-cap)
  array:Array<T> with: (setter => set-array, init => Array<T>(cap))
  begin:Int with: (setter => set-begin, init => 0)
  size:Int with: (setter => set-size, init => 0)
with:
  constructor => #Queue

public defn Queue<T> (initial-cap:Int) -> Queue<T> :
  core/ensure-non-negative("capacity", initial-cap)
  #Queue<T>(next-pow2(initial-cap))

defn ensure-capacity<?T> (q:Queue<?T>, c:Int) :
  defn set-capacity (c:Int) :
    val new-array = Array<T>(c)
    for i in 0 to size(q) do :
      new-array[i] = array(q)[wrapped-index(q, i)]
    set-array(q, new-array)
    set-cap(q, c)
    set-begin(q, 0)
  set-capacity(next-pow2(c)) when c > cap(q)

defn wrapped-index (q:Queue, i:Int) :
  (begin(q) + i) & (cap(q) - 1)

defmethod get<?T> (q:Queue<?T>, i:Int) :
  core/ensure-index-in-bounds(q, i)
  array(q)[wrapped-index(q, i)]

defmethod set<?T> (q:Queue<?T>, i:Int, value:T) :
  if i == -1 :
    add(q, value)
  else :
    core/ensure-index-in-bounds(q, i)
    array(q)[wrapped-index(q, i)] = value

defmethod add<?T> (q:Queue<?T>, x:T) :
  ensure-capacity(q, size(q) + 1)
  set-begin(q, wrapped-index(q, -1 + cap(q)))
  array(q)[begin(q)] = x
  set-size(q, size(q) + 1)

defmethod pop (q:Queue) :
  #if-not-defined(OPTIMIZE) :
    fatal("Empty Queue") when size(q) == 0
  set-size(q, size(q) - 1)
  array(q)[wrapped-index(q, size(q))]

defmethod peek (q:Queue) :
  #if-not-defined(OPTIMIZE) :
    fatal("Empty Queue") when size(q) == 0
  array(q)[wrapped-index(q, size(q) - 1)]

defmethod length (q:Queue) :
  size(q)

defmethod clear (q:Queue) :
  set-size(q, 0)

public defn Queue<T> () -> Queue<T> :
  Queue<T>(8)

;==================================
;======== Printer / Writer ========
;==================================

defmethod print (o:OutputStream, q:Queue) :
  print(o, "Queue(%,)" % [seq(written,q)])

;============================================================
;======================== Tables ============================
;============================================================

;==============================
;==== Mandatory Operations ====
;==============================

public deftype Table<K,V> <: Collection<KeyValue<K,V>> & Lengthable & HasContents
public defmulti set<?K,?V> (t:Table<?K,?V>, k:K, v:V) -> False
public defmulti get?<?K,?V> (t:Table<?K,?V>, k:K, d:?V) -> V
public defmulti default<?K,?V> (t:Table<?K,?V>, k:K) -> V
public defmulti remove<?K> (t:Table<?K,?>, k:K) -> True|False
public defmulti clear (t:Table) -> False

;=============================
;==== Abstract Operations ====
;=============================

public defmulti key?<?K> (t:Table<?K,?>, k:K) -> True|False
public defmulti get<?K,?V> (t:Table<?K,?V>, k:K) -> V
public defmulti update<?K,?V> (t:Table<?K,?V>, f:V -> V, k:K) -> V
public defmulti keys<?K> (t:Table<?K,?>) -> Seqable<K>
public defmulti values<?V> (t:Table<?,?V>) -> Seqable<V>
public defmulti set?<?K,?V> (t:Table<?K,?V>, k:K, f:() -> V) -> V
public defmulti map!<?K,?V> (f:KeyValue<K,V> -> V, t:Table<?K,?V>) -> False

;==================================
;==== Abstract Implementations ====
;==================================
defmethod key?<?K> (t:Table<?K,?>, k:K) :
  get?(t, k, sentinel()) is-not Sentinel
  
defmethod get<?K,?V> (t:Table<?K,?V>, k:K) -> V :
  match(get?(t, k, sentinel())) :
    (v:Sentinel) : default(t, k)
    (v:V) : v

defmethod update<?K,?V> (t:Table<?K,?V>, f:V -> V, k:K) -> V :
  val v* = f(t[k])
  t[k] = v*
  v*

defmethod set?<?K,?V> (t:Table<?K,?V>, k:K, f:() -> V) -> V :
  match(get?(t, k, sentinel())) :
    (v:Sentinel) :
      val v* = f()
      t[k] = v*
      v*
    (v:V) :
      v

defmethod keys<?K> (t:Table<?K,?>) :
  seq(key, t)

defmethod values<?V> (t:Table<?,?V>) :
  seq(value, t)

public defn get?<?K,?V> (t:Table<?K,?V>, k:K) :
  get?(t, k, false)

public defn empty? (t:Table) :
  length(t) == 0

defmethod map!<?K,?V> (f:KeyValue<K,V> -> V, t:Table<?K,?V>) :
  for entry in t do :
    t[key(entry)] = f(entry)

public defn set-all<?K,?V> (t:Table<?K,?V>, ks:Seqable<K>, vs:Seqable<V>) :
  for (k in ks, v in vs) do :
    t[k] = v

defmethod same-contents? (a:Table, b:Table) :
  if length(a) == length(b) :
    for entry in b all? :
      val bkey = key(entry)
      val bval = value(entry)
      if key?(a, bkey) :
        val aval = a[bkey]
        same-contents?(aval, bval)

;============================================================
;====================== HashTables ==========================
;============================================================

public defstruct HashTable<K,V> <: Table<K,V> :
  cap : Int with: (setter => set-cap)
  limit : Int with: (setter => set-limit, init => cap * 3 / 4)
  mask : Int with: (setter => set-mask, init => cap - 1)  
  slots : Array<Sentinel|TableItem<K,V>|Array<TableItem<K,V>>> with: (setter => set-slots, init => Array<Sentinel|TableItem<K,V>|Array<TableItem<K,V>>>(cap, sentinel()))
  sizes : IntArray with: (setter => set-sizes, init => IntArray(cap, 0))
  size : Int with: (setter => set-size, init => 0)
  key-hash : K -> Int
  key-equal? : (K,K) -> True | False
  default : K -> V
  create-on-default: True|False
with:
  constructor => #HashTable

defn key-hash<?K,?V> (t:HashTable<?K,?V>, k:K) -> Int :
  key-hash(t)(k)

defn key-equal?<?K,?V> (t:HashTable<?K,?V>, x:K, y:K) -> True|False :
  key-equal?(t)(x, y)

defn init<?K,?V> (t:HashTable<?K,?V>, c:Int) :
  set-cap(t, c)
  set-limit(t, c * 3 / 4)
  set-mask(t, c - 1)
  set-slots(t, Array<Sentinel|TableItem<K,V>|Array<TableItem<K,V>>>(c, sentinel()))
  set-sizes(t, IntArray(c, 0))
  set-size(t, 0)

defmethod clear<?K,?V> (t:HashTable<?K,?V>) :
  set-size(t, 0)
  set-all(slots(t), 0 to false, sentinel())

public defn HashTable<K,V> (cap0:Int,
                            key-hash: K -> Int,
                            key-equal?: (K,K) -> True|False
                            default: K -> V,
                            create-on-default:True|False) -> HashTable<K,V> :
  #HashTable<K,V>(next-pow2(max(8, cap0)), key-hash, key-equal?, default, create-on-default)

;===================
;==== Utilities ====
;===================
defn loc (t:HashTable, h:Int) -> Int :
  h & mask(t)

;Matching predicate for TableItem
defn match?<?K,?V> (t:HashTable<?K,?V>, a:TableItem<K,V>, h:Int, k:K) :
  hash(a) == h and
  key-equal?(t, key(a), k)
defn match?<?K,?V> (t:HashTable<?K,?V>, a:TableItem<K,V>, b:TableItem<K,V>) :
  match?(t, a, hash(b), key(b))

;Find number of items whose hash is less than h
defn num-before<?K,?V> (t:HashTable<?K,?V>, xs:Array<TableItem<K,V>>, n:Int, h:Int) :
  bsearch({hash(_) < _}, xs, n, h)

;Look for item with given hash and key starting from i
defn* index-of-item<?K,?V> (t:HashTable<?K,?V>, xs:Array<TableItem<K,V>>, i:Int, n:Int, h:Int, k:K) :
  if i < n :
    val x = xs[i]
    if hash(x) == h :
      if key-equal?(t, key(x), k) : i
      else : index-of-item(t, xs, i + 1, n, h, k)

;Shift items in xs from i to n right by one element
defn* shift-right<?K,?V> (xs:Array<TableItem<?K,?V>>, i:Int, n:Int) :
  for j in n to i by -1 do :
    xs[j] = xs[j - 1]

;Shift items in xs from (i + 1) to n left by one element
defn* shift-left<?K,?V> (xs:Array<TableItem<?K,?V>>, i:Int, n:Int) :
  for j in i to (n - 1) do :
    xs[j] = xs[j + 1]    

;Copy to  array with hole in position i
defn* copy-with-hole<?K,?V> (t:HashTable<?K,?V>, xs:Array<TableItem<K,V>>, i:Int, n:Int) :
  val xs* = Array<TableItem<K,V>>(length(xs) * 2)
  xs*[0 to i] = xs[0 to i]
  xs*[(i + 1) to (n + 1)] = xs[i to n]
  xs*

;==========================
;==== Entry Operations ====
;==========================
defn increment-size<?K,?V> (t:HashTable<?K,?V>) :
  set-size(t, size(t) + 1)
  increase-capacity(t) when size(t) >= limit(t)

defn decrement-size<?K,?V> (t:HashTable<?K,?V>) :
  set-size(t, size(t) - 1)

defn increase-capacity<?K,?V> (t:HashTable<?K,?V>) :
  val items = sequence(t, {_})
  init(t, cap(t) * 2)
  do(put{t, _}, items)

defn create-bucket<?K,?V> (t:HashTable<?K,?V>, slot:Int, x0:TableItem<K,V>, x1:TableItem<K,V>) :
  val bucket = Array<TableItem<K,V>>(4)
  slots(t)[slot] = bucket
  sizes(t)[slot] = 2
  ;Populate bucket
  if hash(x0) < hash(x1) :
    ;Add in front
    bucket[0] = x0
    bucket[1] = x1
  else :
    ;Add in back
    bucket[0] = x1
    bucket[1] = x0

defn add-to-bucket<?K,?V> (t:HashTable<?K,?V>, slot:Int, bucket:Array<TableItem<K,V>>, i:Int, n:Int, x:TableItem<K,V>) :
  ;Case 1 of 2: Bucket has space.
  if n + 1 < length(bucket) :
    shift-right(bucket, i, n)
    bucket[i] = x
  ;Case 2 of 2: Bucket is full.
  else :
    val bucket* = copy-with-hole(t, bucket, i, n)
    slots(t)[slot] = bucket*
    bucket*[i] = x
  sizes(t)[slot] = n + 1

;=======================
;==== Put Operation ====
;=======================
defmethod set<?K,?V> (t:HashTable<?K,?V>, k:K, v:V) :
  put(t, TableItem<K,V>(key-hash(t, k), k, v))

defn put<?K,?V> (t:HashTable<?K,?V>, x:TableItem<K,V>) :
  val slot = loc(t, hash(x))
  match(slots(t)[slot]) :
    ;Case 1 of 3: Unoccupied bucket
    (s:Sentinel) :
      ;New Entry
      slots(t)[slot] = x
      increment-size(t)
    ;Case 2 of 3: Single item bucket
    (s:TableItem<K,V>) :
      ;Case 1 of 2: Item matches
      if match?(t,s,x) :
        ;Replace Entry
        slots(t)[slot] = x
      ;Case 2 of 2: Add Item
      else :
        create-bucket(t, slot, s, x)
        increment-size(t)
    ;Case 3 of 3: Multiple item bucket
    (s:Array<TableItem<K,V>>) :
      val n = sizes(t)[slot]
      val h = hash(x)
      val i = num-before(t, s, n, h)
      match(index-of-item(t, s, i, n, h, key(x))) :
        ;Case 1 of 2: Item exists in bucket
        (idx:Int) :
          s[idx] = x
        ;Case 2 of 2: Add new item to bucket
        (idx:False) :
          add-to-bucket(t, slot, s, i, n, x)
          increment-size(t)

;===========================
;==== Lookup? Operation ====
;===========================
defmethod get?<?K,?V,?D> (t:HashTable<?K,?V>, k:K, default:?D) :
  val h = key-hash(t, k)
  val slot = loc(t, h)
  match(slots(t)[slot]) :
    ;Case 1 of 3: Unoccupied bucket
    (s:Sentinel) :
      default
    ;Case 2 of 3: Single item bucket
    (s:TableItem<K,V>) :
      ;Case 1 of 2: Item matches
      if match?(t,s,h,k) : value(s)
      else : default
    ;Case 3 of 3: Multiple item bucket
    (s:Array<TableItem<K,V>>) :
      val n = sizes(t)[slot]
      val i = num-before(t, s, n, h)
      match(index-of-item(t, s, i, n, h, k)) :
        (idx:Int) : value(s[idx])
        (idx:False) : default

;==========================
;==== Lookup Operation ====
;==========================
defmethod get<?K,?V> (t:HashTable<?K,?V>, k:K) :
  val h = key-hash(t, k)
  defn item (v:V) : TableItem<K,V>(h,k,v)
  val slot = loc(t, h)
  match(slots(t)[slot]) :
    ;Case 1 of 3: Unoccupied bucket
    (s:Sentinel) :
      val v = default(t)(k)
      if create-on-default(t) :
        slots(t)[slot] = item(v)
        increment-size(t)
      v
    ;Case 2 of 3: Single item bucket
    (s:TableItem<K,V>) :
      ;Case 1 of 2: Item matches
      if match?(t, s,h,k) :
        value(s)
      else :
        val v = default(t)(k)
        if create-on-default(t) :
          create-bucket(t, slot, s, item(v))
          increment-size(t)
        v          
    ;Case 3 of 3: Multiple item bucket
    (s:Array<TableItem<K,V>>) :
      val n = sizes(t)[slot]
      val i = num-before(t, s, n, h)
      match(index-of-item(t, s, i, n, h, k)) :
        (idx:Int) :
          value(s[idx])
        (idx:False) :
          val v = default(t)(k)
          if create-on-default(t) :
            add-to-bucket(t,slot, s, i, n, item(v))
            increment-size(t)
          v

;==========================
;==== Update Operation ====
;==========================
defmethod update<?K,?V> (t:HashTable<?K,?V>, f:V -> V, k:K) :
  val h = key-hash(t,k)
  defn item (v:V) : TableItem<K,V>(h,k,v)
  val slot = loc(t,h)
  match(slots(t)[slot]) :
    ;Case 1 of 3: Unoccupied bucket
    (s:Sentinel) :
      val v = f(default(t)(k))
      slots(t)[slot] = item(v)
      increment-size(t)
      v
    ;Case 2 of 3: Single item bucket
    (s:TableItem<K,V>) :
      ;Case 1 of 2: Item matches
      if match?(t,s,h,k) :
        val v = f(value(s))
        slots(t)[slot] = item(v)
        v
      else :
        val v = f(default(t)(k))
        create-bucket(t,slot, s, item(v))
        increment-size(t)
        v
    ;Case 3 of 3: Multiple item bucket
    (s:Array<TableItem<K,V>>) :
      val n = sizes(t)[slot]
      val i = num-before(t, s, n, h)
      match(index-of-item(t, s, i, n, h, k)) :
        (idx:Int) :
          val v = f(value(s[idx]))
          s[idx] = item(v)
          v
        (idx:False) :
          val v = f(default(t)(k))
          add-to-bucket(t, slot, s, i, n, item(v))
          increment-size(t)
          v

;========================
;==== Key? Operation ====
;========================
defmethod key?<?K,?V> (t:HashTable<?K,?V>, k:K) :
  val h = key-hash(t, k)
  val slot = loc(t, h)
  match(slots(t)[slot]) :
    ;Case 1 of 3: Unoccupied bucket
    (s:Sentinel) : false
    ;Case 2 of 3: Single item bucket
    (s:TableItem<K,V>) : match?(t,s,h,k)
    ;Case 3 of 3: Multiple item bucket
    (s:Array<TableItem<K,V>>) :
      val n = sizes(t)[slot]
      val i = num-before(t, s, n, h)
      index-of-item(t, s, i, n, h, k) is Int

;==========================
;==== Remove Operation ====
;==========================
defmethod remove<?K,?V> (t:HashTable<?K,?V>, k:K) :
  val h = key-hash(t,k)
  val slot = loc(t,h)
  match(slots(t)[slot]) :
    ;Case 1 of 3: Unoccupied bucket
    (s:Sentinel) :
      false
    ;Case 2 of 3: Single item bucket
    (s:TableItem<K,V>) :
      if match?(t,s,h,k) :
        slots(t)[slot] = sentinel()
        decrement-size(t)
        true
    ;Case 3 of 3: Multiple item bucket
    (s:Array<TableItem<K,V>>) :
      val n = sizes(t)[slot]
      val i = num-before(t, s, n, h)
      match(index-of-item(t, s, i, n, h, k)) :
        (idx:False) : false
        (idx:Int) :
          shift-left(s, idx, n)
          sizes(t)[slot] = n - 1
          decrement-size(t)
          true

;========================
;==== Map! Operation ====
;========================
defn map!<?K,?V> (t:HashTable<?K,?V>, f:KeyValue<K,V> -> V) :
  for (slot in slots(t), idx in 0 to false) do :
    match(slot) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        false
      ;Case 2 of 3: Single item bucket
      (s:TableItem<K,V>) :
        val v = f(key(s) => value(s))
        slots(t)[idx] = TableItem<K,V>(hash(s), key(s), v)
      ;Case 3 of 3: Multiple item bucket
      (s:Array<TableItem<K,V>>) :
        val n = sizes(t)[idx]
        for i in 0 to n do :
          val x = s[i]
          val v = f(key(x) => value(x))
          s[i] = TableItem<K,V>(hash(x), key(x), v)

;=============================
;==== Iteration Operation ====
;=============================
defn sequence<?K,?V,?T> (t:HashTable<?K,?V>, f:TableItem<K,V> -> ?T) :
  val sizes = sizes(t)
  val slots = slots(t)
  generate<T> :
    for idx in 0 to length(slots) do :
      match(slots[idx]) :
        (s:Sentinel) : false
        (s:TableItem<K,V>) : yield(f(s))
        (s:Array<TableItem<K,V>>) : for j in 0 to sizes[idx] do : yield(f(s[j]))

defmethod to-seq<?K,?V> (t:HashTable<?K,?V>) :
  defn make-entry (x:TableItem<K,V>) : key(x) => value(x)
  sequence(t, make-entry)
defmethod keys<?K,?V> (t:HashTable<?K,?V>) :
  sequence(t, key)
defmethod values<?K,?V> (t:HashTable<?K,?V>) :
  sequence(t, value)
defmethod length<?K,?V> (t:HashTable<?K,?V>) :
  size(t)
defmethod default<?K,?V> (t:HashTable<?K,?V>, k:K) :
  val v = default(t)(k)
  if create-on-default(t) : t[k] = v
  v

;==================================
;==== Convenience Constructors ====
;==================================

;Trivial default function which just throws a RuntimeError.
defn no-such-key (k) -> Void :
  throw(MissingTableKey(k))

public defn HashTable<K,V> (initial-cap:Int, hash: K -> Int, equal?: (K,K) -> True|False) :
  HashTable<K,V>(initial-cap, hash, equal?, no-such-key, false)

public defn HashTable<K,V> (hash: K -> Int, equal?: (K,K) -> True|False) :
  HashTable<K,V>(8, hash, equal?, no-such-key, false)

public defn HashTable<K,V> () -> HashTable<K,V> :
  HashTable<K&Hashable&Equalable,V>(8, hash, equal?, no-such-key, false)

public defn HashTable<K,V> (default:V) -> HashTable<K,V> :
  HashTable<K&Hashable&Equalable,V>(8, hash, equal?, {default}, false)

public defn HashTable<K,V> (hash: K -> Int,
                            equal?: (K,K) -> True|False,
                            default:V) ->
                            HashTable<K,V> :
  HashTable<K,V>(8, hash, equal?, {default}, false)

public defn HashTable-init<K,V> (init: K -> V) -> HashTable<K,V> :
  HashTable<K&Hashable&Equalable,V>(8, hash, equal?, init, true)

public defn HashTable-init<K,V> (hash: K -> Int,
                                 equal?: (K,K) -> True|False,
                                 init: K -> V) ->
                                 HashTable<K,V> :
  HashTable<K,V>(8, hash, equal?, init, true)

public defn to-hashtable<K,V> (es:Seqable<KeyValue<K,V>>) -> HashTable<K,V> :
  val t = HashTable<K,V>()
  for e in es do :
    t[key(e)] = value(e)
  t

public defn to-hashtable<K,V> (ks:Seqable<K>, vs:Seqable<V>) -> HashTable<K,V> :
  val t = HashTable<K,V>()
  set-all(t, ks, vs)
  t

;==================================
;======== Printer / Writer ========
;==================================

defmethod print (o:OutputStream, t:HashTable) :
  print(o, "HashTable(")
  for entry in t do :
    lnprint(o, Indented(entry))
  print(o, ")")

;============================================================
;===================== Int Tables ===========================
;============================================================

public defstruct IntTable<V> <: Table<Int,V> :
  cap : Int with: (setter => set-cap)
  limit : Int with: (setter => set-limit, init => cap * 3 / 4)
  mask : Int with: (setter => set-mask, init => cap - 1)  
  slots : Array<Sentinel|IntItem<V>|Array<IntItem<V>>> with: (setter => set-slots, init => Array<Sentinel|IntItem<V>|Array<IntItem<V>>>(cap, sentinel()))
  sizes : IntArray with: (setter => set-sizes, init => IntArray(cap, 0))
  size : Int with: (setter => set-size, init => 0)
  default : Int -> V
  create-on-default: True|False
with:
  constructor => #IntTable

defn init<?V> (t:IntTable<?V>, c:Int) :
  set-cap(t, c)
  set-limit(t, c * 3 / 4)
  set-mask(t, c - 1)
  set-slots(t, Array<Sentinel|IntItem<V>|Array<IntItem<V>>>(c, sentinel()))
  set-sizes(t, IntArray(c, 0))
  set-size(t, 0)

defmethod clear<?V> (t:IntTable<?V>) :
  set-size(t, 0)
  set-all(slots(t), 0 to false, sentinel())

public defn IntTable<V> (cap0:Int,
                         default: Int -> V,
                         create-on-default:True|False) -> IntTable<V> :
  #IntTable<V>(next-pow2(max(8, cap0)), default, create-on-default)

defmethod length<?V> (t:IntTable<?V>) :
  size(t)

defmethod default<?V> (t:IntTable<?V>, k:Int) :
  val v = default(t)(k)
  if create-on-default(t) : t[k] = v
  v

;===================
;==== Utilities ====
;===================
defn loc<?V> (t:IntTable<?V>, h:Int) :
  h & mask(t)

;Matching predicate for IntItem
defn match?<?V> (a:IntItem<?V>, k:Int) :
  key(a) == k
defn match?<?V> (a:IntItem<?V>, b:IntItem<?V>) :
  match?(a, key(b))

;Find number of items whose hash is less than h
defn num-before<?V> (xs:Array<IntItem<?V>>, n:Int, k:Int) :
  bsearch({key(_) < _}, xs, n, k)

;Look for item with given hash and key starting from i
defn* index-of-item<?V> (xs:Array<IntItem<?V>>, i:Int, n:Int, k:Int) :
  if i < n :
    val x = xs[i]
    if key(x) == k : i

;Shift items in xs from i to n right by one element
defn* shift-right<?V> (xs:Array<IntItem<?V>>, i:Int, n:Int) :
  for j in n to i by -1 do :
    xs[j] = xs[j - 1]

;Shift items in xs from (i + 1) to n left by one element
defn* shift-left<?V> (xs:Array<IntItem<?V>>, i:Int, n:Int) :
  for j in i to (n - 1) do :
    xs[j] = xs[j + 1]    

;Copy to new array with hole in position i
defn* copy-with-hole<?V> (xs:Array<IntItem<?V>>, i:Int, n:Int) :
  val xs* = Array<IntItem<V>>(length(xs) * 2)
  xs*[0 to i] = xs[0 to i]
  xs*[(i + 1) to (n + 1)] = xs[i to n]
  xs*

;==========================
;==== Entry Operations ====
;==========================
defn increment-size<?V> (t:IntTable<?V>) :
  set-size(t, size(t) + 1)
  increase-capacity(t) when size(t) >= limit(t)

defn decrement-size<?V> (t:IntTable<?V>) :
  set-size(t, size(t) - 1)

defn increase-capacity<?V> (t:IntTable<?V>) :
  val items = sequence(t, {_})
  init(t, cap(t) * 2)
  do(put{t, _}, items)

defn create-bucket<?V> (t:IntTable<?V>, slot:Int, x0:IntItem<V>, x1:IntItem<V>) :
  val bucket = Array<IntItem<V>>(4)
  slots(t)[slot] = bucket
  sizes(t)[slot] = 2
  ;Populate bucket
  if key(x0) < key(x1) :
    ;Add in front
    bucket[0] = x0
    bucket[1] = x1
  else :
    ;Add in back
    bucket[0] = x1
    bucket[1] = x0

defn add-to-bucket<?V> (t:IntTable<?V>, slot:Int, bucket:Array<IntItem<V>>, i:Int, n:Int, x:IntItem<V>) :
  ;Case 1 of 2: Bucket has space.
  if n + 1 < length(bucket) :
    shift-right(bucket, i, n)
    bucket[i] = x
  ;Case 2 of 2: Bucket is full.
  else :
    val bucket* = copy-with-hole(bucket, i, n)
    slots(t)[slot] = bucket*
    bucket*[i] = x
  sizes(t)[slot] = n + 1

;=======================
;==== Put Operation ====
;=======================
defmethod set<?V> (t:IntTable<?V>, k:Int, v:V) :
  put(t, IntItem<V>(k, v))

defn put<?V> (t:IntTable<?V>, x:IntItem<V>) :
  val slot = loc(t, key(x))
  match(slots(t)[slot]) :
    ;Case 1 of 3: Unoccupied bucket
    (s:Sentinel) :
      ;New Entry
      slots(t)[slot] = x
      increment-size(t)
    ;Case 2 of 3: Single item bucket
    (s:IntItem<V>) :
      ;Case 1 of 2: Item matches
      if match?(s,x) :
        ;Replace Entry
        slots(t)[slot] = x
      ;Case 2 of 2: Add Item
      else :
        create-bucket(t, slot, s, x)
        increment-size(t)
    ;Case 3 of 3: Multiple item bucket
    (s:Array<IntItem<V>>) :
      val n = sizes(t)[slot]
      val i = num-before(s, n, key(x))
      match(index-of-item(s, i, n, key(x))) :
        ;Case 1 of 2: Item exists in bucket
        (idx:Int) :
          s[idx] = x
        ;Case 2 of 2: Add new item to bucket
        (idx:False) :
          add-to-bucket(t, slot, s, i, n, x)
          increment-size(t)

;===========================
;==== Lookup? Operation ====
;===========================
defmethod get?<?V,?D> (t:IntTable<?V>, k:Int, default:?D) :
  val slot = loc(t, k)
  match(slots(t)[slot]) :
    ;Case 1 of 3: Unoccupied bucket
    (s:Sentinel) :
      default
    ;Case 2 of 3: Single item bucket
    (s:IntItem<V>) :
      ;Case 1 of 2: Item matches
      if match?(s,k) : value(s)
      else : default
    ;Case 3 of 3: Multiple item bucket
    (s:Array<IntItem<V>>) :
      val n = sizes(t)[slot]
      val i = num-before(s, n, k)
      match(index-of-item(s, i, n, k)) :
        (idx:Int) : value(s[idx])
        (idx:False) : default

;==========================
;==== Lookup Operation ====
;==========================
defmethod get<?V> (t:IntTable<?V>, k:Int) :
  defn item (v:V) : IntItem<V>(k,v)
  val slot = loc(t, k)
  match(slots(t)[slot]) :
    ;Case 1 of 3: Unoccupied bucket
    (s:Sentinel) :
      val v = default(t)(k)
      if create-on-default(t) :
        slots(t)[slot] = item(v)
        increment-size(t)
      v
    ;Case 2 of 3: Single item bucket
    (s:IntItem<V>) :
      ;Case 1 of 2: Item matches
      if match?(s,k) :
        value(s)
      else :
        val v = default(t)(k)
        if create-on-default(t) :
          create-bucket(t, slot, s, item(v))
          increment-size(t)
        v          
    ;Case 3 of 3: Multiple item bucket
    (s:Array<IntItem<V>>) :
      val n = sizes(t)[slot]
      val i = num-before(s, n, k)
      match(index-of-item(s, i, n, k)) :
        (idx:Int) :
          value(s[idx])
        (idx:False) :
          val v = default(t)(k)
          if create-on-default(t) :
            add-to-bucket(t, slot, s, i, n, item(v))
            increment-size(t)
          v

;==========================
;==== Update Operation ====
;==========================
defmethod update<?V> (t:IntTable<?V>, f:V -> V, k:Int) :
  defn item (v:V) : IntItem<V>(k,v)
  val slot = loc(t, k)
  match(slots(t)[slot]) :
    ;Case 1 of 3: Unoccupied bucket
    (s:Sentinel) :
      val v = f(default(t)(k))
      slots(t)[slot] = item(v)
      increment-size(t)
      v
    ;Case 2 of 3: Single item bucket
    (s:IntItem<V>) :
      ;Case 1 of 2: Item matches
      if match?(s,k) :
        val v = f(value(s))
        slots(t)[slot] = item(v)
        v
      else :
        val v = f(default(t)(k))
        create-bucket(t, slot, s, item(v))
        increment-size(t)
        v
    ;Case 3 of 3: Multiple item bucket
    (s:Array<IntItem<V>>) :
      val n = sizes(t)[slot]
      val i = num-before(s, n, k)
      match(index-of-item(s, i, n, k)) :
        (idx:Int) :
          val v = f(value(s[idx]))
          s[idx] = item(v)
          v
        (idx:False) :
          val v = f(default(t)(k))
          add-to-bucket(t, slot, s, i, n, item(v))
          increment-size(t)
          v

;========================
;==== Key? Operation ====
;========================
defmethod key?<?V> (t:IntTable<?V>, k:Int) :
  val slot = loc(t, k)
  match(slots(t)[slot]) :
    ;Case 1 of 3: Unoccupied bucket
    (s:Sentinel) : false
    ;Case 2 of 3: Single item bucket
    (s:IntItem<V>) : match?(s,k)
    ;Case 3 of 3: Multiple item bucket
    (s:Array<IntItem<V>>) :
      val n = sizes(t)[slot]
      val i = num-before(s, n, k)
      index-of-item(s, i, n, k) is Int

;==========================
;==== Remove Operation ====
;==========================
defmethod remove<?V> (t:IntTable<?V>, k:Int) :
  val slot = loc(t, k)
  match(slots(t)[slot]) :
    ;Case 1 of 3: Unoccupied bucket
    (s:Sentinel) :
      false
    ;Case 2 of 3: Single item bucket
    (s:IntItem<V>) :
      if match?(s,k) :
        slots(t)[slot] = sentinel()
        decrement-size(t)
        true
    ;Case 3 of 3: Multiple item bucket
    (s:Array<IntItem<V>>) :
      val n = sizes(t)[slot]
      val i = num-before(s, n, k)
      match(index-of-item(s, i, n, k)) :
        (idx:False) : false
        (idx:Int) :
          shift-left(s, idx, n)
          sizes(t)[slot] = n - 1
          decrement-size(t)
          true

;========================
;==== Map! Operation ====
;========================
defmethod map!<?V> (f:KeyValue<Int,V> -> V, t:IntTable<?V>) :
  for (slot in slots(t), idx in 0 to false) do :
    match(slot) :
      ;Case 1 of 3: Unoccupied bucket
      (s:Sentinel) :
        false
      ;Case 2 of 3: Single item bucket
      (s:IntItem<V>) :
        val v = f(key(s) => value(s))
        slots(t)[idx] = IntItem<V>(key(s), v)
      ;Case 3 of 3: Multiple item bucket
      (s:Array<IntItem<V>>) :
        val n = sizes(t)[idx]
        for i in 0 to n do :
          val x = s[i]
          val v = f(key(x) => value(x))
          s[i] = IntItem<V>(key(x), v)

;=============================
;==== Iteration Operation ====
;=============================
defn sequence<?V,?T> (t:IntTable<?V>, f:IntItem<V> -> ?T) :
  val sizes = sizes(t)
  val slots = slots(t)
  generate<T> :
    for idx in 0 to length(slots) do :
      match(slots[idx]) :
        (s:Sentinel) : false
        (s:IntItem<V>) : yield(f(s))
        (s:Array<IntItem<V>>) : for j in 0 to sizes[idx] do : yield(f(s[j]))

defmethod to-seq<?V> (t:IntTable<?V>) :
  defn make-entry (x:IntItem<V>) : key(x) => value(x)
  sequence(t, make-entry)
defmethod keys<?V> (t:IntTable<?V>) :
  sequence(t, key)
defmethod values<?V> (t:IntTable<?V>) :
  sequence(t, value)

;==================================
;==== Convenience Constructors ====
;==================================
public defn IntTable<V> () :
  IntTable<V>(8, no-such-key, false)

public defn IntTable<V> (default:V) :
  IntTable<V>(8, {default}, false)

public defn IntTable-init<V> (init: Int -> V) :
  IntTable<V>(8, init, true)

public defn to-inttable<V> (es:Seqable<KeyValue<Int,V>>) -> IntTable<V> :
  val t = IntTable<V>()
  for e in es do :
    t[key(e)] = value(e)
  t

public defn to-inttable<V> (ks:Seqable<Int>, vs:Seqable<V>) -> IntTable<V> :
  val t = IntTable<V>()
  set-all(t, ks, vs)
  t

;==================================
;======== Printer / Writer ========
;==================================

defmethod print (o:OutputStream, t:IntTable) :
  print(o, "IntTable(")
  for entry in t do :
    lnprint(o, Indented(entry))
  print(o, ")")


;============================================================
;======================== Sets ==============================
;============================================================

;==============================
;==== Mandatory Operations ====
;==============================

public deftype Set<K> <: Collection<K> & Lengthable & HasContents
public defmulti add<?K> (s:Set<?K>, k:K) -> True|False
public defmulti remove<?K> (s:Set<?K>, k:K) -> True|False
public defmulti get<?K> (s:Set<?K>, k:K) -> True|False
public defmulti clear (s:Set) -> False

;==================================
;==== Abstract Implementations ====
;==================================
public defn empty? (s:Set) :
  length(s) == 0

public defmulti add-all<?K> (s:Set<?K>, ks:Seqable<K>) -> False
defmethod add-all<?K> (s:Set<?K>, ks:Seqable<K>) :
  for k in ks do : add(s, k)

defmethod same-contents? (a:Set, b:Set) :
  length(a) == length(b) and all?({a[_]}, b)

;============================================================
;====================== HashSets ============================
;============================================================

public defstruct HashSet<K> <: Set<K> :
  cap : Int with: (setter => set-cap)
  limit : Int with: (setter => set-limit, init => cap * 3 / 4)
  mask : Int with: (setter => set-mask, init => cap - 1)  
  slots : Array<Sentinel|SetItem<K>|Array<SetItem<K>>> with: (setter => set-slots, init => Array<Sentinel|SetItem<K>|Array<SetItem<K>>>(cap, sentinel()))
  sizes : IntArray with: (setter => set-sizes, init => IntArray(cap, 0))
  size : Int with: (setter => set-size, init => 0)
  key-hash : K -> Int
  key-equal? : (K,K) -> True | False
with:
  constructor => #HashSet

defn init<?K> (t:HashSet<?K>, c:Int) :
  set-cap(t, c)
  set-limit(t, c * 3 / 4)
  set-mask(t, c - 1)
  set-slots(t, Array<Sentinel|SetItem<K>|Array<SetItem<K>>>(c, sentinel()))
  set-sizes(t, IntArray(c, 0))
  set-size(t, 0)

defmethod clear<?K> (t:HashSet<?K>) :
  set-size(t, 0)
  set-all(slots(t), 0 to false, sentinel())

public defn HashSet<K> (cap0:Int,
                        key-hash: K -> Int,
                        key-equal?: (K,K) -> True|False) -> HashSet<K> :
  #HashSet<K>(next-pow2(max(8, cap0)), key-hash, key-equal?)


;===================
;==== Utilities ====
;===================
defn set-item<?K> (s:HashSet<?K>, k:K) :
  SetItem<K>(key-hash(s, k), k)

defn loc<?K> (s:HashSet<?K>, h:Int) :
  h & mask(s)

defn key-hash<?K> (t:HashSet<?K>, k:K) -> Int :
  key-hash(t)(k)

defn key-equal?<?K> (t:HashSet<?K>, x:K, y:K) -> True|False :
  key-equal?(t)(x, y)

;Matching predicate for TableItem
defn match?<?K> (s:HashSet<?K>, a:SetItem<K>, b:SetItem<K>) :
  hash(a) == hash(b) and
  key-equal?(s, key(a), key(b))

;Find number of items whose hash is less than h
defn num-before<?K> (s:HashSet<?K>, xs:Array<SetItem<K>>, n:Int, x:SetItem<K>) :
  bsearch({hash(_) < hash(_)}, xs, n, x)

;Look for item with given hash and key starting from i
defn* index-of-item<?K> (s:HashSet<?K>, xs:Array<SetItem<K>>, i:Int, n:Int, y:SetItem<K>) :
  if i < n :
    val x = xs[i]
    if hash(x) == hash(y) :
      if key-equal?(s, key(x), key(y)) : i
      else : index-of-item(s, xs, i + 1, n, y)

;Shift items in xs from i to n right by one element
defn* shift-right<?K> (xs:Array<SetItem<?K>>, i:Int, n:Int) :
  for j in n to i by -1 do :
    xs[j] = xs[j - 1]

;Shift items in xs from (i + 1) to n left by one element
defn* shift-left<?K> (xs:Array<SetItem<?K>>, i:Int, n:Int) :
  for j in i to (n - 1) do :
    xs[j] = xs[j + 1]    

;Copy to new array with hole in position i
defn* copy-with-hole<?K> (xs:Array<SetItem<?K>>, i:Int, n:Int) :
  val xs* = Array<SetItem<K>>(length(xs) * 2)
  xs*[0 to i] = xs[0 to i]
  xs*[(i + 1) to (n + 1)] = xs[i to n]
  xs*

;==========================
;==== Entry Operations ====
;==========================
defn increment-size<?K> (s:HashSet<?K>) :
  set-size(s, size(s) + 1)
  increase-capacity(s) when size(s) >= limit(s)

defn decrement-size<?K> (s:HashSet<?K>) :
  set-size(s, size(s) - 1)

defn increase-capacity<?K> (s:HashSet<?K>) :
  val items = sequence(s, {_})
  init(s, cap(s) * 2)
  do(put{s, _}, items)

defn create-bucket<?K> (t:HashSet<?K>, slot:Int, x0:SetItem<K>, x1:SetItem<K>) :
  val bucket = Array<SetItem<K>>(4)
  slots(t)[slot] = bucket
  sizes(t)[slot] = 2
  ;Populate bucket
  if hash(x0) < hash(x1) :
    ;Add in front
    bucket[0] = x0
    bucket[1] = x1
  else :
    ;Add in back
    bucket[0] = x1
    bucket[1] = x0

defn add-to-bucket<?K> (t:HashSet<?K>, slot:Int, bucket:Array<SetItem<K>>, i:Int, n:Int, x:SetItem<K>) :
  ;Case 1 of 2: Bucket has space.
  if n + 1 < length(bucket) :
    shift-right(bucket, i, n)
    bucket[i] = x
  ;Case 2 of 2: Bucket is full.
  else :
    val bucket* = copy-with-hole(bucket, i, n)
    slots(t)[slot] = bucket*
    bucket*[i] = x
  sizes(t)[slot] = n + 1

;=======================
;==== Put Operation ====
;=======================
;Returns true if new item is added
defn put<?K> (t:HashSet<?K>, x:SetItem<K>) :
  val slot = loc(t, hash(x))
  match(slots(t)[slot]) :
    ;Case 1 of 3: Unoccupied bucket
    (s:Sentinel) :
      ;New Entry
      slots(t)[slot] = x
      increment-size(t)
      true
    ;Case 2 of 3: Single item bucket
    (s:SetItem<K>) :
      ;Case 1 of 2: Item matches
      if match?(t,s,x) :
        false
      ;Case 2 of 2: Add Item
      else :
        create-bucket(t, slot, s, x)
        increment-size(t)
        true
    ;Case 3 of 3: Multiple item bucket
    (s:Array<SetItem<K>>) :
      val n = sizes(t)[slot]
      val i = num-before(t, s, n, x)
      match(index-of-item(t, s, i, n, x)) :
        ;Case 1 of 2: Item exists in bucket
        (idx:Int) :
          false
        ;Case 2 of 2: Add new item to bucket
        (idx:False) :
          add-to-bucket(t, slot, s, i, n, x)
          increment-size(t)
          true

;========================
;==== Key? Operation ====
;========================
defn exists?<?K> (t:HashSet<?K>, x:SetItem<K>) :
  val slot = loc(t, hash(x))
  match(slots(t)[slot]) :
    ;Case 1 of 3: Unoccupied bucket
    (s:Sentinel) : false
    ;Case 2 of 3: Single item bucket
    (s:SetItem<K>) : match?(t,s,x)
    ;Case 3 of 3: Multiple item bucket
    (s:Array<SetItem<K>>) :
      val n = sizes(t)[slot]
      val i = num-before(t, s, n, x)
      index-of-item(t, s, i, n, x) is Int

;==========================
;==== Remove Operation ====
;==========================
;Returns true if item was removed
defn remove<?K> (t:HashSet<?K>,x:SetItem<K>) :
  val slot = loc(t, hash(x))
  match(slots(t)[slot]) :
    ;Case 1 of 3: Unoccupied bucket
    (s:Sentinel) :
      false
    ;Case 2 of 3: Single item bucket
    (s:SetItem<K>) :
      if match?(t,s,x) :
        slots(t)[slot] = sentinel()
        decrement-size(t)
        true
    ;Case 3 of 3: Multiple item bucket
    (s:Array<SetItem<K>>) :
      val n = sizes(t)[slot]
      val i = num-before(t, s, n, x)
      match(index-of-item(t, s, i, n, x)) :
        (idx:False) : false
        (idx:Int) :
          shift-left(s, idx, n)
          sizes(t)[slot] = n - 1
          decrement-size(t)
          true

;=============================
;==== Iteration Operation ====
;=============================
defn sequence<?K,?T> (s:HashSet<?K>, f:SetItem<K> -> ?T) :
  val sizes = sizes(s)
  val slots = slots(s)
  generate<T> :
    for idx in 0 to length(slots) do :
      match(slots[idx]) :
        (s:Sentinel) : false
        (s:SetItem<K>) : yield(f(s))
        (s:Array<SetItem<K>>) : for j in 0 to sizes[idx] do : yield(f(s[j]))

defmethod add<?K> (s:HashSet<?K>, k:K) :
  put(s, set-item(s, k))
defmethod get<?K> (s:HashSet<?K>, k:K) :
  exists?(s, set-item(s, k))
defmethod remove<?K> (s:HashSet<?K>, k:K) :
  remove(s, set-item(s, k))     
defmethod to-seq<?K> (s:HashSet<?K>) :
  sequence(s, key)
defmethod length<?K> (s:HashSet<?K>) :
  size(s)

;==================================
;==== Convenience Constructors ====
;==================================
public defn HashSet<K> (hash: K -> Int, equal?: (K,K) -> True|False) :
  HashSet<K>(8, hash, equal?)

public defn HashSet<K> () -> HashSet<K> :
  HashSet<K&Hashable&Equalable>(8, hash, equal?)

public defn to-hashset<K> (xs:Seqable<K>) -> HashSet<K> :
  val s = HashSet<K>()
  do(add{s, _}, xs)
  s

public defn hashset-union<T> (a:Seqable<T&Equalable&Hashable>, b:Seqable<T&Equalable&Hashable>) -> HashSet<T> :
  to-hashset<T>(cat(a,b))

public defn hashset-intersection<T> (a:Seqable<T&Equalable&Hashable>, b:Seqable<T&Equalable&Hashable>) -> HashSet<T> :
  val aset = to-hashset<T>(a)
  to-hashset<T> $ filter({aset[_]}, b)

;==================================
;======== Printer / Writer ========
;==================================

defmethod print (o:OutputStream, s:HashSet) :
  print(o, "HashSet(%,)" % [seq(written,s)])

;============================================================
;====================== IntSets =============================
;============================================================

public defstruct IntSet <: Set<Int> :
  cap : Int with: (setter => set-cap)
  limit : Int with: (setter => set-limit, init => cap * 3 / 4)
  mask : Int with: (setter => set-mask, init => cap - 1)  
  slots : Array<Sentinel|Int|IntArray> with: (setter => set-slots, init => Array<Sentinel|Int|IntArray>(cap, sentinel()))
  sizes : IntArray with: (setter => set-sizes, init => IntArray(cap, 0))
  size : Int with: (setter => set-size, init => 0)
with:
  constructor => #IntSet

defn init (t:IntSet, c:Int) :
  set-cap(t, c)
  set-limit(t, c * 3 / 4)
  set-mask(t, c - 1)
  set-slots(t, Array<Sentinel|Int|IntArray>(c, sentinel()))
  set-sizes(t, IntArray(c, 0))
  set-size(t, 0)

defmethod clear (t:IntSet) :
  set-size(t, 0)
  set-all(slots(t), 0 to false, sentinel())

public defn IntSet (cap0:Int) -> IntSet :
  #IntSet(next-pow2(max(8, cap0)))

;===================
;==== Utilities ====
;===================    
defn loc (t:IntSet, h:Int) :
  h & mask(t)

;Find number of items whose hash is less than h
defn num-before (xs:IntArray, n:Int, x:Int) :
  bsearch(less?, xs, n, x)

;Look for item with given hash and key starting from i
defn* index-of-item (xs:IntArray, i:Int, n:Int, y:Int) :
  if i < n :
    val x = xs[i]
    if x == y : i

;Shift items in xs from i to n right by one element
defn* shift-right (xs:IntArray, i:Int, n:Int) :
  for j in n to i by -1 do :
    xs[j] = xs[j - 1]

;Shift items in xs from (i + 1) to n left by one element
defn* shift-left (xs:IntArray, i:Int, n:Int) :
  for j in i to (n - 1) do :
    xs[j] = xs[j + 1]    

;Copy to new array with hole in position i
defn* copy-with-hole (xs:IntArray, i:Int, n:Int) :
  val xs* = IntArray(length(xs) * 2)
  xs*[0 to i] = xs[0 to i]
  xs*[(i + 1) to (n + 1)] = xs[i to n]
  xs*

;==========================
;==== Entry Operations ====
;==========================
defn increment-size (t:IntSet) :
  set-size(t, length(t) + 1)
  increase-capacity(t) when length(t) >= limit(t)

defn decrement-size (t:IntSet) :
  set-size(t, length(t) - 1)

defn increase-capacity (t:IntSet) :
  val s = to-seq(t)
  init(t, cap(t) * 2)
  do(add{t, _}, s)

defn create-bucket (t:IntSet, slot:Int, x0:Int, x1:Int) :
  val bucket = IntArray(4)
  slots(t)[slot] = bucket
  sizes(t)[slot] = 2
  ;Populate bucket
  if x0 < x1 :
    ;Add in front
    bucket[0] = x0
    bucket[1] = x1
  else :
    ;Add in back
    bucket[0] = x1
    bucket[1] = x0

defn add-to-bucket (t:IntSet, slot:Int, bucket:IntArray, i:Int, n:Int, x:Int) :
  ;Case 1 of 2: Bucket has space.
  if n + 1 < length(bucket) :
    shift-right(bucket, i, n)
    bucket[i] = x
  ;Case 2 of 2: Bucket is full.
  else :
    val bucket* = copy-with-hole(bucket, i, n)
    slots(t)[slot] = bucket*
    bucket*[i] = x
  sizes(t)[slot] = n + 1

;=======================
;==== Put Operation ====
;=======================
;Returns true if new item is added
defmethod add (t:IntSet, x:Int) :
  val slot = loc(t, x)
  match(slots(t)[slot]) :
    ;Case 1 of 3: Unoccupied bucket
    (s:Sentinel) :
      ;New Entry
      slots(t)[slot] = x
      increment-size(t)
      true
    ;Case 2 of 3: Single item bucket
    (s:Int) :
      ;Case 1 of 2: Item matches
      if s == x :
        false
      ;Case 2 of 2: Add Item
      else :
        create-bucket(t, slot, s, x)
        increment-size(t)
        true
    ;Case 3 of 3: Multiple item bucket
    (s:IntArray) :
      val n = sizes(t)[slot]
      val i = num-before(s, n, x)
      match(index-of-item(s, i, n, x)) :
        ;Case 1 of 2: Item exists in bucket
        (idx:Int) :
          false
        ;Case 2 of 2: Add new item to bucket
        (idx:False) :
          add-to-bucket(t, slot, s, i, n, x)
          increment-size(t)
          true

;========================
;==== Key? Operation ====
;========================
defmethod get (t:IntSet, x:Int) :
  val slot = loc(t, x)
  match(slots(t)[slot]) :
    ;Case 1 of 3: Unoccupied bucket
    (s:Sentinel) : false
    ;Case 2 of 3: Single item bucket
    (s:Int) : s == x
    ;Case 3 of 3: Multiple item bucket
    (s:IntArray) :
      val n = sizes(t)[slot]
      val i = num-before(s, n, x)
      index-of-item(s, i, n, x) is Int

;==========================
;==== Remove Operation ====
;==========================
;Returns true if item was removed
defmethod remove (t:IntSet, x:Int) :
  val slot = loc(t, x)
  match(slots(t)[slot]) :
    ;Case 1 of 3: Unoccupied bucket
    (s:Sentinel) :
      false
    ;Case 2 of 3: Single item bucket
    (s:Int) :
      if s == x :
        slots(t)[slot] = sentinel()
        decrement-size(t)
        true
    ;Case 3 of 3: Multiple item bucket
    (s:IntArray) :
      val n = sizes(t)[slot]
      val i = num-before(s, n, x)
      match(index-of-item(s, i, n, x)) :
        (idx:False) : false
        (idx:Int) :
          shift-left(s, idx, n)
          sizes(t)[slot] = n - 1
          decrement-size(t)
          true

;=============================
;==== Iteration Operation ====
;=============================
defmethod to-seq (t:IntSet) :
  val sizes = sizes(t)
  val slots = slots(t)
  generate<Int> :
    for idx in 0 to length(slots) do :
      match(slots[idx]) :
        (s:Sentinel) : false
        (s:Int) : yield(s)
        (s:IntArray) : for j in 0 to sizes[idx] do : yield(s[j])

defmethod length (t:IntSet) :
  size(t)

;==================================
;==== Convenience Constructors ====
;==================================
public defn IntSet () :
  IntSet(8)

public defn to-intset (xs:Seqable<Int>) -> IntSet :
  val s = IntSet()
  do(add{s, _}, xs)
  s

;==================================
;======== Printer / Writer ========
;==================================

defmethod print (o:OutputStream, s:IntSet) :
  print(o, "IntSet(%,)" % [seq(written,s)])
 
;============================================================
;==================== Errors ================================
;============================================================

;Occurs when we try to set/get a missing key in a table.
public defstruct MissingTableKey <: RuntimeError :
  key

defmethod print (o:OutputStream, e:MissingTableKey) :
  print(o, "Key %_ does not exist in table." % [key(e)])
