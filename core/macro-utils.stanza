;See License.txt for details about licensing.
;TODO: Templates should be lazy unfilled objects, then a fill
;interpreter will fill in the thing at the end. This is so bindings
;don't have to passed around repeatedly.

defpackage macro-utils :
   import core
   import collections

;============================================================
;=================== Utilities ==============================
;============================================================

public defn tagged-list? (form, tag:Symbol) -> True|False :
   match(form) :
      (t:Token) : tagged-list?(item(t), tag)
      (t:List) :
         if not empty?(t) :
            match(unwrap-token(head(t))) :
               (h:Symbol) : h == tag
               (h) : false
      (t) : false

;============================================================
;=================== Templates ==============================
;============================================================

defstruct Splice :
   item:List
   
defstruct Substitute :
   pattern
   bindings: Collection<KeyValue<Symbol,?>>

defstruct Nested :
   bindings: Collection<Collection<KeyValue<Symbol,?>>>

defstruct Choice :
   index: Int

defstruct Deep :
   item

defmethod print (o:OutputStream, x:Splice) :
   print(o, "SPLICE(%_)" % [item(x)])

defmethod print (o:OutputStream, x:Substitute) :
   print(o, "SUBSTITUTE(%_, %_)" % [pattern(x), bindings(x)])

defmethod print (o:OutputStream, x:Nested) :
   print(o, "NESTED(%_)" % [bindings(x)])

defmethod print (o:OutputStream, x:Choice) :
   print(o, "CHOICE(%_)" % [index(x)])

defmethod print (o:OutputStream, x:Deep) :
   print(o, "DEEP(%_)" % [item(x)])

;============================================================
;=============== Template Interpreter =======================
;============================================================

deftype Flag

defn fill-template (form) :
   ;Top level fill interpreter
   ;Returns a completely filled template.
   defn fill (form, bs:List<KeyValue<Symbol,?>>) -> ? :
      match(form) :
         (form:Substitute) :
            val bs* = append(bindings(form), bs)
            substitute(pattern(form), bs*)
         (form:List) :
            fill-all(form, bs)
         (form:Splice) :
            Splice(fill(item(form), bs))
         (form:Token) :
            Token(fill(item(form), bs), info(form))
         (form) :
            form

   defn fill-all (form:List, bs:List<KeyValue<Symbol,?>>) -> List :
      if empty?(form) : List()
      else : attach(fill(head(form), bs), fill(tail(form), bs))

   ;Attach the given head to the given list
   ;according to the proper splicing rules.
   defn attach (h, rest:List) :
      match(h) :
         (h:Splice) : append(item(h), rest)
         (h) : cons(h, rest)

   defn get-binding (x:Symbol, bs:List<KeyValue<Symbol,?>>) :
      match(lookup?(bs, x, new Flag)) :
         (v:Flag) : None()
         (v:Deep) : One(item(v))
         (v) : One(v)

   defn deep (bs:List<KeyValue<Symbol,?>>) :
      to-list $ for b in bs filter :
         value(b) is Deep

   defn afns (xs:List) -> [List, List] :
      if empty?(xs) or not tagged-list?(head(xs), `@do-afn) :
         [List(), xs]
      else :
         val a-args = tail(unwrap-token(head(xs)))
         val [b-args, rest] = afns(tail(xs))
         [cons(a-args, b-args), rest]

   defn substitute (pattern, bs:List<KeyValue<Symbol,?>>) -> ? :
      match(pattern) :
         (pattern:Symbol) :
            head(substitute(pattern, List(), bs))
         (pattern:List) :
            if empty?(pattern) : pattern
            else : substitute(head(pattern), tail(pattern), bs)
         (pattern) :
            pattern
            
   defn substitute (h, rest, bs:List<KeyValue<Symbol,?>>) -> List :
      match(h) :
         (h:Symbol) :
            val v = get-binding(h, bs)
            if empty?(v) :
               cons(h, substitute(rest, bs))
            else :
               match(value!(v)) :
                  (h:Nested) :
                     val [afns, _] = afns(rest)
                     fatal("Nested template must be followed with a pattern.") when empty?(afns)
                     val subbed = for b in bindings(h) seq-cat :
                        substitute(head(afns), append(b, bs))
                     append(subbed, substitute(tail(rest), bs))   
                  (h:Choice) :
                     val [afns, tail] = afns(rest)
                     fatal("Choice template index (%_) out of bounds." % [index(h)]) when index(h) >= length(afns)
                     append(substitute(afns[index(h)], bs), substitute(tail, bs))
                  (h) :
                     val h* = fill(h, deep(bs))
                     attach(h*, substitute(rest, bs))
         (h) :
            cons(substitute(h, bs), substitute(rest, bs))

   fill(form, List())

;============================================================
;==================== Scratch ===============================
;============================================================

defn main () :
   val form1 = Substitute(
      `(#y #x x), [])
      
   val form = `(#y #x f(x) g{a}{b}{c d e} bindings{x})
   val template = Substitute(form, [
      `#y => Deep(`global-y)
      `#x => Deep(`global-x)
      `x => Splice(`(g y z))
      `c => List(Splice(`(1)), Splice(`(2)), Splice(`(3)))
      `g => Choice(2)
      `bindings => Nested $ [
         [`x => form1
          `#x => Deep(`global-x2)]
         []
      ]])
   println(fill-template(template))

main()

;;============================================================
;;=================== Public Interface =======================
;;============================================================
;
;public defn splice (item:Collection|Token) :
;   match(unwrap-token(item)) :
;      (x:Collection) : SpliceTemplate(x)
;      (x) : fatal("Splicing operator requires a Collection.")   
;
;public defn nested (items:Collection<Collection<KeyValue<Symbol,?>>>) :
;   NestedTemplate(items)
;
;public defn choice (n:Int) :
;   ChoiceTemplate(n)
;   
;public defn choice (b:True|False) :
;   ChoiceTemplate(0 when b else 1)
;
;;TODO: Rename collection to plural
;public defn collect (entries: Seqable<KeyValue<Symbol, Seqable>>) :
;   ;Collect keys and values
;   val keys = Vector<Symbol>()
;   val values = Vector<Vector<?>>()
;   for entry in entries do :
;      add(keys, key(entry))
;      add(values, to-vector<?>(value(entry)))
;
;   if empty?(keys) :
;      nested(List())
;   else :      
;      ;Ensure that all values have same length
;      val n = length(values[0])
;      if not all?({length(_) == n}, values) :
;         fatal("All entries in a collect template must have same length.")
;    
;      ;Make templates
;      nested $ to-list $ for i in 0 to n seq :
;         to-list $ for (k in keys, v in values) seq :
;            k => v[i]
;
;public defn fill-template (template, replacements:Collection<KeyValue<Symbol,?>>) :
;   fill(template, to-list(replacements))
;
;;============================================================
;;=================== Utilities ==============================
;;============================================================
;
;public defn tagged-list? (form, tag:Symbol) -> True|False :
;   match(form) :
;      (t:Token) : tagged-list?(item(t), tag)
;      (t:FullList) :
;         match(unwrap-token(head(t))) :
;            (h:Symbol) : h == tag
;            (h) : false
;      (t) : false
;
;defstruct Sentinel
;
;;============================================================
;;=================== Templates ==============================
;;============================================================
;   
;defstruct SpliceTemplate :
;   item: Collection   
;
;defstruct NestedTemplate :
;   items: Collection<Collection<KeyValue<Symbol,?>>>   
;
;defstruct ChoiceTemplate :
;   selection: Int
;
;;============================================================
;;=================== Fill Interpreter =======================
;;============================================================
;
;defn fill (template, replacements:List<KeyValue<Symbol,?>>) -> ? :
;   ;                     Choice
;   ;                     ======
;   defn following-do-afns (xs:List) -> [List<List>, List] :
;      if empty?(xs) :
;         [List(), xs]
;      else if tagged-list?(head(xs), `@do-afn) :
;         val x = tail(unwrap-token(head(xs)))
;         val [xs, rest] = following-do-afns(tail(xs))
;         [cons(x,xs), rest]
;      else :
;         [List(), xs]
;
;   defn select-choice (t:ChoiceTemplate, xs:List) -> [List, List] :
;      val [forms, rest*] = following-do-afns(xs)
;      if selection(t) >= length(forms) :
;         fatal("ChoiceTemplate index (%_) is out of bounds." % [selection(t)])
;      val filled = fill(forms[selection(t)], replacements)
;      [filled, rest*]   
;
;   ;                 Nested Template
;   ;                 ===============
;   defn replace-nested (t:NestedTemplate, rest:List) -> [List, List] :
;      if (not empty?(rest)) and tagged-list?(head(rest), `@do-afn) :
;         val form = tail(unwrap-token(head(rest)))
;         val rest* = tail(rest)
;         val filled = for env in items(t) seq-append :
;            fill(form, append(env, replacements))
;         [filled, rest*]   
;      else :
;         fatal("Nested keyword is not followed with a template.")
;         
;   ;                 Processing Loop
;   ;                 ===============
;   defn get-template (x) -> Maybe :
;      match(unwrap-token(x)) :
;         (x:Symbol) :
;            val e = lookup?(replacements, x, Sentinel())
;            if e is Sentinel : None()
;            else : One(e)
;         (x) : None()
;         
;   defn loop (form) -> ? :
;      match(form) :
;         (t:Token) :
;            Token(loop(item(t)), info(t))
;         (xs:FullList) :
;            val rest = tail(xs)
;            match(get-template(head(xs))) :
;               (t:One) :
;                  match(value(t)) :
;                     (t:SpliceTemplate) :
;                        append(item(t), loop(rest))
;                     (t:NestedTemplate) :
;                        val [x*, rest*] = replace-nested(t, rest)
;                        append(x*, loop(rest*))
;                     (t:ChoiceTemplate) :
;                        val [x*, rest*] = select-choice(t, rest)
;                        append(x*, loop(rest*))
;                     (t) :
;                        cons(t, loop(rest))                     
;               (t:None) :
;                  cons(loop(head(xs)), loop(rest))               
;         (x) :
;            x
;
;   ;                     Driver
;   ;                     ======
;   loop(template)