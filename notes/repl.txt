Philosophy of Reloading
=======================

(1) The only mode is reload. There is no shadow mode.
(2) Reloading is allowed to fail.
(3) Reloading fails when the Live World depends upon some definition in the Reloaded World and the Reloaded World no longer has that definition.
(4) The Live World is:
  - All packages that are not reloaded.
  - The instance methods of live objects.
  - Live closures

(5) The only other command is reload-all. This clears the entire heap, destroys all live objects, and reloads everything that has changed. 

HYPOTHESIS: There is only one use-case for shadowing: We want to keep the existing objects, and they should behave the same way as before. The hypothesis is that this is a non-use-case, no one actually wants this. 

Two Use Cases
=============

1. Selective Reload:
     I updated my code.
     Load in the new changes.
     Tell me if I broke some dependency.

2. Reload All:
     Here's my new codebase.
     Reload everything.
     Do it quickly.

Step-by-Step
============

Step 1: Let us first start with a minimal language, and grow the depth to the end, and then add the other constructs needed for full Stanza.

  defpackage mypackage :
    import package1
    import package2

  defstruct A :
    x: B
    y: C
  
  defstruct B
  
  defn myfunction (x:A, y:B) -> C :
    myfunction2(op(x, y))

  defn myfunction2 (y:C) -> D :
    op(y)
    
That's it. It allows for packages, struct definitions, and function definitions. The within-function commands are either primitive operations or function calls. There is no control flow either at this point.

We don't need a type inference system, because we mandate that the types be specified. And therefore we can just check it against the expected type. 


func f1023 (abd, adf, odf) :
  def abd : t1
  def adf : t2
  def odf : t3
  in
  body{abd, adf, odf}

During inlining what happens? We append the defs, and the body. Does that require renaming? Yes if we want to keep the defs globally unique. No, if not. The changes of collision are small, so we will often not require renaming. 

What are the advantages of globally unique identifiers? Type inference is trivial? Because every identifier has only a single type. That is true, but it seems like it's not used very often. 

What about basic blocks? 


Now, what happens if we need to look at the live objects and figure out what to do about them?

Live objects have methods that they can run on:
  - These methods call other things.
  - Things that still have to be there when code is reloaded. 

- Note that only live objects that are created within the package being reloaded is actually a problem.

- NOTE: Here's a conservative rule that will definitely work:
  - You can NEVER change an existing definition.

No live objects can change? 

================================================================================
================================================================================
================================================================================

The expression language has the explicit concept of an 'init', which is good.

The virtual machine language does not have the explicit concept of an 'init'. Currently, it uses the distinguished function 0, but that's likely to run into problems soon.

Starting from the use-cases again, here's the things that we need to be able to do:
  1. Load in some packages, and run the initializers.
  2. The user types in code on the repl, load in the code, and run it.
     (and then throw it away).
  3. Run all the initializers for a given package again. 

Suppose we can just poke the VM, and tell it to run a given function.
     
So a package needs to know how to reference its initializers. 
That seems fine. The ID tracker should keep track of this. 

