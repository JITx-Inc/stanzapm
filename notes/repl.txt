Philosophy of Reloading
=======================

(1) The only mode is reload. There is no shadow mode.
(2) Reloading is allowed to fail.
(3) Reloading fails when the Live World depends upon some definition in the Reloaded World and the Reloaded World no longer has that definition.
(4) The Live World is:
  - All packages that are not reloaded.
  - The instance methods of all the live objects.

(5) The only other command is reload-all. This clears the entire heap, destroys all live objects, and reloads everything that has changed. 

HYPOTHESIS: There is only one use-case for shadowing: We want to keep the existing objects, and they should behave the same way as before. The hypothesis is that this is a non-use-case, no one actually wants this. 

Two Use Cases
=============

1. Selective Reload:
     I updated my code.
     Load in the new changes.
     Tell me if I broke some dependency.

2. Reload All:
     Here's my new codebase.
     Reload everything.
     Do it quickly.

Step-by-Step
============

Step 1: Let us first start with a minimal language, and grow the depth to the end, and then add the other constructs needed for full Stanza.

  defpackage mypackage :
    import package1
    import package2

  defstruct A :
    x: B
    y: C
  
  defstruct B
  
  defn myfunction (x:A, y:B) -> C :
    myfunction2(op(x, y))

  defn myfunction2 (y:C) -> D :
    op(y)
    
That's it. It allows for packages, struct definitions, and function definitions. The within-function commands are either primitive operations or function calls. There is no control flow either at this point.


