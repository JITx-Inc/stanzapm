Design of the Descriptor Language
=================================

Here are all the possible global identifiers of a definition:

A typeid is uniquely specified by its package and its name.
  Type(mypackage, MyType)

A functionid is uniquely specified by its package, name, and argument types.
  Func(mypackage, MyFunc, Type1, Type2, Type3)

Here's the grammar for types:
  Byte
  Int
  Long
  Float
  Double
  EOf(Typeid)

Here is how an export is defined:

  def 113 Type(mypackage, MyType), Type
  def 114 Func(mypackage, MyFunc, Type1, Type2, Type3), Func(Type1, Type2, Type3, RetType)


  

Design of the Expression Language
=================================

The main functionality of the package is defined using package-local integer IDs.

  defn F103 (L1, L113) -> T117 :
    def L1 : T1
    def L113 : T12|int
    body ...

The imports/exports section of the package defines the relation between this package and other packages. Every export definition looks like this:

  export 113 type(compiler/stz-compiler, MyStruct)
  export 119 type(compiler/stz-compiler, MyStruct)
  export 190 func(compiler/stz-compiler, myfunction,
               type(compiler/stz-compiler, A),
               type(compiler/stz-compiler, B),
               type(compiler/stz-compiler, C))

Every ID is associated with a unique descriptor. This descriptor allows us to look for an expected definition. 

  import 113 type(compiler/stz-compiler, MyStruct)
  import 117 func(compiler/stz-compiler, myfunction,
                          type(compiler/stz-compiler, A),
                          type(compiler/stz-compiler, B),
                          type(compiler/stz-compiler, C))

How is checking versus matching handled? There is a full ID? And we can extract a partial ID for matching? This is particularly true for struct definitions. 

============================================================

Okay, each package will have a list of imports and exports.

When we reload a package, we compare it's list of exports with what is required by the other packages, to determine whether it can be safely loaded. Otherwise it issues an error.

FLOW:
  -> Given the environment, we can infer types and typecheck the reloaded package.
  -> Once it typechecks, we can produce the import/export list.
  -> That import/export list can then be checked against the live heap for possible collisions.


So the VM contains the import/export environment, and can check a proposal import/export list. 

============================================================
======================= Expressions to Handle ==============
============================================================


GUARDS:

  1. Parameters into HiStanza function 
  2. Results from HiStanza function
  3. Parameters into LoStanza function
  4. Results from LoStanza function
  5. Arguments into HiStanza function
  6. Arguments into LoStanza function
  7. Values out of HiStanza storage
  8. Values out of LoStanza storage
  
  9. Values into HiStanza storage (Same as Results from HiStanza function)
  10. Values into LoStanza storage (Same as Results from LoStanza function)

INVARIANTS:

  - From within LoStanza you may assume that:
    - it is called correctly.
    - it operates correctly. 

The only tricky case is interacting with HiStanza functions from within LoStanza:
  - check it as well...
  - essentially everything that touches HiStanza is checked. OKAY.
    that is straightforward at least.

All other cases are straightforward:

    If that is true, then why should HiStanza check calls to LoStanza?

============================================================
========================= TODO =============================
============================================================

Questions:
  - For the check-do form, why do we need the xtype? Doesn't the type
    of the destination already give this?
    - What about for mutable variables? We cannot assign directly to
      them anyway. All assignments have to be done through EAssign.
  - Ditto for the do form.
  - If we do not guarantee the return types from functions, will we
    have too many checks? We will guarantee the return types from functions.
  - What is the difference between Init/Set
  - Do we need an initialized? annotation to check whether variables
    are initialized and to eliminate the CheckSet check?

Answers:
  - We do not need the xtype, so get rid of it.
  - We will change ESet to EDef.
  - We will use EStore for assignment.
  - We will eliminate tail-call multis and methods. It's not used. And
    then enforce function post-conditions by confirming types on
    return.
  - We will have methods inherit the return type of their multis to
    help enforce post-conditions.

