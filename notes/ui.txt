[===== Build System =====]

Use Case:
  1. I am working on a large collection of packages, each in their own
  files. They are constantly in a state of development.
  2. I now write a small program (perhaps a test program) that imports
  a package.
  3. I want to compile the small program with the most up-to-date
  version of its dependencies as possible.

[===== Dynamic Scope =====]

Use Case:
  1. I have two "fibers" that both update a dynamic variable POSITION,
  incrementing and decrementing it to reflect the position of a ball.
  2. I run each fiber within a let-var to reflect that they each have
  their own version of POSITION.
  3. This should run correctly as control flow flip flops between the
  two.

[===== Inlining of Productions containing != Rules =====]

Use Case:
  1. I have this rule that matches all forms except the x symbol:
  
      defproduction sube
      defrule sube != (x)
      defrule sube = (?x) : x

  2. In the main rule, I then try to read one of these.

      defrule e = (?e:#sube) : e

  3. What is the difference between that and the inline statement?

      defrule e = inline #sube

[===== Conditional Subtyping =====]

Two Desires:
  1. Test whether x is Hashable before calling hash on it. Thus if x
  is Hashable returns true, then calling hash should not crash the
  program.
  
  2. Assume that Apple is not Hashable. Calling hash on a List<Apple>
  should be caught by the compiler, because it will obviously crash
  the program.

[===== Inheritance of State =====]

Use Case:
  1. As a top-level method, I can write

      defmethod diameter (c:Circle) :
        2.0 * radius(c)

     but I cannot write a memoized version of it.

     I wish to write something like the following :

      defmethods Circle :
        var diameter = false
        defmethod diameter (this) :
          (diameter = 2.0 * radius(this)) when diameter is False
          diameter as Double

     With this ability, we will be able to automatically lock
     sequences so that the original sequence is not touched anymore
     after they go through some sequence operator.

      val xs = filter(pred?, ys)
      next(ys) <-- this will now flag an error.
