defpackage stz/vm-normalize :
  import core
  import collections
  import stz/vm-ir
  import stz/basic-ops
  import stz/backend

;- HighStanza IntOps need to be lowered to sequences of primitive ops.
;- Call commands need to be broken up into register and memory arguments.
;- Large immediates need to be pushed to the constant tables.
;- Alloc instructions need to be broken into a test instruction and an action instruction.
;- Load/Store instructions need to be expressed with a single base and offset.
;- Stack extension needs to be lowered.
;- Multifns need to be lowered.
;- CallClosures need to be lowered.
;- External Memory Locations 

public defn normalize (prog:VMPackage, backend:Backend) :
  val funcs* = for f in funcs(prog) map :
    val func* = normalize(func(f), backend)
    VMDefn(id(f), dependencies(f), func*)
  sub-funcs(prog, funcs*)

public defn normalize (f:VMFunction, backend:Backend) :
  ;Create instruction buffer
  val buffer = InsBuffer(f)
  
  ;Load instructions for a single standard function
  defn load-instructions (f:VMFunc) :
    load-prelude(f)
    do(load-instruction, ins(f))

  ;Load instructions for a multi
  defn load-multi-instructions (f:VMFunc) :
    ;Emit normalized dispatch instruction
    val f-ins = to-seq(ins(f))
    val dispatch-ins = next(f-ins) as MethodDispatchIns
    val default-dispatch = default(dispatch-ins)
    val amb-dispatch = amb(dispatch-ins)
    emit(buffer, MethodDispatchIns(multi(dispatch-ins), [], [], default-dispatch, amb-dispatch))
    for i in f-ins do :
      load-instruction(i)
      match(i:LabelIns) :
        if n(i) == default-dispatch or n(i) == amb-dispatch :
          load-prelude(f)

  ;Load instructions for a variable-arity multifn
  defn load-instructions (f:VMMultifn) :
    for entry in funcs(f) do :
      val arity = key(entry)
      val func = value(entry)
      val right-arity-lbl = make-label(buffer)
      val wrong-arity-lbl = make-label(buffer)
      emit(buffer, Branch0Ins(right-arity-lbl, wrong-arity-lbl, ArgEqOp(arg(f), arity)))
      emit(buffer, LabelIns(right-arity-lbl))
      load-instructions(func)
      emit(buffer, LabelIns(wrong-arity-lbl))
    load-instructions(default(f))

  ;Load prelude to a function
  defn load-prelude (f:VMFunc) :
    ;Check stack extension
    val has-stack-lbl = make-label(buffer)
    val no-stack-lbl = make-label(buffer)
    load-instruction(Branch0Ins(has-stack-lbl, no-stack-lbl, HasStackOp()))
    load-instruction(LabelIns(no-stack-lbl))
    load-instruction(ExtendStackIns())
    load-instruction(GotoIns(has-stack-lbl))
    load-instruction(LabelIns(has-stack-lbl))
    
    ;Get arguments    
    val ret = ret-records(buffer, args(f), backend)
    load-instruction(ArgIns(ret))

  ;Size of an object on heap
  defn object-size-on-heap (sz:Int) :
    max((sz + 8 + 7) & -8, 16)
  defn object-size-on-heap (x:VMImm) :
    object-size-on-heap(value(x as NumConst) as Int)

  ;Load single instruction
  defn load-instruction (i:VMIns) :
    match(i) :
      (i:CallIns) :
        val args = call-records(buffer, ys(i), backend)
        val ret = ret-records(buffer, xs(i), backend)
        emit(buffer, CallRecordIns(ret, /f(i), args, info(i), StanzaCall()))
      (i:TCallIns) :
        val args = call-records(buffer, ys(i), backend)
        val ret = RetRecords([])
        emit(buffer, CallRecordIns(ret, /f(i), args, false, StanzaTCall()))
      (i:CallCIns) :
        val args = callc-records(buffer, ys(i), backend)
        val ret = retc-records(buffer, xs(i) backend)
        emit(buffer, CallRecordIns(ret, /f(i), args, info(i), CCall()))
      (i:CallClosureIns) :
        val args = call-records(buffer, ys(i), backend)
        val ret = ret-records(buffer, xs(i), backend)
        val code = make-local(buffer, VMLong())
        emit(buffer, LoadIns(code, /f(i), false, 16 - 1))
        emit(buffer, CallRecordIns(ret, code, args, info(i), StanzaCall()))
      (i:TCallClosureIns) :
        val args = call-records(buffer, ys(i), backend)
        val ret = RetRecords([])
        val code = make-local(buffer, VMLong())
        emit(buffer, LoadIns(code, /f(i), false, 16 - 1))
        emit(buffer, CallRecordIns(ret, code, args, false, StanzaTCall()))
      (i:AllocIns) :
        if all?({_ is NumConst}, sizes(i)) :
          val sizes-on-heap = map(object-size-on-heap, sizes(i))
          val size-on-heap = NumConst(to-long(sum(sizes-on-heap)))
          val has-space-lbl = make-label(buffer)
          val no-space-lbl = make-label(buffer)
          emit(buffer, Branch1Ins(has-space-lbl, no-space-lbl, HasHeapOp(), size-on-heap))
          emit(buffer, LabelIns(no-space-lbl))
          emit(buffer, ExtendHeapIns(size-on-heap, info(i)))
          emit(buffer, GotoIns(has-space-lbl))
          emit(buffer, LabelIns(has-space-lbl))
          for (x in xs(i), type in types(i), size-on-heap in sizes-on-heap) do :
            emit(buffer, AllocOnHeap(x, NumConst(size-on-heap)))
            emit(buffer, StoreIns(x, false, -1, Tag(type)))
        else :
          fatal("Multiple variable-sized allocations.") when length(sizes(i)) > 1
          val x = xs(i)[0]
          val size = sizes(i)[0]
          val type = types(i)[0]
          val size-on-heap = make-local(buffer, VMLong())
          emit(buffer, Op2Ins(size-on-heap, AddOp(), size, NumConst(15L)))
          emit(buffer, Op2Ins(size-on-heap, AndOp(), size-on-heap, NumConst(-8L)))
          val has-space-lbl = make-label(buffer)
          val no-space-lbl = make-label(buffer)
          emit(buffer, Branch1Ins(has-space-lbl, no-space-lbl, HasHeapOp(), size-on-heap))
          emit(buffer, LabelIns(no-space-lbl))
          emit(buffer, ExtendHeapIns(size-on-heap, info(i)))
          emit(buffer, GotoIns(has-space-lbl))
          emit(buffer, LabelIns(has-space-lbl))
          emit(buffer, AllocOnHeap(x, size-on-heap))
          emit(buffer, StoreIns(x, false, -1, Tag(type)))
      (i:StoreIns) :
        ;Compute new offset after factoring in ref tag
        val offset* = (offset(i) + 8 - 1) when type(buffer,x(i)) is VMRef
                 else offset(i)
        match(y(i)) :
          (y:False) :
            emit(buffer, StoreIns(x(i), false, offset*, z(i), class(i)))
          (y:VMImm) :
            val base = make-local(buffer, VMLong())
            emit(buffer, Op2Ins(base, AddOp(), x(i), y))
            emit(buffer, StoreIns(base, false, offset*, z(i), class(i)))
      (i:LoadIns) :
        ;Compute new offset after factoring in ref tag
        val offset* = (offset(i) + 8 - 1) when type(buffer,y(i)) is VMRef
                 else offset(i)
        match(z(i)) :
          (z:False) :
            emit(buffer, LoadIns(x(i), y(i), false, offset*, class(i)))
          (z:VMImm) :
            val base = make-local(buffer, VMLong())
            emit(buffer, Op2Ins(base, AddOp(), y(i), z))
            emit(buffer, LoadIns(x(i), base, false, offset*, class(i)))
      (i) :
        emit(buffer, i)

  ;A multi starts with a method-dispatch instruction
  defn multi? (f:VMFunc) :
    not empty?(ins(f)) and ins(f)[0] is MethodDispatchIns

  ;Load instructions  
  match(f) :
    (f:VMFunc) :
      if multi?(f) : load-multi-instructions(f)
      else : load-instructions(f)
    (f:VMMultifn) :
      load-instructions(f)
  
  ;Convert buffer to function
  val func = to-func(buffer)

  ;Ensure we did normalization correctly
  println(func)
  ensure-normalized(func, backend)

  ;Return normalized function
  func

;============================================================
;==================== New Instructions ======================
;============================================================

public defstruct CallRecordIns <: VMIns :
  ret: RetRecords
  f: VMImm
  args: CallRecords
  info: False|FileInfo with: (as-method => true)
  type: CallType
 with: (printer => true)

public defstruct ArgIns <: VMIns :
  ret: RetRecords
with: (printer => true)

public defstruct AllocOnHeap <: VMIns :
  x: Local
  size: VMImm
with: (printer => true)

public defstruct ExtendHeapIns <: VMIns :
  size: VMImm
  info: False|FileInfo with: (as-method => true)
with: (printer => true)

public defstruct ExtendStackIns <: VMIns
with: (printer => true)

public defstruct HasHeapOp <: VMOp
with: (printer => true)

public defstruct HasStackOp <: VMOp
with: (printer => true)

public defstruct ArgEqOp <: VMOp :
  arg: Int
  value: Int
with: (printer => true)

public deftype CallType
public defstruct StanzaCall <: CallType with: (printer => true)
public defstruct StanzaTCall <: CallType with: (printer => true)
public defstruct CCall <: CallType with: (printer => true)
public defstruct YieldCall <: CallType with: (printer => true)

public deftype ArgType
public defstruct StanzaArg <: ArgType with: (printer => true)
public defstruct CArg <: ArgType with: (printer => true)

;============================================================
;============== Classification of Immediates ================
;============================================================

;x is a large immediate if it can fit in a x86 set instruction.
defn large-immediate? (x:VMImm) :
  match(x) :
    (x:NumConst) : value(x) is-not Long|Double
    (x) : true

;x is a small immediate if it can fit as an x86 immediate operand.
defn small-immediate? (x:VMImm) :
  val max = 1 << 16
  val min = -1 << 16
  defn small? (v:Int) : v >= min and v <= max
  defn small? (v:Long) : v >= to-long(min) and v <= to-long(max)
  match(x) :
    (x:NumConst) :
      match(value(x)) :
        (x:Byte) : true
        (x:Int|Long) : small?(x)
        (x) : false
    (x:CodeId) : false
    (x:ExternId) : false
    (x:ExternDefnId) : false
    (x:GlobalId) : false
    (x:DataId) : false
    (x:ConstId) : false
    (x) : true

;x is a function immediate if it can be used directly in an x86 call
;instruction.
defn function-immediate? (x:VMImm) :
  match(x) :
    (x:CodeId) : true
    (x:ExternId) : true
    (x:ExternDefnId) : true
    (x) : small-immediate?(x)

;x is a storage immediate if it can be used directly in an x86
;load/store instruction as the location address.
defn storage-immediate? (x:VMImm) :
  x is Local|ExternId|GlobalId|DataId

;============================================================
;================== Calling Convention ======================
;============================================================
public deftype CallLoc
public defstruct CallReg <: CallLoc :
  index: Int
with: (printer => true)
public defstruct CallFReg <: CallLoc :
  index: Int
with: (printer => true)
public defstruct CallMemArg <: CallLoc :
  index: Int
with: (printer => true)

public deftype CallArg :
  VMImm <: CallArg
public defstruct ShadowArg <: CallArg :
  value: VMImm
with: (printer => true)

public defstruct CallRecords :
  records: Tuple<CallRecord>
with: (printer => true)

public defstruct CallRecord :
  arg: CallArg
  loc: CallLoc
with: (printer => true)

public defstruct RetRecords :
  records: Tuple<RetRecord>
with: (printer => true)

public defstruct RetRecord :
  x: Local
  loc: CallLoc
with: (printer => true)

defn ret-records (b:InsBuffer, xs:Seqable<Local|VMType>, backend:Backend) -> RetRecords :
  val records = Vector<RetRecord>()
  val regs = seq(CallReg, call-regs(backend))
  val fregs = seq(CallFReg, call-fregs(backend))
  val mems = seq(CallMemArg, 0 to false)
  for x in xs do :
    val t = match(x:Local) : type(b,x)
            else : x as VMType
    val loc = 
      if integral?(t) :
        if empty?(regs) : next(mems)
        else : next(regs)      
      else :
        if empty?(fregs) : next(mems)
        else : next(fregs)
    match(x:Local) :
      add(records, RetRecord(x, loc))
  RetRecords(to-tuple(records))    

defn retc-records (b:InsBuffer, xs0:Seqable<Local|VMType>, backend:Backend) -> RetRecords :
  val records = Vector<RetRecord>()
  val xs = to-seq(xs0)
  if not empty?(xs) :
    val x = next(xs)
    match(x:Local) :
      val t = type(b,x)
      if integral?(t) : add(records, RetRecord(x, CallReg(0)))
      else : add(records, RetRecord(x, CallFReg(0)))
  if not empty?(xs) :
    fatal("More than a single C return value!")
  RetRecords(to-tuple(records))      

defn call-records (b:InsBuffer, xs:Seqable<VMImm>, backend:Backend) -> CallRecords :
  val records = Vector<CallRecord>()
  val regs = seq(CallReg, call-regs(backend))
  val fregs = seq(CallFReg, call-fregs(backend))
  val mems = seq(CallMemArg, 0 to false)
  for x in xs do :
    val t = type(b,x)
    val loc = 
      if integral?(t) :
        if empty?(regs) : next(mems)
        else : next(regs)      
      else :
        if empty?(fregs) : next(mems)
        else : next(fregs)
    add(records,CallRecord(x, loc))
  CallRecords(to-tuple(records))

defn callc-records (b:InsBuffer, xs:Seqable<VMImm>, backend:Backend) -> CallRecords :
  val records = Vector<CallRecord>()
  defn rec (x:CallArg, l:CallLoc) :
    add(records, CallRecord(x,l))
  val regs = seq(CallReg, callc-regs(backend))
  val fregs = seq(CallFReg, callc-fregs(backend))
  val mems = seq(CallMemArg, 0 to false)
  match(backend) :
    (backend:W64Backend) :
      for x in xs do :
        val t = type(b,x)
        if integral?(t) :             
          if empty?(regs) :                ;If no more integer registers
            rec(x, next(mems))               ;place in mem argument
          else :
            rec(x, next(regs))             ;Otherwise place in integer register
            next(fregs)                    ;and eat real register
        else :
          if empty?(fregs) :               ;If no more real registers
            rec(x, next(mems))               ;place in mem argument
          else :
            rec(x, next(fregs))            ;Otherwise place in real register
            rec(ShadowArg(x), next(regs))  ;and place shadow in integer register        
    (backend) :
      for x in xs do :
        val t = type(b,x)
        if integral?(t) :
          if empty?(regs) : rec(x, next(mems))
          else : rec(x, next(regs))
        else :
          if empty?(fregs) : rec(x, next(mems))
          else : rec(x, next(fregs))        
  CallRecords(to-tuple(records))

defn match-records (xs:Seqable<VMImm>, backend:Backend) -> CallRecords :
  val records = Vector<CallRecord>()
  defn rec (x:CallArg, l:CallLoc) :
    add(records, CallRecord(x,l))
    
  val regs = seq(CallReg, call-regs(backend))
  val mems = seq(CallMemArg, 0 to false)
  for x in xs do :
    if empty?(regs) : rec(x, next(mems))
    else : rec(x, next(regs))

  CallRecords(to-tuple(records))

defn integral? (t:VMType) : t is VMByte|VMInt|VMLong|VMRef
  
;============================================================
;=================== Normalization Check ====================
;============================================================

defn ensure-normalized (f0:VMFunction, backend:Backend) :
  ;Ensure that function is a VMFunc
  val function = f0 as VMFunc
  
  ;Check that no arguments are remaining
  fatal("Arguments remaining in function!") when not empty?(args(function))

  ;Check that operand sizes are okay
  defn ensure-operand-sizes (i:VMIns) :
    defn ensure-function-immediate (f:VMImm) :
      fatal("Not a function immediate") when not function-immediate?(f)
    defn ensure-large-immediate (f:VMImm) :
      fatal("Not a large immediate") when not large-immediate?(f)
    defn ensure-small-immediate (f:VMImm) :
      fatal("Not a small immediate") when not small-immediate?(f)
    defn ensure-storage-immediate (f:VMImm) :
      fatal("Not a storage immediate") when not storage-immediate?(f)
    match(i) :
      (i:CallRecordIns) :
        ensure-function-immediate(f(i))
        for r in records(args(i)) do :
          ensure-large-immediate(arg(r) as VMImm)
      (i:Op1Ins) :
        ensure-small-immediate(y(i))
      (i:Op2Ins) :
        ensure-small-immediate(y(i))
        ensure-small-immediate(z(i))
      (i:Branch1Ins) :
        ensure-small-immediate(x(i))
      (i:Branch2Ins) :
        ensure-small-immediate(x(i))
        ensure-small-immediate(y(i))
      (i:MatchIns|DispatchIns) :
        do(ensure-large-immediate, ys(i))
      (i:StoreIns) :
        ensure-storage-immediate(x(i))
        ensure-small-immediate(z(i))
      (i:LoadIns) :
        ensure-storage-immediate(y(i))
      (i) :
        false

  ;Checks on calling records
  defn ensure-no-mem-locs (r:CallRecords) :
    for r in records(r) do :
      if loc(r) is CallMemArg :
        fatal("Memory argument remaining.")
  defn ensure-no-mem-locs (r:RetRecords) :
    for r in records(r) do :
      if loc(r) is CallMemArg :
        fatal("Memory argument remaining.")
  defn ensure-no-shadows (r:CallRecords) :
    for r in records(r) do :
      if arg(r) is ShadowArg :
        fatal("Shadowed argument remaining.")

  ;Checks on primitive operations
  defn ensure-lowlevel-op (op:VMOp) :
    match(op:IntAddOp|IntSubOp|IntMulOp|IntDivOp|IntModOp|IntAndOp|
             IntOrOp|IntXorOp|IntNotOp|IntShlOp|IntShrOp|IntAshrOp|
             IntLtOp|IntGtOp|IntLeOp|IntGeOp|IntNegOp) :
      fatal("High-level op %_ remaining." % [op])

  ;Check each instruction
  for i in ins(function) do :
    ;Forbidden instructions
    match(i) :
      (i:CallClosureIns|TCallClosureIns|CallIns|TCallIns|CallCIns) :
        fatal("Unnormalized Call remaining")
      (i:AllocIns) :
        fatal("Alloc instruction remaining")
      (i:CommentIns) :
        fatal("Comment instruction remaining")
      (i) :
        false       

    ;Instruction specific constraints
    match(i) :
      (i:ArgIns) :
        ensure-no-mem-locs(ret(i))
      (i:CallRecordIns) :
        ensure-no-mem-locs(ret(i))
        ensure-no-mem-locs(args(i))
        ensure-no-shadows(args(i))
      (i:MatchIns|DispatchIns) :
        ensure-no-mem-locs(match-records(ys(i), backend))
      (i:MethodDispatchIns) :
        fatal("Non-empty method dispatch arguments.") when not empty?(ys(i))
        fatal("Non-empty method dispatch arguments.") when not empty?(zs(i))
      (i:Op0Ins|Op1Ins|Op2Ins) :      
        ensure-lowlevel-op(op(i))
      (i:StoreIns) :
        fatal("Variable offset remaining") when y(i) is VMImm
      (i:LoadIns) :
        fatal("Variable offset remaining") when z(i) is VMImm
      (i) :
        false

    ;General checks
    ensure-operand-sizes(i)

;============================================================
;=================== Instruction Buffer =====================
;============================================================

deftype InsBuffer
defmulti type (b:InsBuffer, x:VMImm) -> VMType
defmulti emit (b:InsBuffer, i:VMIns) -> False
defmulti to-func (b:InsBuffer) -> VMFunc
defmulti make-label (b:InsBuffer) -> Int
defmulti make-local (b:InsBuffer, t:VMType) -> Local

defn InsBuffer (function:VMFunction) :
  val def-table = IntTable<VMDef>()
  val label-set = IntSet()
  val buffer = Vector<VMIns>()
  val label-counter = to-seq(0 to false)
  val def-counter = to-seq(0 to false)
  
  defn do-functions (f:VMFunc -> ?) :
    match(function) :
      (func:VMFunc) :
        f(func)
      (func:VMMultifn) :
        do(f{value(_)}, funcs(func))
        f(default(func))  
  defn load-defs (f:VMFunc) :  
    for d in defs(f) do : def-table[id(d)] = d
  defn load-labels (f:VMFunc) :
    add-all(label-set, seq(n, filter-by<LabelIns>(ins(f))))

  do-functions(load-defs)
  do-functions(load-labels)

  new InsBuffer :
    defmethod type (this, x:VMImm) :
      match(x:Local) : type(def-table[index(x)])
      else : type(x)
    defmethod emit (this, i:VMIns) :
      add(buffer, i)
    defmethod to-func (this) :
      val all-defs = to-tuple(values(def-table))
      VMFunc([], all-defs, to-tuple(buffer))
    defmethod make-label (this) :
      let loop () :
        val i = next(label-counter)
        if label-set[i] : loop()
        else : i
    defmethod make-local (this, t:VMType) :
      val n = let loop () :
        val i = next(def-counter)
        if key?(def-table, i) : loop()
        else : i
      def-table[n] = VMDef(n, t)
      Local(n)
     