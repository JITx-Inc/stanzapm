defpackage stz/vm :
  import core
  import collections
  import stz/vm-ir

;============================================================
;==================== Linked Instructions ===================
;============================================================

public deftype LinkedIns :
  NewStackIns <: LinkedIns
  SetIns <: LinkedIns
  Op0Ins <: LinkedIns
  JumpIns <: LinkedIns

public deftype JumpIns :
  GotoIns <: JumpIns
  Branch1Ins <: JumpIns  

public defstruct LinkedStoreIns <: LinkedIns :
  size: Int
  x: VMImm
  y: VMImm
  z: VMImm
public defstruct LinkedLoadIns <: LinkedIns :
  size: Int
  x: Local
  y: VMImm
  z: VMImm  
public defstruct LinkedRefStoreIns <: LinkedIns :
  size: Int
  x: VMImm
  y: VMImm
  z: VMImm
public defstruct LinkedRefLoadIns <: LinkedIns :
  size: Int
  x: Local
  y: VMImm
  z: VMImm  
public defstruct SetReg <: LinkedIns :
  reg: Int
  x: VMImm
public defstruct GetReg <: LinkedIns :
  x: Local
  reg: Int
public defstruct PushFrameIns <: LinkedIns :
  frame-size: Int
public defstruct PopFrameIns <: LinkedIns :
  frame-size: Int
public defstruct LinkedCall <: LinkedIns :
  f: VMImm
public defstruct LinkedCallClosure <: LinkedIns :
  f: VMImm
public defstruct LinkedCallC <: LinkedIns :
  f: VMImm
  launcher: Long
public defstruct LinkedYield <: LinkedIns :
  f: VMImm
public defstruct LinkedReturn <: LinkedIns
public defstruct FunctionEntry <: LinkedIns :
  num-locals:Int
public defstruct LinkedDump <: LinkedIns :
  x: Local
public defstruct LinkedOp1Ins <: LinkedIns :
  type: VMType
  x: Local
  op: VMOp
  y: VMImm
public defstruct LinkedOp2Ins <: LinkedIns :
  type: VMType
  x: Local
  op: VMOp
  y: VMImm
  z: VMImm
public defstruct LinkedBranch2Ins <: LinkedIns :
  type: VMType
  n: Int with: (updater => sub-n)
  op: VMOp
  x: VMImm
  y: VMImm
public defstruct LinkedLiveIns <: LinkedIns :
  map: Int
public defstruct LinkedBranchRegIns <: LinkedIns :
  n: Int
  reg: Int
  value: Int  
public defstruct LinkedErrorIns <: LinkedIns :
  msg: String
public defstruct LinkedReserveIns <: LinkedIns :
  space: VMImm
  num-obj: Int
public defstruct LinkedAllocIns <: LinkedIns :
  x: Local
  type: Int
  size: VMImm

;============================================================
;======================= Printer ============================
;============================================================
defmethod print (o:OutputStream, i:LinkedReserveIns) :
  print(o, "reserve %_, %_" % [space(i), num-obj(i)])

defmethod print (o:OutputStream, i:LinkedAllocIns) :
  print(o, "%_ = alloc<%_> %_" % [x(i), type(i), size(i)])
  
defmethod print (o:OutputStream, i:LinkedErrorIns) :
  print(o, "error %~" % [msg(i)])
  
defmethod print (o:OutputStream, i:PushFrameIns) :
  print(o, "push-frame %_" % [frame-size(i)])

defmethod print (o:OutputStream, i:PopFrameIns) :
  print(o, "pop-frame %_" % [frame-size(i)])

defmethod print (o:OutputStream, i:LinkedStoreIns) :
  print(o, "%_[%_] = %_ (%_ bytes)" % [x(i), y(i), z(i), size(i)])

defmethod print (o:OutputStream, i:LinkedLoadIns) :
  print(o, "%_ = %_[%_] (%_ bytes)" % [x(i), y(i), z(i), size(i)])

defmethod print (o:OutputStream, i:LinkedRefStoreIns) :
  print(o, "ref %_[%_] = %_ (%_ bytes)" % [x(i), y(i), z(i), size(i)])

defmethod print (o:OutputStream, i:LinkedRefLoadIns) :
  print(o, "%_ = ref %_[%_] (%_ bytes)" % [x(i), y(i), z(i), size(i)])

defmethod print (o:OutputStream, i:LinkedOp1Ins) :
  print(o, "%_ = %_ %_ %_" % [x(i), type(i), op(i), y(i)])

defmethod print (o:OutputStream, i:LinkedOp2Ins) :
  print(o, "%_ = %_ %_ %_ %_" % [x(i), type(i), op(i), y(i), z(i)])

defmethod print (o:OutputStream, i:LinkedBranch2Ins) :
  print(o, "goto %_ when %_ %_ %_ %_" % [n(i), type(i), op(i), x(i), y(i)])

defmethod print (o:OutputStream, r:SetReg) :
  print(o, "reg %_ = %_" % [reg(r), x(r)])

defmethod print (o:OutputStream, r:GetReg) :
  print(o, "%_ = reg %_" % [x(r), reg(r)])

defmethod print (o:OutputStream, x:LinkedCall) :
  print(o, "call %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedCallC) :
  print(o, "call-c %_ (launcher %_)" % [f(x), launcher(x)])

defmethod print (o:OutputStream, x:LinkedCallClosure) :
  print(o, "call-closure %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedYield) :
  print(o, "yield %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedReturn) :
  print(o, "return")

defmethod print (o:OutputStream, x:FunctionEntry) :
  print(o, "enter (num-locals = %_)" % [num-locals(x)])

defmethod print (o:OutputStream, ins:LinkedDump) :
  print(o, "dump %_" % [x(ins)])

defmethod print (o:OutputStream, ins:LinkedLiveIns) :
  print(o, "live %_" % [map(ins)])

defmethod print (o:OutputStream, ins:LinkedBranchRegIns) :
  print(o, "goto %_ when R%_ == %_" % [n(ins), reg(ins), value(ins)])

;============================================================
;======================= Linker =============================
;============================================================

deftype Linker
defmulti instructions (l:Linker) -> Tuple<LinkedIns>
defmulti link (l:Linker, f:VMFunction) -> Int
defmulti live-map-table (l:Linker) -> LiveMapTable

defn Linker () :
  ;===== Overall Buffer =====
  val ins-buffer = Vector<LinkedIns>()
  val live-map-table = LiveMapTable()

  ;===== Temporary Linking Buffer =====
  val buffer = Vector<LinkedIns|False>()
  defn delayed-ins (f:Int -> LinkedIns) :
    val pos = length(buffer)
    add(buffer, false)
    within delay() :
      buffer[pos] = f(pos)

  ;Link the function
  defn link (f:VMFunction) :
    ;Generate to temporary buffer
    match(f) :
      (f:VMMulti) : link-multi(f)
      (f:VMFunc) : link-func(f)
    ;Load into main buffer
    val pos = length(ins-buffer)
    add-all(ins-buffer, buffer as Seqable<LinkedIns>)
    clear(buffer)
    ;Return address of linked function
    pos

  ;Generate the code for a multi function
  defn link-multi (multi:VMMulti) :
    ;Get function position
    val function-pos = length(buffer)

    within delay-actions() :
      ;Fill in function position table
      val func-pos-table = IntTable<Int>()    
      ;Add branching instructions
      for entry in funcs(multi) do :
        within pos = delayed-ins() :
          val func-pos = func-pos-table[id(value(entry))]
          LinkedBranchRegIns(func-pos - pos, arg(multi), key(entry))
      ;Add default branch
      match(default(multi)) :
        (default:VMFunc) : link-func(default)          
        (multi:False) : add(buffer, LinkedErrorIns("Multi dispatch failure."))
      ;Branches
      for func in seq(value,funcs(multi)) do :
        func-pos-table[id(func)] = link-func(func)

    ;Return function position
    function-pos

  ;Generate the code for a single function
  defn link-func (func:VMFunc) :  
    ;Create mapping from local ID to slot
    val deftable = to-inttable<VMDef> $
      for def in defs(func) seq :
        id(def) => def
    ;Retrieve the size of an immediate
    defn imm-size (x:VMImm) :
      match(x:Local) : size(type(deftable[index(x)]))
      else : size(x)
    defn imm-type (x:VMImm) :
      match(x:Local) : type(deftable[index(x)])
      else : type(x)
    defn imm-type (x:False) :
      x
    defn simple-type (t:VMType) :
      match(t) :
        (t:VMRef) : VMLong()
        (t:VMPointer) : VMLong()
        (t) : t
    ;Create label table
    val label-table = IntTable<Int>()
    
    ;Compute relative locations
    defn link-ins<?T> (ins:VMIns&?T, pos:Int) -> T :
      defn sub-target (n:Int) :
        label-table[n] - pos
      defn sub-slot (x:Local) :
        Local(local(deftable[index(x)]))
      map(sub-target, sub-slot, ins) as VMIns&T

    ;Register Instructions
    defn get-regs (xs:Tuple<Local|False>) :
      for (x in xs, i in 0 to false) do :
        match(x:Local) :
          add(buffer, GetReg(x, i))
    defn set-regs (xs:Tuple<VMImm>) :
      for (x in xs, i in 0 to false) do :
        add(buffer, SetReg(i, x))
        
    ;Get function position
    val function-pos = length(buffer)
    
    ;Link instructions
    within delay-actions() :
      ;Create entry instructions
      val num-locals = maximum(-1, seq(local, defs(func))) + 1
      val frame-size = SIZEOF-FRAME + num-locals * 8
      add(buffer, FunctionEntry(num-locals))
      get-regs(args(func))
      ;Link and add to buffer
      for ins in ins(func) do :
        val pos = length(buffer)        
        match(ins) :
          (ins:LabelIns) :
            label-table[n(ins)] = pos
          (ins:CallIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, PushFrameIns(frame-size))
            add(buffer, LinkedCall(f(ins*)))
            add(buffer, PopFrameIns(frame-size))
            get-regs(xs(ins*))
          (ins:CallCIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            val format = coalesce(CallFormat(xtypes, ytypes)) where :
              val xtypes = map(imm-type,xs(ins))
              val ytypes = map(imm-type,ys(ins))
            val launcher = FORMAT-TABLE[format]
            add(buffer, PushFrameIns(frame-size))
            add(buffer, LinkedCallC(f(ins*), launcher))
            add(buffer, PopFrameIns(frame-size))
            get-regs(xs(ins*))
          (ins:CallClosureIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, PushFrameIns(frame-size))
            add(buffer, LinkedCallClosure(f(ins*)))
            add(buffer, PopFrameIns(frame-size))
            get-regs(xs(ins*))
          (ins:YieldIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, LinkedYield(f(ins*)))
            get-regs(xs(ins*))
          (ins:ReturnIns) :
            val ins* = link-ins(ins, pos)
            set-regs(xs(ins*))
            add(buffer, LinkedReturn())
          (ins:DumpIns) :
            val ins* = link-ins(ins, pos)
            for x in xs(ins*) do :
              add(buffer, LinkedDump(x))
          (ins:RecordLiveIns) :
            val ins* = link-ins(ins, pos)
            val map = LivenessMap(map(index, live(ins*)), num-locals)
            val map-i = map-index(live-map-table, map)
            add(buffer, LinkedLiveIns(map-i))
          (ins:StoreIns) :
            val ins* = link-ins(ins, pos)
            val size = imm-size(z(ins))
            match(imm-type(x(ins))) :
              (t:VMRef) : add(buffer, LinkedRefStoreIns(size, x(ins*), y(ins*), z(ins*)))
              (t) : add(buffer, LinkedStoreIns(size, x(ins*), y(ins*), z(ins*)))
          (ins:LoadIns) :
            val ins* = link-ins(ins, pos)
            val size = imm-size(x(ins))
            match(imm-type(y(ins))) :
              (t:VMRef) : add(buffer, LinkedRefLoadIns(size, x(ins*), y(ins*), z(ins*)))
              (t) : add(buffer, LinkedLoadIns(size, x(ins*), y(ins*), z(ins*)))
          (ins:Op1Ins) :
            val ins* = link-ins(ins, pos)
            val t = simple-type(imm-type(y(ins)))
            add(buffer, LinkedOp1Ins(t, x(ins*), op(ins*), y(ins*)))
          (ins:Op2Ins) :
            val ins* = link-ins(ins, pos)
            val t = simple-type(imm-type(y(ins)))
            add(buffer, LinkedOp2Ins(t, x(ins*), op(ins*), y(ins*), z(ins*)))
          (ins:Branch2Ins) :
            within pos = delayed-ins() :
              val ins* = link-ins(ins, pos)
              val t = simple-type(imm-type(y(ins)))
              LinkedBranch2Ins(t, n(ins*), op(ins*), x(ins*), y(ins*))
          (ins:JumpIns&VMIns) :
            within pos = delayed-ins() :
              link-ins(ins, pos)
          (ins:NewStackIns) :
            val ins* = link-ins(ins, pos)
            add(buffer, LinkedReserveIns(NumConst(SIZEOF-STACK), 1))
            add(buffer, ins*)
          (ins:AllocIns) :
            val ins* = link-ins(ins, pos)
            if length(sizes(ins*)) == 1 :
              val x = xs(ins*)[0]
              val type = types(ins*)[0]
              val size = sizes(ins*)[0]
              add(buffer, LinkedReserveIns(size, 1))
              add(buffer, LinkedAllocIns(x, type, size))
            else :
              val num-obj = length(sizes(ins*))
              val size = sum $
                for s in sizes(ins*) seq :
                  value(s as NumConst) as Int
              add(buffer, LinkedReserveIns(NumConst(size), num-obj))
              for (x in xs(ins*), t in types(ins*), s in sizes(ins*)) do :
                add(buffer, LinkedAllocIns(x, t, s))
          (ins:LinkedIns&VMIns) :
            add(buffer, link-ins(ins, pos))
    ;Dump to instruction buffer
    function-pos

  new Linker :
    defmethod instructions (this) : to-tuple(ins-buffer)
    defmethod link (this, f:VMFunction) : link(f)
    defmethod live-map-table (this) : live-map-table

;============================================================
;================= Live Map Analysis ========================
;============================================================
deftype LiveMapTable
defmulti map-index (t:LiveMapTable, map:LivenessMap) -> Int
defmulti get (t:LiveMapTable, i:Int) -> LivenessMap

defstruct LivenessMap <: Hashable&Equalable :
  live-slots: Tuple<Int>
  num-slots: Int
with:
  constructor => #LivenessMap
defn LivenessMap (slots:Tuple<Int>, num-slots:Int) :
  #LivenessMap(qsort(slots), num-slots)
defmethod hash (m:LivenessMap) :
  num-slots(m) + 7 * hash(live-slots(m))
defmethod equal? (a:LivenessMap, b:LivenessMap) :
  live-slots(a) == live-slots(b) and
  num-slots(a) == num-slots(b)

public defn LiveMapTable () :
  val maps = Vector<LivenessMap>()
  val table = HashTable<LivenessMap,Int>()
  new LiveMapTable :
    defmethod map-index (this, map:LivenessMap) :
      if not key?(table, map) :
        table[map] = length(maps)
        add(maps, map)
      table[map]
    defmethod get (this, i:Int) :
      maps[i]

;============================================================
;================= Class Display Analysis ===================
;============================================================
deftype ClassTable
defmulti class? (this, c:Int) -> True|False
defmulti instanceof? (t:ClassTable, child:Int, parent:Int) -> True|False

public defn ClassTable (classes:Tuple<VMClass>) :
  val class-table = to-inttable<VMClass> $
    for c in classes seq : id(c) => c
  val parent-table = IntTable<Tuple<Int>>()
  defn @all-parents (c:Int) :
    val rec = class-table[c]
    to-tuple(cat([c], seq-cat(all-parents, parents(rec))))
  defn all-parents (c:Int) :
    if not key?(parent-table, c) :
      parent-table[c] = @all-parents(c)
    parent-table[c]
  new ClassTable :
    defmethod class? (this, c:Int) :
      key?(class-table, c)
    defmethod instanceof? (this, child:Int, parent:Int) :
      contains?(all-parents(child), parent)

;============================================================
;==================== Extern Table ==========================
;============================================================

public deftype ExternTable
public defmulti get (t:ExternTable, i:Int) -> Long
public defmulti set (t:ExternTable, i:Int, addr:Long) -> False

defn ExternTable () :
  val table = Vector<Long|False>()
  new ExternTable :
    defmethod get (this, i:Int) :
      table[i] as Long
    defmethod set (this, i:Int, addr:Long) :
      set-at(table, i, addr, false)

public val EXTERN-TABLE = ExternTable()

;============================================================
;===================== Format Table =========================
;============================================================

public defstruct CallFormat <: Hashable&Equalable :
  xs: Tuple<VMType|False>
  ys: Tuple<VMType>
with :
  printer => true

defmethod hash (f:CallFormat) :
  hash(xs(f)) + 7 * hash(ys(f))
defmethod equal? (a:CallFormat, b:CallFormat) :
  xs(a) == xs(b) and ys(a) == ys(b)

public deftype FormatTable
public defmulti get (t:FormatTable, f:CallFormat) -> Long
public defmulti set (t:FormatTable, f:CallFormat, l:Long) -> False

defn FormatTable () :
  val table = HashTable<CallFormat,Long>()  
  new FormatTable :
    defmethod get (this, f:CallFormat) : table[f]
    defmethod set (this, f:CallFormat, l:Long) : table[f] = l

public val FORMAT-TABLE = FormatTable()

;============================================================
;=================== Format Coalescing ======================
;============================================================

defn exemplar-type (t:VMType) :
  match(t:VMRef|VMPointer) : VMLong()
  else : t

public defn coalesce (f:CallFormat) :
  ;New return result
  val x* =
    if empty?(xs(f)) :
      VMLong()
    else :
      match(xs(f)[0]) :
        (x:False) :
          VMLong()
        (x:VMType) :
          match(exemplar-type(x)) :
            (t:VMByte|VMInt) : VMLong()
            (t) : t

  ;New arguments
  val ys* = for y in ys(f) map :
    match(exemplar-type(y)) :
      (y:VMByte|VMInt) : VMLong()
      (y) : y

  ;Return coalesced call format
  CallFormat([x*], ys*)
    
;============================================================
;=================== Global Table ===========================
;============================================================

deftype GlobalTable
defmulti space (t:GlobalTable) -> Int
defmulti position (t:GlobalTable, gid:Int) -> Int
defmulti roots (t:GlobalTable) -> Seqable<Int>

defn GlobalTable (prog:VMProg) :
  val global-space = maximum{0, _} $ 
    for g in globals(prog) seq :
      position(g) + size(g)
  val table = Vector<VMGlobal|False>()
  for g in globals(prog) do :
    set-at(table, id(g), g, false)
  new GlobalTable :
    defmethod space (this) :
      global-space
    defmethod position (this, gid:Int) :
      position(table[gid] as VMGlobal)
    defmethod roots (this) :
      for g in filter-by<VMGlobal>(table) seq-cat :
        val root-base = position(g) / 8
        for r in roots(g) seq :
          root-base + r

;============================================================
;==================== VM Constants ==========================
;============================================================

lostanza val REF-TAG:long = 1L

lostanza defn untag (x:long) -> ptr<?> :
  return (x - REF-TAG + 8) as ptr<?>

lostanza defn tag (x:ptr<?>) -> long :
  return (x + REF-TAG) as long

;============================================================
;=================== VM Structures ==========================
;============================================================

lostanza deftype VirtualMachine :
  registers: ptr<long>
  globals: ptr<long>
  heap: ptr<long>
  heap-top: ptr<long>
  heap-end: ptr<long>
  heap-limit: ptr<long>
  current-stack: long
  stack-pointer: ptr<Frame>
  pc: int

lostanza deftype Frame :
  return: long
  liveness-map: long
  slots: long ...

lostanza deftype Stack :
  size: long
  frames: ptr<Frame>
  stack-pointer: ptr<Frame>
  pc: int

lostanza deftype Function :
  num-slots: long
  code: long
  slots: long ...

lostanza val SIZEOF-FRAME:ref<Int> = new Int{sizeof(Frame) as int}
lostanza val SIZEOF-STACK:ref<Int> = new Int{sizeof(Stack) as int}

;============================================================
;==================== VM Implementation =====================
;============================================================

lostanza defn VirtualMachine (gt:ref<GlobalTable>) -> ref<VirtualMachine> :
  val registers = call-c clib/malloc(sizeof(ptr<?>) * 256)
  val globals = call-c clib/malloc(space(gt).value)
  val heap-size = 512 * 1024
  val heap = call-c clib/malloc(heap-size)
  val heap-limit = heap + heap-size
  val null = 0L as ptr<?>
  return new VirtualMachine{registers, globals, heap, heap, heap, heap-limit,
                            0L, null, 0}

lostanza defn alloc-stack (vm:ref<VirtualMachine>, pc:int) -> long :
  val stack-size = 1024 * 1024
  val frames = call-c clib/malloc(stack-size)
  val s = tag(vm.heap-top)
  val null = 0L as ptr<?>
  vm.heap-top = vm.heap-top + 8 + sizeof(Stack)
  val sptr:ptr<Stack> = untag(s)
  sptr.size = stack-size
  sptr.frames = frames
  sptr.stack-pointer = frames
  sptr.pc = pc
  sptr.frames.return = -1L
  return s

lostanza defn call-c-function (function:long, registers:ptr<long>, format:int) -> long :
  if format == 0 :
    val fptr = function as ptr<((long long long long long long) -> long)>
    val result = call-c [fptr](registers[0], registers[1], registers[2], registers[3], registers[4], registers[5])
    registers[0] = result
    return 0
  else :
    fatal("Unknown format.")
    return 0

lostanza defn eval-imm (frame:ptr<Frame>, gt:ref<GlobalTable>, globals:ptr<long>, x:ref<VMImm>) -> long :
  match(x) :
    (x:ref<Local>) :
      return frame.slots[index(x).value]
    (x:ref<NumConst>) :
      match(value(x)) :
        (v:ref<Byte>) : return v.value
        (v:ref<Int>) : return v.value
        (v:ref<Long>) : return v.value
        (v:ref<Float>) :
          val value = v.value
          return ($ls-prim bits value)
        (v:ref<Double>) :
          val value = v.value
          return ($ls-prim bits value)
    (x:ref<CodeId>) :
      return fid(x).value
    (x:ref<ExternId>) :
      return get(EXTERN-TABLE,eid(x)).value
    (x:ref<GlobalId>) :
      val offset = position(gt, gid(x)).value
      return (globals + offset) as long

lostanza defn eval-op (current-stack:long, op:ref<VMOp>) -> long :
  match(op) :
    (op:ref<CurrentStackOp>) : return current-stack
  return 0

lostanza defn eval-op (class-table:ref<ClassTable>, type:ref<VMType>, op:ref<VMOp>, y:long) -> long :
  match(type) :
    (type:ref<VMByte>) :
      val y = y as byte
      match(op) :
        (op:ref<NotOp>) : return (~ y)
        (op) : (fatal("Illegal op."), return 0)
    (type:ref<VMInt>) :
      val y = y as int
      match(op) :
        (op:ref<NotOp>) : return (~ y)
        (op:ref<NegOp>) : return (- y)
        (op) : (fatal("Illegal op."), return 0)
    (type:ref<VMLong>) :
      match(op) :
        (op:ref<NotOp>) : return (~ y)
        (op:ref<NegOp>) : return (- y)
        (op:ref<InstanceofOp>) : 
          val tag = new Int{[(y - REF-TAG) as ptr<long>] as int}
          return instanceof?(class-table, tag, /type(op)) == true
        (op) : (fatal("Illegal op."), return 0)
    (type:ref<VMFloat>) :
      val yint = y as int
      val y = ($ls-prim fnum yint)
      match(op) :
        (op:ref<NegOp>) : return float-bits((- y))
        (op) : (fatal("Illegal op."), return 0)
    (type:ref<VMDouble>) :
      val y = ($ls-prim fnum y)
      match(op) :
        (op:ref<NegOp>) : return double-bits((- y))
        (op) : (fatal("Illegal op."), return 0)

lostanza defn float-bits (x:float) -> long : return ($ls-prim bits x)
lostanza defn double-bits (x:double) -> long : return ($ls-prim bits x)
lostanza defn eval-op (type:ref<VMType>, op:ref<VMOp>, y:long, z:long) -> long :
  match(type) :
    (type:ref<VMByte>) :
      val y = y as byte
      val z = z as byte
      match(op) :
        (op:ref<AddOp>) : return y + z
        (op:ref<SubOp>) : return y - z 
        (op:ref<MulOp>) : return y * z
        (op:ref<DivOp>) : return y / z
        (op:ref<ModOp>) : return y % z
        (op:ref<AndOp>) : return y & z
        (op:ref<OrOp>) : return y | z
        (op:ref<XorOp>) : return y ^ z
        (op:ref<ShlOp>) : return y << z
        (op:ref<ShrOp>) : return y >> z
        (op:ref<AshrOp>) : return y >>> z
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<UleOp>) : return ($ls-prim ule y z)
        (op:ref<UltOp>) : return ($ls-prim ult y z)
        (op:ref<UgtOp>) : return ($ls-prim ugt y z)
        (op:ref<UgeOp>) : return ($ls-prim uge y z)
        (op) : (fatal("Illegal operand."), return 0)
    (type:ref<VMInt>) :
      val y = y as int
      val z = z as int
      match(op) :
        (op:ref<AddOp>) : return y + z
        (op:ref<SubOp>) : return y - z 
        (op:ref<MulOp>) : return y * z
        (op:ref<DivOp>) : return y / z
        (op:ref<ModOp>) : return y % z
        (op:ref<AndOp>) : return y & z
        (op:ref<OrOp>) : return y | z
        (op:ref<XorOp>) : return y ^ z
        (op:ref<ShlOp>) : return y << z
        (op:ref<ShrOp>) : return y >> z
        (op:ref<AshrOp>) : return y >>> z
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<LtOp>) : return y < z
        (op:ref<GtOp>) : return y > z
        (op:ref<LeOp>) : return y <= z
        (op:ref<GeOp>) : return y >= z
        (op:ref<UleOp>) : return ($ls-prim ule y z)
        (op:ref<UltOp>) : return ($ls-prim ult y z)
        (op:ref<UgtOp>) : return ($ls-prim ugt y z)
        (op:ref<UgeOp>) : return ($ls-prim uge y z)
    (type:ref<VMLong>) :
      match(op) :
        (op:ref<AddOp>) : return y + z
        (op:ref<SubOp>) : return y - z 
        (op:ref<MulOp>) : return y * z
        (op:ref<DivOp>) : return y / z
        (op:ref<ModOp>) : return y % z
        (op:ref<AndOp>) : return y & z
        (op:ref<OrOp>) : return y | z
        (op:ref<XorOp>) : return y ^ z
        (op:ref<ShlOp>) : return y << z
        (op:ref<ShrOp>) : return y >> z
        (op:ref<AshrOp>) : return y >>> z
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<LtOp>) : return y < z
        (op:ref<GtOp>) : return y > z
        (op:ref<LeOp>) : return y <= z
        (op:ref<GeOp>) : return y >= z
        (op:ref<UleOp>) : return ($ls-prim ule y z)
        (op:ref<UltOp>) : return ($ls-prim ult y z)
        (op:ref<UgtOp>) : return ($ls-prim ugt y z)
        (op:ref<UgeOp>) : return ($ls-prim uge y z)
    (type:ref<VMFloat>) :
      val yint = y as int
      val zint = z as int
      val y = ($ls-prim fnum yint)
      val z = ($ls-prim fnum zint)
      match(op) :
        (op:ref<AddOp>) : return float-bits(y + z)
        (op:ref<SubOp>) : return float-bits(y - z )
        (op:ref<MulOp>) : return float-bits(y * z)
        (op:ref<DivOp>) : return float-bits(y / z)
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<LtOp>) : return y < z
        (op:ref<GtOp>) : return y > z
        (op:ref<LeOp>) : return y <= z
        (op:ref<GeOp>) : return y >= z
        (op) : (fatal("Illegal operand."), return 0)      
    (type:ref<VMDouble>) :
      val y = ($ls-prim fnum y)
      val z = ($ls-prim fnum z)
      match(op) :
        (op:ref<AddOp>) : return double-bits(y + z)
        (op:ref<SubOp>) : return double-bits(y - z )
        (op:ref<MulOp>) : return double-bits(y * z)
        (op:ref<DivOp>) : return double-bits(y / z)
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<LtOp>) : return y < z
        (op:ref<GtOp>) : return y > z
        (op:ref<LeOp>) : return y <= z
        (op:ref<GeOp>) : return y >= z
        (op) : (fatal("Illegal operand."), return 0)

defn print-ins (ins:LinkedIns) :
  println("Trace (%_)" % [ins])

lostanza defn assign (frame:ptr<Frame>, l:ref<Local>, value:long) -> long :
  frame.slots[index(l).value] = value
  return 0

lostanza defn run (vm:ref<VirtualMachine>,             
                   instructions:ref<Tuple<LinkedIns>>,
                   functions:ref<Tuple<Int>>,
                   class-table:ref<ClassTable>,
                   global-table:ref<GlobalTable>,
                   live-map-table:ref<LiveMapTable>,
                   trace?:ref<True|False>) -> ref<False> :
  ;Define machine quantities                 
  val regs = vm.registers
  val globals = vm.globals
  var heap-limit:ptr<long> = vm.heap-limit
  var heap-end:ptr<long>
  var heap-top:ptr<long>
  var stack-pointer:ptr<Frame>
  var stack-end:ptr<Frame>
  var current-stack:long
  
  labels :
    begin :
      val mainpc = get(functions, new Int{0}).value
      ;Reserve and allocate initial stack
      vm.heap-end = vm.heap-end + 8 + sizeof(Stack)
      val main-stack = alloc-stack(vm, mainpc)
      heap-end = vm.heap-end
      heap-top = vm.heap-top
      goto load-stack(main-stack)
    load-stack (stack:long) :
      current-stack = stack
      val sptr:ptr<Stack> = untag(current-stack)
      stack-pointer = sptr.stack-pointer
      stack-end = sptr.frames + sptr.size
      goto step(sptr.pc)      
    call-function (fid:int, return:int) :
      val old-sp = stack-pointer
      stack-pointer.return = return
      val pos = get(functions, new Int{fid}).value
      goto step(pos)
    step (pc:int) :
      val ins = get(instructions, new Int{pc})
      if trace? == true : print-ins(ins)
      match(ins) :
        (ins:ref<NewStackIns>) :
          val fid = eval-imm(stack-pointer, global-table, globals, fid(ins)) as int
          val fpc = get(functions, new Int{fid}).value
          vm.heap-top = heap-top
          vm.heap-end = heap-end          
          val stk = alloc-stack(vm, fpc)
          heap-top = vm.heap-top
          heap-end = vm.heap-end
          assign(stack-pointer, x(ins), stk)
          goto step(pc + 1)
        (ins:ref<SetIns>) :
          assign(stack-pointer, x(ins), eval-imm(stack-pointer, global-table, globals, y(ins)))
          goto step(pc + 1)
        (ins:ref<Op0Ins>) :
          assign(stack-pointer, x(ins), eval-op(current-stack, op(ins)))
          goto step(pc + 1)        
        (ins:ref<LinkedOp1Ins>) :
          val y = eval-imm(stack-pointer, global-table, globals, y(ins))
          assign(stack-pointer, x(ins), eval-op(class-table, type(ins), op(ins), y))
          goto step(pc + 1)        
        (ins:ref<LinkedOp2Ins>) :
          val y = eval-imm(stack-pointer, global-table, globals, y(ins))
          val z = eval-imm(stack-pointer, global-table, globals, z(ins))
          assign(stack-pointer, x(ins), eval-op(type(ins), op(ins), y, z))
          goto step(pc + 1)
        (ins:ref<LinkedReserveIns>) :
          val size = eval-imm(stack-pointer, global-table, globals, space(ins))
          if size & 0x7L : fatal("Size is not a multiple of 8.")
          val total-size = size + 8 * num-obj(ins).value
          heap-end = heap-end + total-size
          if heap-end > heap-limit :
            vm.heap-top = heap-top
            vm.heap-end = heap-end
            vm.current-stack = current-stack
            vm.stack-pointer = stack-pointer
            vm.pc = pc
            scan-roots(vm, global-table, live-map-table)            
            fatal("Out of heap memory.")
          goto step(pc + 1)
        (ins:ref<LinkedAllocIns>) :
          val size = eval-imm(stack-pointer, global-table, globals, size(ins))
          val total-size = size + 8
          [heap-top] = type(ins).value
          assign(stack-pointer, x(ins), tag(heap-top))
          heap-top = heap-top + total-size
          if heap-top > heap-end : fatal("Beyond allocated limits.")
          goto step(pc + 1)
        (ins:ref<LinkedRefStoreIns>) :
          val x = eval-imm(stack-pointer, global-table, globals, x(ins))
          val y = eval-imm(stack-pointer, global-table, globals, y(ins))
          val z = eval-imm(stack-pointer, global-table, globals, z(ins))
          val xptr = untag(x)
          val sz = size(ins).value
          if sz == 1 : [xptr as ptr<byte> + y] = z as byte
          else if sz == 4 : [xptr as ptr<int> + y] = z as int
          else if sz == 8 : [xptr as ptr<long> + y] = z as long
          else : fatal("Invalid size.")
          goto step(pc + 1)
        (ins:ref<LinkedRefLoadIns>) :
          val y = eval-imm(stack-pointer, global-table, globals, y(ins))
          val z = eval-imm(stack-pointer, global-table, globals, z(ins))
          val yptr:ptr<long> = untag(y)
          val sz = size(ins).value
          var value:long
          if sz == 1 : value = [yptr as ptr<byte> + z]
          else if sz == 4 : value = [yptr as ptr<int> + z]
          else if sz == 8 : value = [yptr as ptr<long> + z]
          else : fatal("Invalid size.")
          assign(stack-pointer, x(ins), value)
          goto step(pc + 1)
        (ins:ref<LinkedStoreIns>) :
          val x = eval-imm(stack-pointer, global-table, globals, x(ins))
          val y = eval-imm(stack-pointer, global-table, globals, y(ins))
          val z = eval-imm(stack-pointer, global-table, globals, z(ins))
          val sz = size(ins).value
          if sz == 1 : [x as ptr<byte> + y] = z as byte
          else if sz == 4 : [x as ptr<int> + y] = z as int
          else if sz == 8 : [x as ptr<long> + y] = z as long
          else : fatal("Invalid size.")
          goto step(pc + 1)
        (ins:ref<LinkedLoadIns>) :
          val y = eval-imm(stack-pointer, global-table, globals, y(ins))
          val z = eval-imm(stack-pointer, global-table, globals, z(ins))
          val sz = size(ins).value
          var value:long
          if sz == 1 : value = [y as ptr<byte> + z]
          else if sz == 4 : value = [y as ptr<int> + z]
          else if sz == 8 : value = [y as ptr<long> + z]
          else : fatal("Invalid size.")
          assign(stack-pointer, x(ins), value)
          goto step(pc + 1)
        (ins:ref<GotoIns>) :
          goto step(pc + n(ins).value)
        (ins:ref<Branch1Ins>) :
          val x = eval-imm(stack-pointer, global-table, globals, x(ins))
          val r = eval-op(class-table, VMLong(), op(ins), x)
          if r : goto step(pc + n(ins).value)
          else : goto step(pc + 1)
        (ins:ref<LinkedBranch2Ins>) :
          val x = eval-imm(stack-pointer, global-table, globals, x(ins))
          val y = eval-imm(stack-pointer, global-table, globals, y(ins))
          val r = eval-op(type(ins), op(ins), x, y)
          if r : goto step(pc + n(ins).value)
          else : goto step(pc + 1)
        (ins:ref<SetReg>) :
          regs[reg(ins).value] = eval-imm(stack-pointer, global-table, globals, x(ins))
          goto step(pc + 1)
        (ins:ref<GetReg>) :
          assign(stack-pointer, x(ins), regs[reg(ins).value])
          goto step(pc + 1)
        (ins:ref<PushFrameIns>) :
          stack-pointer = stack-pointer + frame-size(ins).value
          goto step(pc + 1)
        (ins:ref<PopFrameIns>) :
          stack-pointer = stack-pointer - frame-size(ins).value
          goto step(pc + 1)
        (ins:ref<LinkedCall>) :          
          val fid = eval-imm(stack-pointer, global-table, globals, f(ins)) as int
          goto call-function(fid, pc + 1)
        (ins:ref<LinkedCallC>) :
          val faddr = eval-imm(stack-pointer, global-table, globals, f(ins))
          val launcher = launcher(ins).value as ptr<((long, ptr<long>) -> long)>
          [launcher](faddr, regs)
          goto step(pc + 1)
        (ins:ref<LinkedCallClosure>) :
          val fref = eval-imm(stack-pointer, global-table, globals, f(ins))
          val fptr = untag(fref) as ptr<Function>
          val fid = fptr.code as int
          goto call-function(fid, pc + 1)
        (ins:ref<LinkedYield>) :
          ;Save current stack
          val s:ptr<Stack> = untag(current-stack)
          s.stack-pointer = stack-pointer
          s.pc = pc + 1
          ;Load next next
          val sref = eval-imm(stack-pointer, global-table, globals, f(ins))          
          goto load-stack(sref)
        (ins:ref<LinkedReturn>) :
          val ret = stack-pointer.return as int
          if ret >= 0 : goto step(ret)          
        (ins:ref<FunctionEntry>) :
          val frame-size = (num-locals(ins).value * 8 + sizeof(Frame)) as int
          val size-required = frame-size + sizeof(Frame)
          if stack-pointer + size-required > stack-end : fatal("Stack overflow.")
          goto step(pc + 1)
        (ins:ref<LinkedDump>) :
          val xvalue = eval-imm(stack-pointer, global-table, globals, x(ins))
          val xint = xvalue as int
          val xvaluef = ($ls-prim fnum xint)
          val xvalued = ($ls-prim fnum xvalue)
          call-c clib/printf("> L%d = %ld (float = %f, double = %f)\n",
                             index(x(ins)).value, xvalue, xvaluef, xvalued)
          goto step(pc + 1)
        (ins:ref<LinkedLiveIns>) :
          stack-pointer.liveness-map = map(ins).value
          goto step(pc + 1)
        (ins:ref<LinkedBranchRegIns>) :
          val rvalue = regs[reg(ins).value] as int
          if rvalue == value(ins).value : goto step(pc + n(ins).value)
          else : goto step(pc + 1)
        (ins:ref<LinkedErrorIns>) :
          fatal(msg(ins))
          
  return false

;============================================================
;==================== Garbage Collector =====================
;============================================================

lostanza defn scan-roots (vm:ref<VirtualMachine>,
                          global-table:ref<GlobalTable>
                          live-map-table:ref<LiveMapTable>) -> long :
  call-c clib/printf("=== Scanning globals ===\n")
  val globals = vm.globals
  val roots = to-seq(roots(global-table))
  while empty?(roots) == false :
    val i = next(roots).value
    scan-root(globals[i])
  return 0

lostanza defn scan-root (r:long) -> long :
  call-c clib/printf(" root = %ld\n", r)
  return 0

;============================================================
;==================== Utilities =============================
;============================================================
defn ensure-length<?T> (v:Vector<?T>, len:Int, x:T) :
  lengthen(v, len, x) when length(v) < len

defn set-at<?T> (v:Vector<?T>, i:Int, x:T, default:T) :
  ensure-length(v, i + 1, default) when length(v) <= i
  v[i] = x

var delay : (() -> ?) -> False =
  fn (f) : fatal("Not within delay-actions block.")
defn delay-actions<?T> (f:() -> ?T) :
  val delays = Vector<(() -> ?)>()
  defn delay-action (action:() -> ?)  : add(delays, action)
  val result = let-var delay = delay-action : f()
  for d in delays do : d()
  clear(delays)
  result

;============================================================
;======================= Driver =============================
;============================================================

public defn interpret (prog:VMProg, trace?:True|False) :
  ;Link functions
  val linker = Linker()
  val func-table = to-tuple(fs as Vector<Int>) where :
    val fs = Vector<Int|False>()
    for f in funcs(prog) do :
      set-at(fs, id(f), link(linker,f), false)

  ;Link classes
  val class-table = ClassTable(classes(prog))

  ;Run
  val gt = GlobalTable(prog)
  val vm = VirtualMachine(gt)
  run(vm,
      instructions(linker),
      func-table,
      class-table,
      gt,
      live-map-table(linker),
      trace?)