defpackage stz/vm :
  import core
  import collections
  import stz/vm-ir
  import stz/vm-table
  import stz/loaded-ids
  import stz/dl-ir
  import stz/basic-ops
  import stz/trie
  import stz/vm-encoder
  import stz/stable-arrays
  import stz/branch-table

;============================================================
;==================== Linked Instructions ===================
;============================================================

public deftype LinkedIns :
  NewStackIns <: LinkedIns
  SetIns <: LinkedIns
  Op0Ins <: LinkedIns
  JumpIns <: LinkedIns
  CommentIns <: LinkedIns

public deftype JumpIns :
  GotoIns <: JumpIns
  Branch1Ins <: JumpIns

public defstruct LinkedStoreIns <: LinkedIns :
  size: Int
  x: VMImm
  y: VMImm
  z: VMImm
  offset: Int
  class: Int|False
public defstruct LinkedLoadIns <: LinkedIns :
  size: Int
  x: Local
  y: VMImm
  z: VMImm
  offset: Int
  class: Int|False
public defstruct LinkedRefStoreIns <: LinkedIns :
  size: Int
  x: VMImm
  y: VMImm
  z: VMImm
  offset: Int
  class: Int|False
public defstruct LinkedRefLoadIns <: LinkedIns :
  size: Int
  x: Local
  y: VMImm
  z: VMImm
  offset: Int
  class: Int|False
public defstruct SetReg <: LinkedIns :
  reg: Int
  x: VMImm
public defstruct GetReg <: LinkedIns :
  x: Local
  reg: Int
  ref?: True|False
public defstruct PopFrameIns <: LinkedIns :
  frame-size: Int
public defstruct LinkedTCall <: LinkedIns :
  f: VMImm
public defstruct LinkedTCallClosure <: LinkedIns :
  f: VMImm
public defstruct LinkedCall <: LinkedIns :
  f: VMImm
  frame-size: Int
public defstruct LinkedCallClosure <: LinkedIns :
  f: VMImm
  frame-size: Int
public defstruct LinkedCallC <: LinkedIns :
  f: VMImm
  launcher: Long
  frame-size: Int
public defstruct LinkedYield <: LinkedIns :
  f: VMImm
public defstruct LinkedReturn <: LinkedIns
public defstruct FunctionEntry <: LinkedIns :
  num-locals:Int
public defstruct LinkedDump <: LinkedIns :
  x: Local
  ref?: True|False
public defstruct LinkedVMCall <: LinkedIns :
  x: Local
  op: VMOp
  y: VMImm
public defstruct LinkedOp1Ins <: LinkedIns :
  type: VMType
  x: Local
  op: VMOp
  y: VMImm
public defstruct LinkedOp2Ins <: LinkedIns :
  type: VMType
  x: Local
  op: VMOp
  y: VMImm
  z: VMImm
public defstruct LinkedBranch2Ins <: LinkedIns :
  type: VMType
  n1: Int
  n2: Int
  op: VMOp
  x: VMImm
  y: VMImm
public defstruct LinkedConvIns <: LinkedIns :
  x: Local
  xtype: VMType
  op: VMOp
  y: VMImm
  ytype: VMType
public defstruct LinkedLiveIns <: LinkedIns :
  map: Int
public defstruct LinkedBranchRegIns <: LinkedIns :
  n: Int
  reg: Int
  value: Int
public defstruct LinkedReserveIns <: LinkedIns :
  n: Int
  space: VMImm
  num-obj: Int
  frame-size: Int
public defstruct LinkedAllocIns <: LinkedIns :
  x: Local
  type: Int
  size: VMImm
public defstruct LinkedDispatchIns <: LinkedIns :
  format: Int
  ys: Tuple<VMImm>
  ns: Tuple<Int>
  default: Int
  amb: Int

;============================================================
;======================= Printer ============================
;============================================================
defmethod print (o:OutputStream, i:LinkedReserveIns) :
  print(o, "reserve %_, %_ and goto %_" % [space(i), num-obj(i), n(i)])

defmethod print (o:OutputStream, i:LinkedVMCall) :
  print(o, "%_ = callvm %_ %_" % [x(i), op(i), y(i)])

defmethod print (o:OutputStream, i:LinkedAllocIns) :
  print(o, "%_ = alloc<%_> %_" % [x(i), type(i), size(i)])

defmethod print (o:OutputStream, i:PopFrameIns) :
  print(o, "pop-frame %_" % [frame-size(i)])

defn class-str? (i:LinkedStoreIns|LinkedLoadIns|LinkedRefStoreIns|LinkedRefLoadIns) :
  match(class(i)) :
    (c:Int) : " (class = %_)" % [c]
    (c:False) : ""

defmethod print (o:OutputStream, i:LinkedStoreIns) :
  print(o, "%_[%_ + %_] = %_ (%_ bytes)%_" % [x(i), y(i), offset(i), z(i), size(i), class-str?(i)])

defmethod print (o:OutputStream, i:LinkedLoadIns) :
  print(o, "%_ = %_[%_ + %_] (%_ bytes)%_" % [x(i), y(i), z(i), offset(i), size(i), class-str?(i)])

defmethod print (o:OutputStream, i:LinkedRefStoreIns) :
  print(o, "ref %_[%_ + %_] = %_ (%_ bytes)%_" % [x(i), y(i), offset(i), z(i), size(i), class-str?(i)])

defmethod print (o:OutputStream, i:LinkedRefLoadIns) :
  print(o, "%_ = ref %_[%_ + %_] (%_ bytes)%_" % [x(i), y(i), z(i), offset(i), size(i), class-str?(i)])

defmethod print (o:OutputStream, i:LinkedOp1Ins) :
  print(o, "%_ = %_ %_ %_" % [x(i), type(i), op(i), y(i)])

defmethod print (o:OutputStream, i:LinkedOp2Ins) :
  print(o, "%_ = %_ %_ %_ %_" % [x(i), type(i), op(i), y(i), z(i)])

defmethod print (o:OutputStream, i:LinkedBranch2Ins) :
  print(o, "goto %_ when %_ %_ %_ %_ else %_" % [n1(i), type(i), op(i), x(i), y(i), n2(i)])

defmethod print (o:OutputStream, r:SetReg) :
  print(o, "reg %_ = %_" % [reg(r), x(r)])

defmethod print (o:OutputStream, r:GetReg) :
  print(o, "%_ = reg %_ (ref = %_)" % [x(r), reg(r), ref?(r)])

defmethod print (o:OutputStream, x:LinkedTCall) :
  print(o, "return call %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedTCallClosure) :
  print(o, "return call-closure %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedCall) :
  print(o, "call %_ (frame-size = %_)" % [f(x), frame-size(x)])

defmethod print (o:OutputStream, x:LinkedCallC) :
  print(o, "call-c %_ (launcher %_, frame-size = %_)" % [f(x), launcher(x), frame-size(x)])

defmethod print (o:OutputStream, x:LinkedCallClosure) :
  print(o, "call-closure %_ (frame-size = %_)" % [f(x), frame-size(x)])

defmethod print (o:OutputStream, x:LinkedYield) :
  print(o, "yield %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedReturn) :
  print(o, "return")

defmethod print (o:OutputStream, x:FunctionEntry) :
  print(o, "enter (num-locals = %_)" % [num-locals(x)])

defmethod print (o:OutputStream, ins:LinkedDump) :
  print(o, "dump %_ (ref? = %_))" % [x(ins), ref?(ins)])

defmethod print (o:OutputStream, ins:LinkedLiveIns) :
  print(o, "live %_" % [map(ins)])

defmethod print (o:OutputStream, ins:LinkedConvIns) :
  print(o, "%_ = %_ (%_ <- %_) %_" % [x(ins), op(ins), xtype(ins), ytype(ins), y(ins)])

defmethod print (o:OutputStream, ins:LinkedBranchRegIns) :
  print(o, "goto %_ when R%_ == %_" % [n(ins), reg(ins), value(ins)])

defmethod print (o:OutputStream, ins:LinkedDispatchIns) :
  print(o, "dispatch[%_](%,) => (%,) (default = %_, amb = %_)" % [
    format(ins), ys(ins), ns(ins), default(ins), amb(ins)])

;============================================================
;======================= Linker =============================
;============================================================

deftype Linker
defmulti link (l:Linker, f:VMFunction, pkgids:PackageIds) -> LinkedFunction
defmulti live-map-table (l:Linker) -> LiveMapTable

;public defstruct FileInfoEntry :
;  pc: Int
;  fileinfo: FileInfo

public defstruct LinkedFunction :
  instructions: Tuple<LinkedIns>
  fileinfos: Tuple<FileInfoEntry>

defn Linker (branch-table:BranchTable) :
  ;===== Livemap Table =====
  val live-map-table = LiveMapTable()

  ;===== FileInformation Table =====
  val fileinfo-table = Vector<FileInfoEntry>()

  ;===== Temporary Linking Buffer =====
  val buffer = Vector<LinkedIns|False>()
  defn delayed-ins (f:Int -> LinkedIns) :
    val pos = length(buffer)
    add(buffer, false)
    within delay() :
      buffer[pos] = f(pos)

  ;Link the function
  defn link (f:VMFunction, pkgids:PackageIds) :
    ;Generate to temporary buffer
    match(f) :
      (f:VMMultifn) : link-multi(f, pkgids)
      (f:VMFunc) : link-func(f, pkgids)
    ;Return instructions and clear buffer
    val result = LinkedFunction(
                   to-tuple(buffer as Vector<LinkedIns>)
                   to-tuple(fileinfo-table))
    clear(buffer)
    clear(fileinfo-table)
    result

  ;Generate the code for a multi function
  defn link-multi (multi:VMMultifn, pkgids:PackageIds) :
    ;Get function position
    val function-pos = length(buffer)

    within delay-actions() :
      ;Fill in function position table
      val func-positions = Vector<Int>()
      ;Add branching instructions
      for (entry in funcs(multi), i in 0 to false) do :
        within pos = delayed-ins() :
          LinkedBranchRegIns(func-positions[i] - pos, arg(multi), key(entry))
      ;Add default branch
      link-func(default(multi), pkgids)
      ;Branches
      for func in seq(value,funcs(multi)) do :
        add(func-positions, link-func(func, pkgids))

    ;Return function position
    function-pos

  ;Generate the code for a single function
  defn link-func (func:VMFunc, pkgids:PackageIds) :
    ;Make an fileinfo entry
    defn record-info (info:FileInfo|False) :
      match(info:FileInfo) :
        val pos = length(buffer)
        add(fileinfo-table, FileInfoEntry(pos, info))
    ;Create mapping from local ID to slot
    val deftable = to-inttable<VMDef> $
      for def in defs(func) seq :
        id(def) => def
    ;Retrieve the size of an immediate
    defn imm-size (x:VMImm) :
      match(x:Local) : size(type(deftable[index(x)]))
      else : size(x)
    defn imm-type (x:VMImm) :
      match(x:Local) : type(deftable[index(x)])
      else : type(x)
    defn imm-type (x:False) :
      x
    ;Create label table
    val label-table = IntTable<Int>()

    ;Compute relative locations
    ;Substitute a local's index with its slot
    defn sub-slot (x:False) : x
    defn sub-slot (x:Local) : Local(local(deftable[index(x)]))

    ;Link an instruction
    defn link-ins<?T> (ins:VMIns&?T, pos:Int) -> T :
      defn sub-label (n:Int) : label-table[n] - pos
      defn sub-id (n:Int) : pkgids[n]
      map(sub-label, sub-slot, sub-id, ins)
    defn link-imm<?T> (x:?T&VMImm) -> T :
      map(sub-slot, {pkgids[_]}, x)

    ;Register Instructions
    defn get-regs (xs:Tuple<Local|False>, oldxs:Tuple<Local|False>) :
      for (x in xs, xo in oldxs, i in 0 to false) do :
        match(x:Local, xo:Local) :
          add(buffer, GetReg(x, i, imm-type(xo) is VMRef))
    defn set-regs (xs:Tuple<VMImm>) :
      for (x in xs, i in 0 to false) do :
        add(buffer, SetReg(i, x))

    ;Get function position
    val function-pos = length(buffer)

    ;Link instructions
    within delay-actions() :
      ;Create entry instructions
      val num-locals = maximum(-1, seq(local, defs(func))) + 1
      val frame-size = SIZEOF-FRAME + num-locals * 8
      val empty-map = LivenessMap([], num-locals)
      add(buffer, FunctionEntry(num-locals))
      get-regs(map(sub-slot, args(func)), args(func))
      ;Link and add to buffer
      for ins in ins(func) do :
        val pos = length(buffer)
        match(ins) :
          (ins:LabelIns) :
            label-table[n(ins)] = pos
          (ins:TCallIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, LinkedTCall(f(ins*)))
          (ins:TCallClosureIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, LinkedTCallClosure(f(ins*)))
          (ins:CallIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, LinkedCall(f(ins*), frame-size))
            record-info(info(ins))
            add(buffer, PopFrameIns(frame-size))
            get-regs(xs(ins*), xs(ins))
          (ins:UnreachableIns) :
            false
          (ins:CallClosureIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, LinkedCallClosure(f(ins*), frame-size))
            record-info(info(ins))
            add(buffer, PopFrameIns(frame-size))
            get-regs(xs(ins*), xs(ins))
          (ins:CallCIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            val format = coalesce(CallFormat(xtypes, ytypes)) where :
              val xtypes = map(imm-type,xs(ins))
              val ytypes = map(imm-type,ys(ins))
            val launcher = FORMAT-TABLE[format]
            add(buffer, LinkedCallC(f(ins*), launcher, frame-size))
            record-info(info(ins))
            get-regs(xs(ins*), xs(ins))
          (ins:YieldIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, LinkedYield(f(ins*)))
            record-info(info(ins))
            get-regs(xs(ins*), xs(ins))
          (ins:ReturnIns) :
            val ins* = link-ins(ins, pos)
            set-regs(xs(ins*))
            add(buffer, LinkedReturn())
          (ins:DumpIns) :
            val ins* = link-ins(ins, pos)
            for (x in xs(ins*), xo in xs(ins)) do :
              add(buffer, LinkedDump(x, imm-type(xo) is VMRef))
          (ins:RecordLiveIns) :
            val ins* = link-ins(ins, pos)
            val map = LivenessMap(map(index, live(ins*)), num-locals)
            val map-i = map-index(live-map-table, map)
            add(buffer, LinkedLiveIns(map-i))
          (ins:StoreIns) :
            val ins* = link-ins(ins, pos)
            val size = imm-size(z(ins))
            defn zero? (x:VMImm|False) :
              match(x:VMImm) : x
              else : NumConst(0)
            match(imm-type(x(ins))) :
              (t:VMRef) : add(buffer, LinkedRefStoreIns(size, x(ins*), zero?(y(ins*)), z(ins*), offset(ins*), class(ins*)))
              (t) : add(buffer, LinkedStoreIns(size, x(ins*), zero?(y(ins*)), z(ins*), offset(ins*), class(ins*)))
          (ins:LoadIns) :
            val ins* = link-ins(ins, pos)
            val size = imm-size(x(ins))
            defn zero? (x:VMImm|False) :
              match(x:VMImm) : x
              else : NumConst(0)
            match(imm-type(y(ins))) :
              (t:VMRef) : add(buffer, LinkedRefLoadIns(size, x(ins*), y(ins*), zero?(z(ins*)), offset(ins*), class(ins*)))
              (t) : add(buffer, LinkedLoadIns(size, x(ins*), y(ins*), zero?(z(ins*)), offset(ins*), class(ins*)))
          (ins:Op1Ins) :
            val ins* = link-ins(ins, pos)
            match(op(ins*)) :
              (op:GCOp) :
                add(buffer, LinkedVMCall(x(ins*), op, y(ins*)))
              (op:ConvOp|InterpretOp) :
                val xt = imm-type(x(ins))
                val yt = imm-type(y(ins))
                add(buffer, LinkedConvIns(x(ins*), xt, op, y(ins*), yt))
              (op:DetagOp|TagOp|IntNotOp|IntNegOp|DerefOp) :
                add(buffer, LinkedOp1Ins(VMRef(), x(ins*), op, y(ins*)))
              (op:InstanceofOp|PrintStackTraceOp) :
                add(buffer, LinkedOp1Ins(VMLong(), x(ins*), op, y(ins*)))
              (op) :
                val t = imm-type(y(ins))
                add(buffer, LinkedOp1Ins(t, x(ins*), op, y(ins*)))
          (ins:Op2Ins) :
            val ins* = link-ins(ins, pos)
            match(op(ins*)) :
              (op:IntAddOp|IntSubOp|IntMulOp|IntDivOp|IntModOp|IntAndOp|IntOrOp|IntXorOp|
                  IntShlOp|IntShrOp|IntAshrOp|IntLtOp|IntGtOp|IntLeOp|IntGeOp) :
                add(buffer, LinkedOp2Ins(VMRef(), x(ins*), op, y(ins*), z(ins*)))
              (op:EqOp|NeOp) :
                val t = match(imm-type(y(ins))) :
                  (yt:VMRef) : imm-type(x(ins)) as VMRef|VMLong
                  (yt) : yt
                add(buffer, LinkedOp2Ins(t, x(ins*), op, y(ins*), z(ins*)))
              (op) :
                val t = imm-type(y(ins))
                add(buffer, LinkedOp2Ins(t, x(ins*), op, y(ins*), z(ins*)))
          (ins:Branch2Ins) :
            within pos = delayed-ins() :
              val ins* = link-ins(ins, pos)
              val t = match(imm-type(x(ins))) :
                (xt:VMRef) : VMLong()
                (xt) : xt
              LinkedBranch2Ins(t, n1(ins*), n2(ins*), op(ins*), x(ins*), y(ins*))
          (ins:DispatchIns) :
            within pos = delayed-ins() :
              val ins* = link-ins(ins, pos)
              val [format, ns] = DispatchFormat(branches(ins*))
              val format-index = add(branch-table, format)
              LinkedDispatchIns(format-index, ys(ins*), ns, default(ins*), amb(ins*))
          (ins:MatchIns) :
            within pos = delayed-ins() :
              val ins* = link-ins(ins, pos)
              val [format, ns] = MatchFormat(branches(ins*))
              val format-index = add(branch-table, format)
              LinkedDispatchIns(format-index, ys(ins*), ns, default(ins*), -1)
          (ins:MethodDispatchIns) :
            set-regs(to-tuple(args)) where :
              val args = seq(link-imm, cat(ys(ins), zs(ins)))
            within pos = delayed-ins() :
              val ins* = link-ins(ins, pos)
              val format-index = add(branch-table,
                MultiFormat(multi(ins*), length(ys(ins*)), length(zs(ins*))))
              LinkedDispatchIns(format-index, zs(ins*), [], default(ins*), amb(ins*))
          (ins:JumpIns&VMIns) :
            within pos = delayed-ins() :
              link-ins(ins, pos)
          (ins:NewStackIns) :
            val ins* = link-ins(ins, pos)
            add(buffer, LinkedReserveIns(2, NumConst(SIZEOF-STACK), 1, frame-size))
            record-info(info(ins))
            add(buffer, PopFrameIns(frame-size))
            add(buffer, ins*)
          (ins:AllocIns) :
            val ins* = link-ins(ins, pos)
            if length(sizes(ins*)) == 1 :
              val x = xs(ins*)[0]
              val type = types(ins*)[0]
              val size = sizes(ins*)[0]
              add(buffer, LinkedReserveIns(2, size, 1, frame-size))
              record-info(info(ins))
              add(buffer, PopFrameIns(frame-size))
              add(buffer, LinkedAllocIns(x, type, size))
            else :
              val num-obj = length(sizes(ins*))
              val size = sum $
                for s in sizes(ins*) seq :
                  value(s as NumConst) as Int
              add(buffer, LinkedReserveIns(2, NumConst(size), num-obj, frame-size))
              record-info(info(ins))
              add(buffer, PopFrameIns(frame-size))
              for (x in xs(ins*), t in types(ins*), s in sizes(ins*)) do :
                add(buffer, LinkedAllocIns(x, t, s))
          (ins:LinkedIns&VMIns) :
            add(buffer, link-ins(ins, pos))
    ;Dump to instruction buffer
    function-pos

  new Linker :
    defmethod link (this, f:VMFunction, pkgids:PackageIds) : link(f, pkgids)
    defmethod live-map-table (this) : live-map-table

;============================================================
;================= Live Map Analysis ========================
;============================================================
deftype LiveMapTable
defmulti map-index (t:LiveMapTable, map:LivenessMap) -> Int
defmulti get (t:LiveMapTable, i:Int) -> LivenessMap
defmulti key? (t:LiveMapTable, i:Int) -> True|False

public defstruct LivenessMap <: Hashable&Equalable :
  live-slots: Tuple<Int>
  num-slots: Int
with:
  constructor => #LivenessMap
defn LivenessMap (slots:Tuple<Int>, num-slots:Int) :
  #LivenessMap(qsort(slots), num-slots)
defmethod hash (m:LivenessMap) :
  num-slots(m) + 7 * hash(live-slots(m))
defmethod equal? (a:LivenessMap, b:LivenessMap) :
  live-slots(a) == live-slots(b) and
  num-slots(a) == num-slots(b)

public defn LiveMapTable () :
  val maps = Vector<LivenessMap>()
  val table = HashTable<LivenessMap,Int>()
  defn add-map (m:LivenessMap) :
    table[m] = length(maps)
    add(maps, m)
  add-map(LivenessMap([], 0))
  new LiveMapTable :
    defmethod map-index (this, map:LivenessMap) :
      add-map(map) when not key?(table, map)
      table[map]
    defmethod get (this, i:Int) :
      maps[i]
    defmethod key? (this, i:Int) :
      i >= 0 and i < length(maps)

;============================================================
;==================== Extern Table ==========================
;============================================================

public deftype ExternTable
public defmulti get (t:ExternTable, name:Symbol) -> Long
public defmulti set (t:ExternTable, name:Symbol, addr:Long) -> False

defn ExternTable () :
  val table = HashTable<Symbol,Long>()
  new ExternTable :
    defmethod get (this, name:Symbol) :
      table[name]
    defmethod set (this, name:Symbol, addr:Long) :
      table[name] = addr

public val EXTERN-TABLE = ExternTable()

;============================================================
;===================== Format Table =========================
;============================================================

public defstruct CallFormat <: Hashable&Equalable :
  xs: Tuple<VMType|False>
  ys: Tuple<VMType>
with :
  printer => true

defmethod hash (f:CallFormat) :
  hash(xs(f)) + 7 * hash(ys(f))
defmethod equal? (a:CallFormat, b:CallFormat) :
  xs(a) == xs(b) and ys(a) == ys(b)

public deftype FormatTable
public defmulti index (t:FormatTable, f:CallFormat) -> Int
public defmulti address (t:FormatTable, index:Int) -> Long
public defmulti get (t:FormatTable, f:CallFormat) -> Long
public defmulti set (t:FormatTable, f:CallFormat, l:Long) -> False

defn FormatTable () :
  val table = HashTable<CallFormat,Int>()
  val addresses = Vector<Long>()
  new FormatTable :
    defmethod index (this, f:CallFormat) : table[f]
    defmethod address (this, index:Int) : addresses[index]
    defmethod get (this, f:CallFormat) : addresses[table[f]]
    defmethod set (this, f:CallFormat, l:Long) :
      add(addresses, l)
      table[f] = length(addresses) - 1

public val FORMAT-TABLE = FormatTable()

;============================================================
;=================== Format Coalescing ======================
;============================================================

defn exemplar-type (t:VMType) :
  match(t:VMRef) : VMLong()
  else : t

public defn coalesce (f:CallFormat) :
  ;New return result
  val x* =
    if empty?(xs(f)) :
      VMLong()
    else :
      match(xs(f)[0]) :
        (x:False) :
          VMLong()
        (x:VMType) :
          match(exemplar-type(x)) :
            (t:VMByte|VMInt) : VMLong()
            (t) : t

  ;New arguments
  val ys* = for y in ys(f) map :
    match(exemplar-type(y)) :
      (y:VMByte|VMInt) : VMLong()
      (y) : y

  ;Return coalesced call format
  CallFormat([x*], ys*)

;============================================================
;==================== Tag Bits ==============================
;============================================================

public lostanza val INT-TAG-BITS:long = 0L
public lostanza val REF-TAG-BITS:long = 1L
public lostanza val MARKER-TAG-BITS:long = 2L
public lostanza val BYTE-TAG-BITS:long = 3L
public lostanza val CHAR-TAG-BITS:long = 4L
public lostanza val FLOAT-TAG-BITS:long = 5L

public lostanza val INT-TAG-INT:ref<Int> = new Int{INT-TAG-BITS as int}
public lostanza val REF-TAG-INT:ref<Int> = new Int{REF-TAG-BITS as int}
public lostanza val MARKER-TAG-INT:ref<Int> = new Int{MARKER-TAG-BITS as int}
public lostanza val BYTE-TAG-INT:ref<Int> = new Int{BYTE-TAG-BITS as int}
public lostanza val CHAR-TAG-INT:ref<Int> = new Int{CHAR-TAG-BITS as int}
public lostanza val FLOAT-TAG-INT:ref<Int> = new Int{FLOAT-TAG-BITS as int}

;============================================================
;==================== VM Constants ==========================
;============================================================

lostanza defn untag (x:long) -> ptr<?> :
  val tagbits = x & 7L
  if tagbits != REF-TAG-BITS : fatal("Not a heap-allocated object!")
  return (x - REF-TAG-BITS + 8) as ptr<?>

lostanza defn tag (x:ptr<?>) -> long :
  return (x + REF-TAG-BITS) as long

public lostanza defn void-marker () -> long :
  return (-1L << 3L) + MARKER-TAG-BITS

public lostanza defn false-marker () -> long :
  return (FALSE-TYPE.value << 3L) + MARKER-TAG-BITS

public defn void-marker-int () :
  marker-int(-1)

public defn marker-int (t:Int) :
  (t << 3) + MARKER-TAG-INT

;============================================================
;=================== VM Structures ==========================
;============================================================

public lostanza deftype VirtualMachine :
  vmtable: ref<VMTable>
  loaded-ids: ref<LoadedIds>
  linker: ref<Linker>
  registers: ptr<long>
  heap: ptr<long>                ;[semi-variable]
  heap-top: ptr<long>            ;[variable]
  heap-limit: ptr<long>          ;[semi-variable]
  free: ptr<long>                ;[semi-variable]
  free-limit: ptr<long>          ;[semi-variable]
  current-stack: long            ;[variable]
  stack-pointer: ptr<StackFrame> ;[variable]
  pc: int                        ;[variable]

lostanza deftype StackFrame :
  return: long
  liveness-map: long
  slots: long ...

lostanza deftype Stack :
  size: long
  frames: ptr<StackFrame>
  stack-pointer: ptr<StackFrame>
  pc: int

lostanza deftype Function :
  num-slots: long
  code: long
  slots: long ...

lostanza deftype ObjectLayout :
  tag: long
  slots: long ...

lostanza deftype BrokenHeartLayout :
  tag: long
  forward: long

lostanza val SIZEOF-FRAME:ref<Int> = new Int{sizeof(StackFrame) as int}
lostanza val SIZEOF-STACK:ref<Int> = new Int{sizeof(Stack) as int}

lostanza defn stack-end (stackref:long) -> ptr<StackFrame> :
  val s:ptr<Stack> = untag(stackref)
  return s.frames + s.size

lostanza defn linker (vm:ref<VirtualMachine>) -> ref<Linker> :
  return vm.linker

lostanza defn loaded-ids (vm:ref<VirtualMachine>) -> ref<LoadedIds> :
  return vm.loaded-ids

lostanza defn vmtable (vm:ref<VirtualMachine>) -> ref<VMTable> :
  return vm.vmtable

;============================================================
;==================== VM Implementation =====================
;============================================================

public lostanza defn VirtualMachine () -> ref<VirtualMachine> :
  val registers = call-c clib/malloc(8 * 256)
  val heap-size = 4 * 1024
  val heap = call-c clib/malloc(heap-size)
  val heap-limit = heap + heap-size
  val free = call-c clib/malloc(heap-size)
  val free-limit = free + heap-size
  val null = 0L as ptr<?>
  val class-table = ClassTable()
  val branch-table = BranchTable(class-table)
  val linker = Linker(branch-table)
  return new VirtualMachine{VMTable(class-table, branch-table), LoadedIds(), linker,
                            registers, heap, heap, heap-limit,
                            free, free-limit, void-marker(), null, 0}

lostanza defn alloc-heap (vm:ref<VirtualMachine>, tag:long, size:long) -> ptr<?> :
  ;Make space on heap
  val obj = vm.heap-top + 8
  [vm.heap-top] = tag
  vm.heap-top = vm.heap-top + 8 + size
  return obj

lostanza defn alloc-stack (vm:ref<VirtualMachine>, pc:int) -> long :
  ;Allocate stack
  val sptr:ptr<Stack> = alloc-heap(vm, STACK-TYPE.value, sizeof(Stack))

  ;Allocate stack frames
  val stack-size = 4 * 1024
  val frames = call-c clib/malloc(stack-size)

  ;Fill in stack fields
  sptr.size = stack-size
  sptr.frames = frames
  sptr.stack-pointer = frames
  sptr.pc = pc * 4
  sptr.frames.return = -1L
  sptr.frames.liveness-map = 0L

  ;Return stack
  return tag(sptr - 8)

lostanza defn eval-imm (x:ref<VMImm>, frame:ptr<StackFrame>, vmtable:ref<VMTable>) -> long :
  match(x) :
    (x:ref<Local>) :
      return frame.slots[index(x).value]
    (x:ref<NumConst>) :
      match(value(x)) :
        (v:ref<Char>) : return v.value
        (v:ref<Byte>) : return v.value
        (v:ref<Int>) : return v.value
        (v:ref<Long>) : return v.value
        (v:ref<Float>) : return float-to-bits(v.value)
        (v:ref<Double>) : return double-to-bits(v.value)
    (x:ref<CodeId>) :
      return id(x).value
    (x:ref<ExternId>) :
      return get(vmtable.extern-addresses, id(x)).value
    (x:ref<GlobalId>) :
      val offset = global-offset(vmtable, id(x)).value
      return (vmtable.globals.mem + offset) as long
    (x:ref<DataId>) :
      val pos = get(vmtable.data-positions, id(x)).value
      return addr!(vmtable.data.mem[pos]) as long
    (x:ref<ConstId>) :
      val n = id(x).value
      val mem:ptr<long> = vmtable.consts.mem
      return mem[n]
    (x:ref<Marker>) :
      return (typeid(x).value << 3L) + MARKER-TAG-BITS
    (x:ref<VoidMarker>) :
      return void-marker()
    (x:ref<Tag>) :
      return typeid(x).value

lostanza defn eval-op (op:ref<VMOp>, current-stack:long,
                       stack-pointer:ptr<StackFrame>, vmtable:ref<VMTable>) -> long :
  match(op) :
    (op:ref<CurrentStackOp>) : return current-stack
    (op:ref<GlobalsOp>) : return vmtable.globals.mem as long
    (op:ref<ConstsDataOp>) : return vmtable.consts-data as long
    (op:ref<ConstsOp>) : return vmtable.consts.mem as long
    (op:ref<FlushVMOp>) :
      val stk:ptr<Stack> = untag(current-stack)
      stk.stack-pointer = stack-pointer
      return 0
  return 0

lostanza defn eval-type (y:long) -> ref<Int> :
  val tagbits = y & 7L
  if tagbits == REF-TAG-BITS :
    return new Int{[(y - REF-TAG-BITS) as ptr<long>] as int}
  else if tagbits == MARKER-TAG-BITS :
    return new Int{(y >> 3L) as int}
  else if tagbits == INT-TAG-BITS :
    return INT-TYPE
  else if tagbits == BYTE-TAG-BITS :
    return BYTE-TYPE
  else if tagbits == CHAR-TAG-BITS :
    return CHAR-TYPE
  else if tagbits == FLOAT-TAG-BITS :
    return FLOAT-TYPE
  else :
    return fatal("Unrecognized tag bits.")

lostanza defn eval-types (ys:ref<Tuple<VMImm>>, frame:ptr<StackFrame>, vmtable:ref<VMTable>) -> ref<Tuple<Int>> :
  ;Create void tuple
  val n = ys.length
  val ret = new Tuple{n}
  for (var i:int = 0, i < n, i = i + 1) :
    ret.items[i] = false
  ;Evaluate type of each y and store in tuple
  for (var i:int = 0, i < n, i = i + 1) :
    val t = eval-type(eval-imm(ys.items[i], frame, vmtable))
    ret.items[i] = t
  ;Return tuple
  return ret

lostanza defn eval-op (type:ref<VMType>, op:ref<VMOp>, y:long, vmtable:ref<VMTable>, livemap:ref<LiveMapTable>) -> long :
  match(type) :
    (type:ref<VMByte>) :
      val y = y as byte
      match(op) :
        (op:ref<NotOp>) : return (~ y)
        (op) : (fatal("Illegal op."), return 0)
    (type:ref<VMInt>) :
      val y = y as int
      match(op) :
        (op:ref<NotOp>) : return (~ y)
        (op:ref<NegOp>) : return (- y)
        (op) : (fatal("Illegal op."), return 0)
    (type:ref<VMLong>) :
      match(op) :
        (op:ref<NotOp>) : return (~ y)
        (op:ref<NegOp>) : return (- y)
        (op:ref<InstanceofOp>) :
          val type = eval-type(y)
          return instanceof?(vmtable.class-table, type, /type(op)) == true
        (op:ref<PrintStackTraceOp>) :
          val stk:ptr<Stack> = untag(y)
          print-stack-trace(stk, vmtable, livemap)
          return 0
        (op) : (fatal("Illegal op."), return 0)
    (type:ref<VMFloat>) :
      val yint = y as int
      val y = ($ls-prim fnum yint)
      match(op) :
        (op:ref<NegOp>) : return float-to-bits((- y))
        (op) : (fatal("Illegal op."), return 0)
    (type:ref<VMDouble>) :
      val y = ($ls-prim fnum y)
      match(op) :
        (op:ref<NegOp>) : return double-to-bits((- y))
        (op) : (fatal("Illegal op."), return 0)
    (type:ref<VMRef>) :
      match(op) :
        (op:ref<TagOp>) :
          val t = /type(op).value
          if t == BYTE-TYPE.value :
            return y << 32L + BYTE-TAG-BITS
          else if t == CHAR-TYPE.value :
            return y << 32L + CHAR-TAG-BITS
          else if t == INT-TYPE.value :
            return y << 32L
          else if t == FLOAT-TYPE.value :
            return y << 32L + FLOAT-TAG-BITS
          else :
            fatal("Illegal op.")
            return 0
        (op:ref<DetagOp>) :
          return y >> 32L
        (op:ref<DerefOp>) :
          return untag(y) as long
        (op:ref<IntNotOp>) :
          return (~ y) & (-1L << 32L)
        (op:ref<IntNegOp>) :
          return (- y)


lostanza defn bit-to-bool (x:long) -> long :
  return (x << 3L) + MARKER-TAG-BITS

lostanza defn eval-op (type:ref<VMType>, op:ref<VMOp>, y:long, z:long) -> long :
  match(type) :
    (type:ref<VMRef>) :
      match(op) :
        (op:ref<IntAddOp>) : return y + z
        (op:ref<IntSubOp>) : return y - z
        (op:ref<IntMulOp>) : return (y >>> 32L) * z
        (op:ref<IntDivOp>) : return (y / z) << 32L
        (op:ref<IntModOp>) : return y % z
        (op:ref<IntAndOp>) : return y & z
        (op:ref<IntOrOp>) : return y | z
        (op:ref<IntXorOp>) : return y ^ z
        (op:ref<IntShlOp>) : return y << (z >>> 32L)
        (op:ref<IntShrOp>) : return ((y >> (z >>> 32L)) >> 32L) << 32L
        (op:ref<IntAshrOp>) : return ((y >>> (z >>> 32L)) >> 32L)
        (op:ref<IntLtOp>) : return bit-to-bool(y < z)
        (op:ref<IntGtOp>) : return bit-to-bool(y > z)
        (op:ref<IntLeOp>) : return bit-to-bool(y <= z)
        (op:ref<IntGeOp>) : return bit-to-bool(y >= z)
        (op:ref<EqOp>) : return bit-to-bool(y == z)
        (op:ref<NeOp>) : return bit-to-bool(y != z)
    (type:ref<VMByte>) :
      val y = y as byte
      val z = z as byte
      match(op) :
        (op:ref<AddOp>) : return y + z
        (op:ref<SubOp>) : return y - z
        (op:ref<MulOp>) : return y * z
        (op:ref<DivOp>) : return y / z
        (op:ref<ModOp>) : return y % z
        (op:ref<AndOp>) : return y & z
        (op:ref<OrOp>) : return y | z
        (op:ref<XorOp>) : return y ^ z
        (op:ref<ShlOp>) : return y << z
        (op:ref<ShrOp>) : return y >> z
        (op:ref<AshrOp>) : return y >>> z
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<UleOp>) : return ($ls-prim ule y z)
        (op:ref<UltOp>) : return ($ls-prim ult y z)
        (op:ref<UgtOp>) : return ($ls-prim ugt y z)
        (op:ref<UgeOp>) : return ($ls-prim uge y z)
        (op) : (fatal("Illegal operand."), return 0)
    (type:ref<VMInt>) :
      val y = y as int
      val z = z as int
      match(op) :
        (op:ref<AddOp>) : return y + z
        (op:ref<SubOp>) : return y - z
        (op:ref<MulOp>) : return y * z
        (op:ref<DivOp>) : return y / z
        (op:ref<ModOp>) : return y % z
        (op:ref<AndOp>) : return y & z
        (op:ref<OrOp>) : return y | z
        (op:ref<XorOp>) : return y ^ z
        (op:ref<ShlOp>) : return y << z
        (op:ref<ShrOp>) : return y >> z
        (op:ref<AshrOp>) : return y >>> z
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<LtOp>) : return y < z
        (op:ref<GtOp>) : return y > z
        (op:ref<LeOp>) : return y <= z
        (op:ref<GeOp>) : return y >= z
        (op:ref<UleOp>) : return ($ls-prim ule y z)
        (op:ref<UltOp>) : return ($ls-prim ult y z)
        (op:ref<UgtOp>) : return ($ls-prim ugt y z)
        (op:ref<UgeOp>) : return ($ls-prim uge y z)
    (type:ref<VMLong>) :
      match(op) :
        (op:ref<AddOp>) : return y + z
        (op:ref<SubOp>) : return y - z
        (op:ref<MulOp>) : return y * z
        (op:ref<DivOp>) : return y / z
        (op:ref<ModOp>) : return y % z
        (op:ref<AndOp>) : return y & z
        (op:ref<OrOp>) : return y | z
        (op:ref<XorOp>) : return y ^ z
        (op:ref<ShlOp>) : return y << z
        (op:ref<ShrOp>) : return y >> z
        (op:ref<AshrOp>) : return y >>> z
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<LtOp>) : return y < z
        (op:ref<GtOp>) : return y > z
        (op:ref<LeOp>) : return y <= z
        (op:ref<GeOp>) : return y >= z
        (op:ref<UleOp>) : return ($ls-prim ule y z)
        (op:ref<UltOp>) : return ($ls-prim ult y z)
        (op:ref<UgtOp>) : return ($ls-prim ugt y z)
        (op:ref<UgeOp>) : return ($ls-prim uge y z)
    (type:ref<VMFloat>) :
      val yint = y as int
      val zint = z as int
      val y = ($ls-prim fnum yint)
      val z = ($ls-prim fnum zint)
      match(op) :
        (op:ref<AddOp>) : return float-to-bits(y + z)
        (op:ref<SubOp>) : return float-to-bits(y - z )
        (op:ref<MulOp>) : return float-to-bits(y * z)
        (op:ref<DivOp>) : return float-to-bits(y / z)
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<LtOp>) : return y < z
        (op:ref<GtOp>) : return y > z
        (op:ref<LeOp>) : return y <= z
        (op:ref<GeOp>) : return y >= z
        (op) : (fatal("Illegal operand."), return 0)
    (type:ref<VMDouble>) :
      val y = ($ls-prim fnum y)
      val z = ($ls-prim fnum z)
      match(op) :
        (op:ref<AddOp>) : return double-to-bits(y + z)
        (op:ref<SubOp>) : return double-to-bits(y - z)
        (op:ref<MulOp>) : return double-to-bits(y * z)
        (op:ref<DivOp>) : return double-to-bits(y / z)
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<LtOp>) : return y < z
        (op:ref<GtOp>) : return y > z
        (op:ref<LeOp>) : return y <= z
        (op:ref<GeOp>) : return y >= z
        (op) : (fatal("Illegal operand."), return 0)

lostanza defn eval-conv (op:ref<VMOp>, xtype:ref<VMType>, ytype:ref<VMType>, y:long) -> long :
  match(op) :
    (op:ref<ConvOp>) :
      match(xtype, ytype) :
        ;Integer <- Integer conversions
        (xtype:ref<VMByte|VMInt|VMLong>, ytype:ref<VMByte>) : return y as byte
        (xtype:ref<VMByte|VMInt|VMLong>, ytype:ref<VMInt>) : return y as int
        (xtype:ref<VMByte|VMInt|VMLong>, ytype:ref<VMLong>) : return y
        ;Float <- Integer conversions
        (xtype:ref<VMDouble>, ytype:ref<VMByte|VMInt|VMLong>) :
          val ylong = eval-conv(op, VMLong(), ytype, y)
          return double-to-bits(ylong as double)
        (xtype:ref<VMFloat>, ytype:ref<VMByte|VMInt|VMLong>) :
          val ylong = eval-conv(op, VMLong(), ytype, y)
          return float-to-bits(ylong as float)
        ;Integer <- Float conversions
        (xtype:ref<VMByte|VMInt|VMLong>, ytype:ref<VMFloat>) :
          val ylong = bits-to-float(y as int) as long
          return eval-conv(op, xtype, VMLong(), ylong)
        (xtype:ref<VMByte|VMInt|VMLong>, ytype:ref<VMDouble>) :
          val ylong = bits-to-double(y) as long
          return eval-conv(op, xtype, VMLong(), ylong)
        ;Float <- Float conversions
        (xtype:ref<VMFloat>, ytype:ref<VMFloat>) : return y
        (xtype:ref<VMDouble>, ytype:ref<VMDouble>) : return y
        (xtype:ref<VMDouble>, ytype:ref<VMFloat>) :
          return double-to-bits(bits-to-float(y as int) as double)
        (xtype:ref<VMFloat>, ytype:ref<VMDouble>) :
          return float-to-bits(bits-to-double(y) as float)
    (op:ref<InterpretOp>) :
      return y

defn print-ins (i:Int, ins:LinkedIns) :
  println("Trace (%_) %_" % [i, ins])

lostanza defn assign (frame:ptr<StackFrame>, l:ref<Local>, value:long) -> long :
  frame.slots[index(l).value] = value
  return 0

public defn run (vm:VirtualMachine, fid:Int) :
  run(vm, fid, false)

lostanza defn load-tag (y:long) -> ref<Int> :
  val tagbits = y & 7L
  if tagbits != REF-TAG-BITS :
    fatal("Not a heap-allocated object!")
  return new Int{[(y - REF-TAG-BITS) as ptr<int>]}

lostanza defn object-size (y:long, c:ref<VMClass>) -> long :
  match(c) :
    (c:ref<VMLeafClass>) :
      return size(c).value
    (c:ref<VMArrayClass>) :
      val obj = (y - REF-TAG-BITS) as ptr<ObjectLayout>
      val length = obj.slots[0]
      if length < 0 : fatal("Negative length!")
      return base-size(c).value + length * item-size(c).value


val NEW-STACK = 0
val SET = 1
val OP0 = 2
val VMCALL = 3
val OP1 = 4
val OP2 = 5
val CONV = 6
val RESERVE = 7
val ALLOC = 8
val REFSTORE = 9
val REFLOAD = 10
val STORE = 11
val LOAD = 12
val GOTO = 13
val BRANCH1 = 14
val BRANCH2 = 15
val DISPATCH = 16
val SETREG = 17
val GETREG = 18
val POPFRAME = 19
val CALL = 20
val CALLCLO = 21
val TCALL = 22
val TCALLCLO = 23
val CALLC = 24
val YIELD = 25
val RETURN = 26
val FNENTRY = 27
val DUMP = 28
val LIVE = 29
val BRANCHREG = 30
val COMMENT = 31
val FN-SECTION = 32
val TOTAL = 33
val DISPATCH-EVAL = 34
val DISPATCH-KEY = 35
val DISPATCH-RETRIEVE = 36


val NUM-CATEGORIES = 37

val CATEGORY-NAMES = ["NEW-STACK", "SET", "OP0", "VMCALL", "OP1", "OP2", "CONV", "RESERVE",
                      "ALLOC", "REFSTORE", "REFLOAD", "STORE", "LOAD", "GOTO", "BRANCH1",
                      "BRANCH2", "DISPATCH", "SETREG", "GETREG", "POPFRAME", "CALL", "CALLCLO",
                      "TCALL", "TCALLCLO", "CALLC", "YIELD", "RETURN", "FNENTRY", "DUMP",
                      "LIVE", "BRANCHREG", "COMMENT", "FN-SECTION", "TOTAL", "DISPATCH-EVAL",
                      "DISPATCH-KEY", "DISPATCH-RETRIEVE"]

val INS-TIMES = Array<Long>(NUM-CATEGORIES, 0L)
val INS-COUNTS = Array<Int>(NUM-CATEGORIES, 0)
defn start-timer (i:Int) :
  INS-TIMES[i] = INS-TIMES[i] - current-time-us()
  INS-COUNTS[i] = INS-COUNTS[i] + 1
defn stop-timer (i:Int) :
  INS-TIMES[i] = INS-TIMES[i] + current-time-us()
defn print-timers () :
  for i in 0 to NUM-CATEGORIES do :
    println("%_: %_ times, %_ us" % [CATEGORY-NAMES[i], INS-COUNTS[i], INS-TIMES[i]])

;============================================================
;================= Bytecode Loop ============================
;============================================================

extern vmloop: (ptr<byte>, ;instructions
                int,       ;length of instructions
                ptr<long>, ;heap-top
                ptr<long>, ;heap-limit
                ptr<long>, ;registers
                long,      ;current-stack
                ptr<long>, ;global offset table
                ptr<long>, ;global memory
                ptr<long>, ;const offset table
                ptr<byte>, ;const memory
                ptr<int>,  ;data offset table
                ptr<long>, ;data memory
                ptr<long>, ;extern address table
                ptr<int>,  ;code offset table
                int,       ;EXTEND_HEAP_ID
                ptr<ptr<long>> ;new-heap-top
                ptr<long>      ;new-current-stack
                ) -> int   ;void return

extern defn call_c_launcher (index:int, faddr:long, registers:ptr<long>) -> int :
  val launcher-address = address(FORMAT-TABLE, new Int{index}).value
  val launcher = launcher-address as ptr<((long, ptr<long>) -> long)>
  [launcher](faddr, registers)
  return 0

extern defn call_garbage_collector (heap-top:ptr<long>,
                                    stack-pointer:ptr<StackFrame>,
                                    current-stack:long,
                                    total-size:long,
                                    new-heap-top:ptr<ptr<long>>,
                                    new-heap-limit:ptr<ptr<long>>,
                                    new-current-stack:ptr<long>) -> int :
  ;Save attributes
  val vm = VIRTUAL-MACHINE as ref<VirtualMachine>
  vm.heap-top = heap-top
  vm.stack-pointer = stack-pointer
  vm.current-stack = current-stack
  ;Call GC
  extend-heap(vm, total-size)
  ;Return values
  [new-heap-top] = vm.heap-top
  [new-heap-limit] = vm.heap-limit
  [new-current-stack] = vm.current-stack
  return 0

extern defn call_stack_extender (heap-top:ptr<long>,
                                 stack-pointer:ptr<StackFrame>,
                                 current-stack:long,
                                 size:long,
                                 new-heap-top:ptr<ptr<long>>,
                                 new-heap-limit:ptr<ptr<long>>,
                                 new-current-stack:ptr<long>) -> int :
  ;Save attributes
  val vm = VIRTUAL-MACHINE as ref<VirtualMachine>
  vm.heap-top = heap-top
  vm.stack-pointer = stack-pointer
  vm.current-stack = current-stack
  ;Call GC
  extend-stack(vm, size)
  ;Return values
  [new-heap-top] = vm.heap-top
  [new-heap-limit] = vm.heap-limit
  [new-current-stack] = vm.current-stack
  return 0

extern defn call_print_stack_trace (stack:long) -> int :
  val vm = VIRTUAL-MACHINE as ref<VirtualMachine>
  val stk:ptr<Stack> = untag(stack)
  print-stack-trace(stk, vmtable(vm), live-map-table(vm.linker))
  return 0

extern defn dispatch_branch (format:int, registers:ptr<long>) -> int :
  val vm = VIRTUAL-MACHINE as ref<VirtualMachine>
  val typeids = typeids(format, registers)
  val result = dispatch(branch-table(vm), new Int{format}, typeids)
  match(get(branch-table(vm), new Int{format}), result) :
    (bf:ref<DispatchFormat>, result:ref<Default>) : return 0
    (bf:ref<DispatchFormat>, result:ref<Amb>) : return 1
    (bf:ref<DispatchFormat>, result:ref<Int>) : return result.value + 2
    (bf:ref<MatchFormat>, result:ref<Default>) : return 0
    (bf:ref<MatchFormat>, result:ref<Int>) : return result.value + 1
    (bf:ref<MultiFormat>, result:ref<Default>) : return 0
    (bf:ref<MultiFormat>, result:ref<Amb>) : return 1
    (bf:ref<MultiFormat>, result:ref<CodeId>) : return id(result).value + 2

val PRIM-TYPEIDS:Tuple<Int> = [INT-TYPE, 0, 0, BYTE-TYPE, CHAR-TYPE, FLOAT-TYPE]
lostanza defn typeid (x:long) -> ref<Int> :
  val tagbits = x & 0x7L
  if tagbits == REF-TAG-BITS :
    val ptr = (x - REF-TAG-BITS) as ptr<int>
    return new Int{[ptr]}
  else if tagbits == MARKER-TAG-BITS :
    return new Int{(x >> 3L) as int}
  else :
    return PRIM-TYPEIDS.items[tagbits]

lostanza defn typeids (num-header-args:int, num-args:int, registers:ptr<long>) -> ref<Tuple<Int>> :
  val ret = new Tuple{num-args}
  for (var i:int = 0, i < num-args, i = i + 1) :
    ret.items[i] = false
  for (var i:int = 0, i < num-args, i = i + 1) :
    ret.items[i] = typeid(registers[i + num-header-args])
  return ret

lostanza defn typeids (format:int, registers:ptr<long>) -> ref<Tuple<Int>> :
  return typeids(num-header-dispatch-args(new Int{format}).value,
                 num-dispatch-args(new Int{format}).value,
                 registers)

defn num-header-dispatch-args (branch-format:Int) :
  val bt = branch-table(VIRTUAL-MACHINE as VirtualMachine)
  match(bt[branch-format]) :
    (f:MatchFormat) : 0
    (f:DispatchFormat) : 0
    (f:MultiFormat) : num-header-args(f)

defn num-dispatch-args (branch-format:Int) :
  val bt = branch-table(VIRTUAL-MACHINE as VirtualMachine)
  match(bt[branch-format]) :
    (f:MatchFormat) : length(branches(f)[0])
    (f:DispatchFormat) : length(branches(f)[0])
    (f:MultiFormat) : num-args(f)

var VIRTUAL-MACHINE : VirtualMachine|False = false
lostanza var new-heap-top:ptr<long>
lostanza var new-current-stack:long
public lostanza defn run-bytecode (vm:ref<VirtualMachine>, start-func:ref<Int>) -> ref<False> :
  ;Set global variable
  VIRTUAL-MACHINE = vm

  ;Retrieve vmtable
  val vmtable = vm.vmtable

  ;Retrieve pc of starting function
  val mainpc = get(vmtable.function-addresses, start-func).value

  ;Initialize starting stack
  if vm.current-stack == void-marker() :
    vm.current-stack = alloc-stack(vm, mainpc)
  else :
    val stk:ptr<Stack> = untag(vm.current-stack)
    stk.pc = mainpc * 4

  ;Retrieve GC id
  val extend-heap-id = get(vm.loaded-ids, CORE-EXTEND-HEAP-ID).value

  ;Start virtual machine loop
  call-c vmloop(vmtable.bytecode.mem,
                vmtable.bytecode.size as int,
                vm.heap-top,
                vm.heap-limit,
                vm.registers,
                vm.current-stack,
                vmtable.global-offsets.data,
                vmtable.globals.mem,
                vmtable.consts.mem,
                vmtable.consts-data.mem,
                vmtable.data-positions.data,
                vmtable.data.mem,
                vmtable.extern-addresses.data,
                vmtable.function-addresses.data,
                extend-heap-id,
                addr(new-heap-top),
                addr(new-current-stack))
  vm.heap-top = new-heap-top
  vm.current-stack = new-current-stack
  val stk:ptr<Stack> = untag(vm.current-stack)
  vm.stack-pointer = stk.stack-pointer

  ;Clear globals
  VIRTUAL-MACHINE = false

  ;Done
  return false

;public lostanza defn continue-bytecode (start-func:ref<Int>) -> ref<False> :
;  ...

;============================================================
;============================================================
;============================================================

var TRACE?:True|False = false

public lostanza defn run (vm:ref<VirtualMachine>, start-func:ref<Int>, trace?:ref<True|False>) -> ref<False> :
  TRACE? = trace?
  ;Define machine quantities
  val vmtable = vm.vmtable
  val instructions = vmtable.instructions
  val regs = vm.registers
  var heap-limit:ptr<long> = vm.heap-limit          ;[LOAD]
  var heap-top:ptr<long>                            ;[STORE/LOAD]
  var stack-pointer:ptr<StackFrame>                 ;[STORE/LOAD]
  var stack-end:ptr<StackFrame>                     ;[LOAD]
  var current-stack:long                            ;[STORE/LOAD]

  ;Speed characteristics
  var num-gc:long = 0
  var num-alloc:long = 0
  var num-ins:long = 0
  var num-reg-set:long = 0

  start-timer(TOTAL)
  labels :
    begin :
      ;Retrieve pc of starting function
      val mainpc = get(vmtable.function-addresses, start-func).value

      ;Initialize starting stack
      if vm.current-stack == void-marker() :
        vm.current-stack = alloc-stack(vm, mainpc)
      else :
        val stk:ptr<Stack> = untag(vm.current-stack)
        stk.pc = mainpc

      ;Set heap-top
      heap-top = vm.heap-top
      goto load-stack(vm.current-stack)
    load-stack (stack:long) :
      current-stack = stack
      val sptr:ptr<Stack> = untag(current-stack)
      stack-pointer = sptr.stack-pointer
      stack-end = /stack-end(current-stack)
      goto step(sptr.pc)
    call-function (fid:int, return:int) :
      start-timer(FN-SECTION)
      stack-pointer.return = return
      val pos = get(vmtable.function-addresses, new Int{fid}).value
      stop-timer(FN-SECTION)
      goto step(pos)
    tcall-function (fid:int) :
      start-timer(FN-SECTION)
      val pos = get(vmtable.function-addresses, new Int{fid}).value
      stop-timer(FN-SECTION)
      goto step(pos)
    step (pc:int) :
      ;Retrieve instruction
      val ins = get(instructions, new Int{pc})

      ;Speed counter
      num-ins = num-ins + 1
      match(ins) :
        (ins:ref<SetReg|GetReg>) : num-reg-set = num-reg-set + 1
        (ins:ref<LinkedAllocIns>) : num-alloc = num-alloc + 1
        (ins:ref<LinkedVMCall>) :
          match(op(ins)) :
            (op:ref<GCOp>) : num-gc = num-gc + 1
            (op) : ()
        (ins) : ()

      ;Trace
      if trace? == true :
        call-c clib/printf(" In frame %p: ", stack-pointer)
        print-ins(new Int{pc}, ins)

      match(ins) :
        (ins:ref<NewStackIns>) :
          start-timer(NEW-STACK)
          val fid = eval-imm(fid(ins), stack-pointer, vmtable) as int
          val fpc = get(vmtable.function-addresses, new Int{fid}).value
          vm.heap-top = heap-top
          val stk = alloc-stack(vm, fpc)
          heap-top = vm.heap-top
          assign(stack-pointer, x(ins), stk)
          stop-timer(NEW-STACK)
          goto step(pc + 1)
        (ins:ref<SetIns>) :
          start-timer(SET)
          assign(stack-pointer, x(ins), eval-imm(y(ins), stack-pointer, vmtable))
          stop-timer(SET)
          goto step(pc + 1)
        (ins:ref<Op0Ins>) :
          start-timer(OP0)
          assign(stack-pointer, x(ins), eval-op(op(ins), current-stack, stack-pointer, vmtable))
          stop-timer(OP0)
          goto step(pc + 1)
        (ins:ref<LinkedVMCall>) :
          match(op(ins)) :
            (op:ref<GCOp>) :
              start-timer(VMCALL)
              ;Evaluate size
              val total-size = eval-imm(y(ins), stack-pointer, vmtable)
              ;Store required values
              vm.heap-top = heap-top
              vm.stack-pointer = stack-pointer
              vm.current-stack = current-stack
              ;Run garbage collector
              extend-heap(vm, total-size)
              ;Load required values
              heap-limit = vm.heap-limit
              heap-top = vm.heap-top
              stack-pointer = vm.stack-pointer
              current-stack = vm.current-stack
              stack-end = /stack-end(current-stack)
              ;Return 0
              regs[0] = 0L
              stop-timer(VMCALL)
              goto step(pc + 1)
            (op) :
              fatal("Unreachable")
        (ins:ref<LinkedOp1Ins>) :
          start-timer(OP1)
          val y = eval-imm(y(ins), stack-pointer, vmtable)
          assign(stack-pointer, x(ins), eval-op(type(ins), op(ins), y, vmtable, live-map-table(vm.linker)))
          stop-timer(OP1)
          goto step(pc + 1)
        (ins:ref<LinkedOp2Ins>) :
          start-timer(OP2)
          val y = eval-imm(y(ins), stack-pointer, vmtable)
          val z = eval-imm(z(ins), stack-pointer, vmtable)
          assign(stack-pointer, x(ins), eval-op(type(ins), op(ins), y, z))
          stop-timer(OP2)
          goto step(pc + 1)
        (ins:ref<LinkedConvIns>) :
          start-timer(CONV)
          val y = eval-imm(y(ins), stack-pointer, vmtable)
          val result = eval-conv(op(ins), xtype(ins), ytype(ins), y)
          assign(stack-pointer, x(ins), result)
          stop-timer(CONV)
          goto step(pc + 1)
        (ins:ref<LinkedReserveIns>) :
          start-timer(RESERVE)
          ;Compute size to allocate
          val size = eval-imm(space(ins), stack-pointer, vmtable)
          if size & 0x7L : fatal("Size is not a multiple of 8.")
          val total-size = size + 8 * num-obj(ins).value

          ;If there is enough space
          if heap-top + total-size <= heap-limit :
            stop-timer(RESERVE)
            goto step(pc + n(ins).value)
          else :
            ;Set arguments
            regs[0] = false-marker()  ;Closure is false
            regs[1] = 1L              ;arity = 1
            regs[2] = total-size      ;size argument
            val fid = get(vm.loaded-ids, CORE-EXTEND-HEAP-ID).value
            stack-pointer = stack-pointer + frame-size(ins).value
            stop-timer(RESERVE)
            goto call-function(fid, pc + 1)
        (ins:ref<LinkedAllocIns>) :
          start-timer(ALLOC)
          val size = eval-imm(size(ins), stack-pointer, vmtable)
          if size < 8 : fatal("Invalid size for object.")
          val total-size = size + 8
          [heap-top] = type(ins).value
          val obj = tag(heap-top)
          if trace? == true : print-tag(obj)
          assign(stack-pointer, x(ins), obj)
          heap-top = heap-top + total-size
          if heap-top > heap-limit : fatal("Beyond heap limits.")
          stop-timer(ALLOC)
          goto step(pc + 1)
        (ins:ref<LinkedRefStoreIns>) :
          start-timer(REFSTORE)
          val x = eval-imm(x(ins), stack-pointer, vmtable)
          val y = eval-imm(y(ins), stack-pointer, vmtable)
          val z = eval-imm(z(ins), stack-pointer, vmtable)
          val o = offset(ins).value
          val sz = size(ins).value

          ;Sanity checks
          ;- x is a heap-allocated reference.
          ;- x has the expected tag.
          ;- the store value has size 8, if a store to the length
          ;  field of an array.
          ;- the store offset is within bounds of the object (if not a
          ;   store to the length field of an array.)
          ;- the store offset is aligned with the size.
          val xtype = load-tag(x)
          if class(ins) != false :
            if xtype != class(ins) :
              fatal("Object has unexpected tag.")
          val class = get(vm.vmtable.class-table, xtype)
          if y + o < 0 : fatal("Load from negative index.")
          if (y + o) & (sz - 1) : fatal("Unaligned load.")
          match(class) :
            (class:ref<VMArrayClass>) :
              if y + o == 0 :
                if sz != 8 : fatal("Inappropriate length field.")
              else :
                val xsize = object-size(x, class)
                if y + o + sz > xsize : fatal("Load out of bounds.")
            (class:ref<VMLeafClass>) :
              val xsize = object-size(x, class)
              if y + o + sz > xsize : fatal("Load out of bounds.")

          ;Execution
          val xptr = untag(x)
          if sz == 1 : [xptr as ptr<byte> + y + o] = z as byte
          else if sz == 4 : [xptr as ptr<int> + y + o] = z as int
          else if sz == 8 : [xptr as ptr<long> + y + o] = z as long
          else : fatal("Invalid size.")
          stop-timer(REFSTORE)
          goto step(pc + 1)
        (ins:ref<LinkedRefLoadIns>) :
          start-timer(REFLOAD)
          val y = eval-imm(y(ins), stack-pointer, vmtable)
          val z = eval-imm(z(ins), stack-pointer, vmtable)
          val o = offset(ins).value
          val sz = size(ins).value

          ;Sanity checks
          ;- y is a heap-allocated reference.
          ;- y has the expected tag.
          ;- the load offset is within bounds of the object.
          ;- the load offset is aligned with the size.
          val ytype = load-tag(y)
          if class(ins) != false :
            if ytype != class(ins) :
              fatal("Object has unexpected tag.")
          val ysize = object-size(y, get(vm.vmtable.class-table, ytype))
          if z + o < 0 : fatal("Load from negative index.")
          if z + o + sz > ysize : fatal("Load out of bounds.")
          if (z + o) & (sz - 1) : fatal("Unaligned load.")

          ;Execution
          val yptr:ptr<long> = untag(y)
          var value:long
          if sz == 1 : value = [yptr as ptr<byte> + z + o]
          else if sz == 4 : value = [yptr as ptr<int> + z + o]
          else if sz == 8 : value = [yptr as ptr<long> + z + o]
          else : fatal("Invalid size.")
          assign(stack-pointer, x(ins), value)
          stop-timer(REFLOAD)
          goto step(pc + 1)
        (ins:ref<LinkedStoreIns>) :
          start-timer(STORE)
          val x = eval-imm(x(ins), stack-pointer, vmtable)
          val y = eval-imm(y(ins), stack-pointer, vmtable)
          val z = eval-imm(z(ins), stack-pointer, vmtable)
          val o = offset(ins).value
          val sz = size(ins).value

          ;Sanity checks
          ;- the store value has size 8, if a store to the length
          ;  field of an array.
          ;- the store offset is within bounds of the object (if not a
          ;   store to the length field of an array.)
          ;- the store offset is aligned with the size.
          if class(ins) != false :
            val xtype = class(ins) as ref<Int>
            val class = get(vm.vmtable.class-table, xtype)
            if y + o < 0 : fatal("Load from negative index.")
            if (y + o) & (sz - 1) : fatal("Unaligned load.")
            match(class) :
              (class:ref<VMArrayClass>) :
                if y + o == 0 :
                  if sz != 8 : fatal("Inappropriate length field.")
                else :
                  val xsize = object-size(x, class)
                  if y + o + sz > xsize : fatal("Load out of bounds.")
              (class:ref<VMLeafClass>) :
                val xsize = object-size(x, class)
                if y + o + sz > xsize : fatal("Load out of bounds.")


          ;Execution
          if sz == 1 : [x as ptr<byte> + y + o] = z as byte
          else if sz == 4 : [x as ptr<int> + y + o] = z as int
          else if sz == 8 : [x as ptr<long> + y + o] = z as long
          else : fatal("Invalid size.")
          stop-timer(STORE)
          goto step(pc + 1)
        (ins:ref<LinkedLoadIns>) :
          start-timer(LOAD)
          val y = eval-imm(y(ins), stack-pointer, vmtable)
          val z = eval-imm(z(ins), stack-pointer, vmtable)
          val o = offset(ins).value
          val sz = size(ins).value

          ;Sanity checks
          ;- the load offset is within bounds of the object.
          ;- the load offset is aligned with the size.
          if class(ins) != false :
            val ytype = class(ins) as ref<Int>
            val ysize = object-size(y, get(vm.vmtable.class-table, ytype))
            if z + o < 0 : fatal("Load from negative index.")
            if z + o + sz > ysize : fatal("Load out of bounds.")
            if (z + o) & (sz - 1) : fatal("Unaligned load.")

          ;Execution
          var value:long
          if sz == 1 : value = [y as ptr<byte> + z + o]
          else if sz == 4 : value = [y as ptr<int> + z + o]
          else if sz == 8 : value = [y as ptr<long> + z + o]
          else : fatal("Invalid size.")
          assign(stack-pointer, x(ins), value)
          stop-timer(LOAD)
          goto step(pc + 1)
        (ins:ref<GotoIns>) :
          start-timer(GOTO)
          stop-timer(GOTO)
          goto step(pc + n(ins).value)
        (ins:ref<Branch1Ins>) :
          start-timer(BRANCH1)
          val x = eval-imm(x(ins), stack-pointer, vmtable)
          match(op(ins)) :
            (op:ref<VMOp>) :
              val r = eval-op(VMLong(), op, x, vmtable, live-map-table(vm.linker))
              stop-timer(BRANCH1)
              if r : goto step(pc + n1(ins).value)
              else : goto step(pc + n2(ins).value)
            (op:ref<False>) :
              stop-timer(BRANCH1)
              if x : goto step(pc + n1(ins).value)
              else : goto step(pc + n2(ins).value)
        (ins:ref<LinkedBranch2Ins>) :
          start-timer(BRANCH2)
          val x = eval-imm(x(ins), stack-pointer, vmtable)
          val y = eval-imm(y(ins), stack-pointer, vmtable)
          val r = eval-op(type(ins), op(ins), x, y)
          stop-timer(BRANCH2)
          if r : goto step(pc + n1(ins).value)
          else : goto step(pc + n2(ins).value)
        (ins:ref<LinkedDispatchIns>) :
          start-timer(DISPATCH-EVAL)
          val ytypes = eval-types(ys(ins), stack-pointer, vmtable)
          stop-timer(DISPATCH-EVAL)
          start-timer(DISPATCH)
          val d = dispatch(vmtable.branch-table, format(ins), ytypes)
          stop-timer(DISPATCH)
          match(d) :
            (r:ref<Int>) : goto step(pc + get(ns(ins), r).value)
            (r:ref<CodeId>) : goto tcall-function(id(r).value)
            (r:ref<Default>) : goto step(pc + default(ins).value)
            (r:ref<Amb>) : goto step(pc + amb(ins).value)
        (ins:ref<SetReg>) :
          start-timer(SETREG)
          regs[reg(ins).value] = eval-imm(x(ins), stack-pointer, vmtable)
          stop-timer(SETREG)
          goto step(pc + 1)
        (ins:ref<GetReg>) :
          start-timer(GETREG)
          assign(stack-pointer, x(ins), regs[reg(ins).value])
          if trace? == true and ref?(ins) == true :
            print-tag(regs[reg(ins).value])
          stop-timer(GETREG)
          goto step(pc + 1)
        (ins:ref<PopFrameIns>) :
          start-timer(POPFRAME)
          stack-pointer = stack-pointer - frame-size(ins).value
          stop-timer(POPFRAME)
          goto step(pc + 1)
        (ins:ref<LinkedCall>) :
          start-timer(CALL)
          val fid = eval-imm(f(ins), stack-pointer, vmtable) as int
          stack-pointer = stack-pointer + frame-size(ins).value
          stop-timer(CALL)
          goto call-function(fid, pc + 1)
        (ins:ref<LinkedCallClosure>) :
          start-timer(CALLCLO)
          val fref = eval-imm(f(ins), stack-pointer, vmtable)

          ;Sanity check: Check that f is actually a function
          val ftype = load-tag(fref)
          if ftype != FN-TYPE and ftype != TYPE-TYPE :
            call-c clib/printf("ftype = %d, fref = %p\n", ftype, fref)
            fatal("Attempt to call non-closure.")

          val fptr = untag(fref) as ptr<Function>
          val fid = fptr.code as int
          stack-pointer = stack-pointer + frame-size(ins).value
          stop-timer(CALLCLO)
          goto call-function(fid, pc + 1)
        (ins:ref<LinkedTCall>) :
          start-timer(TCALL)
          val fid = eval-imm(f(ins), stack-pointer, vmtable) as int
          stop-timer(TCALL)
          goto tcall-function(fid)
        (ins:ref<LinkedTCallClosure>) :
          start-timer(TCALLCLO)
          val fref = eval-imm(f(ins), stack-pointer, vmtable)

          ;Sanity check: Check that f is actually a function
          val ftype = load-tag(fref)
          if ftype != FN-TYPE and ftype != TYPE-TYPE :
            call-c clib/printf("ftype = %d, fref = %p\n", ftype, fref)
            fatal("Attempt to call non-closure.")

          ;Execution
          val fptr = untag(fref) as ptr<Function>
          val fid = fptr.code as int
          stop-timer(TCALLCLO)
          goto tcall-function(fid)
        (ins:ref<LinkedCallC>) :
          start-timer(CALLC)
          val faddr = eval-imm(f(ins), stack-pointer, vmtable)
          val launcher = launcher(ins).value as ptr<((long, ptr<long>) -> long)>
          stack-pointer = stack-pointer + frame-size(ins).value
          [launcher](faddr, regs)
          stack-pointer = stack-pointer - frame-size(ins).value
          stop-timer(CALLC)
          goto step(pc + 1)
        (ins:ref<LinkedYield>) :
          start-timer(YIELD)
          ;Save current stack
          val s:ptr<Stack> = untag(current-stack)
          s.stack-pointer = stack-pointer
          s.pc = pc + 1
          ;Load next next
          val sref = eval-imm(f(ins), stack-pointer, vmtable)
          ;Sanity check: Check that sref is a stack
          val stype = load-tag(sref)
          if stype != STACK-TYPE : fatal("Attempt to yield to non-stack.")
          stop-timer(YIELD)
          goto load-stack(sref)
        (ins:ref<LinkedReturn>) :
          start-timer(RETURN)
          val ret = stack-pointer.return as int
          stop-timer(RETURN)
          if ret >= 0 : goto step(ret)
        (ins:ref<FunctionEntry>) :
          start-timer(FNENTRY)
          val frame-size = (num-locals(ins).value * 8 + sizeof(StackFrame)) as int
          val size-required = frame-size + sizeof(StackFrame)
          if stack-pointer + size-required > stack-end :
            ;Store required values
            vm.heap-top = heap-top
            vm.stack-pointer = stack-pointer
            vm.current-stack = current-stack
            ;Run garbage collector
            extend-stack(vm, size-required)
            ;Load required values
            heap-limit = vm.heap-limit
            heap-top = vm.heap-top
            stack-pointer = vm.stack-pointer
            current-stack = vm.current-stack
            stack-end = /stack-end(current-stack)
          if trace? == true : call-c clib/printf("Entered with stack pointer = %p\n", stack-pointer)
          stop-timer(FNENTRY)
          goto step(pc + 1)
        (ins:ref<LinkedDump>) :
          start-timer(DUMP)
          val xvalue = eval-imm(x(ins), stack-pointer, vmtable)
          val xint = xvalue as int
          val xvaluef = ($ls-prim fnum xint)
          val xvalued = ($ls-prim fnum xvalue)
          call-c clib/printf("> L%d = %ld (float = %f, double = %f)\n",
                             index(x(ins)).value, xvalue, xvaluef, xvalued)
          if trace? == true and ref?(ins) == true : print-tag(xvalue)
          stop-timer(DUMP)
          goto step(pc + 1)
        (ins:ref<LinkedLiveIns>) :
          start-timer(LIVE)
          stack-pointer.liveness-map = map(ins).value
          if trace? == true : call-c clib/printf("Saved map to frame %p\n", stack-pointer)
          stop-timer(LIVE)
          goto step(pc + 1)
        (ins:ref<LinkedBranchRegIns>) :
          start-timer(BRANCHREG)
          val rvalue = regs[reg(ins).value] as int
          if rvalue == value(ins).value :
            stop-timer(BRANCHREG)
            goto step(pc + n(ins).value)
          else :
            stop-timer(BRANCHREG)
            goto step(pc + 1)
        (ins:ref<CommentIns>) :
          start-timer(COMMENT)
          stop-timer(COMMENT)
          goto step(pc + 1)

  val stk:ptr<Stack> = untag(current-stack)
  vm.heap-top = heap-top
  vm.current-stack = current-stack
  vm.stack-pointer = stack-pointer
  stk.stack-pointer = stack-pointer


  ;Speed characteristics [DEBUG]
  stop-timer(TOTAL)
  print-timers()
  ;call-c clib/printf("[===== Speed Counters =====]\n")
  ;call-c clib/printf("Number of Instructions Executed = %ld\n", num-ins)
  ;call-c clib/printf("Number of Register Instructions Executed = %ld\n", num-reg-set)
  ;call-c clib/printf("Number of Allocations = %ld\n", num-alloc)
  ;call-c clib/printf("Number of GC = %ld\n", num-gc)

  return false

;============================================================
;==================== Dispatch ==============================
;============================================================

lostanza defn branch-table (vm:ref<VirtualMachine>) -> ref<BranchTable> :
  return vm.vmtable.branch-table

;============================================================
;===================== Stack Traces =========================
;============================================================

lostanza defn print-stack-trace (stack:ptr<Stack>, vmtable:ref<VMTable>, livemap:ref<LiveMapTable>) -> ref<False> :
  val buffer = Vector<FileInfo>()

  ;Discover return addresses
  val end-sp = stack.stack-pointer
  labels :
    begin : goto loop(stack.frames)
    loop (sp:ptr<StackFrame>) :
      ;Store in return buffer
      ;if it exists in the file info table
      val ret = new Int{(sp.return / 4L) as int}
      match(get?(vmtable.fileinfos, ret)) :
        (info:ref<FileInfo>) : add(buffer, info)
        (info) : ()

      ;Continue if we're not at the end of the stack
      if sp < end-sp :
        val map-index = sp.liveness-map as int
        val stackmap = get(livemap, new Int{map-index})
        val num-slots = num-slots(stackmap).value
        val next-frame = addr(sp.slots[num-slots]) as ptr<StackFrame>
        goto loop(next-frame)

  ;Print out the buffer
  print-stack-buffer(buffer)

  ;Return false
  return false

defn print-stack-buffer (buffer:Vector<FileInfo>) :
  for e in in-reverse(buffer) do :
    println(STANDARD-ERROR-STREAM, "  at %_" % [e])

;============================================================
;==================== Heap/Stack Extension ==================
;============================================================

extern memcpy : (ptr<?>, ptr<?>, long) -> int
lostanza defn extend-stack (vm:ref<VirtualMachine>, size:long) -> long :
  ;Retrieve current stack
  val s:ptr<Stack> = untag(vm.current-stack)
  ;Compute new size of stack
  val desired-size = vm.stack-pointer + size - s.frames
  var size*:long = s.size
  while size* < desired-size : size* = size* * 2
  ;Allocate new frames, and copy over old frames
  val frames* = call-c clib/malloc(size*)
  call-c memcpy(frames*, s.frames, s.size)
  ;Free old frames and swap in new frames
  val sp-pos = vm.stack-pointer - s.frames
  call-c clib/free(s.frames)
  s.size = size*
  s.frames = frames*
  s.stack-pointer = s.frames + sp-pos
  vm.stack-pointer = s.stack-pointer
  ;Return
  return 0

lostanza defn extend-heap (vm:ref<VirtualMachine>, size:long) -> long :
  ;First run the garbage collector,
  collect-garbage(vm)

  ;then check whether we're still out of space.
  if vm.heap-top + size > vm.heap-limit :
    ;Compute desired heap size
    val desired-space = vm.heap-top + size - vm.heap
    var space:long = vm.heap-limit - vm.heap
    while space < desired-space : space = space * 2
    ;Resize the heap and use the GC to move contents over
    resize-freespace(vm, space)
    collect-garbage(vm)
    resize-freespace(vm, space)
    ;Now we have enough space.
    return 0

  ;at this point, we don't need to expand the heap,
  ;but we might want to for next time.
  else :
    ;Expand the freeheap if we're using more than 50% of it,
    ;or if the heapspace is bigger than the freespace.
    val used-space = vm.heap-top - vm.heap
    val heap-space = vm.heap-limit - vm.heap
    val free-space = vm.free-limit - vm.free
    val usage-ratio = (used-space as float) / (heap-space as float)
    ;Resize free if the usage-ratio is too high
    if usage-ratio > 0.5f :
      resize-freespace(vm, heap-space * 2)
    ;Otherwise resize free if the heap is larger than free
    else if heap-space > free-space :
      resize-freespace(vm, heap-space)
    ;We have enough space to satisfy the request
    return 0

lostanza defn ensure-heap-space (vm:ref<VirtualMachine>, size:long, num-objs:long) -> int :
  val total-size = size + num-objs * 8
  if vm.heap-top + total-size > vm.heap-limit :
    extend-heap(vm, total-size)
  return 0

lostanza defn resize-freespace (vm:ref<VirtualMachine>, space:long) -> int :
  call-c clib/free(vm.free)
  vm.free = call-c clib/malloc(space)
  vm.free-limit = vm.free + space
  return 0

;============================================================
;==================== Garbage Collector =====================
;============================================================

lostanza defn collect-garbage (vm:ref<VirtualMachine>) -> long :
  ;Cap the current stack
  val s:ptr<Stack> = untag(vm.current-stack)
  s.stack-pointer = vm.stack-pointer

  ;Swap free with heap
  val heap = vm.heap
  val heap-limit = vm.heap-limit
  val free = vm.free
  val free-limit = vm.free-limit
  vm.heap = free
  vm.heap-top = free
  vm.heap-limit = free-limit
  vm.free = heap
  vm.free-limit = heap-limit

  ;Scan global roots
  val globals:ptr<long> = vm.vmtable.globals.mem
  val roots = to-seq(roots(vm.vmtable.global-table))
  while empty?(roots) == false :
    val i = next(roots).value
    globals[i] = post-gc-object(globals[i], vm)

  ;Scan const roots
  val nconsts = vm.vmtable.consts.size / 8
  val consts:ptr<long> = vm.vmtable.consts.mem
  for (var i:int = 0, i < nconsts, i = i + 1) :
    consts[i] = post-gc-object(consts[i], vm)

  ;Scan stack roots
  vm.current-stack = post-gc-object(vm.current-stack, vm)

  ;Scan heap
  scan-heap(vm)

  ;Return
  return 0

lostanza defn num-slots (f:ptr<StackFrame>, vm:ref<VirtualMachine>) -> int :
  val map = get(live-map-table(vm.linker), new Int{f.liveness-map as int})
  return num-slots(map).value

lostanza defn scan-frames (frames:ptr<StackFrame>, f-end:ptr<StackFrame>, vm:ref<VirtualMachine>) -> int :
  var f:ptr<StackFrame> = frames
  while f <= f-end :
    val map = get(live-map-table(vm.linker), new Int{f.liveness-map as int})
    val live-slots = live-slots(map)
    val num-live = length(live-slots).value
    for (var i:int = 0, i < num-live, i = i + 1) :
      val s = get(live-slots, new Int{i}).value
      f.slots[s] = post-gc-object(f.slots[s], vm)
    f = addr(f.slots[num-slots(map).value]) as ptr<StackFrame>
  return 0

lostanza defn scan-heap (vm:ref<VirtualMachine>) -> int :
  var p:ptr<long> = vm.heap
  val class-table = vm.vmtable.class-table
  while p < vm.heap-top :
    p = scan-object(p, vm, class-table)
  return 0

lostanza defn scan-object (p:ptr<long>, vm:ref<VirtualMachine>, class-table:ref<ClassTable>) -> ptr<long> :
  ;p is [tag, cells ...]
  val tag = [p] as int
  val class = get(class-table, new Int{tag})
  match(class) :
    (class:ref<VMLeafClass>) :
      ;Scan the frames of a stack
      if tag == STACK-TYPE.value :
        val s = (p + 8) as ptr<Stack>
        scan-frames(s.frames, s.stack-pointer, vm)
      ;Get properties
      val size = size(class).value
      val roots = roots(class)
      val num-roots = length(roots).value
      ;Scan slots
      val obj = p as ptr<ObjectLayout>
      for (var i:int = 0, i < num-roots, i = i + 1) :
        val r = get(roots, new Int{i}).value
        obj.slots[r] = post-gc-object(obj.slots[r], vm)
      ;Return end of object
      return p + 8 + size
    (class:ref<VMArrayClass>) :
      ;Get properties
      val base-roots = base-roots(class)
      val item-roots = item-roots(class)
      val base-size = base-size(class).value
      val item-size = item-size(class).value
      val num-base-roots = length(base-roots).value
      val num-item-roots = length(item-roots).value
      ;Scan base roots
      val array = p as ptr<ObjectLayout>
      val len = array.slots[0]
      for (var i:int = 0, i < num-base-roots, i = i + 1) :
        val r = get(base-roots, new Int{i}).value
        array.slots[r] = post-gc-object(array.slots[r], vm)
      ;Scan item roots
      var items:ptr<long> = addr(array.slots) + base-size
      if num-item-roots > 0 :
        for (var n:long = 0, n < len, n = n + 1) :
          for (var i:int = 0, i < num-item-roots, i = i + 1) :
            val r = get(item-roots, new Int{i}).value
            items[r] = post-gc-object(items[r], vm)
          items = items + item-size
      ;Return end of array
      val size = (8 + base-size + item-size * len + 7L) & -8L
      return p + size

lostanza defn post-gc-object (ref:long, vm:ref<VirtualMachine>) -> long :
  val tagbits = ref & 7L
  if tagbits == REF-TAG-BITS :
    val obj = (ref - REF-TAG-BITS) as ptr<long>
    val obj-tag = [obj]
    ;Case: Broken Heart
    if obj-tag == -1L :
      val heart = obj as ptr<BrokenHeartLayout>
      return heart.forward
    ;Case: Uncopied object
    else :
      val obj* = tag(vm.heap-top)
      val class = get(vm.vmtable.class-table, new Int{obj-tag as int})
      copy-bytes-to-heap(obj, num-bytes(obj, class, vm), vm)
      set-broken-heart(obj, obj*)
      return obj*
  else :
    return ref

lostanza defn set-broken-heart (obj:ptr<long>, obj*:long) -> int :
  val heart = obj as ptr<BrokenHeartLayout>
  heart.tag = -1L
  heart.forward = obj*
  return 0

lostanza defn num-bytes (obj:ptr<?>, class:ref<VMClass>, vm:ref<VirtualMachine>) -> long :
  match(class) :
    (class:ref<VMLeafClass>) :
      return 8 + size(class).value
    (class:ref<VMArrayClass>) :
      val array = obj as ptr<ObjectLayout>
      val len = array.slots[0]
      val base-size = base-size(class).value
      val item-size = item-size(class).value
      return (8 + base-size + len * item-size + 7) & -8L

lostanza defn copy-bytes-to-heap (p:ptr<?>, n:long, vm:ref<VirtualMachine>) -> int :
  val heap = vm.heap-top
  val nwords = n >>> 3
  val src = p as ptr<long>
  for (var i:long = 0, i < nwords, i = i + 1) :
    heap[i] = src[i]
  vm.heap-top = heap + n
  return 0

;============================================================
;==================== Liveness Detector =====================
;============================================================

lostanza var LIVENESS-BUFFER:ptr<BrokenHeartLayout>
lostanza var LIVENESS-BUFFER-TOP:ptr<BrokenHeartLayout>

lostanza defn mark-in-liveness-buffer (obj:ptr<ObjectLayout>) -> int :
  if obj.tag == -1L : fatal("Already marked!")
  LIVENESS-BUFFER-TOP.tag = obj.tag
  LIVENESS-BUFFER-TOP.forward = obj as long
  LIVENESS-BUFFER-TOP = LIVENESS-BUFFER-TOP + sizeof(BrokenHeartLayout)
  obj.tag = -1L
  return 0

lostanza defn mark-ref (ref:long) -> int :
  val tagbits = ref & 7L
  if tagbits == REF-TAG-BITS :
    val obj = (ref - REF-TAG-BITS) as ptr<ObjectLayout>
    ;If object is not already marked
    if obj.tag != -1L :
      mark-in-liveness-buffer(obj)
  return 0

lostanza defn mark-frames (frames:ptr<StackFrame>, f-end:ptr<StackFrame>, vm:ref<VirtualMachine>) -> int :
  var f:ptr<StackFrame> = frames
  while f <= f-end :
    val map = get(live-map-table(vm.linker), new Int{f.liveness-map as int})
    val live-slots = live-slots(map)
    val num-live = length(live-slots).value
    for (var i:int = 0, i < num-live, i = i + 1) :
      val s = get(live-slots, new Int{i}).value
      mark-ref(f.slots[s])
    f = addr(f.slots[num-slots(map).value]) as ptr<StackFrame>
  return 0

lostanza defn mark-object (p:ptr<long>, tag:int, vm:ref<VirtualMachine>, class-table:ref<ClassTable>) -> int :
  ;p is [tag, cells ...]
  val class = get(class-table, new Int{tag})
  match(class) :
    (class:ref<VMLeafClass>) :
      ;Mark the frames of a stack
      if tag == STACK-TYPE.value :
        val s = (p + 8) as ptr<Stack>
        mark-frames(s.frames, s.stack-pointer, vm)
      ;Get properties
      val size = size(class).value
      val roots = roots(class)
      val num-roots = length(roots).value
      ;Mark slots
      val obj = p as ptr<ObjectLayout>
      for (var i:int = 0, i < num-roots, i = i + 1) :
        val r = get(roots, new Int{i}).value
        mark-ref(obj.slots[r])
    (class:ref<VMArrayClass>) :
      ;Get properties
      val base-roots = base-roots(class)
      val item-roots = item-roots(class)
      val base-size = base-size(class).value
      val item-size = item-size(class).value
      val num-base-roots = length(base-roots).value
      val num-item-roots = length(item-roots).value
      ;Mark base roots
      val array = p as ptr<ObjectLayout>
      val len = array.slots[0]
      for (var i:int = 0, i < num-base-roots, i = i + 1) :
        val r = get(base-roots, new Int{i}).value
        mark-ref(array.slots[r])
      ;Mark item roots
      var items:ptr<long> = addr(array.slots) + base-size
      if num-item-roots > 0 :
        for (var n:long = 0, n < len, n = n + 1) :
          for (var i:int = 0, i < num-item-roots, i = i + 1) :
            val r = get(item-roots, new Int{i}).value
            mark-ref(items[r])
          items = items + item-size
  return 0

lostanza defn mark-liveness-buffer (vm:ref<VirtualMachine>) -> int :
  val class-table = vm.vmtable.class-table
  var buffer:ptr<BrokenHeartLayout> = LIVENESS-BUFFER
  while buffer < LIVENESS-BUFFER-TOP :
    mark-object(buffer.forward as ptr<long>, buffer.tag as int, vm, class-table)
    buffer = buffer + sizeof(BrokenHeartLayout)
  return 0

lostanza defn restore-tag (heart:ptr<BrokenHeartLayout>) -> int :
  val obj = heart.forward as ptr<ObjectLayout>
  obj.tag = heart.tag
  return 0

public lostanza defn compute-live (vm:ref<VirtualMachine>, exclude:ref<Seqable<Symbol>>) -> ref<Tuple<Rec>> :
  ;Use free memory for liveness buffer
  ;(Guaranteed to be large enough)
  LIVENESS-BUFFER = vm.free as ptr<BrokenHeartLayout>
  LIVENESS-BUFFER-TOP = vm.free as ptr<BrokenHeartLayout>

  ;Scan global roots
  val globals:ptr<long> = vm.vmtable.globals.mem
  val roots = to-seq(roots(vm.vmtable.global-table, exclude))
  while empty?(roots) == false :
    val i = next(roots).value
    mark-ref(globals[i])

  ;Scan const roots
  val nconsts = vm.vmtable.consts.size / 8
  val consts:ptr<long> = vm.vmtable.consts.mem
  for (var i:int = 0, i < nconsts, i = i + 1) :
    mark-ref(consts[i])

  ;Scan stack roots
  mark-ref(vm.current-stack)

  ;Scan liveness buffer
  mark-liveness-buffer(vm)

  ;Get live set
  val live-recs = RecSet()
  for (var heart:ptr<BrokenHeartLayout> = LIVENESS-BUFFER,
       heart < LIVENESS-BUFFER-TOP,
       heart = heart + sizeof(BrokenHeartLayout)) :
    val tag = heart.tag as int
    if tag == FN-TYPE.value :
      val f = (heart.forward + 8L) as ptr<Function>
      val code = new Int{f.code as int}
      add-all(live-recs, function-dependencies(vm.loaded-ids, code))
    else :
      val tag = new Int{tag}
      add-all(live-recs, class-dependencies(vm.loaded-ids, tag))
    restore-tag(heart)

  ;Return ids
  return to-tuple(live-recs)

defn RecSet () :
  HashSet<Rec>(hash{id(_)}, {id(_) == id(_)})

;============================================================
;===================== Debugging ============================
;============================================================

lostanza defn dump-heap (vm:ref<VirtualMachine>) -> int :
  return dump-heap(vm.heap, vm.heap-top, vm)

lostanza defn dump-heap (pstart:ptr<long>, pend:ptr<long>, vm:ref<VirtualMachine>) -> int :
  val stackrefs = Vector<Long>()
  call-c clib/printf("Heap:\n")
  var p:ptr<long> = pstart
  while p < pend :
    val tag = [p] as int
    if tag == STACK-TYPE.value :
      add(stackrefs, new Long{/tag(p)})
    val class = get(vm.vmtable.class-table, new Int{tag})
    match(class) :
      (class:ref<VMLeafClass>) :
        val obj = p as ptr<ObjectLayout>
        val size = size(class).value
        call-c clib/printf("  %p: [Object %d, size = %d]", /tag(p), tag, size)
        for (var i:long = 0, i < size, i = i + 8) :
          call-c clib/printf("  %lx", [p + 8 + i])
        call-c clib/printf("\n")
        ;Advance to next object
        p = p + 8 + size
      (class:ref<VMArrayClass>) :
        val array = p as ptr<ObjectLayout>
        val len = array.slots[0]
        val base-size = base-size(class).value
        val item-size = item-size(class).value
        val size = base-size + item-size * len
        call-c clib/printf("  %p: [Array %d, length = %ld, base-size = %d, item-size = %d]",
                           /tag(p), tag, len, base-size, item-size)
        for (var i:long = 0, i < size, i = i + 8) :
          call-c clib/printf("  %lx", [p + 8 + i])
        call-c clib/printf("\n")
        ;Advance to next object
        p = p + (8 + size + 7) & -8L
  ;Dump stacks
  for (var i:int = 0, i < length(stackrefs).value, i = i + 1) :
    val s = get(stackrefs, new Int{i})
    dump-stack(s.value, vm)
  return 0

lostanza defn dump-stack (stackref:long, vm:ref<VirtualMachine>) -> int :
  val stk:ptr<Stack> = untag(stackref)
  var f:ptr<StackFrame> = stk.frames
  val f-end = stk.stack-pointer
  call-c clib/printf("Stack %p:\n", stackref)
  while f <= f-end :
    ;Get frame properties
    val map-index = new Int{f.liveness-map as int}
    if key?(live-map-table(vm.linker), map-index) == true :
      val map = get(live-map-table(vm.linker), map-index)
      val live-slots = live-slots(map)
      val num-slots = num-slots(map).value
      ;Print properties
      val num-live = length(live-slots).value
      var slot-i:int = 0
      call-c clib/printf("  %p: [StackFrame %ld, num-slots = %d]\n", f, f.liveness-map, num-slots)
      for (var i:int = 0, i < num-slots, i = i + 1) :
        if slot-i < num-live and live-slots.items[slot-i].value == i :
          call-c clib/printf("    %d: [%lx]\n", i, f.slots[i])
          slot-i = slot-i + 1
        else :
          call-c clib/printf("    %d: %lx\n", i, f.slots[i])
      ;Advance to next frame
      f = addr(f.slots[num-slots]) as ptr<StackFrame>
    else :
      call-c clib/printf("  %p: [BAD FRAME %x]\n", f, f.liveness-map)
      return 0
  return 0

lostanza defn print-tag (ref:long) -> int :
  call-c clib/printf("inspect tag of %p\n", ref)
  val tagbits = ref & 7L
  if tagbits == REF-TAG-BITS :
    val tag = [(ref - REF-TAG-BITS) as ptr<long>]
    if tag == FN-TYPE.value or tag == TYPE-TYPE.value :
      val f:ptr<Function> = untag(ref)
      call-c clib/printf("tagbits = %ld (REF), tag = %ld (FN/TYPE), code = %ld\n", tagbits, tag, f.code)
    else :
      call-c clib/printf("tagbits = %ld (REF), tag = %ld\n", tagbits, tag)
  else if tagbits == MARKER-TAG-BITS :
    val tag = ref >> 3L
    call-c clib/printf("tagbits = %ld (MARKER), tag = %ld\n", tagbits, tag)
  else if tagbits == INT-TAG-BITS :
    call-c clib/printf("tagbits = %ld (INT)\n", tagbits)
  else if tagbits == BYTE-TAG-BITS :
    call-c clib/printf("tagbits = %ld (BYTE)\n", tagbits)
  else if tagbits == CHAR-TAG-BITS :
    call-c clib/printf("tagbits = %ld (CHAR)\n", tagbits)
  else if tagbits == FLOAT-TAG-BITS :
    call-c clib/printf("tagbits = %ld (FLOAT)\n", tagbits)
  else :
    call-c clib/printf("Unrecognized tag bits.\n")
  return 0

defn dump-linked (vmt:VMTable) :
  val ins-buffer = instructions(vmt)
  val faddr = IntTable<Int>()
  for (addr in function-addresses(vmt), f in 0 to false) do :
    faddr[addr] = f
  for (ins in ins-buffer, i in 0 to false) do :
    match(get?(faddr, i)) :
      (f:Int) : println("F%_ :" % [f])
      (_:False) : false
    println("  (%_) %_" % [i, ins])

lostanza defn instructions (vmt:ref<VMTable>) -> ref<Vector<LinkedIns>> :
  return vmt.instructions
lostanza defn function-addresses (vmt:ref<VMTable>) -> ref<StableIntArray> :
  return vmt.function-addresses

;============================================================
;===================== Resolving ============================
;============================================================

defn resolve (pkgids:PackageIds, vmp:VMPackage) :
  defn resolve (n:Int) : pkgids[n]
  defn resolve (x:False) : false
  defn resolve<?T> (x:?T&(VMGlobal|VMData|VMClass|VMFunction|VMMethod|VMExtern)) :
    map-id(resolve,x) as T&(VMGlobal|VMData|VMClass|VMFunction|VMMethod|VMExtern)
  VMPackage(
    packageio(vmp)
    resolve(init(vmp))
    map(resolve,globals(vmp))
    map(resolve,datas(vmp))
    to-tuple(consts(pkgids))
    map(resolve,classes(vmp))
    map(resolve,funcs(vmp))
    map(resolve,methods(vmp))
    map(resolve,externs(vmp)))

;============================================================
;================= Instruction Encoding =====================
;============================================================

defn EncodingResolver (branch-table:BranchTable, live-map-table:LiveMapTable) :
  new EncodingResolver :
    defmethod callc-format (this, xtypes:Tuple<VMType|False>, ytypes:Tuple<VMType>) :
      index(FORMAT-TABLE, coalesce(CallFormat(xtypes, ytypes)))
    defmethod liveness-map (this, live:Tuple<Int>, num-locals:Int) :
      map-index(live-map-table, LivenessMap(live, num-locals))
    defmethod object-header-size (this) :
      8
    defmethod stack-size (this) :
      SIZEOF-STACK
    defmethod dispatch-format (this, branches:Tuple<Tuple<TypeSet>>) :
      add(branch-table, DispatchFormat(branches))
    defmethod match-format (this, branches:Tuple<Tuple<TypeSet>>) :
      add(branch-table, MatchFormat(branches))
    defmethod method-format (this, multi:Int, num-header-args:Int, num-args:Int) :
      add(branch-table, MultiFormat(multi, num-header-args, num-args))
    defmethod marker (this, type:Int) : marker-int(type)
    defmethod void-marker (this) : void-marker-int()
    defmethod ref-offset (this) : REF-TAG-INT

;============================================================
;====================== Loading =============================
;============================================================

public defn load (vm:VirtualMachine, vmps:Collection<VMPackage>,
                  keep-existing-globals?:True|False) :
  ;defn dump (vmp:VMPackage, suffix:String) :
  ;  val [_, local-name] = qualifier(package(vmp))
  ;  val filename = string-join $ [local-name, suffix]
  ;  spit(filename, vmp)

  val new-consts = Vector<VMConst>()
  val vmt = vmtable(vm)

  ;Make global ids
  make-package-ids(loaded-ids(vm), vmps)

  for vmp0 in vmps do :
    ;Get package ids
    val pkgids = package-ids(loaded-ids(vm), vmp0)

    ;Register dependencies
    for f in funcs(vmp0) do :
      set-function-dependencies(pkgids, id(f), dependencies(f))
    for c in filter-by<VMLeafClass|VMArrayClass>(classes(vmp0)) do :
      set-class-dependencies(pkgids, id(c), dependencies(c))

    ;Resolution
    ;dump(vmp0, ".vm")
    val vmp = resolve(pkgids, vmp0)
    ;dump(vmp, ".vm.resolved")

    ;Link functions
    for f in funcs(vmp) do :
      ;val linked = link(linker(vm), f, pkgids)
      ;load-function(vmt, id(f), linked)
      val ef = encode(f, pkgids, EncodingResolver(branch-table(vm), live-map-table(linker(vm))))
      load-function(vmt, id(f), ef)

    ;Stage constants to be loaded
    add-all(new-consts, consts(vmp))

    ;Load definitions
    load-globals(vmt, globals(vmp), package(vmp), keep-existing-globals?)
    load-classes(vmt, classes(vmp))
    load-datas(vmt, datas(vmp))
    load-externs(vmt, externs(vmp))
    load-methods(branch-table(vm), methods(vmp), package(vmp))

    ;Register initialization function
    set-init(vmt, package(vmp), init(vmp))

  ;TODO: Make update efficient
  update(branch-table(vm))

  ;Load constants
  load-consts(vmt, to-tuple(new-consts))

  ;Initialize constants
  if none?({package(_) == `core}, vmps) :
    val init-consts-id = loaded-ids(vm)[CORE-INIT-CONSTS-ID]
    run-bytecode(vm, init-consts-id)

  ;dump-linked(vmt)

public defn init-package (vm:VirtualMachine, package:Symbol) :
  val f = init(vmtable(vm), package)
  match(f:Int) :
    val trace? = false
    val use-launcher? = package != `core
    if use-launcher? : launch-init(vm, f, trace?)
    else : run-bytecode(vm, f)

lostanza defn launch-init (vm:ref<VirtualMachine>, fid:ref<Int>, trace?:ref<True|False>) -> ref<False> :
  ;Create the closure representing the initialization function
  val closure-size = 8 + 8
  ensure-heap-space(vm, closure-size, 1)
  val closure:ptr<Function> = alloc-heap(vm, FN-TYPE.value, closure-size)
  closure.num-slots = 0L
  closure.code = fid.value
  ;Call closure using the launcher function
  vm.registers[0] = false-marker()
  vm.registers[1] = 1L
  vm.registers[2] = tag(closure - 8L)
  val launcher-id = get(loaded-ids(vm), CORE-EXECUTE-TOPLEVEL-COMMAND-ID)
  run-bytecode(vm, launcher-id)
  ;Return
  return false

public lostanza defn clear-globals (vm:ref<VirtualMachine>) -> ref<False> :
  ;Scan global roots
  val globals:ptr<long> = vm.vmtable.globals.mem
  val roots = to-seq(roots(vm.vmtable.global-table))
  while empty?(roots) == false :
    val i = next(roots).value
    globals[i] = void-marker()
  return false

;============================================================
;==================== Utilities =============================
;============================================================
lostanza defn float-to-bits (x:float) -> int :
  return ($ls-prim bits x)

lostanza defn double-to-bits (x:double) -> long :
  return ($ls-prim bits x)

lostanza defn bits-to-float (x:int) -> float :
  return ($ls-prim fnum x)

lostanza defn bits-to-double (x:long) -> double :
  return ($ls-prim fnum x)

var delay : (() -> ?) -> False =
  fn (f) : fatal("Not within delay-actions block.")
defn delay-actions<?T> (f:() -> ?T) :
  val delays = Vector<(() -> ?)>()
  defn delay-action (action:() -> ?)  : add(delays, action)
  val result = let-var delay = delay-action : f()
  for d in delays do : d()
  clear(delays)
  result