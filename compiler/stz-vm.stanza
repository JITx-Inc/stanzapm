defpackage stz/vm :
  import core
  import collections
  import reader

;============================================================
;================== Design of Instructions ==================
;============================================================

public defstruct VMProg :
  classes: Tuple<VMClass>
  funcs: Tuple<VMFunc>

public deftype VMImm
public defstruct Local <: VMImm :
  index: Int
public defstruct IntConst <: VMImm :
  value: Int
public defstruct DoubleConst <: VMImm :
  value: Double
public defstruct CodeId <: VMImm :
  fid: Int

public deftype VMType
public defstruct VMInt <: VMType
public defstruct VMDouble <: VMType
public defstruct VMRef <: VMType
public defstruct VMPointer <: VMType

public defstruct VMFunc :
  id: Int
  defs: Tuple<VMDef>
  ins: Tuple<VMIns>

public defstruct VMDef :
  id: Int
  type: VMType
  local: Int

public deftype VMClass
public defmulti id (c:VMClass) -> Int
public defmulti parents (c:VMClass) -> Tuple<Int>

public defstruct VMArrayClass <: VMClass :
  id: Int with: (as-method => true)
  parents: Tuple<Int> with: (as-method => true)
  base-size: Int
  item-size: Int
public defstruct VMLeafClass <: VMClass :
  id: Int with: (as-method => true)
  parents: Tuple<Int> with: (as-method => true)
  size: Int
public defstruct VMAbstractClass <: VMClass :
  id: Int with: (as-method => true)
  parents: Tuple<Int> with: (as-method => true)

public deftype VMIns
public defstruct CallIns <: VMIns :
  xs: Tuple<Local|False>
  f: VMImm
  ys: Tuple<VMImm>
public defstruct CallClosureIns <: VMIns :
  xs: Tuple<Local|False>
  f: VMImm
  ys: Tuple<VMImm>
public defstruct YieldIns <: VMIns :
  xs: Tuple<Local|False>
  f: VMImm
  ys: Tuple<VMImm>
public defstruct NewStackIns <: VMIns :
  x: Local
  fid: VMImm
public defstruct SetIns <: VMIns :
  x: Local
  y: VMImm
public defstruct Op1Ins <: VMIns :
  x: Local
  op: VMOp
  y: VMImm
public defstruct Op2Ins <: VMIns :
  x: Local
  op: VMOp
  y: VMImm
  z: VMImm
public defstruct LabelIns <: VMIns :
  n: Int
public defstruct GotoIns <: VMIns :
  n: Int with: (updater => sub-n)
public defstruct Branch1Ins <: VMIns :
  n: Int with: (updater => sub-n)
  op: VMOp
  x: VMImm
public defstruct Branch2Ins <: VMIns :
  n: Int with: (updater => sub-n)
  op: VMOp
  x: VMImm
  y: VMImm
public defstruct ReserveIns <: VMIns :
  num-objects: Int
  size: VMImm
public defstruct AllocIns <: VMIns :
  x: Local
  type: Int
  size: VMImm
public defstruct RefSetIns <: VMIns :
  x: VMImm
  y: VMImm
  z: VMImm
public defstruct RefGetIns <: VMIns :
  x: Local
  y: VMImm
  z: VMImm
public defstruct AcceptIns <: VMIns :
  xs: Tuple<Local|False>
public defstruct ReturnIns <: VMIns :
  xs: Tuple<VMImm>

public deftype VMOp
public defstruct AddOp <: VMOp
public defstruct SubOp <: VMOp
public defstruct MulOp <: VMOp
public defstruct DivOp <: VMOp
public defstruct ModOp <: VMOp
public defstruct AndOp <: VMOp
public defstruct OrOp <: VMOp
public defstruct XorOp <: VMOp
public defstruct NotOp <: VMOp
public defstruct ShlOp <: VMOp
public defstruct ShrOp <: VMOp
public defstruct AshrOp <: VMOp
public defstruct EqOp <: VMOp
public defstruct NeOp <: VMOp
public defstruct LtOp <: VMOp
public defstruct GtOp <: VMOp
public defstruct LeOp <: VMOp
public defstruct GeOp <: VMOp
public defstruct UleOp <: VMOp
public defstruct UltOp <: VMOp
public defstruct UgtOp <: VMOp
public defstruct UgeOp <: VMOp
public defstruct NegOp <: VMOp
public defstruct InstanceofOp <: VMOp : (type:Int)

;============================================================
;==================== Printer ===============================
;============================================================

defmethod print (o:OutputStream, p:VMProg) :
  for (x in cat(classes(p), funcs(p)), i in 0 to false) do :
    if i == 0 : print(o, x)
    else : lnprint(o, x)

defmethod print (o:OutputStream, d:VMDef) :
  print(o, "def %_ : %_ (local %_)" % [id(d), type(d), local(d)])

defmethod print (o:OutputStream, f:VMFunc) :
  print(o, "func %_ :" % [id(f)])
  val o2 = IndentedStream(o)
  do(lnprint{o2, _}, defs(f))
  do(lnprint{o2, _}, ins(f))
  
defmethod print (o:OutputStream, c:VMAbstractClass) :
  print(o, "class %_ (%,)" % [id(c), parents(c)])

defmethod print (o:OutputStream, c:VMLeafClass) :
  print(o, "class %_ (%,) (size = %_)" % [id(c), parents(c), size(c)])

defmethod print (o:OutputStream, c:VMArrayClass) :
  print(o, "class %_ (%,) (base-size = %_, item-size = %_)" % [id(c), parents(c), base-size(c), item-size(c)])

defmethod print (o:OutputStream, x:VMImm) :
  print{o, _} $ match(x) :
    (x:Local) : "L%_" % [index(x)]
    (x:IntConst) : "%~" % [value(x)]
    (x:DoubleConst) : "%~" % [value(x)]
    (x:CodeId) : "F%_" % [fid(x)]
  
defmethod print (o:OutputStream, i:VMIns) :
  defn args (xs:Tuple<VMImm|False>) :
    val xs* = for x in xs seq :
      match(x:False) : "_"
      else : x
    "(%,)" % [xs*]
  print{o, _} $ match(i) :
    (i:CallIns) : "%_ = call %_ (%,)" % [args(xs(i)), f(i), ys(i)]
    (i:CallClosureIns): "%_ = call-closure %_ (%,)" % [args(xs(i)), f(i), ys(i)]
    (i:YieldIns) : "%_ = yield %_ (%,)" % [args(xs(i)), f(i), ys(i)]
    (i:NewStackIns) : "%_ = new-stack %_" % [x(i), fid(i)]
    (i:SetIns) : "%_ = %_" % [x(i), y(i)]
    (i:Op1Ins) : "%_ = %_ %_" % [x(i), op(i), y(i)]
    (i:Op2Ins) : "%_ = %_ %_ %_" % [x(i), op(i), y(i), z(i)]
    (i:LabelIns) : "label %_" % [n(i)]
    (i:GotoIns) : "goto %_" % [n(i)]
    (i:Branch1Ins) : "goto %_ when %_ %_" % [n(i), op(i), x(i)]
    (i:Branch2Ins) : "goto %_ when %_ %_ %_" % [n(i), op(i), x(i), y(i)]
    (i:ReserveIns) : "reserve %_ %_" % [num-objects(i), size(i)]
    (i:AllocIns) : "%_ = alloc<%_> %_" % [x(i), type(i), size(i)]
    (i:RefSetIns) : "%_[%_] = %_" % [x(i), y(i), z(i)]
    (i:RefGetIns) : "%_ = %_[%_]" % [x(i), y(i), z(i)]
    (i:AcceptIns) : "accept %_" % [args(xs(i))]
    (i:ReturnIns) : "return (%,)" % [xs(i)]

defmethod print (o:OutputStream, op:VMOp) :
  print{o, _} $ match(op) :
    (op:InstanceofOp) : "instanceof<%_>" % [type(op)]
    (op:AddOp) : "add"
    (op:SubOp) : "sub"
    (op:MulOp) : "mul"
    (op:DivOp) : "div"
    (op:ModOp) : "mod"
    (op:AndOp) : "and"
    (op:OrOp) : "or"
    (op:XorOp) : "xor"
    (op:NotOp) : "not"
    (op:ShlOp) : "shl"
    (op:ShrOp) : "shr"
    (op:AshrOp) : "ashr"
    (op:EqOp) : "eq"
    (op:NeOp) : "ne"
    (op:LtOp) : "lt"
    (op:GtOp) : "gt"
    (op:LeOp) : "le"
    (op:GeOp) : "ge"
    (op:UleOp) : "ule"
    (op:UltOp) : "ult"
    (op:UgtOp) : "ugt"
    (op:UgeOp) : "uge"
    (op:NegOp) : "neg"

defmethod print (o:OutputStream, t:VMType) :
  print{o, _} $ match(t) :
    (t:VMInt) : "int"
    (t:VMDouble) : "double"
    (t:VMRef) : "ref"
    (t:VMPointer) : "ptr"

defn lnprint (o:OutputStream, x) :
  print(o, '\n')
  print(o, x)

;============================================================
;======================= Reader =============================
;============================================================

defsyntax vmcode :
  defproduction op1 : VMOp
  defrule op1 = (instanceof<?t:#int!>) : InstanceofOp(t)
  defrule op1 = (not) : NotOp()
  defrule op1 = (neg) : NegOp()

  defproduction op2 : VMOp
  defrule op2 = (add) : AddOp()
  defrule op2 = (sub) : SubOp()
  defrule op2 = (mul) : MulOp()
  defrule op2 = (div) : DivOp()
  defrule op2 = (mod) : ModOp()
  defrule op2 = (and) : AndOp()
  defrule op2 = (or) : OrOp()
  defrule op2 = (xor) : XorOp()
  defrule op2 = (shl) : ShlOp()
  defrule op2 = (shr) : ShrOp()
  defrule op2 = (ashr) : AshrOp()
  defrule op2 = (eq) : EqOp()
  defrule op2 = (ne) : NeOp()
  defrule op2 = (lt) : LtOp()
  defrule op2 = (gt) : GtOp()
  defrule op2 = (le) : LeOp()
  defrule op2 = (ge) : GeOp()
  defrule op2 = (ule) : UleOp()
  defrule op2 = (ult) : UltOp()
  defrule op2 = (ugt) : UgtOp()
  defrule op2 = (uge) : UgeOp()

  defproduction type : VMType
  defrule type = (int) : VMInt()
  defrule type = (double) : VMDouble()
  defrule type = (ref) : VMRef()
  defrule type = (ptr) : VMPointer()

  defn char-prefix? (x, c:Char) :
    unwrap-token(x) is Symbol and to-string(x)[0] == c
  defn char-index! (info:FileInfo|False, x:Symbol|Token) :
    val i = to-int(to-string(x)[1 to false])
    match(i:Int) : i
    else : throw(VME(info, "Invalid name: %~" % [x]))
  defproduction local : Local
  defrule local = (?r) when char-prefix?(r, 'L') : Local(char-index!(closest-info(), r))

  defproduction imm : VMImm
  defrule imm = (?x) when unwrap-token(x) is Int : IntConst(unwrap-token(x))
  defrule imm = (?x) when unwrap-token(x) is Double : DoubleConst(unwrap-token(x))
  defrule imm = (?x) when char-prefix?(x, 'F') : CodeId(char-index!(closest-info(), x))
  defrule imm = (?x:#local) : x

  defproduction ins : VMIns
  defrule ins = (?xs:#args = call ?f:#imm! (?ys:#imm! ...)) : CallIns(xs, f, to-tuple(ys))
  defrule ins = (?xs:#args = call-closure ?f:#imm! (?ys:#imm! ...)) : CallClosureIns(xs, f, to-tuple(ys))
  defrule ins = (?xs:#args = yield ?f:#imm! (?ys:#imm! ...)) : YieldIns(xs, f, to-tuple(ys))
  defrule ins = (?x:#local = new-stack ?fid:#imm!) : NewStackIns(x, fid)
  defrule ins = (?x:#local = alloc<?t:#int!> ?size:#imm!) : AllocIns(x, t, size)
  defrule ins = (?x:#local = ?y:#imm[?z:#imm!]) : RefGetIns(x, y, z)
  defrule ins = (?x:#imm[?y:#imm] = ?z:#imm!) : RefSetIns(x, y, z)
  defrule ins = (?x:#local = ?o:#op1 ?y:#imm!) : Op1Ins(x, o, y)
  defrule ins = (?x:#local = ?o:#op2 ?y:#imm! ?z:#imm!) : Op2Ins(x, o, y, z)
  defrule ins = (?x:#local = ?y:#imm!) : SetIns(x,y)
  defrule ins = (label ?n:#int!) : LabelIns(n)
  defrule ins = (goto ?n:#int! when ?o:#op2 ?x:#imm! ?y:#imm!) : Branch2Ins(n, o, x, y)
  defrule ins = (goto ?n:#int! when ?o:#op1 ?x:#imm!) : Branch1Ins(n, o, x)
  defrule ins = (goto ?n:#int!) : GotoIns(n)
  defrule ins = (reserve ?num-objects:#int! ?sz:#imm!) : ReserveIns(num-objects, sz)
  defrule ins = (accept ?xs:#args) : AcceptIns(xs)
  defrule ins = (return (?xs:#imm! ...)) : ReturnIns(to-tuple(xs))

  defproduction args : Tuple<Local|False>
  defrule args = ((?xs:#arg ...)) : to-tuple(xs)  
  defproduction arg : Local|False
  defrule arg = (?x:#local) : x
  defrule arg = (_) : false

  defproduction def : VMDef
  defrule def = (def ?n:#int! : ?t:#type! (local ?l:#int!)) : VMDef(n, t, l)

  defproduction func : VMFunc
  defrule func = (func ?id:#int! :
                    ?defs:#def ...
                    ?ins:#ins! ...) :
    VMFunc(id, to-tuple(defs), to-tuple(ins))

  defproduction class : VMClass
  defrule class = (class ?id:#int! (?parents:#int! ...) (base-size = ?base:#int!, item-size = ?item:#int!)) :
    VMArrayClass(id, to-tuple(parents), base, item)
  defrule class = (class ?id:#int! (?parents:#int! ...) (size = ?size:#int!)) :
    VMLeafClass(id, to-tuple(parents), size)
  defrule class = (class ?id:#int! (?parents:#int! ...)) :
    VMAbstractClass(id, to-tuple(parents))

  public defproduction prog : VMProg
  defrule prog = (?classes:#class ... ?funcs:#func! ...) :
    VMProg(to-tuple(classes), to-tuple(funcs))

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  ;===== Failure =====
  defproduction imm! : VMImm
  defrule imm! = (?x:#imm) : x
  fail-if imm! = () : VME(closest-info(), "Expected an immediate here.")

  defproduction int! : Int
  defrule int! = (?x:#int) : x
  fail-if int! = () : VME(closest-info(), "Expected an integer here.")

  defproduction ins! : VMIns
  defrule ins! = (?x:#ins) : x
  fail-if ins! = () : VME(closest-info(), "Expected an instruction here.")

  defproduction func! : VMFunc
  defrule func! = (?x:#func) : x
  fail-if func! = () : VME(closest-info(), "Expected a function here.")

  defproduction type! : VMType
  defrule type! = (?x:#type) : x
  fail-if type! = () : VME(closest-info(), "Expected a type here.")

;============================================================
;====================== Errors ==============================
;============================================================

public defstruct VMError <: Exception :
  info: FileInfo|False
  msg

public defn VME (info:FileInfo|False, msg) :
  VMError(info, msg)

defmethod print (o:OutputStream, e:VMError) :
  val info-str = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [info-str, msg(e)])

;============================================================
;================ Overall Instruction Buffer ================
;============================================================
;deftype InsBuffer
;defmulti get (b:InsBuffer, i:Int) -> VMIns
;defmulti set (b:InsBuffer, i:Int, ins:VMIns) -> False
;defmulti alloc (b:InsBuffer, size:Int) -> Int
;defmulti free (b:InsBuffer, n:Int) -> False
;
;defn InsBuffer () :
;  val v = Vector<VMIns>()
;  val segments = IntTable<InsSegment>()
;  new InsBuffer :
;    defmethod get (this, i:Int) :
;      v[i]
;    defmethod set (this, i:Int, ins:VMIns) :
;      v[i] = ins
;    defmethod alloc (this, size:Int) -> Int :
;      val pos = length(v)
;      lengthen(v, length(v) + size, NoOpIns())
;      segments[pos] = InsSegment(size)
;      pos
;    defmethod free (this, n:Int) -> False :
;      fatal("Not yet implemented")
;
;defstruct InsSegment :
;  size: Int      
;
;;============================================================
;;================= Class Display Analysis ===================
;;============================================================
;deftype ClassTable
;defmulti class? (this, c:Int) -> True|False
;defmulti instanceof? (t:ClassTable, child:Int, parent:Int) -> True|False
;
;public defn ClassTable (classes:Tuple<VMClass>) :
;  val class-table = to-inttable<VMClass> $
;    for c in classes seq : id(c) => c
;  val parent-table = IntTable<Tuple<Int>>()
;  defn @all-parents (c:Int) :
;    val rec = class-table[c]
;    to-tuple(cat([c], seq-cat(all-parents, parents(rec))))
;  defn all-parents (c:Int) :
;    if not key?(parent-table, c) :
;      parent-table[c] = @all-parents(c)
;    parent-table[c]  
;  new ClassTable :
;    defmethod class? (this, c:Int) :
;      key?(class-table, c)
;    defmethod instanceof? (this, child:Int, parent:Int) :
;      contains?(all-parents(child), parent)
;
;;============================================================
;;====================== Mappers =============================
;;============================================================
;
;deftype HasTargetLabel :
;  GotoIns <: HasTargetLabel
;  Branch1Ins <: HasTargetLabel
;  Branch2Ins <: HasTargetLabel
;
;defn map-labels (f:Int -> Int, ins:HasTargetLabel) -> VMIns&HasTargetLabel :
;  match(ins) :
;    (ins:GotoIns) : sub-n(ins, f(n(ins)))
;    (ins:Branch1Ins) : sub-n(ins, f(n(ins)))
;    (ins:Branch2Ins) : sub-n(ins, f(n(ins)))
;
;;============================================================
;;==================== Stack Layout ==========================
;;============================================================
;
;;STACK LAYOUT: [TAG | SIZE | SP | RETURN | FRAME-SIZE | FRAMES ...]
;val INITIAL-STACK-SIZE = 512 * 8
;val STACK-TYPE-TAG = -1
;val STACK-TAG-POS = 0
;val STACK-SIZE-POS = 8
;val STACK-SP-POS = 16
;val STACK-RETURN-POS = 24
;val STACK-FRAME-SIZE-POS = 32
;val STACK-FRAME-POS = 40
;
;;============================================================
;;==================== Interpretation ========================
;;============================================================
;defstruct FuncRecord :
;  id: Int
;  args: Tuple<VMType>
;  local-size: Int
;  pos: Int
;
;deftype HeapValue :
;  Int <: HeapValue
;  Double <: HeapValue
;  False <: HeapValue
;defstruct TypeTag <: HeapValue :
;  type: Int
;with: (printer => true)
;defstruct Reference <: HeapValue :
;  address: Int
;with: (printer => true)  
;
;public defn interpret (prog:VMProg) :
;  ;Instruction buffer
;  val buffer = InsBuffer()
;  val func-records = IntTable<FuncRecord>()
;  val class-table = ClassTable(classes(prog))
;
;  ;Load a function into the VM
;  defn load-function (f:VMFunc) :
;    val pos = alloc(buffer, length(ins(f)))
;    val labels = IntTable<Int>()
;    within (delay) = with-delay() :
;      let loop (src:Int = 0, dst:Int = pos) :
;        if src < length(ins(f)) :
;          match(ins(f)[src]) :
;            (ins:LabelIns) :
;              labels[n(ins)] = dst
;              loop(src + 1, dst)
;            (ins:VMIns&HasTargetLabel) :
;              delay $ fn () :
;                buffer[dst] = map-labels({labels[_]}, ins)
;              loop(src + 1, dst + 1)
;            (ins) :
;              buffer[dst] = ins
;              match(ins:AllocIns) :
;                fatal("Invalid type %_" % [type(ins)]) when not class?(class-table, type(ins))
;              loop(src + 1, dst + 1)
;    func-records[id(f)] = FuncRecord(id(f), args(f), local-size(f), pos)
;  do(load-function, funcs(prog))
;
;  ;Define machine quantities
;  val registers = Array<HeapValue>(256, false)
;  val heap = IntTable<HeapValue>()
;  var heap-top:Int = 0
;  var heap-size:Int = 0
;  var current-stack:Reference
;  var stack-pointer:Int
;  var stack-end:Int
;  var current-frame-size:Int
;
;  ;Evaluation
;  defn eval (op:VMOp, y) :
;    match(op) :
;      (op:NotOp) : bit-not(y)
;      (op:NegOp) : negate(y)
;      (op:InstanceofOp) : bool-to-int(eval-pred(op, y))
;
;  defn eval (op:VMOp, y, z) :
;    match(op) :
;      (op:AddOp) : plus(y, z)
;      (op:SubOp) : minus(y, z)
;      (op:MulOp) : times(y, z)
;      (op:DivOp) : divide(y, z)
;      (op:ModOp) : modulo(y, z)
;      (op:AndOp) : bit-and(y, z)
;      (op:OrOp) : bit-or(y, z)
;      (op:XorOp) : bit-xor(y, z)
;      (op:ShlOp) : shift-left(y, z)
;      (op:ShrOp) : shift-right(y, z)
;      (op:AshrOp) : arithmetic-shift-right(y, z)
;      (op:EqOp) : bool-to-int(eval-pred(op, y, z))
;      (op:NeOp) : bool-to-int(eval-pred(op, y, z))
;      (op:LtOp) : bool-to-int(eval-pred(op, y, z))
;      (op:GtOp) : bool-to-int(eval-pred(op, y, z))
;      (op:LeOp) : bool-to-int(eval-pred(op, y, z))
;      (op:GeOp) : bool-to-int(eval-pred(op, y, z))
;      (op:UleOp) : bool-to-int(eval-pred(op, y, z))
;      (op:UltOp) : bool-to-int(eval-pred(op, y, z))
;      (op:UgtOp) : bool-to-int(eval-pred(op, y, z))
;      (op:UgeOp) : bool-to-int(eval-pred(op, y, z))
;
;  defn eval-pred (op:VMOp, y) :
;    match(op) :
;      (op:InstanceofOp) :
;        val tag = heap[address(y as Reference)] as TypeTag
;        instanceof?(class-table, type(tag), type(op))
;
;  defn eval-pred (op:VMOp, y, z) :
;    match(op) :
;      (op:EqOp) : equal?(y,z)
;      (op:NeOp) : not equal?(y, z)
;      (op:LtOp) : y < z
;      (op:GtOp) : y > z
;      (op:LeOp) : y <= z
;      (op:GeOp) : y >= z
;      (op:UleOp) : fatal("Not yet supported")
;      (op:UltOp) : fatal("Not yet supported")
;      (op:UgtOp) : fatal("Not yet supported")
;      (op:UgeOp) : fatal("Not yet supported")
;
;  ;Allocate a stack
;  defn alloc-stack (fid:Int) :
;    val s = Reference(heap-top)
;    heap-size = heap-size + INITIAL-STACK-SIZE
;    heap-top = heap-top + INITIAL-STACK-SIZE
;    val rec = func-records[fid]
;    store-field(s, STACK-TAG-POS, TypeTag(STACK-TYPE-TAG))
;    store-field(s, STACK-SIZE-POS, INITIAL-STACK-SIZE)
;    store-field(s, STACK-SP-POS, address(s) + STACK-FRAME-POS)
;    store-field(s, STACK-RETURN-POS, pos(rec))
;    store-field(s, STACK-FRAME-SIZE-POS, local-size(rec) + 16)
;    store-field(s, STACK-FRAME-POS + 0, false)
;    store-field(s, STACK-FRAME-POS + 8, false)
;    s
;
;  ;Load stack fields
;  defn load-field (r:Reference, field:Int) :
;    heap[address(r) + field]
;  defn store-field (r:Reference, field:Int, value) :
;    heap[address(r) + field] = value
;
;  ;Interpretation loop
;  defn* run (i:Int) :
;    ;Assign a value to a register
;    defn* assign (r:Reg, v:HeapValue) :
;      registers[index(r)] = v
;    defn eval-imm (imm:VMImm) :
;      match(imm) :
;        (r:Reg) : registers[index(r)]
;        (x:IntConst) : value(x)
;        (x:DoubleConst) : value(x)
;        (x:CodeId) : fid(x)
;    defn* step () : run(i + 1)
;    defn* jump (n:Int) : run(n)
;
;    val ins = buffer[i]
;    println("Trace: %_ (sp = %_)" % [ins, stack-pointer])
;    match(ins) :
;      (ins:SetIns) :
;        assign(x(ins), eval-imm(y(ins)))
;        step()
;      (ins:Op1Ins) :
;        assign(x(ins), eval(op(ins), eval-imm(y(ins))))
;        step()
;      (ins:Op2Ins) :
;        assign(x(ins), eval(op(ins), eval-imm(y(ins)), eval-imm(z(ins))))
;        step()
;      (ins:LabelIns) :
;        step()
;      (ins:GotoIns) :
;        jump(n(ins))
;      (ins:Branch1Ins) :
;        val pred = eval-pred(op(ins), eval-imm(x(ins)))
;        jump(n(ins)) when pred else step()
;      (ins:Branch2Ins) :
;        val pred = eval-pred(op(ins), eval-imm(x(ins)), eval-imm(y(ins)))
;        jump(n(ins)) when pred else step()
;      (ins:CallIns) :
;        call-func(fid(ins), i + 1)
;      (ins:CallClosureIns) :
;        val ref = eval-imm(x(ins)) as Reference
;        val fid = heap[address(ref) + 8 + 8] as Int
;        call-func(fid, i + 1)
;      (ins:ReturnIns) :
;        val return = heap[stack-pointer]
;        val old-sp = heap[stack-pointer + 8]
;        match(return:Int) :
;          current-frame-size = stack-pointer - old-sp as Int
;          stack-pointer = old-sp as Int
;          run(return)          
;      (ins:YieldIns) :
;        ;Save current context
;        val s0 = current-stack
;        store-field(s0, STACK-SP-POS, stack-pointer)
;        store-field(s0, STACK-RETURN-POS, i + 1)
;        store-field(s0, STACK-FRAME-SIZE-POS, current-frame-size)
;        ;Load next context        
;        val s = eval-imm(x(ins)) as Reference
;        load-stack(s)
;      (ins:NewStackIns) :
;        assign(x(ins), alloc-stack(fid(ins)))
;        step()
;      (ins:ReserveIns) :
;        val sz = eval-imm(size(ins)) as Int
;        fatal("Size is not a multiple of 8.") when not multiple8?(sz)
;        heap-size = heap-size + sz + 8 * num-objects(ins)
;        step()
;      (ins:AllocIns) :
;        val sz = eval-imm(size(ins)) as Int
;        val total-sz = sz + 8
;        fatal("Size is not a multiple of 8.") when not multiple8?(sz)
;        fatal("Beyond allocated limits.") when heap-top + total-sz > heap-size
;        heap[heap-top] = TypeTag(type(ins))        
;        assign(x(ins), Reference(heap-top))
;        heap-top = heap-top + total-sz
;        step()
;      (ins:RefSetIns) :
;        val ref = eval-imm(x(ins)) as Reference
;        val offset = eval-imm(y(ins)) as Int
;        val value = eval-imm(z(ins))
;        val addr = address(ref) + 8 + offset
;        fatal("Out of heap bounds.") when (addr + size(type(ins))) > heap-size
;        heap[addr] = value
;        step()
;      (ins:RefGetIns) :
;        val ref = eval-imm(y(ins)) as Reference
;        val offset = eval-imm(z(ins)) as Int
;        val addr = address(ref) + 8 + offset
;        fatal("Out of heap bounds.") when (addr + size(type(ins))) > heap-size
;        assign(x(ins), heap[addr])
;        step()
;      (ins:GetLocalIns) :
;        val pos = stack-pointer + 16 + offset(ins)
;        fatal("Out of stack bounds.") when pos >= stack-pointer + current-frame-size
;        assign(x(ins), heap[pos])
;        step()
;      (ins:SetLocalIns) :
;        val pos = stack-pointer + 16 + offset(ins)
;        fatal("Out of stack bounds.") when pos >= stack-pointer + current-frame-size
;        heap[pos] = eval-imm(x(ins))
;        step()
;
;  defn* call-func (fid:Int, return:Int) :
;    val fp = stack-pointer + current-frame-size
;    fatal("Stack overflow.") when (fp + 16) > stack-end
;    heap[fp] = return
;    heap[fp + 8] = stack-pointer
;    stack-pointer = fp
;    val rec = func-records[fid]
;    current-frame-size = local-size(rec) + 16
;    run(pos(rec))
;
;  defn* load-stack (s:Reference) :
;    current-stack = s
;    stack-pointer = load-field(s, STACK-SP-POS) as Int
;    val ret = load-field(s, STACK-RETURN-POS) as Int
;    current-frame-size = load-field(s, STACK-FRAME-SIZE-POS) as Int
;    val stack-size = load-field(current-stack, STACK-SIZE-POS) as Int
;    stack-end = address(s) + stack-size
;    run(ret)
;
;  ;Start from main function 0
;  load-stack(alloc-stack(0))
;
;  ;Print result of registers
;  for (v in registers, i in 0 to false) do :
;    if v is-not False :
;      println("R%_ = %_" % [i, v])
;
;defn size (t:VMType) :
;  match(t) :
;    (t:VMInt) : 4
;    (t:VMDouble) : 8
;    (t:VMRef) : 8
;    (t:VMPointer) : 8
;  
;;============================================================
;;==================== Utilities =============================
;;============================================================
;defn ensure-length<?T> (v:Vector<?T>, len:Int, x:T) :
;  lengthen(v, len, x) when length(v) < len
;
;defn multiple8? (x:Int) :
;  (x & 0x7) == 0
;
;defn bool-to-int (x:True|False) :
;  1 when x else 0
;
;defn with-delay<?T> (f:((() -> ?) -> False) -> ?T) :
;  val delays = Vector<(() -> ?)>()
;  defn* delay (x:() -> ?) : add(delays, x)
;  val result = f(delay)
;  for d in delays do : d()
;  result
;
;============================================================
;=================== Scratch Pad ============================
;============================================================

defn main () :
  val filename = command-line-arguments()[1]
  val forms = read-file(filename)
  val prog = parse-syntax[vmcode / #prog](forms)
  println(prog)
  ;interpret(prog)

main()














