defpackage stz/vm :
  import core
  import collections

;============================================================
;================== Design of Instructions ==================
;============================================================

public defstruct VMProg :
  ins: Tuple<VMIns>

public deftype VMImm
public defstruct Reg <: VMImm :
  index: Int
public defstruct IntConst <: VMImm :
  value: Int
public defstruct DoubleConst <: VMImm :
  value: Double

public deftype VMType
public defstruct VMInt <: VMType
public defstruct VMDouble <: VMType
public defstruct VMRef <: VMType
public defstruct VMPointer <: VMType

public deftype VMIns
public defstruct Set <: VMIns :
  x: Reg
  y: VMImm
public defstruct Op1 <: VMIns :
  x: Reg
  op: VMOp
  y: VMImm
public defstruct Op2 <: VMIns :
  x: Reg
  op: VMOp
  y: VMImm
  z: VMImm
public defstruct Label <: VMIns :
  n: Int
public defstruct Goto <: VMIns :
  n: Int
public defstruct Branch2 <: VMIns :
  n: Int
  op: VMOp
  x: VMImm
  y: VMImm
public defstruct Return <: VMIns 

public deftype VMOp
public defstruct AddOp <: VMOp : (type:VMType)
public defstruct SubOp <: VMOp : (type:VMType)
public defstruct MulOp <: VMOp : (type:VMType)
public defstruct DivOp <: VMOp : (type:VMType)
public defstruct ModOp <: VMOp : (type:VMType)
public defstruct AndOp <: VMOp : (type:VMType)
public defstruct OrOp <: VMOp : (type:VMType)
public defstruct XorOp <: VMOp : (type:VMType)
public defstruct NotOp <: VMOp : (type:VMType)
public defstruct ShlOp <: VMOp : (type:VMType)
public defstruct ShrOp <: VMOp : (type:VMType)
public defstruct AshrOp <: VMOp : (type:VMType)
public defstruct EqOp <: VMOp : (type:VMType)
public defstruct NeOp <: VMOp : (type:VMType)
public defstruct LtOp <: VMOp : (type:VMType)
public defstruct GtOp <: VMOp : (type:VMType)
public defstruct LeOp <: VMOp : (type:VMType)
public defstruct GeOp <: VMOp : (type:VMType)
public defstruct UleOp <: VMOp : (type:VMType)
public defstruct UltOp <: VMOp : (type:VMType)
public defstruct UgtOp <: VMOp : (type:VMType)
public defstruct UgeOp <: VMOp : (type:VMType)
public defstruct NegOp <: VMOp : (type:VMType)

;============================================================
;==================== Printer ===============================
;============================================================

defmethod print (o:OutputStream, x:VMImm) :
  print{o, _} $ match(x) :
    (x:Reg) : "R%_" % [index(x)]
    (x:IntConst) : "%~" % [value(x)]
    (x:DoubleConst) : "%~" % [value(x)]

defmethod print (o:OutputStream, i:VMIns) :
  print{o, _} $ match(i) :
    (i:Set) : "%_ = %_" % [x(i), y(i)]
    (i:Op1) : "%_ = %_ %_" % [x(i), op(i), y(i)]
    (i:Op2) : "%_ = %_ %_ %_" % [x(i), op(i), y(i), z(i)]
    (i:Label) : "label %_" % [n(i)]
    (i:Goto) : "goto %_" % [n(i)]
    (i:Branch2) : "goto %_ when %_ %_ %_" % [n(i), op(i), x(i), y(i)]
    (i:Return) : "return"

defmethod print (o:OutputStream, o:VMOp) :
  print(o, "%_ " % [type(o)])
  print{o, _} $ match(o) :
    (o:Add) : "add"
    (o:Sub) : "sub"
    (o:Mul) : "mul"
    (o:Div) : "div"
    (o:Mod) : "mod"
    (o:And) : "and"
    (o:Or) : "or"
    (o:Xor) : "xor"
    (o:Not) : "not"
    (o:Shl) : "shl"
    (o:Shr) : "shr"
    (o:Ashr) : "ashr"
    (o:Eq) : "eq"
    (o:Ne) : "ne"
    (o:Lt) : "lt"
    (o:Gt) : "gt"
    (o:Le) : "le"
    (o:Ge) : "ge"
    (o:Ule) : "ule"
    (o:Ult) : "ult"
    (o:Ugt) : "ugt"
    (o:Uge) : "uge"
    (o:Neg) : "neg"

defmethod print (o:OutputStream, t:VMType) :
  print{o, _} $ match(t) :
    (t:VMInt) : "int"
    (t:VMDouble) : "double"
    (t:VMRef) : "ref"
    (t:VMPointer) : "ptr"

;============================================================
;======================= Reader =============================
;============================================================

defsyntax vmcode :
  defproduction op : VMOp
  defrule op = (?t:#type add) : AddOp(t)
  defrule op = (?t:#type sub) : SubOp(t)
  defrule op = (?t:#type mul) : MulOp(t)
  defrule op = (?t:#type div) : DivOp(t)
  defrule op = (?t:#type mod) : ModOp(t)
  defrule op = (?t:#type and) : AndOp(t)
  defrule op = (?t:#type or) : OrOp(t)
  defrule op = (?t:#type xor) : XorOp(t)
  defrule op = (?t:#type not) : NotOp(t)
  defrule op = (?t:#type shl) : ShlOp(t)
  defrule op = (?t:#type shr) : ShrOp(t)
  defrule op = (?t:#type ashr) : AshrOp(t)
  defrule op = (?t:#type eq) : EqOp(t)
  defrule op = (?t:#type ne) : NeOp(t)
  defrule op = (?t:#type lt) : LtOp(t)
  defrule op = (?t:#type gt) : GtOp(t)
  defrule op = (?t:#type le) : LeOp(t)
  defrule op = (?t:#type ge) : GeOp(t)
  defrule op = (?t:#type ule) : UleOp(t)
  defrule op = (?t:#type ult) : UltOp(t)
  defrule op = (?t:#type ugt) : UgtOp(t)
  defrule op = (?t:#type uge) : UgeOp(t)
  defrule op = (?t:#type neg) : NegOp(t)

  defproduction type : VMType
  defrule type = (int) : VMInt()
  defrule double = (double) : VMDouble()
  defrule ref = (ref) : VMRef()
  defrule ptr = (ptr) : VMPointer()

  defn reg? (x) :
    unwrap-token(x) is Symbol and prefix?(to-string(x), "R")
  defn reg-index! (x:Symbol|Token) :
    val i = to-int(to-string(x)[1 to false])
    match(i:Int) : i
    else : throw(VME("Invalid register: %~" % [x]))
  defproduction reg : Reg
  defrule reg = (?r) when reg?(r) : Reg(reg-index!(r))

  defproduction imm : VMImm
  defrule imm = (?x) when unwrap-token(x) is Int : IntConst(unwrap-token(x))
  defrule imm = (?x) when unwrap-token(x) is Double : DoubleConst(unwrap-token(x))
  defrule imm = (?r:#reg) : r

  defproduction ins : VMIns
  defrule ins = (?x:#reg = ?o:#op1 ?y:#imm!) : Op1(x, o, y)
  defrule ins = (?x:#reg = ?o:#op2 ?y:#imm! ?z:#imm!) : Op2(x, o, y, z)
  defrule ins = (?x:#reg = ?y:#imm!) : Set(x,y)
  defrule ins = (label ?n:#int!) : Label(n)
  defrule ins = (goto ?n:#int! when ?o:#op2 ?x:#imm! ?z:#imm!) : Branch2(n, o, x, y)
  defrule ins = (goto ?n:#int!) : Goto(n)
  defrule ins = (return) : Return()

  public defproduction prog : VMProg
  defrule prog = (?ins:#ins! ...) : VMProg(to-tuple(ins))

