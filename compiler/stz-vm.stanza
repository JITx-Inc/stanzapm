defpackage stz/vm :
  import core
  import collections
  import reader

;============================================================
;================== Design of Instructions ==================
;============================================================

public defstruct VMProg :
  funcs: Tuple<VMFunc>

public deftype VMImm
public defstruct Reg <: VMImm :
  index: Int
public defstruct IntConst <: VMImm :
  value: Int
public defstruct DoubleConst <: VMImm :
  value: Double

public deftype VMType
public defstruct VMInt <: VMType
public defstruct VMDouble <: VMType
public defstruct VMRef <: VMType
public defstruct VMPointer <: VMType

public defstruct VMFunc :
  id: Int
  args: Tuple<VMType>
  num-reg: Int
  ins: Tuple<VMIns>

public deftype VMIns
public defstruct CallIns <: VMIns :
  fid: Int
  x: Reg
public defstruct SetIns <: VMIns :
  x: Reg
  y: VMImm
public defstruct Op1Ins <: VMIns :
  x: Reg
  op: VMOp
  y: VMImm
public defstruct Op2Ins <: VMIns :
  x: Reg
  op: VMOp
  y: VMImm
  z: VMImm
public defstruct LabelIns <: VMIns :
  n: Int
public defstruct GotoIns <: VMIns :
  n: Int
public defstruct Branch2Ins <: VMIns :
  n: Int
  op: VMOp
  x: VMImm
  y: VMImm
public defstruct ReserveIns <: VMIns :
  size: VMImm
public defstruct AllocIns <: VMIns :
  x: Reg
  type: Int
  size: VMImm
public defstruct RefSetIns <: VMIns :
  type: VMType
  x: VMImm
  y: VMImm
  z: VMImm
public defstruct RefGetIns <: VMIns :
  type: VMType
  x: Reg
  y: VMImm
  z: VMImm
public defstruct ReturnIns <: VMIns 
public defstruct NoOpIns <: VMIns

public deftype VMOp
public defstruct AddOp <: VMOp : (type:VMType)
public defstruct SubOp <: VMOp : (type:VMType)
public defstruct MulOp <: VMOp : (type:VMType)
public defstruct DivOp <: VMOp : (type:VMType)
public defstruct ModOp <: VMOp : (type:VMType)
public defstruct AndOp <: VMOp : (type:VMType)
public defstruct OrOp <: VMOp : (type:VMType)
public defstruct XorOp <: VMOp : (type:VMType)
public defstruct NotOp <: VMOp : (type:VMType)
public defstruct ShlOp <: VMOp : (type:VMType)
public defstruct ShrOp <: VMOp : (type:VMType)
public defstruct AshrOp <: VMOp : (type:VMType)
public defstruct EqOp <: VMOp : (type:VMType)
public defstruct NeOp <: VMOp : (type:VMType)
public defstruct LtOp <: VMOp : (type:VMType)
public defstruct GtOp <: VMOp : (type:VMType)
public defstruct LeOp <: VMOp : (type:VMType)
public defstruct GeOp <: VMOp : (type:VMType)
public defstruct UleOp <: VMOp : (type:VMType)
public defstruct UltOp <: VMOp : (type:VMType)
public defstruct UgtOp <: VMOp : (type:VMType)
public defstruct UgeOp <: VMOp : (type:VMType)
public defstruct NegOp <: VMOp : (type:VMType)

;============================================================
;==================== Printer ===============================
;============================================================

defmethod print (o:OutputStream, p:VMProg) :
  for (f in funcs(p), i in 0 to false) do :
    if i == 0 : print(o, f)
    else : lnprint(o, f)

defmethod print (o:OutputStream, f:VMFunc) :
  print(o, "func %_ (%,) :" % [id(f), args(f)])
  val o2 = IndentedStream(o)
  lnprint(o2, "num-reg = %_" % [num-reg(f)])
  do(lnprint{o2, _}, ins(f))

defmethod print (o:OutputStream, x:VMImm) :
  print{o, _} $ match(x) :
    (x:Reg) : "R%_" % [index(x)]
    (x:IntConst) : "%~" % [value(x)]
    (x:DoubleConst) : "%~" % [value(x)]
  
defmethod print (o:OutputStream, i:VMIns) :
  print{o, _} $ match(i) :
    (i:CallIns) : "%_ = call %_" % [x(i), fid(i)]
    (i:ReserveIns) : "reserve %_" % [size(i)]
    (i:AllocIns) : "%_ = alloc<%_> %_" % [x(i), type(i), size(i)]
    (i:RefSetIns) : "%_[%_] = %_ %_" % [x(i), y(i), type(i), z(i)]
    (i:RefGetIns) : "%_ = %_ %_[%_]" % [x(i), type(i), y(i), z(i)]    
    (i:SetIns) : "%_ = %_" % [x(i), y(i)]
    (i:Op1Ins) : "%_ = %_ %_" % [x(i), op(i), y(i)]
    (i:Op2Ins) : "%_ = %_ %_ %_" % [x(i), op(i), y(i), z(i)]
    (i:LabelIns) : "label %_" % [n(i)]
    (i:GotoIns) : "goto %_" % [n(i)]
    (i:Branch2Ins) : "goto %_ when %_ %_ %_" % [n(i), op(i), x(i), y(i)]
    (i:ReturnIns) : "return"
    (i:NoOpIns) : "noop"

defmethod print (o:OutputStream, op:VMOp) :
  print(o, "%_ " % [type(op as ?)])
  print{o, _} $ match(op) :
    (op:AddOp) : "add"
    (op:SubOp) : "sub"
    (op:MulOp) : "mul"
    (op:DivOp) : "div"
    (op:ModOp) : "mod"
    (op:AndOp) : "and"
    (op:OrOp) : "or"
    (op:XorOp) : "xor"
    (op:NotOp) : "not"
    (op:ShlOp) : "shl"
    (op:ShrOp) : "shr"
    (op:AshrOp) : "ashr"
    (op:EqOp) : "eq"
    (op:NeOp) : "ne"
    (op:LtOp) : "lt"
    (op:GtOp) : "gt"
    (op:LeOp) : "le"
    (op:GeOp) : "ge"
    (op:UleOp) : "ule"
    (op:UltOp) : "ult"
    (op:UgtOp) : "ugt"
    (op:UgeOp) : "uge"
    (op:NegOp) : "neg"

defmethod print (o:OutputStream, t:VMType) :
  print{o, _} $ match(t) :
    (t:VMInt) : "int"
    (t:VMDouble) : "double"
    (t:VMRef) : "ref"
    (t:VMPointer) : "ptr"

defn lnprint (o:OutputStream, x) :
  print(o, '\n')
  print(o, x)

;============================================================
;======================= Reader =============================
;============================================================

defsyntax vmcode :
  defproduction op1 : VMOp
  defrule op1 = (?t:#type not) : NotOp(t)
  defrule op1 = (?t:#type neg) : NegOp(t)

  defproduction op2 : VMOp
  defrule op2 = (?t:#type add) : AddOp(t)
  defrule op2 = (?t:#type sub) : SubOp(t)
  defrule op2 = (?t:#type mul) : MulOp(t)
  defrule op2 = (?t:#type div) : DivOp(t)
  defrule op2 = (?t:#type mod) : ModOp(t)
  defrule op2 = (?t:#type and) : AndOp(t)
  defrule op2 = (?t:#type or) : OrOp(t)
  defrule op2 = (?t:#type xor) : XorOp(t)
  defrule op2 = (?t:#type shl) : ShlOp(t)
  defrule op2 = (?t:#type shr) : ShrOp(t)
  defrule op2 = (?t:#type ashr) : AshrOp(t)
  defrule op2 = (?t:#type eq) : EqOp(t)
  defrule op2 = (?t:#type ne) : NeOp(t)
  defrule op2 = (?t:#type lt) : LtOp(t)
  defrule op2 = (?t:#type gt) : GtOp(t)
  defrule op2 = (?t:#type le) : LeOp(t)
  defrule op2 = (?t:#type ge) : GeOp(t)
  defrule op2 = (?t:#type ule) : UleOp(t)
  defrule op2 = (?t:#type ult) : UltOp(t)
  defrule op2 = (?t:#type ugt) : UgtOp(t)
  defrule op2 = (?t:#type uge) : UgeOp(t)

  defproduction type : VMType
  defrule type = (int) : VMInt()
  defrule type = (double) : VMDouble()
  defrule type = (ref) : VMRef()
  defrule type = (ptr) : VMPointer()

  defn reg? (x) :
    unwrap-token(x) is Symbol and prefix?(to-string(x), "R")
  defn reg-index! (info:FileInfo|False, x:Symbol|Token) :
    val i = to-int(to-string(x)[1 to false])
    match(i:Int) : i
    else : throw(VME(info, "Invalid register: %~" % [x]))
  defproduction reg : Reg
  defrule reg = (?r) when reg?(r) : Reg(reg-index!(closest-info(), r))

  defproduction imm : VMImm
  defrule imm = (?x) when unwrap-token(x) is Int : IntConst(unwrap-token(x))
  defrule imm = (?x) when unwrap-token(x) is Double : DoubleConst(unwrap-token(x))
  defrule imm = (?r:#reg) : r

  defproduction ins : VMIns
  defrule ins = (?x:#reg = call ?fid:#int!) : CallIns(fid, x)
  defrule ins = (?x:#reg = ?o:#op1 ?y:#imm!) : Op1Ins(x, o, y)
  defrule ins = (?x:#reg = ?o:#op2 ?y:#imm! ?z:#imm!) : Op2Ins(x, o, y, z)
  defrule ins = (?x:#reg = ?y:#imm!) : SetIns(x,y)
  defrule ins = (label ?n:#int!) : LabelIns(n)
  defrule ins = (goto ?n:#int! when ?o:#op2 ?x:#imm! ?y:#imm!) : Branch2Ins(n, o, x, y)
  defrule ins = (goto ?n:#int!) : GotoIns(n)
  defrule ins = (reserve ?sz:#imm!) : ReserveIns(sz)
  defrule ins = (?x:#reg = alloc<?t:#int!> ?size:#imm!) : AllocIns(x, t, size)
  defrule ins = (?x:#imm[?y:#imm] = ?t:#type ?z:#imm!) : RefSetIns(t, x, y, z)
  defrule ins = (?x:#reg = ?t:#type ?y:#imm[?z:#imm!]) : RefGetIns(t, x, y, z)
  defrule ins = (return) : ReturnIns()

  defproduction func : VMFunc
  defrule func = (func ?id:#int! (?args:#type! ...) :
                    num-regs = ?nreg:#int!
                    ?ins:#ins! ...) :
    VMFunc(id, to-tuple(args), nreg, to-tuple(ins))

  public defproduction prog : VMProg
  defrule prog = (?funcs:#func! ...) : VMProg(to-tuple(funcs))

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  ;===== Failure =====
  defproduction imm! : VMImm
  defrule imm! = (?x:#imm) : x
  fail-if imm! = () : VME(closest-info(), "Expected an immediate here.")

  defproduction int! : Int
  defrule int! = (?x:#int) : x
  fail-if int! = () : VME(closest-info(), "Expected an integer here.")

  defproduction ins! : VMIns
  defrule ins! = (?x:#ins) : x
  fail-if ins! = () : VME(closest-info(), "Expected an instruction here.")

  defproduction func! : VMFunc
  defrule func! = (?x:#func) : x
  fail-if func! = () : VME(closest-info(), "Expected a function here.")

  defproduction type! : VMType
  defrule type! = (?x:#type) : x
  fail-if type! = () : VME(closest-info(), "Expected a type here.")

;============================================================
;====================== Errors ==============================
;============================================================

public defstruct VMError <: Exception :
  info: FileInfo|False
  msg

public defn VME (info:FileInfo|False, msg) :
  VMError(info, msg)

defmethod print (o:OutputStream, e:VMError) :
  val info-str = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [info-str, msg(e)])

;============================================================
;================ Overall Instruction Buffer ================
;============================================================
deftype InsBuffer
defmulti get (b:InsBuffer, i:Int) -> VMIns
defmulti set (b:InsBuffer, i:Int, ins:VMIns) -> False
defmulti alloc (b:InsBuffer, size:Int) -> Int
defmulti free (b:InsBuffer, n:Int) -> False

defn InsBuffer () :
  val v = Vector<VMIns>()
  val segments = IntTable<InsSegment>()
  new InsBuffer :
    defmethod get (this, i:Int) :
      v[i]
    defmethod set (this, i:Int, ins:VMIns) :
      v[i] = ins
    defmethod alloc (this, size:Int) -> Int :
      val pos = length(v)
      lengthen(v, length(v) + size, NoOpIns())
      segments[pos] = InsSegment(size)
      pos
    defmethod free (this, n:Int) -> False :
      fatal("Not yet implemented")

defstruct InsSegment :
  size: Int      

;============================================================
;==================== Interpretation ========================
;============================================================

defn ensure-length<?T> (v:Vector<?T>, len:Int, x:T) :
  lengthen(v, len, x) when length(v) < len

defstruct FuncRecord :
  id: Int
  args: Tuple<VMType>
  num-reg: Int
  pos: Int

defstruct StackRecord :
  return: Int
  frame-pointer: Int

deftype HeapValue :
  Int <: HeapValue
  Double <: HeapValue
defstruct TypeTag <: HeapValue :
  type: Int
with: (printer => true)
defstruct Reference <: HeapValue :
  address: Int
with: (printer => true)  

public defn interpret (prog:VMProg) :
  ;Instruction buffer
  val buffer = InsBuffer()
  val func-records = IntTable<FuncRecord>()

  ;Load a function into the VM
  defn load-function (f:VMFunc) :
    val pos = alloc(buffer, length(ins(f)))
    val labels = IntTable<Int>()
    within (delay) = with-delay() :
      let loop (src:Int = 0, dst:Int = pos) :
        if src < length(ins(f)) :
          match(ins(f)[src]) :
            (ins:LabelIns) :
              labels[n(ins)] = dst
              loop(src + 1, dst)
            (ins:GotoIns) :
              delay $ fn () :
                buffer[dst] = GotoIns(labels[n(ins)])
              loop(src + 1, dst + 1)
            (ins:Branch2Ins) :
              delay $ fn () :
                buffer[dst] = Branch2Ins(labels[n(ins)], op(ins), x(ins), y(ins))
              loop(src + 1, dst + 1)
            (ins) :
              buffer[dst] = ins
              loop(src + 1, dst + 1)
    func-records[id(f)] = FuncRecord(id(f), args(f), num-reg(f), pos)
  do(load-function, funcs(prog))

  ;Define machine quantities
  val registers = Vector<?>()
  val callstack = Vector<StackRecord>()
  val heap = IntTable<?>()
  var heap-top:Int = 0
  var heap-size:Int = 0

  ;Evaluation
  defn eval (op:VMOp, y) :
    match(op) :
      (op:NotOp) : bit-not(y)
      (op:NegOp) : negate(y)

  defn eval (op:VMOp, y, z) :
    match(op) :
      (op:AddOp) : plus(y, z)
      (op:SubOp) : minus(y, z)
      (op:MulOp) : times(y, z)
      (op:DivOp) : divide(y, z)
      (op:ModOp) : modulo(y, z)
      (op:AndOp) : bit-and(y, z)
      (op:OrOp) : bit-or(y, z)
      (op:XorOp) : bit-xor(y, z)
      (op:ShlOp) : shift-left(y, z)
      (op:ShrOp) : shift-right(y, z)
      (op:AshrOp) : arithmetic-shift-right(y, z)

  defn eval-pred (op:VMOp, y, z) :
    match(op) :
      (op:EqOp) : equal?(y,z)
      (op:NeOp) : not equal?(y, z)
      (op:LtOp) : y < z
      (op:GtOp) : y > z
      (op:LeOp) : y <= z
      (op:GeOp) : y >= z
      (op:UleOp) : fatal("Not yet supported")
      (op:UltOp) : fatal("Not yet supported")
      (op:UgtOp) : fatal("Not yet supported")
      (op:UgeOp) : fatal("Not yet supported")

  ;Interpretation loop
  defn* run (i:Int, fp:Int) :
    ;Assign a value to a register
    defn* assign (r:Reg, v) :
      registers[fp + index(r)] = v
    defn eval-imm (imm:VMImm) :
      match(imm) :
        (r:Reg) : registers[fp + index(r)]
        (x:IntConst) : value(x)
        (x:DoubleConst) : value(x)
    defn* step () : run(i + 1, fp)
    defn* jump (n:Int) : run(n, fp)

    val ins = buffer[i]
    println("Trace: %_" % [ins])
    match(ins) :
      (ins:SetIns) :
        assign(x(ins), eval-imm(y(ins)))
        step()
      (ins:Op1Ins) :
        assign(x(ins), eval(op(ins), eval-imm(y(ins))))
        step()
      (ins:Op2Ins) :
        assign(x(ins), eval(op(ins), eval-imm(y(ins)), eval-imm(z(ins))))
        step()
      (ins:LabelIns) :
        step()
      (ins:GotoIns) :
        jump(n(ins))
      (ins:Branch2Ins) :
        val pred = eval-pred(op(ins), eval-imm(x(ins)), eval-imm(y(ins)))
        jump(n(ins)) when pred else step()
      (ins:CallIns) :
        val fp* = fp + index(x(ins))
        call-func(fid(ins), fp*, StackRecord(i + 1, fp))
      (ins:ReturnIns) :
        if not empty?(callstack) :
          val rec = pop(callstack)
          run(return(rec), frame-pointer(rec))
      (ins:ReserveIns) :
        val sz = eval-imm(size(ins)) as Int
        fatal("Size is not a multiple of 8.") when not multiple8?(sz)
        heap-size = heap-size + sz
        step()
      (ins:AllocIns) :
        val sz = eval-imm(size(ins)) as Int
        fatal("Size is not a multiple of 8.") when not multiple8?(sz)
        fatal("Beyond allocated limits.") when heap-top + sz > heap-size
        heap[heap-top] = TypeTag(type(ins))        
        assign(x(ins), Reference(heap-top))
        heap-top = heap-top + sz
        step()
      (ins:RefSetIns) :
        val ref = eval-imm(x(ins)) as Reference
        val offset = eval-imm(y(ins)) as Int
        val value = eval-imm(z(ins))
        val addr = address(ref) + offset
        fatal("Out of heap bounds.") when (addr + size(type(ins))) > heap-size
        heap[addr] = value
        step()
      (ins:RefGetIns) :
        val ref = eval-imm(y(ins)) as Reference
        val offset = eval-imm(z(ins)) as Int
        val addr = address(ref) + offset
        fatal("Out of heap bounds.") when (addr + size(type(ins))) > heap-size
        assign(x(ins), heap[addr])
        step()

  defn* call-func (f:Int, fp:Int, st:StackRecord|False) :
    match(st:StackRecord) :
      add(callstack, st)
    val rec = func-records[f]
    lengthen(registers, fp + num-reg(rec), false)
    run(pos(rec), fp)

  ;Print result of registers
  call-func(0, 0, false)
  for (v in registers, i in 0 to false) do :
    println("R%_ = %_" % [i, v])

defn size (t:VMType) :
  match(t) :
    (t:VMInt) : 4
    (t:VMDouble) : 8
    (t:VMRef) : 8
    (t:VMPointer) : 8

defn multiple8? (x:Int) :
  (x & 0x7) == 0
  
;============================================================
;==================== Utilities =============================
;============================================================

defn with-delay<?T> (f:((() -> ?) -> False) -> ?T) :
  val delays = Vector<(() -> ?)>()
  defn* delay (x:() -> ?) : add(delays, x)
  val result = f(delay)
  for d in delays do : d()
  result

;============================================================
;=================== Scratch Pad ============================
;============================================================

defn main () :
  val filename = command-line-arguments()[1]
  val forms = read-file(filename)
  val prog = parse-syntax[vmcode / #prog](forms)
  println(prog)
  interpret(prog)

main()