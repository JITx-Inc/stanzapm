defpackage stz/vm :
  import core
  import collections
  import reader

;============================================================
;================== Design of Instructions ==================
;============================================================

public defstruct VMProg :
  ins: Tuple<VMIns>

public deftype VMImm
public defstruct Reg <: VMImm :
  index: Int
public defstruct IntConst <: VMImm :
  value: Int
public defstruct DoubleConst <: VMImm :
  value: Double

public deftype VMType
public defstruct VMInt <: VMType
public defstruct VMDouble <: VMType
public defstruct VMRef <: VMType
public defstruct VMPointer <: VMType

public deftype VMIns
public defstruct SetIns <: VMIns :
  x: Reg
  y: VMImm
public defstruct Op1Ins <: VMIns :
  x: Reg
  op: VMOp
  y: VMImm
public defstruct Op2Ins <: VMIns :
  x: Reg
  op: VMOp
  y: VMImm
  z: VMImm
public defstruct LabelIns <: VMIns :
  n: Int
public defstruct GotoIns <: VMIns :
  n: Int
public defstruct Branch2Ins <: VMIns :
  n: Int
  op: VMOp
  x: VMImm
  y: VMImm
public defstruct ReturnIns <: VMIns 

public deftype VMOp
public defstruct AddOp <: VMOp : (type:VMType)
public defstruct SubOp <: VMOp : (type:VMType)
public defstruct MulOp <: VMOp : (type:VMType)
public defstruct DivOp <: VMOp : (type:VMType)
public defstruct ModOp <: VMOp : (type:VMType)
public defstruct AndOp <: VMOp : (type:VMType)
public defstruct OrOp <: VMOp : (type:VMType)
public defstruct XorOp <: VMOp : (type:VMType)
public defstruct NotOp <: VMOp : (type:VMType)
public defstruct ShlOp <: VMOp : (type:VMType)
public defstruct ShrOp <: VMOp : (type:VMType)
public defstruct AshrOp <: VMOp : (type:VMType)
public defstruct EqOp <: VMOp : (type:VMType)
public defstruct NeOp <: VMOp : (type:VMType)
public defstruct LtOp <: VMOp : (type:VMType)
public defstruct GtOp <: VMOp : (type:VMType)
public defstruct LeOp <: VMOp : (type:VMType)
public defstruct GeOp <: VMOp : (type:VMType)
public defstruct UleOp <: VMOp : (type:VMType)
public defstruct UltOp <: VMOp : (type:VMType)
public defstruct UgtOp <: VMOp : (type:VMType)
public defstruct UgeOp <: VMOp : (type:VMType)
public defstruct NegOp <: VMOp : (type:VMType)

;============================================================
;==================== Printer ===============================
;============================================================

defmethod print (o:OutputStream, p:VMProg) :
  for (ins in ins(p), i in 0 to false) do :
    print(o, '\n') when i > 0
    print(o, ins)

defmethod print (o:OutputStream, x:VMImm) :
  print{o, _} $ match(x) :
    (x:Reg) : "R%_" % [index(x)]
    (x:IntConst) : "%~" % [value(x)]
    (x:DoubleConst) : "%~" % [value(x)]

defmethod print (o:OutputStream, i:VMIns) :
  print{o, _} $ match(i) :
    (i:SetIns) : "%_ = %_" % [x(i), y(i)]
    (i:Op1Ins) : "%_ = %_ %_" % [x(i), op(i), y(i)]
    (i:Op2Ins) : "%_ = %_ %_ %_" % [x(i), op(i), y(i), z(i)]
    (i:LabelIns) : "label %_" % [n(i)]
    (i:GotoIns) : "goto %_" % [n(i)]
    (i:Branch2Ins) : "goto %_ when %_ %_ %_" % [n(i), op(i), x(i), y(i)]
    (i:ReturnIns) : "return"

defmethod print (o:OutputStream, op:VMOp) :
  print(o, "%_ " % [type(op as ?)])
  print{o, _} $ match(op) :
    (op:AddOp) : "add"
    (op:SubOp) : "sub"
    (op:MulOp) : "mul"
    (op:DivOp) : "div"
    (op:ModOp) : "mod"
    (op:AndOp) : "and"
    (op:OrOp) : "or"
    (op:XorOp) : "xor"
    (op:NotOp) : "not"
    (op:ShlOp) : "shl"
    (op:ShrOp) : "shr"
    (op:AshrOp) : "ashr"
    (op:EqOp) : "eq"
    (op:NeOp) : "ne"
    (op:LtOp) : "lt"
    (op:GtOp) : "gt"
    (op:LeOp) : "le"
    (op:GeOp) : "ge"
    (op:UleOp) : "ule"
    (op:UltOp) : "ult"
    (op:UgtOp) : "ugt"
    (op:UgeOp) : "uge"
    (op:NegOp) : "neg"

defmethod print (o:OutputStream, t:VMType) :
  print{o, _} $ match(t) :
    (t:VMInt) : "int"
    (t:VMDouble) : "double"
    (t:VMRef) : "ref"
    (t:VMPointer) : "ptr"

;============================================================
;======================= Reader =============================
;============================================================

defsyntax vmcode :
  defproduction op1 : VMOp
  defrule op1 = (?t:#type not) : NotOp(t)
  defrule op1 = (?t:#type neg) : NegOp(t)

  defproduction op2 : VMOp
  defrule op2 = (?t:#type add) : AddOp(t)
  defrule op2 = (?t:#type sub) : SubOp(t)
  defrule op2 = (?t:#type mul) : MulOp(t)
  defrule op2 = (?t:#type div) : DivOp(t)
  defrule op2 = (?t:#type mod) : ModOp(t)
  defrule op2 = (?t:#type and) : AndOp(t)
  defrule op2 = (?t:#type or) : OrOp(t)
  defrule op2 = (?t:#type xor) : XorOp(t)
  defrule op2 = (?t:#type shl) : ShlOp(t)
  defrule op2 = (?t:#type shr) : ShrOp(t)
  defrule op2 = (?t:#type ashr) : AshrOp(t)
  defrule op2 = (?t:#type eq) : EqOp(t)
  defrule op2 = (?t:#type ne) : NeOp(t)
  defrule op2 = (?t:#type lt) : LtOp(t)
  defrule op2 = (?t:#type gt) : GtOp(t)
  defrule op2 = (?t:#type le) : LeOp(t)
  defrule op2 = (?t:#type ge) : GeOp(t)
  defrule op2 = (?t:#type ule) : UleOp(t)
  defrule op2 = (?t:#type ult) : UltOp(t)
  defrule op2 = (?t:#type ugt) : UgtOp(t)
  defrule op2 = (?t:#type uge) : UgeOp(t)


  defproduction type : VMType
  defrule type = (int) : VMInt()
  defrule type = (double) : VMDouble()
  defrule type = (ref) : VMRef()
  defrule type = (ptr) : VMPointer()

  defn reg? (x) :
    unwrap-token(x) is Symbol and prefix?(to-string(x), "R")
  defn reg-index! (info:FileInfo|False, x:Symbol|Token) :
    val i = to-int(to-string(x)[1 to false])
    match(i:Int) : i
    else : throw(VME(info, "Invalid register: %~" % [x]))
  defproduction reg : Reg
  defrule reg = (?r) when reg?(r) : Reg(reg-index!(closest-info(), r))

  defproduction imm : VMImm
  defrule imm = (?x) when unwrap-token(x) is Int : IntConst(unwrap-token(x))
  defrule imm = (?x) when unwrap-token(x) is Double : DoubleConst(unwrap-token(x))
  defrule imm = (?r:#reg) : r

  defproduction ins : VMIns
  defrule ins = (?x:#reg = ?o:#op1 ?y:#imm!) : Op1Ins(x, o, y)
  defrule ins = (?x:#reg = ?o:#op2 ?y:#imm! ?z:#imm!) : Op2Ins(x, o, y, z)
  defrule ins = (?x:#reg = ?y:#imm!) : SetIns(x,y)
  defrule ins = (label ?n:#int!) : LabelIns(n)
  defrule ins = (goto ?n:#int! when ?o:#op2 ?x:#imm! ?y:#imm!) : Branch2Ins(n, o, x, y)
  defrule ins = (goto ?n:#int!) : GotoIns(n)
  defrule ins = (return) : ReturnIns()

  public defproduction prog : VMProg
  defrule prog = (?ins:#ins! ...) : VMProg(to-tuple(ins))

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  ;===== Failure =====
  defproduction imm! : VMImm
  defrule imm! = (?x:#imm) : x
  fail-if imm! = () : VME(closest-info(), "Expected an immediate here.")

  defproduction int! : Int
  defrule int! = (?x:#int) : x
  fail-if int! = () : VME(closest-info(), "Expected an integer here.")

  defproduction ins! : VMIns
  defrule ins! = (?x:#ins) : x
  fail-if ins! = () : VME(closest-info(), "Expected an instruction here.")

;============================================================
;====================== Errors ==============================
;============================================================

public defstruct VMError <: Exception :
  info: FileInfo|False
  msg

public defn VME (info:FileInfo|False, msg) :
  VMError(info, msg)

defmethod print (o:OutputStream, e:VMError) :
  val info-str = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [info-str, msg(e)])

;============================================================
;==================== Interpretation ========================
;============================================================

defn ensure-length<?T> (v:Vector<?T>, len:Int, x:T) :
  lengthen(v, len, x) when length(v) < len

public defn interpret (prog:VMProg) :
  ;Load jump table
  val jump-table = Vector<Int>()
  for (ins in ins(prog), i in 0 to false) do :
    match(ins:LabelIns) :
      ensure-length(jump-table, n(ins), -1)
      jump-table[n(ins)] = i

  ;Define registers
  val registers = Vector<?>()

  ;Evaluation
  defn eval (imm:VMImm) :
    match(imm) :
      (r:Reg) : registers[index(r)]
      (x:IntConst) : value(x)
      (x:DoubleConst) : value(x)

  defn eval (op:VMOp, y) :
    match(op) :
      (op:NotOp) : bit-not(y)
      (op:NegOp) : negate(y)

  defn eval (op:VMOp, y, z) :
    match(op) :
      (op:AddOp) : plus(y, z)
      (op:SubOp) : minus(y, z)
      (op:MulOp) : times(y, z)
      (op:DivOp) : divide(y, z)
      (op:ModOp) : modulo(y, z)
      (op:AndOp) : bit-and(y, z)
      (op:OrOp) : bit-or(y, z)
      (op:XorOp) : bit-xor(y, z)
      (op:ShlOp) : shift-left(y, z)
      (op:ShrOp) : shift-right(y, z)
      (op:AshrOp) : arithmetic-shift-right(y, z)

  defn eval-pred (op:VMOp, y, z) :
    match(op) :
      (op:EqOp) : equal?(y,z)
      (op:NeOp) : not equal?(y, z)
      (op:LtOp) : y < z
      (op:GtOp) : y > z
      (op:LeOp) : y <= z
      (op:GeOp) : y >= z
      (op:UleOp) : fatal("Not yet supported")
      (op:UltOp) : fatal("Not yet supported")
      (op:UgtOp) : fatal("Not yet supported")
      (op:UgeOp) : fatal("Not yet supported")

  defn assign (r:Reg, v) :
    ensure-length(registers, index(r), false)
    registers[index(r)] = v

  ;Interpretation loop
  let loop (i:Int = 0) :
    val ins = ins(prog)[i]
    println("Trace: %_" % [ins])
    match(ins) :
      (ins:SetIns) :
        assign(x(ins), eval(y(ins)))
        loop(i + 1)
      (ins:Op1Ins) :
        assign(x(ins), eval(op(ins), eval(y(ins))))
        loop(i + 1)
      (ins:Op2Ins) :
        assign(x(ins), eval(op(ins), eval(y(ins)), eval(z(ins))))
        loop(i + 1)
      (ins:LabelIns) :
        loop(i + 1)
      (ins:GotoIns) :
        loop(jump-table[n(ins)])
      (ins:Branch2Ins) :
        if eval-pred(op(ins), eval(x(ins)), eval(y(ins))) : loop(jump-table[n(ins)])
        else : loop(i + 1)
      (ins:ReturnIns) :
        false

  ;Print result of registers
  for (v in registers, i in 0 to false) do :
    println("R%_ = %_" % [i, v])
  
  

  

;============================================================
;=================== Scratch Pad ============================
;============================================================

defn main () :
  val filename = command-line-arguments()[1]
  val forms = read-file(filename)
  val prog = parse-syntax[vmcode / #prog](forms)
  println(prog)
  interpret(prog)

main()