defpackage stz/vm :
  import core
  import collections
  import stz/vm-ir

;============================================================
;==================== Linked Instructions ===================
;============================================================

public deftype LinkedIns :
  NewStackIns <: LinkedIns
  SetIns <: LinkedIns
  Op0Ins <: LinkedIns
  ReserveIns <: LinkedIns
  AllocIns <: LinkedIns
  JumpIns <: LinkedIns

public deftype JumpIns :
  GotoIns <: JumpIns
  Branch1Ins <: JumpIns  

public defstruct LinkedRefSetIns <: LinkedIns :
  size: Int
  x: VMImm
  y: VMImm
  z: VMImm
public defstruct LinkedRefGetIns <: LinkedIns :
  size: Int
  x: Local
  y: VMImm
  z: VMImm  
public defstruct SetReg <: LinkedIns :
  reg: Int
  x: VMImm
public defstruct GetReg <: LinkedIns :
  x: Local
  reg: Int
public defstruct LinkedCall <: LinkedIns :
  f: VMImm
public defstruct LinkedCallClosure <: LinkedIns :
  f: VMImm
public defstruct LinkedYield <: LinkedIns :
  f: VMImm
public defstruct LinkedReturn <: LinkedIns
public defstruct FunctionEntry <: LinkedIns :
  num-locals:Int
public defstruct LinkedDump <: LinkedIns :
  x: Local
public defstruct LinkedOp1Ins <: LinkedIns :
  type: VMType
  x: Local
  op: VMOp
  y: VMImm
public defstruct LinkedOp2Ins <: LinkedIns :
  type: VMType
  x: Local
  op: VMOp
  y: VMImm
  z: VMImm
public defstruct LinkedBranch2Ins <: LinkedIns :
  type: VMType
  n: Int with: (updater => sub-n)
  op: VMOp
  x: VMImm
  y: VMImm

;============================================================
;======================= Printer ============================
;============================================================

defmethod print (o:OutputStream, i:LinkedRefSetIns) :
  print(o, "%_[%_] = %_ (%_ bytes)" % [x(i), y(i), z(i), size(i)])

defmethod print (o:OutputStream, i:LinkedRefGetIns) :
  print(o, "%_ = %_[%_] (%_ bytes)" % [x(i), y(i), z(i), size(i)])

defmethod print (o:OutputStream, i:LinkedOp1Ins) :
  print(o, "%_ = %_ %_ %_" % [x(i), type(i), op(i), y(i)])

defmethod print (o:OutputStream, i:LinkedOp2Ins) :
  print(o, "%_ = %_ %_ %_ %_" % [x(i), type(i), op(i), y(i), z(i)])

defmethod print (o:OutputStream, i:LinkedBranch2Ins) :
  print(o, "goto %_ when %_ %_ %_" % [n(i), type(i), op(i), x(i), y(i)])

defmethod print (o:OutputStream, r:SetReg) :
  print(o, "reg %_ = %_" % [reg(r), x(r)])

defmethod print (o:OutputStream, r:GetReg) :
  print(o, "%_ = reg %_" % [x(r), reg(r)])

defmethod print (o:OutputStream, x:LinkedCall) :
  print(o, "call %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedCallClosure) :
  print(o, "call-closure %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedYield) :
  print(o, "yield %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedReturn) :
  print(o, "return")

defmethod print (o:OutputStream, x:FunctionEntry) :
  print(o, "enter (num-locals = %_)" % [num-locals(x)])

defmethod print (o:OutputStream, ins:LinkedDump) :
  print(o, "dump %_" % [x(ins)])

;============================================================
;=================== Size Calculations ======================
;============================================================

defn size (x:VMImm) :
  match(x) :
    (x:NumConst) :
      match(value(x)) :
        (v:Byte) : 1
        (v:Int) : 4
        (v:Long) : 8
        (v:Float) : 4
        (v:Double) : 8
    (x:CodeId) : 8

defn type (x:VMImm) :
  match(x) :
    (x:NumConst) :
      match(value(x)) :
        (v:Byte) : VMByte()
        (v:Int) : VMInt()
        (v:Long) : VMLong()
        (v:Float) : VMFloat()
        (v:Double) : VMDouble()
    (x:CodeId) : VMPointer()

defn size (t:VMType) :
  match(t) :
    (t:VMByte) : 1
    (t:VMInt) : 4
    (t:VMLong) : 8
    (t:VMFloat) : 4
    (t:VMDouble) : 8
    (t:VMRef) : 8
    (t:VMPointer) : 8

;============================================================
;======================= Linker =============================
;============================================================

deftype Linker
defmulti instructions (l:Linker) -> Tuple<LinkedIns>
defmulti link (l:Linker, f:VMFunc) -> Int

defn Linker () :
  ;===== Overall Buffer =====
  val ins-buffer = Vector<LinkedIns>()

  ;===== Temporary Linking Buffer =====
  val buffer = Vector<LinkedIns|False>()
  defn link (func:VMFunc) :
    ;Create mapping from local ID to slot
    val deftable = to-inttable<VMDef> $
      for def in defs(func) seq :
        id(def) => def
    ;Retrieve the size of an immediate
    defn imm-size (x:VMImm) :
      match(x:Local) : size(type(deftable[index(x)]))
      else : size(x)
    defn imm-type (x:VMImm) :
      match(x:Local) : type(deftable[index(x)])
      else : type(x)
    defn simple-type (t:VMType) :
      match(t) :
        (t:VMRef) : VMLong()
        (t:VMPointer) : VMLong()
        (t) : t
    ;Substitute a local's abstract index with its frame slot
    defn sub-slot<?T> (x:VMImm&?T) -> T :
      {_ as VMImm&T} $
        match(x:Local) : Local(local(deftable[index(x)]))
        else : x
    ;Create label table
    val label-table = IntTable<Int>()
    ;Replace the target destination with an offset
    defn offset (n:Int, pos:Int) -> Int :
      label-table[n] - pos
    defn sub-offset (jins:JumpIns, pos:Int) -> LinkedIns :
      val ins = jins as GotoIns|Branch1Ins
      sub-n(ins, offset(n(ins), pos))
    ;Register Instructions
    defn get-regs (xs:Tuple<Local|False>) :
      for (x in xs, i in 0 to false) do :
        match(x:Local) :
          add(buffer, GetReg(sub-slot(x), i))
    defn set-regs (xs:Tuple<VMImm>) :
      for (x in xs, i in 0 to false) do :
        add(buffer, SetReg(i, sub-slot(x)))
    ;Link instructions
    within delay-actions() :
      ;Create entry instructions
      val num-locals = maximum(-1, seq(local, defs(func))) + 1
      add(buffer, FunctionEntry(num-locals))
      get-regs(args(func))
      ;Link and add to buffer
      for ins in ins(func) do :
        match(ins) :
          (ins:LabelIns) :
            label-table[n(ins)] = length(buffer)
          (ins:CallIns) :
            set-regs(ys(ins))
            add(buffer, LinkedCall(sub-slot(f(ins))))
            get-regs(xs(ins))
          (ins:CallClosureIns) :
            set-regs(ys(ins))
            add(buffer, LinkedCallClosure(sub-slot(f(ins))))
            get-regs(xs(ins))
          (ins:YieldIns) :
            set-regs(ys(ins))
            add(buffer, LinkedYield(sub-slot(f(ins))))
            get-regs(xs(ins))
          (ins:ReturnIns) :
            set-regs(xs(ins))
            add(buffer, LinkedReturn())
          (ins:DumpIns) :
            for x in xs(ins) do :
              add(buffer, LinkedDump(sub-slot(x)))
          (ins:RefSetIns) :
            val size = imm-size(z(ins))
            add(buffer, LinkedRefSetIns(size, sub-slot(x(ins)), sub-slot(y(ins)), sub-slot(z(ins))))
          (ins:RefGetIns) :
            val size = imm-size(x(ins))
            add(buffer, LinkedRefGetIns(size, sub-slot(x(ins)), sub-slot(y(ins)), sub-slot(z(ins))))
          (ins:Op1Ins) :
            val t = simple-type(imm-type(y(ins)))
            add(buffer, LinkedOp1Ins(t, sub-slot(x(ins)), op(ins), sub-slot(y(ins))))
          (ins:Op2Ins) :
            val t = simple-type(imm-type(y(ins)))
            add(buffer, LinkedOp2Ins(t, sub-slot(x(ins)), op(ins), sub-slot(y(ins)), sub-slot(z(ins))))
          (ins:Branch2Ins) :
            val pos = length(buffer)
            add(buffer, false)
            within delay() :
              val t = simple-type(imm-type(y(ins)))
              buffer[pos] = LinkedBranch2Ins(t, offset(n(ins), pos), op(ins), sub-slot(x(ins)), sub-slot(y(ins)))
          (ins:JumpIns&VMIns) :
            val pos = length(buffer)
            add(buffer, false)
            within delay() :
              val ins* = map(sub-slot, ins) as JumpIns
              buffer[pos] = sub-offset(ins*, pos)
          (ins:LinkedIns&VMIns) :
            val ins* = map(sub-slot, ins)
            add(buffer, ins*)
    ;Dump to instruction buffer
    val pos = length(ins-buffer)
    add-all(ins-buffer, buffer as Seqable<LinkedIns>)
    clear(buffer)
    ;Return instruction address of linked function
    pos

  new Linker :
    defmethod instructions (this) :
      to-tuple(ins-buffer)
    defmethod link (this, f:VMFunc) :
      link(f)

defn map (f:VMImm -> VMImm, ins:LinkedIns) -> LinkedIns :
  defn flocal (x:Local) : f(x) as Local
  match(ins) :
    (ins:NewStackIns) : NewStackIns(flocal(x(ins)), f(fid(ins)))
    (ins:SetIns) : SetIns(flocal(x(ins)), f(y(ins)))
    (ins:Op0Ins) : Op0Ins(flocal(x(ins)), op(ins))
    (ins:GotoIns) : ins
    (ins:Branch1Ins) : Branch1Ins(n(ins), op(ins), f(x(ins)))
    (ins:ReserveIns) : ins
    (ins:AllocIns) : AllocIns(flocal(x(ins)), type(ins), size(ins))

;============================================================
;================= Class Display Analysis ===================
;============================================================
deftype ClassTable
defmulti class? (this, c:Int) -> True|False
defmulti instanceof? (t:ClassTable, child:Int, parent:Int) -> True|False

public defn ClassTable (classes:Tuple<VMClass>) :
  val class-table = to-inttable<VMClass> $
    for c in classes seq : id(c) => c
  val parent-table = IntTable<Tuple<Int>>()
  defn @all-parents (c:Int) :
    val rec = class-table[c]
    to-tuple(cat([c], seq-cat(all-parents, parents(rec))))
  defn all-parents (c:Int) :
    if not key?(parent-table, c) :
      parent-table[c] = @all-parents(c)
    parent-table[c]
  new ClassTable :
    defmethod class? (this, c:Int) :
      key?(class-table, c)
    defmethod instanceof? (this, child:Int, parent:Int) :
      contains?(all-parents(child), parent)

;============================================================
;==================== VM Constants ==========================
;============================================================

lostanza val REF-TAG:long = 1L

lostanza defn untag (x:long) -> ptr<?> :
  return (x - REF-TAG + 8) as ptr<?>

lostanza defn tag (x:ptr<?>) -> long :
  return (x + REF-TAG) as long

;============================================================
;=================== VM Structures ==========================
;============================================================

lostanza deftype VirtualMachine :
  registers: ptr<long>
  heap: ptr<long>
  heap-top: ptr<long>
  heap-end: ptr<long>
  heap-limit: ptr<long>
  current-stack: long
  stack-pointer: ptr<Frame>
  frame-size: int
  pc: int

lostanza deftype Frame :
  return: long
  sp: ptr<Frame>
  slots: long ...

lostanza deftype Stack :
  size: long
  frames: ptr<Frame>
  stack-pointer: ptr<Frame>
  frame-size: int
  pc: int

lostanza deftype Function :
  num-slots: long
  code: long
  slots: long ...



;============================================================
;==================== VM Implementation =====================
;============================================================

lostanza defn VirtualMachine () -> ref<VirtualMachine> :
  val registers = call-c clib/malloc(sizeof(ptr<?>) * 256)
  val heap = call-c clib/malloc(512 * 1024 * 1024)
  val heap-limit = heap + 512 * 1024 * 1024
  val null = 0L as ptr<?>
  return new VirtualMachine{registers, heap, heap, heap, heap-limit,
                            0L, null, 0, 0}

lostanza defn alloc-stack (vm:ref<VirtualMachine>, pc:int) -> long :
  val stack-size = 1024 * 1024
  val frames = call-c clib/malloc(stack-size)
  val s = tag(vm.heap-top)
  val null = 0L as ptr<?>
  vm.heap-top = vm.heap-top + 8 + sizeof(Stack)
  vm.heap-end = vm.heap-end + 8 + sizeof(Stack)
  val sptr:ptr<Stack> = untag(s)
  sptr.size = stack-size
  sptr.frames = frames
  sptr.stack-pointer = frames
  sptr.frame-size = 0
  sptr.pc = pc
  sptr.frames.return = -1L
  sptr.frames.sp = null
  return s

lostanza defn eval-imm (frame:ptr<Frame>, x:ref<VMImm>) -> long :
  match(x) :
    (x:ref<Local>) :
      return frame.slots[index(x).value]
    (x:ref<NumConst>) :
      match(value(x)) :
        (v:ref<Byte>) : return v.value
        (v:ref<Int>) : return v.value
        (v:ref<Long>) : return v.value
        (v:ref<Float>) :
          val value = v.value
          return ($ls-prim bits value)
        (v:ref<Double>) :
          val value = v.value
          return ($ls-prim bits value)
    (x:ref<CodeId>) :
      return fid(x).value

lostanza defn eval-op (current-stack:long, op:ref<VMOp>) -> long :
  match(op) :
    (op:ref<CurrentStackOp>) : return current-stack
  return 0

lostanza defn eval-op (class-table:ref<ClassTable>, type:ref<VMType>, op:ref<VMOp>, y:long) -> long :
  match(op, type) :
    (op:ref<NotOp>, type:ref<VMByte|VMInt|VMLong>) : return (~ y)
    (op:ref<NotOp>, type) : fatal("Illegal type.")
    
    (op:ref<NegOp>, type:ref<VMInt|VMLong>) : return (- y)
    (op:ref<NegOp>, type:ref<VMFloat>) :
      val yint = y as int
      val yfloat = ($ls-prim fnum yint)
      val result = (- yfloat)
      return ($ls-prim bits result)
    (op:ref<NegOp>, type:ref<VMDouble>) : 
      val yfloat = ($ls-prim fnum y)
      val result = (- yfloat)
      return ($ls-prim bits result)
    (op:ref<NegOp>, type) : fatal("Illegal type.")
    
    (op:ref<InstanceofOp>, type:ref<VMLong>) :
      val tag = new Int{[(y - REF-TAG) as ptr<long>] as int}
      val instance? = instanceof?(class-table, tag, /type(op))
      if instance? == true : return 1
      else : return 0
    (op:ref<InstanceofOp>, type) : fatal("Illegal type.")
  return 0

lostanza defn eval-op (type:ref<VMType>, op:ref<VMOp>, y:long, z:long) -> long :
  match(type) :
    (type:ref<VMByte|VMInt|VMLong>) :
      match(op, type) :
        (op:ref<AddOp>, type) : return y + z
        (op:ref<SubOp>, type) : return y - z 
        (op:ref<MulOp>, type) : return y * z
        (op:ref<DivOp>, type) : return y / z
        (op:ref<ModOp>, type) : return y % z
        (op:ref<AndOp>, type) : return y & z
        (op:ref<OrOp>, type) : return y | z
        (op:ref<XorOp>, type) : return y ^ z
        (op:ref<ShlOp>, type) : return y << z
        (op:ref<ShrOp>, type) : return y >> z
        (op:ref<AshrOp>, type) : return y >>> z
        (op:ref<EqOp>, type) : return y == z
        (op:ref<NeOp>, type) : return y != z
        (op:ref<LtOp>, type:ref<VMInt|VMLong>) : return y < z
        (op:ref<GtOp>, type:ref<VMInt|VMLong>) : return y > z
        (op:ref<LeOp>, type:ref<VMInt|VMLong>) : return y <= z
        (op:ref<GeOp>, type:ref<VMInt|VMLong>) : return y >= z
        (op:ref<LtOp>, type:ref<VMByte>) : fatal("Illegal type.")
        (op:ref<GtOp>, type:ref<VMByte>) : fatal("Illegal type.")
        (op:ref<LeOp>, type:ref<VMByte>) : fatal("Illegal type.")
        (op:ref<GeOp>, type:ref<VMByte>) : fatal("Illegal type.")
        (op:ref<UleOp>, type) : return ($ls-prim ule y z)
        (op:ref<UltOp>, type) : return ($ls-prim ult y z)
        (op:ref<UgtOp>, type) : return ($ls-prim ugt y z)
        (op:ref<UgeOp>, type) : return ($ls-prim uge y z)
      return 0
    (type:ref<VMFloat>) :
      val yint = y as int
      val zint = z as int
      val yf = ($ls-prim fnum yint)
      val zf = ($ls-prim fnum zint)
      var result:float
      match(op) :
        (op:ref<AddOp>) : result = yf + zf
        (op:ref<SubOp>) : result = yf - zf 
        (op:ref<MulOp>) : result = yf * zf
        (op:ref<DivOp>) : result = yf / zf
        (op:ref<ModOp>) : fatal("Illegal type.")
        (op:ref<AndOp>) : fatal("Illegal type.")
        (op:ref<OrOp>) : fatal("Illegal type.")
        (op:ref<XorOp>) : fatal("Illegal type.")
        (op:ref<ShlOp>) : fatal("Illegal type.")
        (op:ref<ShrOp>) : fatal("Illegal type.")
        (op:ref<AshrOp>) : fatal("Illegal type.")
        (op:ref<EqOp>) : return yf == zf
        (op:ref<NeOp>) : return yf != zf
        (op:ref<LtOp>) : return yf < zf
        (op:ref<GtOp>) : return yf > zf
        (op:ref<LeOp>) : return yf <= zf
        (op:ref<GeOp>) : return yf >= zf
        (op:ref<UleOp>) : fatal("Illegal type.")
        (op:ref<UltOp>) : fatal("Illegal type.")
        (op:ref<UgtOp>) : fatal("Illegal type.")
        (op:ref<UgeOp>) : fatal("Illegal type.")
      return ($ls-prim bits result)
    (type:ref<VMDouble>) :
      val yf = ($ls-prim fnum y)
      val zf = ($ls-prim fnum z)
      var result:double
      match(op) :
        (op:ref<AddOp>) : result = yf + zf
        (op:ref<SubOp>) : result = yf - zf 
        (op:ref<MulOp>) : result = yf * zf
        (op:ref<DivOp>) : result = yf / zf
        (op:ref<ModOp>) : fatal("Illegal type.")
        (op:ref<AndOp>) : fatal("Illegal type.")
        (op:ref<OrOp>) : fatal("Illegal type.")
        (op:ref<XorOp>) : fatal("Illegal type.")
        (op:ref<ShlOp>) : fatal("Illegal type.")
        (op:ref<ShrOp>) : fatal("Illegal type.")
        (op:ref<AshrOp>) : fatal("Illegal type.")
        (op:ref<EqOp>) : return yf == zf
        (op:ref<NeOp>) : return yf != zf
        (op:ref<LtOp>) : return yf < zf
        (op:ref<GtOp>) : return yf > zf
        (op:ref<LeOp>) : return yf <= zf
        (op:ref<GeOp>) : return yf >= zf
        (op:ref<UleOp>) : fatal("Illegal type.")
        (op:ref<UltOp>) : fatal("Illegal type.")
        (op:ref<UgtOp>) : fatal("Illegal type.")
        (op:ref<UgeOp>) : fatal("Illegal type.")
      return ($ls-prim bits result)

defn print-ins (ins:LinkedIns) :
  println("Trace (%_)" % [ins])

lostanza defn assign (frame:ptr<Frame>, l:ref<Local>, value:long) -> long :
  frame.slots[index(l).value] = value
  return 0

lostanza defn run (vm:ref<VirtualMachine>,
                   instructions:ref<Tuple<LinkedIns>>,
                   functions:ref<Tuple<Int>>,
                   class-table:ref<ClassTable>,
                   trace?:ref<True|False>) -> ref<False> :
  ;Define machine quantities                 
  val regs = vm.registers
  var heap-limit:ptr<long> = vm.heap-limit
  var frame-size:int
  var heap-end:ptr<long>
  var heap-top:ptr<long>
  var stack-pointer:ptr<Frame>
  var stack-end:ptr<Frame>
  var current-stack:long
  
  labels :
    begin :
      val mainpc = get(functions, new Int{0}).value
      val main-stack = alloc-stack(vm, mainpc)
      heap-end = vm.heap-end
      heap-top = vm.heap-top
      goto load-stack(main-stack)
    load-stack (stack:long) :
      current-stack = stack
      val sptr:ptr<Stack> = untag(current-stack)
      stack-pointer = sptr.stack-pointer
      stack-end = sptr.frames + sptr.size
      frame-size = sptr.frame-size
      goto step(sptr.pc)      
    call-function (fid:int, return:int) :
      val old-sp = stack-pointer
      stack-pointer = stack-pointer + frame-size
      stack-pointer.return = return
      stack-pointer.sp = old-sp
      val pos = get(functions, new Int{fid}).value
      goto step(pos)
    step (pc:int) :
      val ins = get(instructions, new Int{pc})
      if trace? == true : print-ins(ins)
      match(ins) :
        (ins:ref<NewStackIns>) :
          val fid = eval-imm(stack-pointer, fid(ins)) as int
          val fpc = get(functions, new Int{fid}).value
          vm.heap-top = heap-top
          vm.heap-end = heap-end          
          val stk = alloc-stack(vm, fpc)
          heap-top = vm.heap-top
          heap-end = vm.heap-end
          assign(stack-pointer, x(ins), stk)
          goto step(pc + 1)
        (ins:ref<SetIns>) :
          assign(stack-pointer, x(ins), eval-imm(stack-pointer, y(ins)))
          goto step(pc + 1)
        (ins:ref<Op0Ins>) :
          assign(stack-pointer, x(ins), eval-op(current-stack, op(ins)))
          goto step(pc + 1)        
        (ins:ref<LinkedOp1Ins>) :
          val y = eval-imm(stack-pointer, y(ins))
          assign(stack-pointer, x(ins), eval-op(class-table, type(ins), op(ins), y))
          goto step(pc + 1)        
        (ins:ref<LinkedOp2Ins>) :
          val y = eval-imm(stack-pointer, y(ins))
          val z = eval-imm(stack-pointer, z(ins))
          assign(stack-pointer, x(ins), eval-op(type(ins), op(ins), y, z))
          goto step(pc + 1)
        (ins:ref<ReserveIns>) :
          val size = eval-imm(stack-pointer, size(ins))
          if size & 0x7L : fatal("Size is not a multiple of 8.")
          val total-size = size + 8 * num-objects(ins).value
          heap-end = heap-end + total-size
          if heap-end > heap-limit : fatal("Out of heap memory.")
          goto step(pc + 1)
        (ins:ref<AllocIns>) :
          val size = eval-imm(stack-pointer, size(ins))
          if size & 0x7L : fatal("Size is not a multiple of 8.")
          val total-size = size + 8
          [heap-top] = type(ins).value
          assign(stack-pointer, x(ins), tag(heap-top))
          heap-top = heap-top + total-size
          if heap-top > heap-end : fatal("Beyond allocated limits.")
          goto step(pc + 1)
        (ins:ref<LinkedRefSetIns>) :
          val x = eval-imm(stack-pointer, x(ins))
          val y = eval-imm(stack-pointer, y(ins))
          val z = eval-imm(stack-pointer, z(ins))
          val xptr = untag(x)
          val sz = size(ins).value
          if sz == 1 : [xptr as ptr<byte> + y] = z as byte
          else if sz == 4 : [xptr as ptr<int> + y] = z as int
          else if sz == 8 : [xptr as ptr<long> + y] = z as long
          else : fatal("Invalid size.")
          goto step(pc + 1)
        (ins:ref<LinkedRefGetIns>) :
          val y = eval-imm(stack-pointer, y(ins))
          val z = eval-imm(stack-pointer, z(ins))
          val yptr:ptr<long> = untag(y)
          val sz = size(ins).value
          var value:long
          if sz == 1 : value = [yptr as ptr<byte> + z]
          else if sz == 4 : value = [yptr as ptr<int> + z]
          else if sz == 8 : value = [yptr as ptr<long> + z]
          else : fatal("Invalid size.")
          assign(stack-pointer, x(ins), value)
          goto step(pc + 1)
        (ins:ref<GotoIns>) :
          goto step(pc + n(ins).value)
        (ins:ref<Branch1Ins>) :
          val x = eval-imm(stack-pointer, x(ins))
          val r = eval-op(class-table, VMLong(), op(ins), x)
          if r : goto step(pc + n(ins).value)
          else : goto step(pc + 1)
        (ins:ref<LinkedBranch2Ins>) :
          val x = eval-imm(stack-pointer, x(ins))
          val y = eval-imm(stack-pointer, y(ins))
          val r = eval-op(type(ins), op(ins), x, y)
          if r : goto step(pc + n(ins).value)
          else : goto step(pc + 1)
        (ins:ref<SetReg>) :
          regs[reg(ins).value] = eval-imm(stack-pointer, x(ins))
          goto step(pc + 1)
        (ins:ref<GetReg>) :
          assign(stack-pointer, x(ins), regs[reg(ins).value])
          goto step(pc + 1)
        (ins:ref<LinkedCall>) :
          val fid = eval-imm(stack-pointer, f(ins)) as int
          goto call-function(fid, pc + 1)
        (ins:ref<LinkedCallClosure>) :
          val fref = eval-imm(stack-pointer, f(ins))
          val fptr = untag(fref) as ptr<Function>
          val fid = fptr.code as int
          goto call-function(fid, pc + 1)
        (ins:ref<LinkedYield>) :
          ;Save current stack
          val s:ptr<Stack> = untag(current-stack)
          s.stack-pointer = stack-pointer
          s.frame-size = frame-size
          s.pc = pc + 1
          ;Load next next
          val sref = eval-imm(stack-pointer, f(ins))          
          goto load-stack(sref)
        (ins:ref<LinkedReturn>) :
          val ret = stack-pointer.return as int
          if ret >= 0 :
            frame-size = (stack-pointer - stack-pointer.sp) as int
            stack-pointer = stack-pointer.sp
            goto step(ret)          
        (ins:ref<FunctionEntry>) :
          frame-size = (num-locals(ins).value * 8 + sizeof(Frame)) as int
          val size-required = frame-size + sizeof(Frame)
          if stack-pointer + size-required > stack-end : fatal("Stack overflow.")
          goto step(pc + 1)
        (ins:ref<LinkedDump>) :
          val xvalue = eval-imm(stack-pointer, x(ins))
          val xint = xvalue as int
          val xvaluef = ($ls-prim fnum xint)
          val xvalued = ($ls-prim fnum xvalue)
          call-c clib/printf("> L%d = %ld (float = %f, double = %f)\n", index(x(ins)).value, xvalue, xvaluef, xvalued)
          goto step(pc + 1)
  return false


;============================================================
;================ Overall Instruction Buffer ================
;============================================================
;deftype InsBuffer
;defmulti get (b:InsBuffer, i:Int) -> VMIns
;defmulti set (b:InsBuffer, i:Int, ins:VMIns) -> False
;defmulti alloc (b:InsBuffer, size:Int) -> Int
;defmulti free (b:InsBuffer, n:Int) -> False
;
;defn InsBuffer () :
;  val v = Vector<VMIns>()
;  val segments = IntTable<InsSegment>()
;  new InsBuffer :
;    defmethod get (this, i:Int) :
;      v[i]
;    defmethod set (this, i:Int, ins:VMIns) :
;      v[i] = ins
;    defmethod alloc (this, size:Int) -> Int :
;      val pos = length(v)
;      lengthen(v, length(v) + size, NoOpIns())
;      segments[pos] = InsSegment(size)
;      pos
;    defmethod free (this, n:Int) -> False :
;      fatal("Not yet implemented")
;
;defstruct InsSegment :
;  size: Int
;

;;============================================================
;;====================== Mappers =============================
;;============================================================
;
;deftype HasTargetLabel :
;  GotoIns <: HasTargetLabel
;  Branch1Ins <: HasTargetLabel
;  Branch2Ins <: HasTargetLabel
;
;defn map-labels (f:Int -> Int, ins:HasTargetLabel) -> VMIns&HasTargetLabel :
;  match(ins) :
;    (ins:GotoIns) : sub-n(ins, f(n(ins)))
;    (ins:Branch1Ins) : sub-n(ins, f(n(ins)))
;    (ins:Branch2Ins) : sub-n(ins, f(n(ins)))
;
;;============================================================
;;==================== Stack Layout ==========================
;;============================================================
;
;;STACK LAYOUT: [TAG | SIZE | SP | RETURN | FRAME-SIZE | FRAMES ...]
;val INITIAL-STACK-SIZE = 512 * 8
;val STACK-TYPE-TAG = -1
;val STACK-TAG-POS = 0
;val STACK-SIZE-POS = 8
;val STACK-SP-POS = 16
;val STACK-RETURN-POS = 24
;val STACK-FRAME-SIZE-POS = 32
;val STACK-FRAME-POS = 40
;
;;============================================================
;;==================== Interpretation ========================
;;============================================================
;defstruct FuncRecord :
;  id: Int
;  args: Tuple<VMType>
;  local-size: Int
;  pos: Int
;
;deftype HeapValue :
;  Int <: HeapValue
;  Double <: HeapValue
;  False <: HeapValue
;defstruct TypeTag <: HeapValue :
;  type: Int
;with: (printer => true)
;defstruct Reference <: HeapValue :
;  address: Int
;with: (printer => true)
;
;public defn interpret (prog:VMProg) :
;  ;Instruction buffer
;  val buffer = InsBuffer()
;  val func-records = IntTable<FuncRecord>()
;  val class-table = ClassTable(classes(prog))
;
;  ;Load a function into the VM
;  defn load-function (f:VMFunc) :
;    val pos = alloc(buffer, length(ins(f)))
;    val labels = IntTable<Int>()
;    within (delay) = with-delay() :
;      let loop (src:Int = 0, dst:Int = pos) :
;        if src < length(ins(f)) :
;          match(ins(f)[src]) :
;            (ins:LabelIns) :
;              labels[n(ins)] = dst
;              loop(src + 1, dst)
;            (ins:VMIns&HasTargetLabel) :
;              delay $ fn () :
;                buffer[dst] = map-labels({labels[_]}, ins)
;              loop(src + 1, dst + 1)
;            (ins) :
;              buffer[dst] = ins
;              match(ins:AllocIns) :
;                fatal("Invalid type %_" % [type(ins)]) when not class?(class-table, type(ins))
;              loop(src + 1, dst + 1)
;    func-records[id(f)] = FuncRecord(id(f), args(f), local-size(f), pos)
;  do(load-function, funcs(prog))
;
;  ;Define machine quantities
;  val registers = Array<HeapValue>(256, false)
;  val heap = IntTable<HeapValue>()
;  var heap-top:Int = 0
;  var heap-size:Int = 0
;  var current-stack:Reference
;  var stack-pointer:Int
;  var stack-end:Int
;  var current-frame-size:Int
;
;  ;Evaluation
;  defn eval (op:VMOp, y) :
;    match(op) :
;      (op:NotOp) : bit-not(y)
;      (op:NegOp) : negate(y)
;      (op:InstanceofOp) : bool-to-int(eval-pred(op, y))
;
;  defn eval (op:VMOp, y, z) :
;    match(op) :
;      (op:AddOp) : plus(y, z)
;      (op:SubOp) : minus(y, z)
;      (op:MulOp) : times(y, z)
;      (op:DivOp) : divide(y, z)
;      (op:ModOp) : modulo(y, z)
;      (op:AndOp) : bit-and(y, z)
;      (op:OrOp) : bit-or(y, z)
;      (op:XorOp) : bit-xor(y, z)
;      (op:ShlOp) : shift-left(y, z)
;      (op:ShrOp) : shift-right(y, z)
;      (op:AshrOp) : arithmetic-shift-right(y, z)
;      (op:EqOp) : bool-to-int(eval-pred(op, y, z))
;      (op:NeOp) : bool-to-int(eval-pred(op, y, z))
;      (op:LtOp) : bool-to-int(eval-pred(op, y, z))
;      (op:GtOp) : bool-to-int(eval-pred(op, y, z))
;      (op:LeOp) : bool-to-int(eval-pred(op, y, z))
;      (op:GeOp) : bool-to-int(eval-pred(op, y, z))
;      (op:UleOp) : bool-to-int(eval-pred(op, y, z))
;      (op:UltOp) : bool-to-int(eval-pred(op, y, z))
;      (op:UgtOp) : bool-to-int(eval-pred(op, y, z))
;      (op:UgeOp) : bool-to-int(eval-pred(op, y, z))
;
;  defn eval-pred (op:VMOp, y) :
;    match(op) :
;      (op:InstanceofOp) :
;        val tag = heap[address(y as Reference)] as TypeTag
;        instanceof?(class-table, type(tag), type(op))
;
;  defn eval-pred (op:VMOp, y, z) :
;    match(op) :
;      (op:EqOp) : equal?(y,z)
;      (op:NeOp) : not equal?(y, z)
;      (op:LtOp) : y < z
;      (op:GtOp) : y > z
;      (op:LeOp) : y <= z
;      (op:GeOp) : y >= z
;      (op:UleOp) : fatal("Not yet supported")
;      (op:UltOp) : fatal("Not yet supported")
;      (op:UgtOp) : fatal("Not yet supported")
;      (op:UgeOp) : fatal("Not yet supported")
;
;  ;Allocate a stack
;  defn alloc-stack (fid:Int) :
;    val s = Reference(heap-top)
;    heap-size = heap-size + INITIAL-STACK-SIZE
;    heap-top = heap-top + INITIAL-STACK-SIZE
;    val rec = func-records[fid]
;    store-field(s, STACK-TAG-POS, TypeTag(STACK-TYPE-TAG))
;    store-field(s, STACK-SIZE-POS, INITIAL-STACK-SIZE)
;    store-field(s, STACK-SP-POS, address(s) + STACK-FRAME-POS)
;    store-field(s, STACK-RETURN-POS, pos(rec))
;    store-field(s, STACK-FRAME-SIZE-POS, local-size(rec) + 16)
;    store-field(s, STACK-FRAME-POS + 0, false)
;    store-field(s, STACK-FRAME-POS + 8, false)
;    s
;
;  ;Load stack fields
;  defn load-field (r:Reference, field:Int) :
;    heap[address(r) + field]
;  defn store-field (r:Reference, field:Int, value) :
;    heap[address(r) + field] = value
;
;  ;Interpretation loop
;  defn* run (i:Int) :
;    ;Assign a value to a register
;    defn* assign (r:Reg, v:HeapValue) :
;      registers[index(r)] = v
;    defn eval-imm (imm:VMImm) :
;      match(imm) :
;        (r:Reg) : registers[index(r)]
;        (x:IntConst) : value(x)
;        (x:DoubleConst) : value(x)
;        (x:CodeId) : fid(x)
;    defn* step () : run(i + 1)
;    defn* jump (n:Int) : run(n)
;
;    val ins = buffer[i]
;    println("Trace: %_ (sp = %_)" % [ins, stack-pointer])
;    match(ins) :
;      (ins:SetIns) :
;        assign(x(ins), eval-imm(y(ins)))
;        step()
;      (ins:Op1Ins) :
;        assign(x(ins), eval(op(ins), eval-imm(y(ins))))
;        step()
;      (ins:Op2Ins) :
;        assign(x(ins), eval(op(ins), eval-imm(y(ins)), eval-imm(z(ins))))
;        step()
;      (ins:LabelIns) :
;        step()
;      (ins:GotoIns) :
;        jump(n(ins))
;      (ins:Branch1Ins) :
;        val pred = eval-pred(op(ins), eval-imm(x(ins)))
;        jump(n(ins)) when pred else step()
;      (ins:Branch2Ins) :
;        val pred = eval-pred(op(ins), eval-imm(x(ins)), eval-imm(y(ins)))
;        jump(n(ins)) when pred else step()
;      (ins:CallIns) :
;        call-func(fid(ins), i + 1)
;      (ins:CallClosureIns) :
;        val ref = eval-imm(x(ins)) as Reference
;        val fid = heap[address(ref) + 8 + 8] as Int
;        call-func(fid, i + 1)
;      (ins:ReturnIns) :
;        val return = heap[stack-pointer]
;        val old-sp = heap[stack-pointer + 8]
;        match(return:Int) :
;          current-frame-size = stack-pointer - old-sp as Int
;          stack-pointer = old-sp as Int
;          run(return)
;      (ins:YieldIns) :
;        ;Save current context
;        val s0 = current-stack
;        store-field(s0, STACK-SP-POS, stack-pointer)
;        store-field(s0, STACK-RETURN-POS, i + 1)
;        store-field(s0, STACK-FRAME-SIZE-POS, current-frame-size)
;        ;Load next context
;        val s = eval-imm(x(ins)) as Reference
;        load-stack(s)
;      (ins:NewStackIns) :
;        assign(x(ins), alloc-stack(fid(ins)))
;        step()
;      (ins:ReserveIns) :
;        val sz = eval-imm(size(ins)) as Int
;        fatal("Size is not a multiple of 8.") when not multiple8?(sz)
;        heap-size = heap-size + sz + 8 * num-objects(ins)
;        step()
;      (ins:AllocIns) :
;        val sz = eval-imm(size(ins)) as Int
;        val total-sz = sz + 8
;        fatal("Size is not a multiple of 8.") when not multiple8?(sz)
;        fatal("Beyond allocated limits.") when heap-top + total-sz > heap-size
;        heap[heap-top] = TypeTag(type(ins))
;        assign(x(ins), Reference(heap-top))
;        heap-top = heap-top + total-sz
;        step()
;      (ins:RefSetIns) :
;        val ref = eval-imm(x(ins)) as Reference
;        val offset = eval-imm(y(ins)) as Int
;        val value = eval-imm(z(ins))
;        val addr = address(ref) + 8 + offset
;        fatal("Out of heap bounds.") when (addr + size(type(ins))) > heap-size
;        heap[addr] = value
;        step()
;      (ins:RefGetIns) :
;        val ref = eval-imm(y(ins)) as Reference
;        val offset = eval-imm(z(ins)) as Int
;        val addr = address(ref) + 8 + offset
;        fatal("Out of heap bounds.") when (addr + size(type(ins))) > heap-size
;        assign(x(ins), heap[addr])
;        step()
;      (ins:GetLocalIns) :
;        val pos = stack-pointer + 16 + offset(ins)
;        fatal("Out of stack bounds.") when pos >= stack-pointer + current-frame-size
;        assign(x(ins), heap[pos])
;        step()
;      (ins:SetLocalIns) :
;        val pos = stack-pointer + 16 + offset(ins)
;        fatal("Out of stack bounds.") when pos >= stack-pointer + current-frame-size
;        heap[pos] = eval-imm(x(ins))
;        step()
;
;  defn* call-func (fid:Int, return:Int) :
;    val fp = stack-pointer + current-frame-size
;    fatal("Stack overflow.") when (fp + 16) > stack-end
;    heap[fp] = return
;    heap[fp + 8] = stack-pointer
;    stack-pointer = fp
;    val rec = func-records[fid]
;    current-frame-size = local-size(rec) + 16
;    run(pos(rec))
;
;  defn* load-stack (s:Reference) :
;    current-stack = s
;    stack-pointer = load-field(s, STACK-SP-POS) as Int
;    val ret = load-field(s, STACK-RETURN-POS) as Int
;    current-frame-size = load-field(s, STACK-FRAME-SIZE-POS) as Int
;    val stack-size = load-field(current-stack, STACK-SIZE-POS) as Int
;    stack-end = address(s) + stack-size
;    run(ret)
;
;  ;Start from main function 0
;  load-stack(alloc-stack(0))
;
;  ;Print result of registers
;  for (v in registers, i in 0 to false) do :
;    if v is-not False :
;      println("R%_ = %_" % [i, v])
;


;;============================================================
;;==================== Utilities =============================
;;============================================================
defn ensure-length<?T> (v:Vector<?T>, len:Int, x:T) :
  lengthen(v, len, x) when length(v) < len

defn set-at<?T> (v:Vector<?T>, i:Int, x:T, default:T) :
  ensure-length(v, i + 1, default) when length(v) <= i
  v[i] = x

;defn multiple8? (x:Int) :
;  (x & 0x7) == 0
;
;defn bool-to-int (x:True|False) :
;  1 when x else 0
;

var delay : (() -> ?) -> False =
  fn (f) : fatal("Not within delay-actions block.")
val DELAYS = Vector<(() -> ?)>()
defn delay-actions<?T> (f:() -> ?T) :
  defn delay-action (action:() -> ?)  : add(DELAYS, action)
  val result = let-var delay = delay-action : f()
  for d in DELAYS do : d()
  clear(DELAYS)
  result

;============================================================
;=================== Scratch Pad ============================
;============================================================

defn main () :
  val filename = command-line-arguments()[1]
  val prog = read-vm-prog(filename)
  println(prog)

  ;Link functions
  val linker = Linker()
  val func-table = Vector<Int|False>()
  for f in funcs(prog) do :
    set-at(func-table, id(f), link(linker,f), false)

  ;Link classes
  val class-table = ClassTable(classes(prog))
    
  ;Run
  val trace? = contains?(command-line-arguments(), "-trace")
  val vm = VirtualMachine()
  run(vm, instructions(linker), to-tuple(func-table as Vector<Int>),
      class-table, trace?)

main()
