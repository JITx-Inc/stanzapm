defpackage stz/vm :
  import core
  import collections
  import stz/vm-ir

;============================================================
;==================== Linked Instructions ===================
;============================================================

public deftype LinkedIns :
  NewStackIns <: LinkedIns
  SetIns <: LinkedIns
  Op0Ins <: LinkedIns
  Op1Ins <: LinkedIns
  Op2Ins <: LinkedIns
  ReserveIns <: LinkedIns
  AllocIns <: LinkedIns
  RefSetIns <: LinkedIns
  RefGetIns <: LinkedIns
  JumpIns <: LinkedIns

public deftype JumpIns :
  GotoIns <: JumpIns
  Branch1Ins <: JumpIns
  Branch2Ins <: JumpIns

public defstruct SetReg <: LinkedIns :
  reg: Int
  x: VMImm
public defstruct GetReg <: LinkedIns :
  x: Local
  reg: Int
public defstruct LinkedCall <: LinkedIns :
  f: VMImm
public defstruct LinkedCallClosure <: LinkedIns :
  f: VMImm
public defstruct LinkedYield <: LinkedIns :
  f: VMImm
public defstruct LinkedReturn <: LinkedIns

public defstruct FunctionEntry <: LinkedIns :
  num-locals:Int

;============================================================
;======================= Printer ============================
;============================================================

defmethod print (o:OutputStream, r:SetReg) :
  print(o, "reg %_ = %_" % [reg(r), x(r)])

defmethod print (o:OutputStream, r:GetReg) :
  print(o, "%_ = reg %_" % [x(r), reg(r)])

defmethod print (o:OutputStream, x:LinkedCall) :
  print(o, "call %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedCallClosure) :
  print(o, "call-closure %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedYield) :
  print(o, "yield %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedReturn) :
  print(o, "return")

defmethod print (o:OutputStream, x:FunctionEntry) :
  print(o, "enter (num-locals = %_)" % [num-locals(x)])

;============================================================
;======================= Linker =============================
;============================================================

deftype Linker
defmulti instructions (l:Linker) -> Tuple<LinkedIns>
defmulti link (l:Linker, f:VMFunc) -> Int

defn Linker () :
  ;===== Overall Buffer =====
  val ins-buffer = Vector<LinkedIns>()

  ;===== Temporary Linking Buffer =====
  val buffer = Vector<LinkedIns|False>()
  defn link (func:VMFunc) :
    ;Create mapping from local ID to slot
    val deftable = to-inttable<Int> $
      for def in defs(func) seq :
        id(def) => local(def)
    ;Substitute a local's abstract index with its frame slot
    defn sub-slot<?T> (x:VMImm&?T) -> T :
      {_ as VMImm&T} $
        match(x:Local) : Local(deftable[index(x)])
        else : x
    ;Create label table
    val label-table = IntTable<Int>()
    ;Replace the target destination with an offset
    defn sub-offset (jins:JumpIns, pos:Int) -> LinkedIns :
      val ins = jins as GotoIns|Branch1Ins|Branch2Ins
      sub-n(ins, label-table[n(ins)] - pos)
    ;Register Instructions
    defn get-regs (xs:Tuple<Local|False>) :
      for (x in xs, i in 0 to false) do :
        match(x:Local) :
          add(buffer, GetReg(sub-slot(x) as Local, i))
    defn set-regs (xs:Tuple<VMImm>) :
      for (x in xs, i in 0 to false) do :
        add(buffer, SetReg(i, sub-slot(x)))
    ;Link instructions
    within delay-actions() :
      ;Create entry instructions
      val num-locals = maximum(-1, seq(local, defs(func))) + 1
      add(buffer, FunctionEntry(num-locals))
      get-regs(args(func))
      ;Link and add to buffer
      for ins in ins(func) do :
        match(ins) :
          (ins:LabelIns) :
            label-table[n(ins)] = length(buffer)
          (ins:CallIns) :
            set-regs(ys(ins))
            add(buffer, LinkedCall(sub-slot(f(ins))))
            get-regs(xs(ins))
          (ins:CallClosureIns) :
            set-regs(ys(ins))
            add(buffer, LinkedCallClosure(sub-slot(f(ins))))
            get-regs(xs(ins))
          (ins:YieldIns) :
            set-regs(ys(ins))
            add(buffer, LinkedYield(sub-slot(f(ins))))
            get-regs(xs(ins))
          (ins:ReturnIns) :
            set-regs(xs(ins))
            add(buffer, LinkedReturn())
          (ins:JumpIns&VMIns) :
            val pos = length(buffer)
            add(buffer, false)
            within delay() :
              val ins* = map(sub-slot, ins) as JumpIns
              buffer[pos] = sub-offset(ins*, pos)
          (ins) :
            val ins* = map(sub-slot, ins)
            add(buffer, ins*)
    ;Dump to instruction buffer
    val pos = length(ins-buffer)
    add-all(ins-buffer, buffer as Seqable<LinkedIns>)
    clear(buffer)
    ;Return instruction address of linked function
    pos

  new Linker :
    defmethod instructions (this) :
      to-tuple(ins-buffer)
    defmethod link (this, f:VMFunc) :
      link(f)

defn map (f:VMImm -> VMImm, ins:VMIns) :
  defn flocal (x:Local) : f(x) as Local
  match(ins) :
    (ins:NewStackIns) : NewStackIns(flocal(x(ins)), f(fid(ins)))
    (ins:SetIns) : SetIns(flocal(x(ins)), f(y(ins)))
    (ins:Op0Ins) : Op0Ins(flocal(x(ins)), op(ins))
    (ins:Op1Ins) : Op1Ins(flocal(x(ins)), op(ins), f(y(ins)))
    (ins:Op2Ins) : Op2Ins(flocal(x(ins)), op(ins), f(y(ins)), f(z(ins)))
    (ins:GotoIns) : ins
    (ins:Branch1Ins) : Branch1Ins(n(ins), op(ins), f(x(ins)))
    (ins:Branch2Ins) : Branch2Ins(n(ins), op(ins), f(x(ins)), f(y(ins)))
    (ins:ReserveIns) : ins
    (ins:AllocIns) : AllocIns(flocal(x(ins)), type(ins), size(ins))
    (ins:RefSetIns) : RefSetIns(f(x(ins)), f(y(ins)), f(z(ins)))
    (ins:RefGetIns) : RefGetIns(flocal(x(ins)), f(y(ins)), f(z(ins)))

;============================================================
;==================== VM Constants ==========================
;============================================================

lostanza val REF-TAG:long = 1L

lostanza defn untag (x:long) -> ptr<?> :
  return (x - REF-TAG + 8) as ptr<?>

lostanza defn tag (x:ptr<?>) -> long :
  return (x + REF-TAG) as long

;============================================================
;==================== VM Implementation =====================
;============================================================

lostanza deftype VirtualMachine :
  registers: ptr<long>
  heap: ptr<long>
  heap-top: ptr<long>
  heap-end: ptr<long>
  heap-limit: ptr<long>
  current-stack: long
  stack-pointer: ptr<Frame>
  frame-size: int
  pc: int

lostanza deftype Frame :
  return: long
  sp: ptr<Frame>
  slots: long ...

lostanza deftype Stack :
  size: long
  frames: ptr<Frame>
  stack-pointer: ptr<Frame>
  frame-size: int
  pc: int

lostanza defn VirtualMachine () -> ref<VirtualMachine> :
  val registers = call-c clib/malloc(sizeof(ptr<?>) * 256)
  val heap = call-c clib/malloc(512 * 1024 * 1024)
  val heap-limit = heap + 512 * 1024 * 1024
  val null = 0L as ptr<?>
  return new VirtualMachine{registers, heap, heap, heap, heap-limit,
                            0L, null, 0, 0}

lostanza defn alloc-stack (vm:ref<VirtualMachine>, pc:int) -> long :
  val stack-size = 1024 * 1024
  val frames = call-c clib/malloc(stack-size)
  val s = tag(vm.heap-top)
  val null = 0L as ptr<?>
  vm.heap-top = vm.heap-top + 8 + sizeof(Stack)
  vm.heap-end = vm.heap-end + 8 + sizeof(Stack)
  val sptr = (s + 8) as ptr<Stack>
  sptr.size = stack-size
  sptr.frames = frames
  sptr.stack-pointer = frames
  sptr.frame-size = 0
  sptr.pc = pc
  sptr.frames.return = -1L
  sptr.frames.sp = null
  return s

lostanza defn eval-imm (registers:ptr<long>, x:ref<VMImm>) -> long :
  match(x) :
    (x:ref<Local>) :
      return registers[index(x).value]
    (x:ref<IntConst>) :
      return value(x).value
    (x:ref<DoubleConst>) :
      val v = value(x).value
      return ($ls-prim bits v)
    (x:ref<CodeId>) :
      return fid(x).value

defn print-ins (ins:LinkedIns) :
  println("Trace (%_)" % [ins])

lostanza defn assign (registers:ptr<long>, l:ref<Local>, value:long) -> long :
  registers[index(l).value] = value
  return 0

lostanza defn run (vm:ref<VirtualMachine>,
                   instructions:ref<Tuple<LinkedIns>>,
                   functions:ref<Tuple<Int>>) -> ref<False> :
  ;Define machine quantities                 
  val regs = vm.registers
  var heap-limit:ptr<long> = vm.heap-limit
  var frame-size:long
  var heap-end:ptr<long>
  var heap-top:ptr<long>
  var stack-pointer:ptr<Frame>
  var current-stack:long
  
  labels :
    begin :
      val mainpc = get(functions, new Int{0}).value
      val main-stack = alloc-stack(vm, mainpc)
      heap-end = vm.heap-end
      heap-top = vm.heap-top
      goto load-stack(main-stack)
    load-stack (stack:long) :
      current-stack = stack
      val sptr:ptr<Stack> = untag(current-stack)
      stack-pointer = sptr.stack-pointer
      frame-size = sptr.frame-size
      goto step(sptr.pc)      
    call-function (fid:int, return:int) :
      val old-sp = stack-pointer
      stack-pointer = stack-pointer + frame-size
      ;fatal("Stack overflow")
      stack-pointer.return = return
      stack-pointer.sp = old-sp
      val pos = get(functions, new Int{fid}).value
      goto step(pos)
    step (pc:int) :
      val ins = get(instructions, new Int{pc})
      print-ins(ins)
      match(ins) :
        (ins:ref<NewStackIns>) : fatal("Not yet implemented")
        (ins:ref<SetIns>) :
          assign(regs, x(ins), eval-imm(regs, y(ins)))
          goto step(pc + 1)
        (ins:ref<Op0Ins>) : fatal("Not yet implemented")
        (ins:ref<Op1Ins>) : fatal("Not yet implemented")
        (ins:ref<Op2Ins>) : fatal("Not yet implemented")
        (ins:ref<ReserveIns>) :
          val size = eval-imm(regs, size(ins))
          if size & 0x7L : fatal("Size is not a multiple of 8.")
          val total-size = size + 8 * num-objects(ins).value
          heap-end = heap-end + total-size
          if heap-end > heap-limit : fatal("Out of heap memory.")
          goto step(pc + 1)
        (ins:ref<AllocIns>) :
          val size = eval-imm(regs, size(ins))
          if size & 0x7L : fatal("Size is not a multiple of 8.")
          val total-size = size + 8
          [heap-top] = type(ins).value
          assign(regs, x(ins), tag(heap-top))
          heap-top = heap-top + total-size
          if heap-top > heap-end : fatal("Beyond allocated limits.")
          goto step(pc + 1)
        (ins:ref<RefSetIns>) :
          val x = eval-imm(regs, x(ins))
          val y = eval-imm(regs, y(ins))
          val z = eval-imm(regs, z(ins))
          val xptr:ptr<long> = untag(x)          ;TODO: Need size specifier
          [xptr + y] = z
          goto step(pc + 1)
        (ins:ref<RefGetIns>) : fatal("Not yet implemented")
        (ins:ref<GotoIns>) : fatal("Not yet implemented")
        (ins:ref<Branch1Ins>) : fatal("Not yet implemented")
        (ins:ref<Branch2Ins>) : fatal("Not yet implemented")
        (ins:ref<SetReg>) :
          regs[reg(ins).value] = eval-imm(regs, x(ins))
          goto step(pc + 1)
        (ins:ref<GetReg>) : fatal("Not yet implemented")
        (ins:ref<LinkedCall>) : fatal("Not yet implemented")
        (ins:ref<LinkedCallClosure>) : fatal("Not yet implemented")
        (ins:ref<LinkedYield>) : fatal("Not yet implemented")
        (ins:ref<LinkedReturn>) :
          fatal("Not yet implemented")
        (ins:ref<FunctionEntry>) :
          frame-size = num-locals(ins).value * 8 + 16
          goto step(pc + 1)    
  return false


;============================================================
;================ Overall Instruction Buffer ================
;============================================================
;deftype InsBuffer
;defmulti get (b:InsBuffer, i:Int) -> VMIns
;defmulti set (b:InsBuffer, i:Int, ins:VMIns) -> False
;defmulti alloc (b:InsBuffer, size:Int) -> Int
;defmulti free (b:InsBuffer, n:Int) -> False
;
;defn InsBuffer () :
;  val v = Vector<VMIns>()
;  val segments = IntTable<InsSegment>()
;  new InsBuffer :
;    defmethod get (this, i:Int) :
;      v[i]
;    defmethod set (this, i:Int, ins:VMIns) :
;      v[i] = ins
;    defmethod alloc (this, size:Int) -> Int :
;      val pos = length(v)
;      lengthen(v, length(v) + size, NoOpIns())
;      segments[pos] = InsSegment(size)
;      pos
;    defmethod free (this, n:Int) -> False :
;      fatal("Not yet implemented")
;
;defstruct InsSegment :
;  size: Int
;
;;============================================================
;;================= Class Display Analysis ===================
;;============================================================
;deftype ClassTable
;defmulti class? (this, c:Int) -> True|False
;defmulti instanceof? (t:ClassTable, child:Int, parent:Int) -> True|False
;
;public defn ClassTable (classes:Tuple<VMClass>) :
;  val class-table = to-inttable<VMClass> $
;    for c in classes seq : id(c) => c
;  val parent-table = IntTable<Tuple<Int>>()
;  defn @all-parents (c:Int) :
;    val rec = class-table[c]
;    to-tuple(cat([c], seq-cat(all-parents, parents(rec))))
;  defn all-parents (c:Int) :
;    if not key?(parent-table, c) :
;      parent-table[c] = @all-parents(c)
;    parent-table[c]
;  new ClassTable :
;    defmethod class? (this, c:Int) :
;      key?(class-table, c)
;    defmethod instanceof? (this, child:Int, parent:Int) :
;      contains?(all-parents(child), parent)
;
;;============================================================
;;====================== Mappers =============================
;;============================================================
;
;deftype HasTargetLabel :
;  GotoIns <: HasTargetLabel
;  Branch1Ins <: HasTargetLabel
;  Branch2Ins <: HasTargetLabel
;
;defn map-labels (f:Int -> Int, ins:HasTargetLabel) -> VMIns&HasTargetLabel :
;  match(ins) :
;    (ins:GotoIns) : sub-n(ins, f(n(ins)))
;    (ins:Branch1Ins) : sub-n(ins, f(n(ins)))
;    (ins:Branch2Ins) : sub-n(ins, f(n(ins)))
;
;;============================================================
;;==================== Stack Layout ==========================
;;============================================================
;
;;STACK LAYOUT: [TAG | SIZE | SP | RETURN | FRAME-SIZE | FRAMES ...]
;val INITIAL-STACK-SIZE = 512 * 8
;val STACK-TYPE-TAG = -1
;val STACK-TAG-POS = 0
;val STACK-SIZE-POS = 8
;val STACK-SP-POS = 16
;val STACK-RETURN-POS = 24
;val STACK-FRAME-SIZE-POS = 32
;val STACK-FRAME-POS = 40
;
;;============================================================
;;==================== Interpretation ========================
;;============================================================
;defstruct FuncRecord :
;  id: Int
;  args: Tuple<VMType>
;  local-size: Int
;  pos: Int
;
;deftype HeapValue :
;  Int <: HeapValue
;  Double <: HeapValue
;  False <: HeapValue
;defstruct TypeTag <: HeapValue :
;  type: Int
;with: (printer => true)
;defstruct Reference <: HeapValue :
;  address: Int
;with: (printer => true)
;
;public defn interpret (prog:VMProg) :
;  ;Instruction buffer
;  val buffer = InsBuffer()
;  val func-records = IntTable<FuncRecord>()
;  val class-table = ClassTable(classes(prog))
;
;  ;Load a function into the VM
;  defn load-function (f:VMFunc) :
;    val pos = alloc(buffer, length(ins(f)))
;    val labels = IntTable<Int>()
;    within (delay) = with-delay() :
;      let loop (src:Int = 0, dst:Int = pos) :
;        if src < length(ins(f)) :
;          match(ins(f)[src]) :
;            (ins:LabelIns) :
;              labels[n(ins)] = dst
;              loop(src + 1, dst)
;            (ins:VMIns&HasTargetLabel) :
;              delay $ fn () :
;                buffer[dst] = map-labels({labels[_]}, ins)
;              loop(src + 1, dst + 1)
;            (ins) :
;              buffer[dst] = ins
;              match(ins:AllocIns) :
;                fatal("Invalid type %_" % [type(ins)]) when not class?(class-table, type(ins))
;              loop(src + 1, dst + 1)
;    func-records[id(f)] = FuncRecord(id(f), args(f), local-size(f), pos)
;  do(load-function, funcs(prog))
;
;  ;Define machine quantities
;  val registers = Array<HeapValue>(256, false)
;  val heap = IntTable<HeapValue>()
;  var heap-top:Int = 0
;  var heap-size:Int = 0
;  var current-stack:Reference
;  var stack-pointer:Int
;  var stack-end:Int
;  var current-frame-size:Int
;
;  ;Evaluation
;  defn eval (op:VMOp, y) :
;    match(op) :
;      (op:NotOp) : bit-not(y)
;      (op:NegOp) : negate(y)
;      (op:InstanceofOp) : bool-to-int(eval-pred(op, y))
;
;  defn eval (op:VMOp, y, z) :
;    match(op) :
;      (op:AddOp) : plus(y, z)
;      (op:SubOp) : minus(y, z)
;      (op:MulOp) : times(y, z)
;      (op:DivOp) : divide(y, z)
;      (op:ModOp) : modulo(y, z)
;      (op:AndOp) : bit-and(y, z)
;      (op:OrOp) : bit-or(y, z)
;      (op:XorOp) : bit-xor(y, z)
;      (op:ShlOp) : shift-left(y, z)
;      (op:ShrOp) : shift-right(y, z)
;      (op:AshrOp) : arithmetic-shift-right(y, z)
;      (op:EqOp) : bool-to-int(eval-pred(op, y, z))
;      (op:NeOp) : bool-to-int(eval-pred(op, y, z))
;      (op:LtOp) : bool-to-int(eval-pred(op, y, z))
;      (op:GtOp) : bool-to-int(eval-pred(op, y, z))
;      (op:LeOp) : bool-to-int(eval-pred(op, y, z))
;      (op:GeOp) : bool-to-int(eval-pred(op, y, z))
;      (op:UleOp) : bool-to-int(eval-pred(op, y, z))
;      (op:UltOp) : bool-to-int(eval-pred(op, y, z))
;      (op:UgtOp) : bool-to-int(eval-pred(op, y, z))
;      (op:UgeOp) : bool-to-int(eval-pred(op, y, z))
;
;  defn eval-pred (op:VMOp, y) :
;    match(op) :
;      (op:InstanceofOp) :
;        val tag = heap[address(y as Reference)] as TypeTag
;        instanceof?(class-table, type(tag), type(op))
;
;  defn eval-pred (op:VMOp, y, z) :
;    match(op) :
;      (op:EqOp) : equal?(y,z)
;      (op:NeOp) : not equal?(y, z)
;      (op:LtOp) : y < z
;      (op:GtOp) : y > z
;      (op:LeOp) : y <= z
;      (op:GeOp) : y >= z
;      (op:UleOp) : fatal("Not yet supported")
;      (op:UltOp) : fatal("Not yet supported")
;      (op:UgtOp) : fatal("Not yet supported")
;      (op:UgeOp) : fatal("Not yet supported")
;
;  ;Allocate a stack
;  defn alloc-stack (fid:Int) :
;    val s = Reference(heap-top)
;    heap-size = heap-size + INITIAL-STACK-SIZE
;    heap-top = heap-top + INITIAL-STACK-SIZE
;    val rec = func-records[fid]
;    store-field(s, STACK-TAG-POS, TypeTag(STACK-TYPE-TAG))
;    store-field(s, STACK-SIZE-POS, INITIAL-STACK-SIZE)
;    store-field(s, STACK-SP-POS, address(s) + STACK-FRAME-POS)
;    store-field(s, STACK-RETURN-POS, pos(rec))
;    store-field(s, STACK-FRAME-SIZE-POS, local-size(rec) + 16)
;    store-field(s, STACK-FRAME-POS + 0, false)
;    store-field(s, STACK-FRAME-POS + 8, false)
;    s
;
;  ;Load stack fields
;  defn load-field (r:Reference, field:Int) :
;    heap[address(r) + field]
;  defn store-field (r:Reference, field:Int, value) :
;    heap[address(r) + field] = value
;
;  ;Interpretation loop
;  defn* run (i:Int) :
;    ;Assign a value to a register
;    defn* assign (r:Reg, v:HeapValue) :
;      registers[index(r)] = v
;    defn eval-imm (imm:VMImm) :
;      match(imm) :
;        (r:Reg) : registers[index(r)]
;        (x:IntConst) : value(x)
;        (x:DoubleConst) : value(x)
;        (x:CodeId) : fid(x)
;    defn* step () : run(i + 1)
;    defn* jump (n:Int) : run(n)
;
;    val ins = buffer[i]
;    println("Trace: %_ (sp = %_)" % [ins, stack-pointer])
;    match(ins) :
;      (ins:SetIns) :
;        assign(x(ins), eval-imm(y(ins)))
;        step()
;      (ins:Op1Ins) :
;        assign(x(ins), eval(op(ins), eval-imm(y(ins))))
;        step()
;      (ins:Op2Ins) :
;        assign(x(ins), eval(op(ins), eval-imm(y(ins)), eval-imm(z(ins))))
;        step()
;      (ins:LabelIns) :
;        step()
;      (ins:GotoIns) :
;        jump(n(ins))
;      (ins:Branch1Ins) :
;        val pred = eval-pred(op(ins), eval-imm(x(ins)))
;        jump(n(ins)) when pred else step()
;      (ins:Branch2Ins) :
;        val pred = eval-pred(op(ins), eval-imm(x(ins)), eval-imm(y(ins)))
;        jump(n(ins)) when pred else step()
;      (ins:CallIns) :
;        call-func(fid(ins), i + 1)
;      (ins:CallClosureIns) :
;        val ref = eval-imm(x(ins)) as Reference
;        val fid = heap[address(ref) + 8 + 8] as Int
;        call-func(fid, i + 1)
;      (ins:ReturnIns) :
;        val return = heap[stack-pointer]
;        val old-sp = heap[stack-pointer + 8]
;        match(return:Int) :
;          current-frame-size = stack-pointer - old-sp as Int
;          stack-pointer = old-sp as Int
;          run(return)
;      (ins:YieldIns) :
;        ;Save current context
;        val s0 = current-stack
;        store-field(s0, STACK-SP-POS, stack-pointer)
;        store-field(s0, STACK-RETURN-POS, i + 1)
;        store-field(s0, STACK-FRAME-SIZE-POS, current-frame-size)
;        ;Load next context
;        val s = eval-imm(x(ins)) as Reference
;        load-stack(s)
;      (ins:NewStackIns) :
;        assign(x(ins), alloc-stack(fid(ins)))
;        step()
;      (ins:ReserveIns) :
;        val sz = eval-imm(size(ins)) as Int
;        fatal("Size is not a multiple of 8.") when not multiple8?(sz)
;        heap-size = heap-size + sz + 8 * num-objects(ins)
;        step()
;      (ins:AllocIns) :
;        val sz = eval-imm(size(ins)) as Int
;        val total-sz = sz + 8
;        fatal("Size is not a multiple of 8.") when not multiple8?(sz)
;        fatal("Beyond allocated limits.") when heap-top + total-sz > heap-size
;        heap[heap-top] = TypeTag(type(ins))
;        assign(x(ins), Reference(heap-top))
;        heap-top = heap-top + total-sz
;        step()
;      (ins:RefSetIns) :
;        val ref = eval-imm(x(ins)) as Reference
;        val offset = eval-imm(y(ins)) as Int
;        val value = eval-imm(z(ins))
;        val addr = address(ref) + 8 + offset
;        fatal("Out of heap bounds.") when (addr + size(type(ins))) > heap-size
;        heap[addr] = value
;        step()
;      (ins:RefGetIns) :
;        val ref = eval-imm(y(ins)) as Reference
;        val offset = eval-imm(z(ins)) as Int
;        val addr = address(ref) + 8 + offset
;        fatal("Out of heap bounds.") when (addr + size(type(ins))) > heap-size
;        assign(x(ins), heap[addr])
;        step()
;      (ins:GetLocalIns) :
;        val pos = stack-pointer + 16 + offset(ins)
;        fatal("Out of stack bounds.") when pos >= stack-pointer + current-frame-size
;        assign(x(ins), heap[pos])
;        step()
;      (ins:SetLocalIns) :
;        val pos = stack-pointer + 16 + offset(ins)
;        fatal("Out of stack bounds.") when pos >= stack-pointer + current-frame-size
;        heap[pos] = eval-imm(x(ins))
;        step()
;
;  defn* call-func (fid:Int, return:Int) :
;    val fp = stack-pointer + current-frame-size
;    fatal("Stack overflow.") when (fp + 16) > stack-end
;    heap[fp] = return
;    heap[fp + 8] = stack-pointer
;    stack-pointer = fp
;    val rec = func-records[fid]
;    current-frame-size = local-size(rec) + 16
;    run(pos(rec))
;
;  defn* load-stack (s:Reference) :
;    current-stack = s
;    stack-pointer = load-field(s, STACK-SP-POS) as Int
;    val ret = load-field(s, STACK-RETURN-POS) as Int
;    current-frame-size = load-field(s, STACK-FRAME-SIZE-POS) as Int
;    val stack-size = load-field(current-stack, STACK-SIZE-POS) as Int
;    stack-end = address(s) + stack-size
;    run(ret)
;
;  ;Start from main function 0
;  load-stack(alloc-stack(0))
;
;  ;Print result of registers
;  for (v in registers, i in 0 to false) do :
;    if v is-not False :
;      println("R%_ = %_" % [i, v])
;
;defn size (t:VMType) :
;  match(t) :
;    (t:VMInt) : 4
;    (t:VMDouble) : 8
;    (t:VMRef) : 8
;    (t:VMPointer) : 8
;
;;============================================================
;;==================== Utilities =============================
;;============================================================
defn ensure-length<?T> (v:Vector<?T>, len:Int, x:T) :
  lengthen(v, len, x) when length(v) < len

defn set-at<?T> (v:Vector<?T>, i:Int, x:T, default:T) :
  ensure-length(v, i + 1, default) when length(v) <= i
  v[i] = x

;defn multiple8? (x:Int) :
;  (x & 0x7) == 0
;
;defn bool-to-int (x:True|False) :
;  1 when x else 0
;

var delay : (() -> ?) -> False =
  fn (f) : fatal("Not within delay-actions block.")
val DELAYS = Vector<(() -> ?)>()
defn delay-actions<?T> (f:() -> ?T) :
  defn delay-action (action:() -> ?)  : add(DELAYS, action)
  val result = let-var delay = delay-action : f()
  for d in DELAYS do : d()
  clear(DELAYS)
  result

;============================================================
;=================== Scratch Pad ============================
;============================================================

defn main () :
  val filename = command-line-arguments()[1]
  val prog = read-vm-prog(filename)
  println(prog)

  ;Link functions
  val linker = Linker()
  val func-table = Vector<Int|False>()
  for f in funcs(prog) do :
    set-at(func-table, id(f), link(linker,f), false)
    
  ;Run
  val vm = VirtualMachine()
  run(vm, instructions(linker), to-tuple(func-table as Vector<Int>))

main()
