defpackage stz/vm :
  import core
  import collections
  import stz/vm-ir

;============================================================
;==================== Linked Instructions ===================
;============================================================

public deftype LinkedIns :
  NewStackIns <: LinkedIns
  SetIns <: LinkedIns
  Op0Ins <: LinkedIns
  JumpIns <: LinkedIns

public deftype JumpIns :
  GotoIns <: JumpIns
  Branch1Ins <: JumpIns  

public defstruct LinkedStoreIns <: LinkedIns :
  size: Int
  x: VMImm
  y: VMImm
  z: VMImm
public defstruct LinkedLoadIns <: LinkedIns :
  size: Int
  x: Local
  y: VMImm
  z: VMImm  
public defstruct LinkedRefStoreIns <: LinkedIns :
  size: Int
  x: VMImm
  y: VMImm
  z: VMImm
public defstruct LinkedRefLoadIns <: LinkedIns :
  size: Int
  x: Local
  y: VMImm
  z: VMImm  
public defstruct SetReg <: LinkedIns :
  reg: Int
  x: VMImm
public defstruct GetReg <: LinkedIns :
  x: Local
  reg: Int
public defstruct PushFrameIns <: LinkedIns :
  frame-size: Int
public defstruct PopFrameIns <: LinkedIns :
  frame-size: Int
public defstruct LinkedCall <: LinkedIns :
  f: VMImm
public defstruct LinkedCallClosure <: LinkedIns :
  f: VMImm
public defstruct LinkedCallC <: LinkedIns :
  f: VMImm
  launcher: Long
public defstruct LinkedYield <: LinkedIns :
  f: VMImm
public defstruct LinkedReturn <: LinkedIns
public defstruct FunctionEntry <: LinkedIns :
  num-locals:Int
  map:Int
public defstruct LinkedDump <: LinkedIns :
  x: Local
public defstruct LinkedOp1Ins <: LinkedIns :
  type: VMType
  x: Local
  op: VMOp
  y: VMImm
public defstruct LinkedOp2Ins <: LinkedIns :
  type: VMType
  x: Local
  op: VMOp
  y: VMImm
  z: VMImm
public defstruct LinkedBranch2Ins <: LinkedIns :
  type: VMType
  n: Int with: (updater => sub-n)
  op: VMOp
  x: VMImm
  y: VMImm
public defstruct LinkedLiveIns <: LinkedIns :
  map: Int
public defstruct LinkedBranchRegIns <: LinkedIns :
  n: Int
  reg: Int
  value: Int  
public defstruct LinkedErrorIns <: LinkedIns :
  msg: String
public defstruct LinkedReserveIns <: LinkedIns :
  space: VMImm
  num-obj: Int
public defstruct LinkedAllocIns <: LinkedIns :
  x: Local
  type: Int
  size: VMImm

;============================================================
;======================= Printer ============================
;============================================================
defmethod print (o:OutputStream, i:LinkedReserveIns) :
  print(o, "reserve %_, %_" % [space(i), num-obj(i)])

defmethod print (o:OutputStream, i:LinkedAllocIns) :
  print(o, "%_ = alloc<%_> %_" % [x(i), type(i), size(i)])
  
defmethod print (o:OutputStream, i:LinkedErrorIns) :
  print(o, "error %~" % [msg(i)])
  
defmethod print (o:OutputStream, i:PushFrameIns) :
  print(o, "push-frame %_" % [frame-size(i)])

defmethod print (o:OutputStream, i:PopFrameIns) :
  print(o, "pop-frame %_" % [frame-size(i)])

defmethod print (o:OutputStream, i:LinkedStoreIns) :
  print(o, "%_[%_] = %_ (%_ bytes)" % [x(i), y(i), z(i), size(i)])

defmethod print (o:OutputStream, i:LinkedLoadIns) :
  print(o, "%_ = %_[%_] (%_ bytes)" % [x(i), y(i), z(i), size(i)])

defmethod print (o:OutputStream, i:LinkedRefStoreIns) :
  print(o, "ref %_[%_] = %_ (%_ bytes)" % [x(i), y(i), z(i), size(i)])

defmethod print (o:OutputStream, i:LinkedRefLoadIns) :
  print(o, "%_ = ref %_[%_] (%_ bytes)" % [x(i), y(i), z(i), size(i)])

defmethod print (o:OutputStream, i:LinkedOp1Ins) :
  print(o, "%_ = %_ %_ %_" % [x(i), type(i), op(i), y(i)])

defmethod print (o:OutputStream, i:LinkedOp2Ins) :
  print(o, "%_ = %_ %_ %_ %_" % [x(i), type(i), op(i), y(i), z(i)])

defmethod print (o:OutputStream, i:LinkedBranch2Ins) :
  print(o, "goto %_ when %_ %_ %_ %_" % [n(i), type(i), op(i), x(i), y(i)])

defmethod print (o:OutputStream, r:SetReg) :
  print(o, "reg %_ = %_" % [reg(r), x(r)])

defmethod print (o:OutputStream, r:GetReg) :
  print(o, "%_ = reg %_" % [x(r), reg(r)])

defmethod print (o:OutputStream, x:LinkedCall) :
  print(o, "call %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedCallC) :
  print(o, "call-c %_ (launcher %_)" % [f(x), launcher(x)])

defmethod print (o:OutputStream, x:LinkedCallClosure) :
  print(o, "call-closure %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedYield) :
  print(o, "yield %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedReturn) :
  print(o, "return")

defmethod print (o:OutputStream, x:FunctionEntry) :
  print(o, "enter (num-locals = %_, map = %_)" % [num-locals(x), map(x)])

defmethod print (o:OutputStream, ins:LinkedDump) :
  print(o, "dump %_" % [x(ins)])

defmethod print (o:OutputStream, ins:LinkedLiveIns) :
  print(o, "live %_" % [map(ins)])

defmethod print (o:OutputStream, ins:LinkedBranchRegIns) :
  print(o, "goto %_ when R%_ == %_" % [n(ins), reg(ins), value(ins)])

;============================================================
;======================= Linker =============================
;============================================================

deftype Linker
defmulti instructions (l:Linker) -> Tuple<LinkedIns>
defmulti link (l:Linker, f:VMFunction) -> Int
defmulti live-map-table (l:Linker) -> LiveMapTable

defn Linker () :
  ;===== Overall Buffer =====
  val ins-buffer = Vector<LinkedIns>()
  val live-map-table = LiveMapTable()

  ;===== Temporary Linking Buffer =====
  val buffer = Vector<LinkedIns|False>()
  defn delayed-ins (f:Int -> LinkedIns) :
    val pos = length(buffer)
    add(buffer, false)
    within delay() :
      buffer[pos] = f(pos)

  ;Link the function
  defn link (f:VMFunction) :
    ;Generate to temporary buffer
    match(f) :
      (f:VMMulti) : link-multi(f)
      (f:VMFunc) : link-func(f)
    ;Load into main buffer
    val pos = length(ins-buffer)
    add-all(ins-buffer, buffer as Seqable<LinkedIns>)
    clear(buffer)
    ;Return address of linked function
    pos

  ;Generate the code for a multi function
  defn link-multi (multi:VMMulti) :
    ;Get function position
    val function-pos = length(buffer)

    within delay-actions() :
      ;Fill in function position table
      val func-pos-table = IntTable<Int>()    
      ;Add branching instructions
      for entry in funcs(multi) do :
        within pos = delayed-ins() :
          val func-pos = func-pos-table[id(value(entry))]
          LinkedBranchRegIns(func-pos - pos, arg(multi), key(entry))
      ;Add default branch
      match(default(multi)) :
        (default:VMFunc) : link-func(default)          
        (multi:False) : add(buffer, LinkedErrorIns("Multi dispatch failure."))
      ;Branches
      for func in seq(value,funcs(multi)) do :
        func-pos-table[id(func)] = link-func(func)

    ;Return function position
    function-pos

  ;Generate the code for a single function
  defn link-func (func:VMFunc) :  
    ;Create mapping from local ID to slot
    val deftable = to-inttable<VMDef> $
      for def in defs(func) seq :
        id(def) => def
    ;Retrieve the size of an immediate
    defn imm-size (x:VMImm) :
      match(x:Local) : size(type(deftable[index(x)]))
      else : size(x)
    defn imm-type (x:VMImm) :
      match(x:Local) : type(deftable[index(x)])
      else : type(x)
    defn imm-type (x:False) :
      x
    defn simple-type (t:VMType) :
      match(t) :
        (t:VMRef) : VMLong()
        (t:VMPointer) : VMLong()
        (t) : t
    ;Create label table
    val label-table = IntTable<Int>()
    
    ;Compute relative locations
    defn link-ins<?T> (ins:VMIns&?T, pos:Int) -> T :
      defn sub-target (n:Int) :
        label-table[n] - pos
      defn sub-slot (x:Local) :
        Local(local(deftable[index(x)]))
      map(sub-target, sub-slot, ins) as VMIns&T

    ;Register Instructions
    defn get-regs (xs:Tuple<Local|False>) :
      for (x in xs, i in 0 to false) do :
        match(x:Local) :
          add(buffer, GetReg(x, i))
    defn set-regs (xs:Tuple<VMImm>) :
      for (x in xs, i in 0 to false) do :
        add(buffer, SetReg(i, x))
        
    ;Get function position
    val function-pos = length(buffer)
    
    ;Link instructions
    within delay-actions() :
      ;Create entry instructions
      val num-locals = maximum(-1, seq(local, defs(func))) + 1
      val frame-size = SIZEOF-FRAME + num-locals * 8
      val empty-map = LivenessMap([], num-locals)
      add(buffer, FunctionEntry(num-locals, map-index(live-map-table, empty-map)))
      get-regs(args(func))
      ;Link and add to buffer
      for ins in ins(func) do :
        val pos = length(buffer)        
        match(ins) :
          (ins:LabelIns) :
            label-table[n(ins)] = pos
          (ins:CallIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, PushFrameIns(frame-size))
            add(buffer, LinkedCall(f(ins*)))
            add(buffer, PopFrameIns(frame-size))
            get-regs(xs(ins*))
          (ins:CallCIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            val format = coalesce(CallFormat(xtypes, ytypes)) where :
              val xtypes = map(imm-type,xs(ins))
              val ytypes = map(imm-type,ys(ins))
            val launcher = FORMAT-TABLE[format]
            add(buffer, PushFrameIns(frame-size))
            add(buffer, LinkedCallC(f(ins*), launcher))
            add(buffer, PopFrameIns(frame-size))
            get-regs(xs(ins*))
          (ins:CallClosureIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, PushFrameIns(frame-size))
            add(buffer, LinkedCallClosure(f(ins*)))
            add(buffer, PopFrameIns(frame-size))
            get-regs(xs(ins*))
          (ins:YieldIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, LinkedYield(f(ins*)))
            get-regs(xs(ins*))
          (ins:ReturnIns) :
            val ins* = link-ins(ins, pos)
            set-regs(xs(ins*))
            add(buffer, LinkedReturn())
          (ins:DumpIns) :
            val ins* = link-ins(ins, pos)
            for x in xs(ins*) do :
              add(buffer, LinkedDump(x))
          (ins:RecordLiveIns) :
            val ins* = link-ins(ins, pos)
            val map = LivenessMap(map(index, live(ins*)), num-locals)
            val map-i = map-index(live-map-table, map)
            add(buffer, LinkedLiveIns(map-i))
          (ins:StoreIns) :
            val ins* = link-ins(ins, pos)
            val size = imm-size(z(ins))
            match(imm-type(x(ins))) :
              (t:VMRef) : add(buffer, LinkedRefStoreIns(size, x(ins*), y(ins*), z(ins*)))
              (t) : add(buffer, LinkedStoreIns(size, x(ins*), y(ins*), z(ins*)))
          (ins:LoadIns) :
            val ins* = link-ins(ins, pos)
            val size = imm-size(x(ins))
            match(imm-type(y(ins))) :
              (t:VMRef) : add(buffer, LinkedRefLoadIns(size, x(ins*), y(ins*), z(ins*)))
              (t) : add(buffer, LinkedLoadIns(size, x(ins*), y(ins*), z(ins*)))
          (ins:Op1Ins) :
            val ins* = link-ins(ins, pos)
            val t = simple-type(imm-type(y(ins)))
            add(buffer, LinkedOp1Ins(t, x(ins*), op(ins*), y(ins*)))
          (ins:Op2Ins) :
            val ins* = link-ins(ins, pos)
            val t = simple-type(imm-type(y(ins)))
            add(buffer, LinkedOp2Ins(t, x(ins*), op(ins*), y(ins*), z(ins*)))
          (ins:Branch2Ins) :
            within pos = delayed-ins() :
              val ins* = link-ins(ins, pos)
              val t = simple-type(imm-type(y(ins)))
              LinkedBranch2Ins(t, n(ins*), op(ins*), x(ins*), y(ins*))
          (ins:JumpIns&VMIns) :
            within pos = delayed-ins() :
              link-ins(ins, pos)
          (ins:NewStackIns) :
            val ins* = link-ins(ins, pos)
            add(buffer, LinkedReserveIns(NumConst(SIZEOF-STACK), 1))
            add(buffer, ins*)
          (ins:AllocIns) :
            val ins* = link-ins(ins, pos)
            if length(sizes(ins*)) == 1 :
              val x = xs(ins*)[0]
              val type = types(ins*)[0]
              val size = sizes(ins*)[0]
              add(buffer, LinkedReserveIns(size, 1))
              add(buffer, LinkedAllocIns(x, type, size))
            else :
              val num-obj = length(sizes(ins*))
              val size = sum $
                for s in sizes(ins*) seq :
                  value(s as NumConst) as Int
              add(buffer, LinkedReserveIns(NumConst(size), num-obj))
              for (x in xs(ins*), t in types(ins*), s in sizes(ins*)) do :
                add(buffer, LinkedAllocIns(x, t, s))
          (ins:LinkedIns&VMIns) :
            add(buffer, link-ins(ins, pos))
    ;Dump to instruction buffer
    function-pos

  new Linker :
    defmethod instructions (this) : to-tuple(ins-buffer)
    defmethod link (this, f:VMFunction) : link(f)
    defmethod live-map-table (this) : live-map-table

;============================================================
;================== Function Table ==========================
;============================================================
deftype FuncTable
defmulti address (f:FuncTable, fid:Int) -> Int

defn FuncTable (linker:Linker, prog:VMProg) :
  val table = Vector<Int|False>()
  for f in funcs(prog) do :
    set-at(table, id(f), link(linker,f), false)
  new FuncTable :
    defmethod address (this, fid:Int) -> Int :
      table[fid] as Int

;============================================================
;================= Live Map Analysis ========================
;============================================================
deftype LiveMapTable
defmulti map-index (t:LiveMapTable, map:LivenessMap) -> Int
defmulti get (t:LiveMapTable, i:Int) -> LivenessMap

defstruct LivenessMap <: Hashable&Equalable :
  live-slots: Tuple<Int>
  num-slots: Int
with:
  constructor => #LivenessMap
defn LivenessMap (slots:Tuple<Int>, num-slots:Int) :
  #LivenessMap(qsort(slots), num-slots)
defmethod hash (m:LivenessMap) :
  num-slots(m) + 7 * hash(live-slots(m))
defmethod equal? (a:LivenessMap, b:LivenessMap) :
  live-slots(a) == live-slots(b) and
  num-slots(a) == num-slots(b)

public defn LiveMapTable () :
  val maps = Vector<LivenessMap>()
  val table = HashTable<LivenessMap,Int>()
  defn add-map (m:LivenessMap) :
    table[m] = length(maps)
    add(maps, m)
  add-map(LivenessMap([], 0))
  new LiveMapTable :
    defmethod map-index (this, map:LivenessMap) :
      add-map(map) when not key?(table, map)
      table[map]
    defmethod get (this, i:Int) :
      maps[i]

;============================================================
;================= Class Display Analysis ===================
;============================================================
deftype ClassTable
defmulti class? (this, c:Int) -> True|False
defmulti instanceof? (t:ClassTable, child:Int, parent:Int) -> True|False
defmulti get (t:ClassTable, c:Int) -> VMClass

public defn ClassTable (classes:Tuple<VMClass>) :
  val class-table = to-inttable<VMClass> $
    for c in classes seq : id(c) => c
  val parent-table = IntTable<Tuple<Int>>()
  defn @all-parents (c:Int) :
    val rec = class-table[c]
    to-tuple(cat([c], seq-cat(all-parents, parents(rec))))
  defn all-parents (c:Int) :
    if not key?(parent-table, c) :
      parent-table[c] = @all-parents(c)
    parent-table[c]
  new ClassTable :
    defmethod class? (this, c:Int) :
      key?(class-table, c)
    defmethod instanceof? (this, child:Int, parent:Int) :
      contains?(all-parents(child), parent)
    defmethod get (this, c:Int) :
      class-table[c]

;============================================================
;==================== Extern Table ==========================
;============================================================

public deftype ExternTable
public defmulti get (t:ExternTable, i:Int) -> Long
public defmulti set (t:ExternTable, i:Int, addr:Long) -> False

defn ExternTable () :
  val table = Vector<Long|False>()
  new ExternTable :
    defmethod get (this, i:Int) :
      table[i] as Long
    defmethod set (this, i:Int, addr:Long) :
      set-at(table, i, addr, false)

public val EXTERN-TABLE = ExternTable()

;============================================================
;===================== Format Table =========================
;============================================================

public defstruct CallFormat <: Hashable&Equalable :
  xs: Tuple<VMType|False>
  ys: Tuple<VMType>
with :
  printer => true

defmethod hash (f:CallFormat) :
  hash(xs(f)) + 7 * hash(ys(f))
defmethod equal? (a:CallFormat, b:CallFormat) :
  xs(a) == xs(b) and ys(a) == ys(b)

public deftype FormatTable
public defmulti get (t:FormatTable, f:CallFormat) -> Long
public defmulti set (t:FormatTable, f:CallFormat, l:Long) -> False

defn FormatTable () :
  val table = HashTable<CallFormat,Long>()  
  new FormatTable :
    defmethod get (this, f:CallFormat) : table[f]
    defmethod set (this, f:CallFormat, l:Long) : table[f] = l

public val FORMAT-TABLE = FormatTable()

;============================================================
;=================== Format Coalescing ======================
;============================================================

defn exemplar-type (t:VMType) :
  match(t:VMRef|VMPointer) : VMLong()
  else : t

public defn coalesce (f:CallFormat) :
  ;New return result
  val x* =
    if empty?(xs(f)) :
      VMLong()
    else :
      match(xs(f)[0]) :
        (x:False) :
          VMLong()
        (x:VMType) :
          match(exemplar-type(x)) :
            (t:VMByte|VMInt) : VMLong()
            (t) : t

  ;New arguments
  val ys* = for y in ys(f) map :
    match(exemplar-type(y)) :
      (y:VMByte|VMInt) : VMLong()
      (y) : y

  ;Return coalesced call format
  CallFormat([x*], ys*)
    
;============================================================
;=================== Global Table ===========================
;============================================================

deftype GlobalTable
defmulti space (t:GlobalTable) -> Int
defmulti position (t:GlobalTable, gid:Int) -> Int
defmulti roots (t:GlobalTable) -> Seqable<Int>

defn GlobalTable (prog:VMProg) :
  val global-space = maximum{0, _} $ 
    for g in globals(prog) seq :
      position(g) + size(g)
  val table = Vector<VMGlobal|False>()
  for g in globals(prog) do :
    set-at(table, id(g), g, false)
  new GlobalTable :
    defmethod space (this) :
      global-space
    defmethod position (this, gid:Int) :
      position(table[gid] as VMGlobal)
    defmethod roots (this) :
      for g in filter-by<VMGlobal>(table) seq-cat :
        val root-base = position(g) / 8
        for r in roots(g) seq :
          root-base + r

;============================================================
;==================== VM Constants ==========================
;============================================================

lostanza val REF-TAG:long = 1L

lostanza defn untag (x:long) -> ptr<?> :
  return (x - REF-TAG + 8) as ptr<?>

lostanza defn tag (x:ptr<?>) -> long :
  return (x + REF-TAG) as long

;============================================================
;=================== VM Structures ==========================
;============================================================

lostanza deftype VirtualMachine :
  global-table: ref<GlobalTable>
  func-table: ref<FuncTable>
  live-map-table: ref<LiveMapTable>
  class-table: ref<ClassTable>
  registers: ptr<long>
  globals: ptr<long>
  heap: ptr<long>           ;[semi-variable]
  heap-top: ptr<long>       ;[variable]
  heap-limit: ptr<long>     ;[semi-variable]
  free: ptr<long>           ;[semi-variable]
  free-limit: ptr<long>     ;[semi-variable]
  current-stack: long       ;[variable]
  stack-pointer: ptr<Frame> ;[variable]
  pc: int                   ;[variable]

lostanza deftype Frame :
  return: long
  liveness-map: long
  slots: long ...

lostanza deftype Stack :
  size: long
  frames: ptr<Frame>
  stack-pointer: ptr<Frame>
  pc: int

lostanza deftype Function :
  num-slots: long
  code: long
  slots: long ...

lostanza deftype ObjectLayout :
  tag: long
  slots: long ...
  
lostanza deftype ArrayLayout :
  tag: long
  length: long
  slots: long ...

lostanza deftype BrokenHeartLayout :
  tag: long
  forward: long

lostanza val SIZEOF-FRAME:ref<Int> = new Int{sizeof(Frame) as int}
lostanza val SIZEOF-STACK:ref<Int> = new Int{sizeof(Stack) as int}
lostanza val STACK-TAG:long = 1L

lostanza defn stack-end (stackref:long) -> ptr<Frame> :
  val s:ptr<Stack> = untag(stackref)
  return s.frames + s.size

;============================================================
;==================== VM Implementation =====================
;============================================================

lostanza defn VirtualMachine (global-table:ref<GlobalTable>,
                              func-table: ref<FuncTable>,
                              live-map-table: ref<LiveMapTable>,
                              class-table: ref<ClassTable>) -> ref<VirtualMachine> :
  val registers = call-c clib/malloc(sizeof(ptr<?>) * 256)
  val globals = call-c clib/malloc(space(global-table).value)
  val heap-size = 3 * 1024
  val heap = call-c clib/malloc(heap-size)
  val heap-limit = heap + heap-size
  val free = call-c clib/malloc(heap-size)
  val free-limit = free + heap-size
  val null = 0L as ptr<?>
  return new VirtualMachine{global-table, func-table, live-map-table, class-table,
                            registers, globals, heap, heap, heap-limit,
                            free, free-limit, 0L, null, 0}

lostanza defn alloc-stack (vm:ref<VirtualMachine>, pc:int) -> long :
  ;Allocate stack on heap
  val s = tag(vm.heap-top)
  [vm.heap-top] = STACK-TAG
  vm.heap-top = vm.heap-top + 8 + sizeof(Stack)

  ;Allocate stack frames
  val stack-size = 4 * 1024
  val frames = call-c clib/malloc(stack-size)

  ;Fill in stack fields
  val sptr:ptr<Stack> = untag(s)
  sptr.size = stack-size
  sptr.frames = frames
  sptr.stack-pointer = frames
  sptr.pc = pc
  sptr.frames.return = -1L
  sptr.frames.liveness-map = 0L

  ;Return stack
  return s

lostanza defn call-c-function (function:long, registers:ptr<long>, format:int) -> long :
  if format == 0 :
    val fptr = function as ptr<((long long long long long long) -> long)>
    val result = call-c [fptr](registers[0], registers[1], registers[2], registers[3], registers[4], registers[5])
    registers[0] = result
    return 0
  else :
    fatal("Unknown format.")
    return 0

lostanza defn eval-imm (frame:ptr<Frame>, gt:ref<GlobalTable>, globals:ptr<long>, x:ref<VMImm>) -> long :
  match(x) :
    (x:ref<Local>) :
      return frame.slots[index(x).value]
    (x:ref<NumConst>) :
      match(value(x)) :
        (v:ref<Byte>) : return v.value
        (v:ref<Int>) : return v.value
        (v:ref<Long>) : return v.value
        (v:ref<Float>) :
          val value = v.value
          return ($ls-prim bits value)
        (v:ref<Double>) :
          val value = v.value
          return ($ls-prim bits value)
    (x:ref<CodeId>) :
      return fid(x).value
    (x:ref<ExternId>) :
      return get(EXTERN-TABLE,eid(x)).value
    (x:ref<GlobalId>) :
      val offset = position(gt, gid(x)).value
      return (globals + offset) as long

lostanza defn eval-op (current-stack:long, op:ref<VMOp>) -> long :
  match(op) :
    (op:ref<CurrentStackOp>) : return current-stack
  return 0

lostanza defn eval-op (class-table:ref<ClassTable>, type:ref<VMType>, op:ref<VMOp>, y:long) -> long :
  match(type) :
    (type:ref<VMByte>) :
      val y = y as byte
      match(op) :
        (op:ref<NotOp>) : return (~ y)
        (op) : (fatal("Illegal op."), return 0)
    (type:ref<VMInt>) :
      val y = y as int
      match(op) :
        (op:ref<NotOp>) : return (~ y)
        (op:ref<NegOp>) : return (- y)
        (op) : (fatal("Illegal op."), return 0)
    (type:ref<VMLong>) :
      match(op) :
        (op:ref<NotOp>) : return (~ y)
        (op:ref<NegOp>) : return (- y)
        (op:ref<InstanceofOp>) : 
          val tag = new Int{[(y - REF-TAG) as ptr<long>] as int}
          return instanceof?(class-table, tag, /type(op)) == true
        (op) : (fatal("Illegal op."), return 0)
    (type:ref<VMFloat>) :
      val yint = y as int
      val y = ($ls-prim fnum yint)
      match(op) :
        (op:ref<NegOp>) : return float-bits((- y))
        (op) : (fatal("Illegal op."), return 0)
    (type:ref<VMDouble>) :
      val y = ($ls-prim fnum y)
      match(op) :
        (op:ref<NegOp>) : return double-bits((- y))
        (op) : (fatal("Illegal op."), return 0)

lostanza defn float-bits (x:float) -> long : return ($ls-prim bits x)
lostanza defn double-bits (x:double) -> long : return ($ls-prim bits x)
lostanza defn eval-op (type:ref<VMType>, op:ref<VMOp>, y:long, z:long) -> long :
  match(type) :
    (type:ref<VMByte>) :
      val y = y as byte
      val z = z as byte
      match(op) :
        (op:ref<AddOp>) : return y + z
        (op:ref<SubOp>) : return y - z 
        (op:ref<MulOp>) : return y * z
        (op:ref<DivOp>) : return y / z
        (op:ref<ModOp>) : return y % z
        (op:ref<AndOp>) : return y & z
        (op:ref<OrOp>) : return y | z
        (op:ref<XorOp>) : return y ^ z
        (op:ref<ShlOp>) : return y << z
        (op:ref<ShrOp>) : return y >> z
        (op:ref<AshrOp>) : return y >>> z
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<UleOp>) : return ($ls-prim ule y z)
        (op:ref<UltOp>) : return ($ls-prim ult y z)
        (op:ref<UgtOp>) : return ($ls-prim ugt y z)
        (op:ref<UgeOp>) : return ($ls-prim uge y z)
        (op) : (fatal("Illegal operand."), return 0)
    (type:ref<VMInt>) :
      val y = y as int
      val z = z as int
      match(op) :
        (op:ref<AddOp>) : return y + z
        (op:ref<SubOp>) : return y - z 
        (op:ref<MulOp>) : return y * z
        (op:ref<DivOp>) : return y / z
        (op:ref<ModOp>) : return y % z
        (op:ref<AndOp>) : return y & z
        (op:ref<OrOp>) : return y | z
        (op:ref<XorOp>) : return y ^ z
        (op:ref<ShlOp>) : return y << z
        (op:ref<ShrOp>) : return y >> z
        (op:ref<AshrOp>) : return y >>> z
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<LtOp>) : return y < z
        (op:ref<GtOp>) : return y > z
        (op:ref<LeOp>) : return y <= z
        (op:ref<GeOp>) : return y >= z
        (op:ref<UleOp>) : return ($ls-prim ule y z)
        (op:ref<UltOp>) : return ($ls-prim ult y z)
        (op:ref<UgtOp>) : return ($ls-prim ugt y z)
        (op:ref<UgeOp>) : return ($ls-prim uge y z)
    (type:ref<VMLong>) :
      match(op) :
        (op:ref<AddOp>) : return y + z
        (op:ref<SubOp>) : return y - z 
        (op:ref<MulOp>) : return y * z
        (op:ref<DivOp>) : return y / z
        (op:ref<ModOp>) : return y % z
        (op:ref<AndOp>) : return y & z
        (op:ref<OrOp>) : return y | z
        (op:ref<XorOp>) : return y ^ z
        (op:ref<ShlOp>) : return y << z
        (op:ref<ShrOp>) : return y >> z
        (op:ref<AshrOp>) : return y >>> z
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<LtOp>) : return y < z
        (op:ref<GtOp>) : return y > z
        (op:ref<LeOp>) : return y <= z
        (op:ref<GeOp>) : return y >= z
        (op:ref<UleOp>) : return ($ls-prim ule y z)
        (op:ref<UltOp>) : return ($ls-prim ult y z)
        (op:ref<UgtOp>) : return ($ls-prim ugt y z)
        (op:ref<UgeOp>) : return ($ls-prim uge y z)
    (type:ref<VMFloat>) :
      val yint = y as int
      val zint = z as int
      val y = ($ls-prim fnum yint)
      val z = ($ls-prim fnum zint)
      match(op) :
        (op:ref<AddOp>) : return float-bits(y + z)
        (op:ref<SubOp>) : return float-bits(y - z )
        (op:ref<MulOp>) : return float-bits(y * z)
        (op:ref<DivOp>) : return float-bits(y / z)
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<LtOp>) : return y < z
        (op:ref<GtOp>) : return y > z
        (op:ref<LeOp>) : return y <= z
        (op:ref<GeOp>) : return y >= z
        (op) : (fatal("Illegal operand."), return 0)      
    (type:ref<VMDouble>) :
      val y = ($ls-prim fnum y)
      val z = ($ls-prim fnum z)
      match(op) :
        (op:ref<AddOp>) : return double-bits(y + z)
        (op:ref<SubOp>) : return double-bits(y - z )
        (op:ref<MulOp>) : return double-bits(y * z)
        (op:ref<DivOp>) : return double-bits(y / z)
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<LtOp>) : return y < z
        (op:ref<GtOp>) : return y > z
        (op:ref<LeOp>) : return y <= z
        (op:ref<GeOp>) : return y >= z
        (op) : (fatal("Illegal operand."), return 0)

defn print-ins (ins:LinkedIns) :
  println("Trace (%_)" % [ins])

lostanza defn assign (frame:ptr<Frame>, l:ref<Local>, value:long) -> long :
  frame.slots[index(l).value] = value
  return 0

lostanza defn run (vm:ref<VirtualMachine>,
                   instructions:ref<Tuple<LinkedIns>>,
                   trace?:ref<True|False>) -> ref<False> :
  ;Define machine quantities      
  val global-table = vm.global-table
  val func-table = vm.func-table
  val live-map-table = vm.live-map-table
  val class-table = vm.class-table
  val regs = vm.registers
  val globals = vm.globals
  var heap-limit:ptr<long> = vm.heap-limit          ;[LOAD]
  var heap-top:ptr<long>                            ;[STORE/LOAD]
  var stack-pointer:ptr<Frame>                      ;[STORE/LOAD]
  var stack-end:ptr<Frame>                          ;[LOAD]
  var current-stack:long                            ;[STORE/LOAD]
  
  labels :
    begin :
      ;Reserve and allocate initial stack
      val mainpc = address(func-table, new Int{0}).value
      val main-stack = alloc-stack(vm, mainpc)
      heap-top = vm.heap-top
      goto load-stack(main-stack)
    load-stack (stack:long) :
      current-stack = stack
      val sptr:ptr<Stack> = untag(current-stack)
      stack-pointer = sptr.stack-pointer
      stack-end = /stack-end(current-stack)
      goto step(sptr.pc)      
    call-function (fid:int, return:int) :
      val old-sp = stack-pointer
      stack-pointer.return = return
      val pos = address(func-table, new Int{fid}).value
      goto step(pos)
    step (pc:int) :
      val ins = get(instructions, new Int{pc})
      if trace? == true : print-ins(ins)
      match(ins) :
        (ins:ref<NewStackIns>) :
          val fid = eval-imm(stack-pointer, global-table, globals, fid(ins)) as int
          val fpc = address(func-table, new Int{fid}).value
          vm.heap-top = heap-top
          val stk = alloc-stack(vm, fpc)
          heap-top = vm.heap-top
          assign(stack-pointer, x(ins), stk)
          goto step(pc + 1)
        (ins:ref<SetIns>) :
          assign(stack-pointer, x(ins), eval-imm(stack-pointer, global-table, globals, y(ins)))
          goto step(pc + 1)
        (ins:ref<Op0Ins>) :
          assign(stack-pointer, x(ins), eval-op(current-stack, op(ins)))
          goto step(pc + 1)        
        (ins:ref<LinkedOp1Ins>) :
          val y = eval-imm(stack-pointer, global-table, globals, y(ins))
          assign(stack-pointer, x(ins), eval-op(class-table, type(ins), op(ins), y))
          goto step(pc + 1)        
        (ins:ref<LinkedOp2Ins>) :
          val y = eval-imm(stack-pointer, global-table, globals, y(ins))
          val z = eval-imm(stack-pointer, global-table, globals, z(ins))
          assign(stack-pointer, x(ins), eval-op(type(ins), op(ins), y, z))
          goto step(pc + 1)
        (ins:ref<LinkedReserveIns>) :
          val size = eval-imm(stack-pointer, global-table, globals, space(ins))
          if size & 0x7L : fatal("Size is not a multiple of 8.")
          val total-size = size + 8 * num-obj(ins).value          
          if heap-top + total-size > heap-limit :
            ;Store required values
            vm.heap-top = heap-top
            vm.stack-pointer = stack-pointer
            vm.current-stack = current-stack
            ;Run garbage collector
            extend-heap(vm, total-size)
            ;Load required values
            heap-limit = vm.heap-limit
            heap-top = vm.heap-top
            stack-pointer = vm.stack-pointer
            current-stack = vm.current-stack
            stack-end = /stack-end(current-stack)
          goto step(pc + 1)
        (ins:ref<LinkedAllocIns>) :
          val size = eval-imm(stack-pointer, global-table, globals, size(ins))
          val total-size = size + 8
          [heap-top] = type(ins).value
          assign(stack-pointer, x(ins), tag(heap-top))
          heap-top = heap-top + total-size
          if heap-top > heap-limit : fatal("Beyond heap limits.")
          goto step(pc + 1)
        (ins:ref<LinkedRefStoreIns>) :
          val x = eval-imm(stack-pointer, global-table, globals, x(ins))
          val y = eval-imm(stack-pointer, global-table, globals, y(ins))
          val z = eval-imm(stack-pointer, global-table, globals, z(ins))
          val xptr = untag(x)
          val sz = size(ins).value
          if sz == 1 : [xptr as ptr<byte> + y] = z as byte
          else if sz == 4 : [xptr as ptr<int> + y] = z as int
          else if sz == 8 : [xptr as ptr<long> + y] = z as long
          else : fatal("Invalid size.")
          goto step(pc + 1)
        (ins:ref<LinkedRefLoadIns>) :
          val y = eval-imm(stack-pointer, global-table, globals, y(ins))
          val z = eval-imm(stack-pointer, global-table, globals, z(ins))
          val yptr:ptr<long> = untag(y)
          val sz = size(ins).value
          var value:long
          if sz == 1 : value = [yptr as ptr<byte> + z]
          else if sz == 4 : value = [yptr as ptr<int> + z]
          else if sz == 8 : value = [yptr as ptr<long> + z]
          else : fatal("Invalid size.")
          assign(stack-pointer, x(ins), value)
          goto step(pc + 1)
        (ins:ref<LinkedStoreIns>) :
          val x = eval-imm(stack-pointer, global-table, globals, x(ins))
          val y = eval-imm(stack-pointer, global-table, globals, y(ins))
          val z = eval-imm(stack-pointer, global-table, globals, z(ins))
          val sz = size(ins).value
          if sz == 1 : [x as ptr<byte> + y] = z as byte
          else if sz == 4 : [x as ptr<int> + y] = z as int
          else if sz == 8 : [x as ptr<long> + y] = z as long
          else : fatal("Invalid size.")
          goto step(pc + 1)
        (ins:ref<LinkedLoadIns>) :
          val y = eval-imm(stack-pointer, global-table, globals, y(ins))
          val z = eval-imm(stack-pointer, global-table, globals, z(ins))
          val sz = size(ins).value
          var value:long
          if sz == 1 : value = [y as ptr<byte> + z]
          else if sz == 4 : value = [y as ptr<int> + z]
          else if sz == 8 : value = [y as ptr<long> + z]
          else : fatal("Invalid size.")
          assign(stack-pointer, x(ins), value)
          goto step(pc + 1)
        (ins:ref<GotoIns>) :
          goto step(pc + n(ins).value)
        (ins:ref<Branch1Ins>) :
          val x = eval-imm(stack-pointer, global-table, globals, x(ins))
          val r = eval-op(class-table, VMLong(), op(ins), x)
          if r : goto step(pc + n(ins).value)
          else : goto step(pc + 1)
        (ins:ref<LinkedBranch2Ins>) :
          val x = eval-imm(stack-pointer, global-table, globals, x(ins))
          val y = eval-imm(stack-pointer, global-table, globals, y(ins))
          val r = eval-op(type(ins), op(ins), x, y)
          if r : goto step(pc + n(ins).value)
          else : goto step(pc + 1)
        (ins:ref<SetReg>) :
          regs[reg(ins).value] = eval-imm(stack-pointer, global-table, globals, x(ins))
          goto step(pc + 1)
        (ins:ref<GetReg>) :
          assign(stack-pointer, x(ins), regs[reg(ins).value])
          goto step(pc + 1)
        (ins:ref<PushFrameIns>) :
          stack-pointer = stack-pointer + frame-size(ins).value
          goto step(pc + 1)
        (ins:ref<PopFrameIns>) :
          stack-pointer = stack-pointer - frame-size(ins).value
          goto step(pc + 1)
        (ins:ref<LinkedCall>) :          
          val fid = eval-imm(stack-pointer, global-table, globals, f(ins)) as int
          goto call-function(fid, pc + 1)
        (ins:ref<LinkedCallC>) :
          val faddr = eval-imm(stack-pointer, global-table, globals, f(ins))
          val launcher = launcher(ins).value as ptr<((long, ptr<long>) -> long)>
          [launcher](faddr, regs)
          goto step(pc + 1)
        (ins:ref<LinkedCallClosure>) :
          val fref = eval-imm(stack-pointer, global-table, globals, f(ins))
          val fptr = untag(fref) as ptr<Function>
          val fid = fptr.code as int
          goto call-function(fid, pc + 1)
        (ins:ref<LinkedYield>) :
          ;Save current stack
          val s:ptr<Stack> = untag(current-stack)
          s.stack-pointer = stack-pointer
          s.pc = pc + 1
          ;Load next next
          val sref = eval-imm(stack-pointer, global-table, globals, f(ins))          
          goto load-stack(sref)
        (ins:ref<LinkedReturn>) :
          val ret = stack-pointer.return as int
          if ret >= 0 : goto step(ret)          
        (ins:ref<FunctionEntry>) :
          val frame-size = (num-locals(ins).value * 8 + sizeof(Frame)) as int
          val size-required = frame-size + sizeof(Frame)
          if stack-pointer + size-required > stack-end :
            ;Store required values
            vm.heap-top = heap-top
            vm.stack-pointer = stack-pointer
            vm.current-stack = current-stack
            ;Run garbage collector
            extend-stack(vm, size-required)
            ;Load required values
            heap-limit = vm.heap-limit
            heap-top = vm.heap-top
            stack-pointer = vm.stack-pointer
            current-stack = vm.current-stack
            stack-end = /stack-end(current-stack)
          stack-pointer.liveness-map = map(ins).value
          goto step(pc + 1)
        (ins:ref<LinkedDump>) :
          val xvalue = eval-imm(stack-pointer, global-table, globals, x(ins))
          val xint = xvalue as int
          val xvaluef = ($ls-prim fnum xint)
          val xvalued = ($ls-prim fnum xvalue)
          call-c clib/printf("> L%d = %ld (float = %f, double = %f)\n",
                             index(x(ins)).value, xvalue, xvaluef, xvalued)
          goto step(pc + 1)
        (ins:ref<LinkedLiveIns>) :
          stack-pointer.liveness-map = map(ins).value
          goto step(pc + 1)
        (ins:ref<LinkedBranchRegIns>) :
          val rvalue = regs[reg(ins).value] as int
          if rvalue == value(ins).value : goto step(pc + n(ins).value)
          else : goto step(pc + 1)
        (ins:ref<LinkedErrorIns>) :
          fatal(msg(ins))
          
  return false

;============================================================
;==================== Garbage Collector =====================
;============================================================

extern memcpy : (ptr<?>, ptr<?>, long) -> int
lostanza defn extend-stack (vm:ref<VirtualMachine>, size:long) -> long :
  ;Retrieve current stack
  val s:ptr<Stack> = untag(vm.current-stack)
  ;Compute new size of stack
  val desired-size = vm.stack-pointer + size - s.frames
  var size*:long = s.size
  while size* < desired-size : size* = size* * 2
  ;Allocate new frames, and copy over old frames
  val frames* = call-c clib/malloc(size*)
  call-c memcpy(frames*, s.frames, s.size)
  ;Free old frames and swap in new frames
  val sp-pos = vm.stack-pointer - s.frames
  call-c clib/free(s.frames)
  s.size = size*
  s.frames = frames*
  vm.stack-pointer = s.frames + sp-pos
  ;Return  
  return 0

lostanza defn extend-heap (vm:ref<VirtualMachine>, size:long) -> long :
  ;First run the garbage collector,
  collect-garbage(vm)
  
  ;then check whether we're still out of space.
  if vm.heap-top + size > vm.heap-limit :
    ;Compute desired heap size
    val desired-space = vm.heap-top + size - vm.heap
    var space:long = vm.heap-limit - vm.heap    
    while space < desired-space : space = space * 2
    ;Resize the heap and use the GC to move contents over
    resize-freespace(vm, space)
    collect-garbage(vm)
    resize-freespace(vm, space)
    ;Now we have enough space.
    return 0

  ;at this point, we don't need to expand the heap,
  ;but we might want to for next time. 
  else :
    ;Expand the freeheap if we're using more than 50% of it,
    ;or if the heapspace is bigger than the freespace.
    val used-space = vm.heap-top - vm.heap
    val heap-space = vm.heap-limit - vm.heap
    val free-space = vm.free-limit - vm.free
    val usage-ratio = (used-space as float) / (heap-space as float)
    ;Resize free if the usage-ratio is too high
    if usage-ratio > 0.5f :
      resize-freespace(vm, heap-space * 2)
    ;Otherwise resize free if the heap is larger than free
    else if heap-space > free-space :
      resize-freespace(vm, heap-space)
    ;We have enough space to satisfy the request
    return 0  

lostanza defn resize-freespace (vm:ref<VirtualMachine>, space:long) -> int :
  call-c clib/free(vm.free)
  vm.free = call-c clib/malloc(space)
  vm.free-limit = vm.free + space
  return 0

lostanza defn collect-garbage (vm:ref<VirtualMachine>) -> long :  
  ;Swap free with heap
  val heap = vm.heap
  val heap-limit = vm.heap-limit
  val free = vm.free
  val free-limit = vm.free-limit
  vm.heap = free
  vm.heap-top = free
  vm.heap-limit = free-limit
  vm.free = heap
  vm.free-limit = heap-limit

  ;Cap the current stack
  val s:ptr<Stack> = untag(vm.current-stack)
  s.stack-pointer = vm.stack-pointer

  ;Scan global roots
  val globals = vm.globals
  val roots = to-seq(roots(vm.global-table))
  while empty?(roots) == false :
    val i = next(roots).value
    globals[i] = post-gc-object(globals[i], vm)

  ;Scan stack roots
  vm.current-stack = post-gc-object(vm.current-stack, vm)

  ;Scan heap
  scan-heap(vm)

  ;Return
  return 0

lostanza defn num-slots (f:ptr<Frame>, vm:ref<VirtualMachine>) -> int :
  val map = get(vm.live-map-table, new Int{f.liveness-map as int})
  return num-slots(map).value

lostanza defn scan-frames (frames:ptr<Frame>, f-end:ptr<Frame>, vm:ref<VirtualMachine>) -> int :
  var f:ptr<Frame> = frames
  while f <= f-end :
    val map = get(vm.live-map-table, new Int{f.liveness-map as int})
    val live-slots = live-slots(map)
    val num-live = length(live-slots).value
    for (var i:int = 0, i < num-live, i = i + 1) :
      val s = get(live-slots, new Int{i}).value
      f.slots[s] = post-gc-object(f.slots[s], vm)
    f = addr(f.slots[num-slots(map).value]) as ptr<Frame>
  return 0

lostanza defn scan-heap (vm:ref<VirtualMachine>) -> int :
  var p:ptr<long> = vm.heap
  while p < vm.heap-top :
    p = scan-object(p, vm)
  return 0

lostanza defn scan-object (p:ptr<long>, vm:ref<VirtualMachine>) -> ptr<long> :
  ;p is [tag, cells ...]
  val tag = [p] as int
  ;Special class Stack
  if tag == STACK-TAG :
    val s = (p + 8) as ptr<Stack>
    scan-frames(s.frames, s.stack-pointer, vm)
    return p + 8 + sizeof(Stack)
  else :
    val class = get(vm.class-table, new Int{tag})
    match(class) :
      (class:ref<VMLeafClass>) :
        ;Get properties
        val size = size(class).value
        val roots = roots(class)
        val num-roots = length(roots).value
        ;Scan slots
        val obj = p as ptr<ObjectLayout>      
        for (var i:int = 0, i < num-roots, i = i + 1) :
          val r = get(roots, new Int{i}).value
          obj.slots[r] = post-gc-object(obj.slots[r], vm)
        ;Return end of object
        return p + 8 + size
      (class:ref<VMArrayClass>) :
        ;Get properties
        val base-roots = base-roots(class)
        val item-roots = item-roots(class)
        val base-size = base-size(class).value
        val item-size = item-size(class).value
        val num-base-roots = length(base-roots).value
        val num-item-roots = length(item-roots).value
        ;Scan base roots
        val array = p as ptr<ArrayLayout>
        for (var i:int = 0, i < num-base-roots, i = i + 1) :
          val r = get(base-roots, new Int{i}).value
          array.slots[r] = post-gc-object(array.slots[r], vm)
        ;Scan item roots
        var items:ptr<long> = addr(array.slots) + base-size
        val len = array.length
        if num-item-roots > 0 :
          for (var n:long = 0, n < len, n = n + 1) :
            for (var i:int = 0, i < num-item-roots, i = i + 1) :
              val r = get(item-roots, new Int{i}).value
              items[r] = post-gc-object(items[r], vm)
            items = items + item-size
        ;Return end of array
        val size = (8 + base-size + item-size * len + 7L) & -8L
        return p + size

lostanza defn post-gc-object (ref:long, vm:ref<VirtualMachine>) -> long :  
  val tagbits = ref & 7L
  if tagbits == REF-TAG :
    val obj = (ref - REF-TAG) as ptr<long>
    val obj-tag = [obj]
    ;Case: Broken Heart
    if obj-tag == -1L :
      val heart = obj as ptr<BrokenHeartLayout>
      return heart.forward
    ;Case: Uncopied object
    else :
      val obj* = tag(vm.heap-top)
      val class = get(vm.class-table, new Int{obj-tag as int})
      copy-bytes-to-heap(obj, num-bytes(obj, class, vm), vm)
      set-broken-heart(obj, obj*)
      return obj*
  else :
    fatal("Tagged primitives not yet supported")
    return 0

lostanza defn set-broken-heart (obj:ptr<long>, obj*:long) -> int :
  val heart = obj as ptr<BrokenHeartLayout>
  heart.tag = -1L
  heart.forward = obj*
  return 0

lostanza defn num-bytes (obj:ptr<?>, class:ref<VMClass>, vm:ref<VirtualMachine>) -> long :
  match(class) :
    (class:ref<VMLeafClass>) :
      return 8 + size(class).value
    (class:ref<VMArrayClass>) :
      val array = obj as ptr<ArrayLayout>
      val base-size = base-size(class).value
      val item-size = item-size(class).value
      return (8 + base-size + array.length * item-size + 7) & -8L
  
lostanza defn copy-bytes-to-heap (p:ptr<?>, n:long, vm:ref<VirtualMachine>) -> int :
  val heap = vm.heap-top
  val nwords = n >>> 3
  val src = p as ptr<long>
  for (var i:long = 0, i < nwords, i = i + 1) :
    heap[i] = src[i]
  vm.heap-top = heap + n
  return 0

;============================================================
;===================== Debugging ============================
;============================================================

lostanza defn dump-heap (pstart:ptr<long>, pend:ptr<long>, vm:ref<VirtualMachine>) -> int :
  val stackrefs = Vector<Long>()
  call-c clib/printf("Heap:\n")
  var p:ptr<long> = pstart
  while p < pend :
    val tag = [p] as int
    if tag == STACK-TAG :
      add(stackrefs, new Long{/tag(p)})      
    val class = get(vm.class-table, new Int{tag})
    match(class) :
      (class:ref<VMLeafClass>) :
        val obj = p as ptr<ObjectLayout>
        val size = size(class).value
        call-c clib/printf("  %p: [Object %d, size = %d]", /tag(p), tag, size)
        for (var i:long = 0, i < size, i = i + 8) :
          call-c clib/printf("  %lx", [p + 8 + i])
        call-c clib/printf("\n")
        ;Advance to next object
        p = p + 8 + size
      (class:ref<VMArrayClass>) :
        val array = p as ptr<ArrayLayout>
        val base-size = base-size(class).value
        val item-size = item-size(class).value
        val size = base-size + item-size * array.length 
        call-c clib/printf("  %p: [Array %d, length = %ld, base-size = %d, item-size = %d]",
                           /tag(p), tag, array.length, base-size, item-size)
        for (var i:long = 0, i < size, i = i + 8) :
          call-c clib/printf("  %lx", [p + 8 + i])
        call-c clib/printf("\n")
        ;Advance to next object
        p = p + (8 + size + 7) & -8L  
  ;Dump stacks
  for (var i:int = 0, i < length(stackrefs).value, i = i + 1) :
    val s = get(stackrefs, new Int{i})
    dump-stack(s.value, vm)
  return 0

lostanza defn dump-stack (stackref:long, vm:ref<VirtualMachine>) -> int :
  val stk:ptr<Stack> = untag(stackref)
  var f:ptr<Frame> = stk.frames
  val f-end = stk.stack-pointer
  call-c clib/printf("Stack %p:\n", stackref)
  while f <= f-end :
    ;Get frame properties
    val map = get(vm.live-map-table, new Int{f.liveness-map as int})
    val live-slots = live-slots(map)
    val num-live = length(live-slots).value
    val num-slots = num-slots(map).value
    ;Print properties
    call-c clib/printf("  %p: [Frame %ld, num-slots = %d]", f, f.liveness-map, num-slots)
    for (var i:int = 0, i < num-slots, i = i + 1) :
      call-c clib/printf("  %lx", f.slots[i])
    call-c clib/printf("\n")
    ;Advance to next frame
    f = addr(f.slots[num-slots]) as ptr<Frame>    
  return 0

;============================================================
;==================== Utilities =============================
;============================================================
defn ensure-length<?T> (v:Vector<?T>, len:Int, x:T) :
  lengthen(v, len, x) when length(v) < len

defn set-at<?T> (v:Vector<?T>, i:Int, x:T, default:T) :
  ensure-length(v, i + 1, default) when length(v) <= i
  v[i] = x

var delay : (() -> ?) -> False =
  fn (f) : fatal("Not within delay-actions block.")
defn delay-actions<?T> (f:() -> ?T) :
  val delays = Vector<(() -> ?)>()
  defn delay-action (action:() -> ?)  : add(delays, action)
  val result = let-var delay = delay-action : f()
  for d in delays do : d()
  clear(delays)
  result

;============================================================
;======================= Driver =============================
;============================================================

public defn interpret (prog:VMProg, trace?:True|False) :
  ;Create tables
  val linker = Linker()
  val global-table = GlobalTable(prog)
  val func-table = FuncTable(linker, prog)  
  val class-table = ClassTable(classes(prog))

  ;Create virtual machine
  val vm = VirtualMachine(global-table, func-table, live-map-table(linker), class-table)

  ;Run virtual machine
  run(vm, instructions(linker), trace?)