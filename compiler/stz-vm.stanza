defpackage stz/vm :
  import core
  import collections
  import reader

;============================================================
;================== Design of Instructions ==================
;============================================================

public defstruct VMProg :
  classes: Tuple<VMClass>
  funcs: Tuple<VMFunc>

public deftype VMImm
public defstruct Reg <: VMImm :
  index: Int
public defstruct IntConst <: VMImm :
  value: Int
public defstruct DoubleConst <: VMImm :
  value: Double
public defstruct CodeId <: VMImm :
  fid: Int

public deftype VMType
public defstruct VMInt <: VMType
public defstruct VMDouble <: VMType
public defstruct VMRef <: VMType
public defstruct VMPointer <: VMType

public defstruct VMFunc :
  id: Int
  args: Tuple<VMType>
  local-size: Int
  ins: Tuple<VMIns>

public deftype VMClass
public defmulti id (c:VMClass) -> Int
public defmulti parents (c:VMClass) -> Tuple<Int>

public defstruct VMArrayClass <: VMClass :
  id: Int with: (as-method => true)
  parents: Tuple<Int> with: (as-method => true)
  base-size: Int
  item-size: Int
public defstruct VMLeafClass <: VMClass :
  id: Int with: (as-method => true)
  parents: Tuple<Int> with: (as-method => true)
  size: Int
public defstruct VMAbstractClass <: VMClass :
  id: Int with: (as-method => true)
  parents: Tuple<Int> with: (as-method => true)

public deftype VMIns
public defstruct CallIns <: VMIns :
  fid: Int
public defstruct CallClosureIns <: VMIns :
  x: VMImm
public defstruct YieldIns <: VMIns :
  x: VMImm
public defstruct NewStackIns <: VMIns :
  x: Reg
  fid: Int
public defstruct SetIns <: VMIns :
  x: Reg
  y: VMImm
public defstruct Op1Ins <: VMIns :
  x: Reg
  op: VMOp
  y: VMImm
public defstruct Op2Ins <: VMIns :
  x: Reg
  op: VMOp
  y: VMImm
  z: VMImm
public defstruct LabelIns <: VMIns :
  n: Int
public defstruct GotoIns <: VMIns :
  n: Int with: (updater => sub-n)
public defstruct Branch1Ins <: VMIns :
  n: Int with: (updater => sub-n)
  op: VMOp
  x: VMImm
public defstruct Branch2Ins <: VMIns :
  n: Int with: (updater => sub-n)
  op: VMOp
  x: VMImm
  y: VMImm
public defstruct ReserveIns <: VMIns :
  num-objects: Int
  size: VMImm
public defstruct AllocIns <: VMIns :
  x: Reg
  type: Int
  size: VMImm
public defstruct RefSetIns <: VMIns :
  type: VMType
  x: VMImm
  y: VMImm
  z: VMImm
public defstruct RefGetIns <: VMIns :
  type: VMType
  x: Reg
  y: VMImm
  z: VMImm
public defstruct GetLocalIns <: VMIns :
  x: Reg
  type: VMType
  offset: Int
public defstruct SetLocalIns <: VMIns :
  type: VMType
  offset: Int
  x: VMImm
public defstruct ReturnIns <: VMIns 
public defstruct NoOpIns <: VMIns

public deftype VMOp
public defstruct AddOp <: VMOp : (type:VMType)
public defstruct SubOp <: VMOp : (type:VMType)
public defstruct MulOp <: VMOp : (type:VMType)
public defstruct DivOp <: VMOp : (type:VMType)
public defstruct ModOp <: VMOp : (type:VMType)
public defstruct AndOp <: VMOp : (type:VMType)
public defstruct OrOp <: VMOp : (type:VMType)
public defstruct XorOp <: VMOp : (type:VMType)
public defstruct NotOp <: VMOp : (type:VMType)
public defstruct ShlOp <: VMOp : (type:VMType)
public defstruct ShrOp <: VMOp : (type:VMType)
public defstruct AshrOp <: VMOp : (type:VMType)
public defstruct EqOp <: VMOp : (type:VMType)
public defstruct NeOp <: VMOp : (type:VMType)
public defstruct LtOp <: VMOp : (type:VMType)
public defstruct GtOp <: VMOp : (type:VMType)
public defstruct LeOp <: VMOp : (type:VMType)
public defstruct GeOp <: VMOp : (type:VMType)
public defstruct UleOp <: VMOp : (type:VMType)
public defstruct UltOp <: VMOp : (type:VMType)
public defstruct UgtOp <: VMOp : (type:VMType)
public defstruct UgeOp <: VMOp : (type:VMType)
public defstruct NegOp <: VMOp : (type:VMType)
public defstruct InstanceofOp <: VMOp : (type:Int)

;============================================================
;==================== Printer ===============================
;============================================================

defmethod print (o:OutputStream, p:VMProg) :
  for (x in cat(classes(p), funcs(p)), i in 0 to false) do :
    if i == 0 : print(o, x)
    else : lnprint(o, x)

defmethod print (o:OutputStream, f:VMFunc) :
  print(o, "func %_ (%,) :" % [id(f), args(f)])
  val o2 = IndentedStream(o)
  lnprint(o2, "local-size = %_" % [local-size(f)])
  do(lnprint{o2, _}, ins(f))
  
defmethod print (o:OutputStream, c:VMAbstractClass) :
  print(o, "class %_ (%,)" % [id(c), parents(c)])

defmethod print (o:OutputStream, c:VMLeafClass) :
  print(o, "class %_ (%,) (size = %_)" % [id(c), parents(c), size(c)])

defmethod print (o:OutputStream, c:VMArrayClass) :
  print(o, "class %_ (%,) (base-size = %_, item-size = %_)" % [id(c), parents(c), base-size(c), item-size(c)])

defmethod print (o:OutputStream, x:VMImm) :
  print{o, _} $ match(x) :
    (x:Reg) : "R%_" % [index(x)]
    (x:IntConst) : "%~" % [value(x)]
    (x:DoubleConst) : "%~" % [value(x)]
    (x:CodeId) : "codeof(%_)" % [fid(x)]
  
defmethod print (o:OutputStream, i:VMIns) :
  print{o, _} $ match(i) :
    (i:YieldIns) : "yield %_" % [x(i)]
    (i:NewStackIns) : "%_ = new-stack %_" % [x(i), fid(i)]
    (i:CallIns) : "call %_" % [fid(i)]
    (i:CallClosureIns): "call-closure %_" % [x(i)]
    (i:ReserveIns) : "reserve %_ %_" % [num-objects(i), size(i)]
    (i:AllocIns) : "%_ = alloc<%_> %_" % [x(i), type(i), size(i)]
    (i:RefSetIns) : "%_[%_] = %_ %_" % [x(i), y(i), type(i), z(i)]
    (i:RefGetIns) : "%_ = %_ %_[%_]" % [x(i), type(i), y(i), z(i)]    
    (i:SetIns) : "%_ = %_" % [x(i), y(i)]
    (i:Op1Ins) : "%_ = %_ %_" % [x(i), op(i), y(i)]
    (i:Op2Ins) : "%_ = %_ %_ %_" % [x(i), op(i), y(i), z(i)]
    (i:LabelIns) : "label %_" % [n(i)]
    (i:GotoIns) : "goto %_" % [n(i)]
    (i:Branch1Ins) : "goto %_ when %_ %_" % [n(i), op(i), x(i)]
    (i:Branch2Ins) : "goto %_ when %_ %_ %_" % [n(i), op(i), x(i), y(i)]
    (i:ReturnIns) : "return"
    (i:NoOpIns) : "noop"
    (i:GetLocalIns) : "%_ = %_ local[%_]" % [x(i), type(i), offset(i)]
    (i:SetLocalIns) : "local[%_] = %_ %_" % [offset(i), type(i), x(i)]

public defstruct InstanceofIns <: VMIns :
  x: Reg
  type: Int

defmethod print (o:OutputStream, op:VMOp) :
  defn typed (name:String) :
    print(o, "%_ " % [type(op as ?)])
    print(o, name)
  match(op) :
    (op:InstanceofOp) : print(o, "instanceof<%_>" % [type(op)])
    (op:AddOp) : typed("add")
    (op:SubOp) : typed("sub")
    (op:MulOp) : typed("mul")
    (op:DivOp) : typed("div")
    (op:ModOp) : typed("mod")
    (op:AndOp) : typed("and")
    (op:OrOp) : typed("or")
    (op:XorOp) : typed("xor")
    (op:NotOp) : typed("not")
    (op:ShlOp) : typed("shl")
    (op:ShrOp) : typed("shr")
    (op:AshrOp) : typed("ashr")
    (op:EqOp) : typed("eq")
    (op:NeOp) : typed("ne")
    (op:LtOp) : typed("lt")
    (op:GtOp) : typed("gt")
    (op:LeOp) : typed("le")
    (op:GeOp) : typed("ge")
    (op:UleOp) : typed("ule")
    (op:UltOp) : typed("ult")
    (op:UgtOp) : typed("ugt")
    (op:UgeOp) : typed("uge")
    (op:NegOp) : typed("neg")

defmethod print (o:OutputStream, t:VMType) :
  print{o, _} $ match(t) :
    (t:VMInt) : "int"
    (t:VMDouble) : "double"
    (t:VMRef) : "ref"
    (t:VMPointer) : "ptr"

defn lnprint (o:OutputStream, x) :
  print(o, '\n')
  print(o, x)

;============================================================
;======================= Reader =============================
;============================================================

defsyntax vmcode :
  defproduction op1 : VMOp
  defrule op1 = (instanceof<?t:#int!>) : InstanceofOp(t)
  defrule op1 = (?t:#type not) : NotOp(t)
  defrule op1 = (?t:#type neg) : NegOp(t)

  defproduction op2 : VMOp
  defrule op2 = (?t:#type add) : AddOp(t)
  defrule op2 = (?t:#type sub) : SubOp(t)
  defrule op2 = (?t:#type mul) : MulOp(t)
  defrule op2 = (?t:#type div) : DivOp(t)
  defrule op2 = (?t:#type mod) : ModOp(t)
  defrule op2 = (?t:#type and) : AndOp(t)
  defrule op2 = (?t:#type or) : OrOp(t)
  defrule op2 = (?t:#type xor) : XorOp(t)
  defrule op2 = (?t:#type shl) : ShlOp(t)
  defrule op2 = (?t:#type shr) : ShrOp(t)
  defrule op2 = (?t:#type ashr) : AshrOp(t)
  defrule op2 = (?t:#type eq) : EqOp(t)
  defrule op2 = (?t:#type ne) : NeOp(t)
  defrule op2 = (?t:#type lt) : LtOp(t)
  defrule op2 = (?t:#type gt) : GtOp(t)
  defrule op2 = (?t:#type le) : LeOp(t)
  defrule op2 = (?t:#type ge) : GeOp(t)
  defrule op2 = (?t:#type ule) : UleOp(t)
  defrule op2 = (?t:#type ult) : UltOp(t)
  defrule op2 = (?t:#type ugt) : UgtOp(t)
  defrule op2 = (?t:#type uge) : UgeOp(t)

  defproduction type : VMType
  defrule type = (int) : VMInt()
  defrule type = (double) : VMDouble()
  defrule type = (ref) : VMRef()
  defrule type = (ptr) : VMPointer()

  defn reg? (x) :
    unwrap-token(x) is Symbol and prefix?(to-string(x), "R")
  defn reg-index! (info:FileInfo|False, x:Symbol|Token) :
    val i = to-int(to-string(x)[1 to false])
    match(i:Int) : i
    else : throw(VME(info, "Invalid register: %~" % [x]))
  defproduction reg : Reg
  defrule reg = (?r) when reg?(r) : Reg(reg-index!(closest-info(), r))

  defproduction imm : VMImm
  defrule imm = (?x) when unwrap-token(x) is Int : IntConst(unwrap-token(x))
  defrule imm = (?x) when unwrap-token(x) is Double : DoubleConst(unwrap-token(x))
  defrule imm = (codeof(?fid:#int!)) : CodeId(fid)
  defrule imm = (?r:#reg) : r

  defproduction ins : VMIns
  defrule ins = (yield ?x:#imm!) : YieldIns(x)
  defrule ins = (call-closure ?x:#imm!) : CallClosureIns(x)
  defrule ins = (call ?fid:#int!) : CallIns(fid)
  defrule ins = (?x:#reg = new-stack ?fid:#int!) : NewStackIns(x, fid)
  defrule ins = (?x:#reg = ?t:#type local[?offset:#int!]) : GetLocalIns(x, t, offset)
  defrule ins = (local[?offset:#int!] = ?t:#type ?x:#imm!) : SetLocalIns(t, offset, x)
  defrule ins = (?x:#reg = alloc<?t:#int!> ?size:#imm!) : AllocIns(x, t, size)
  defrule ins = (?x:#reg = ?t:#type ?y:#imm[?z:#imm!]) : RefGetIns(t, x, y, z)
  defrule ins = (?x:#imm[?y:#imm] = ?t:#type ?z:#imm!) : RefSetIns(t, x, y, z)
  defrule ins = (?x:#reg = ?o:#op1 ?y:#imm!) : Op1Ins(x, o, y)
  defrule ins = (?x:#reg = ?o:#op2 ?y:#imm! ?z:#imm!) : Op2Ins(x, o, y, z)
  defrule ins = (?x:#reg = ?y:#imm!) : SetIns(x,y)
  defrule ins = (label ?n:#int!) : LabelIns(n)
  defrule ins = (goto ?n:#int! when ?o:#op2 ?x:#imm! ?y:#imm!) : Branch2Ins(n, o, x, y)
  defrule ins = (goto ?n:#int! when ?o:#op1 ?x:#imm!) : Branch1Ins(n, o, x)
  defrule ins = (goto ?n:#int!) : GotoIns(n)
  defrule ins = (reserve ?num-objects:#int! ?sz:#imm!) : ReserveIns(num-objects, sz)
  defrule ins = (return) : ReturnIns()

  defproduction func : VMFunc
  defrule func = (func ?id:#int! (?args:#type! ...) :
                    local-size = ?size:#int!
                    ?ins:#ins! ...) :
    VMFunc(id, to-tuple(args), size, to-tuple(ins))

  defproduction class : VMClass
  defrule class = (class ?id:#int! (?parents:#int! ...) (base-size = ?base:#int!, item-size = ?item:#int!)) :
    VMArrayClass(id, to-tuple(parents), base, item)
  defrule class = (class ?id:#int! (?parents:#int! ...) (size = ?size:#int!)) :
    VMLeafClass(id, to-tuple(parents), size)
  defrule class = (class ?id:#int! (?parents:#int! ...)) :
    VMAbstractClass(id, to-tuple(parents))

  public defproduction prog : VMProg
  defrule prog = (?classes:#class ... ?funcs:#func! ...) :
    VMProg(to-tuple(classes), to-tuple(funcs))

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  ;===== Failure =====
  defproduction imm! : VMImm
  defrule imm! = (?x:#imm) : x
  fail-if imm! = () : VME(closest-info(), "Expected an immediate here.")

  defproduction int! : Int
  defrule int! = (?x:#int) : x
  fail-if int! = () : VME(closest-info(), "Expected an integer here.")

  defproduction ins! : VMIns
  defrule ins! = (?x:#ins) : x
  fail-if ins! = () : VME(closest-info(), "Expected an instruction here.")

  defproduction func! : VMFunc
  defrule func! = (?x:#func) : x
  fail-if func! = () : VME(closest-info(), "Expected a function here.")

  defproduction type! : VMType
  defrule type! = (?x:#type) : x
  fail-if type! = () : VME(closest-info(), "Expected a type here.")

;============================================================
;====================== Errors ==============================
;============================================================

public defstruct VMError <: Exception :
  info: FileInfo|False
  msg

public defn VME (info:FileInfo|False, msg) :
  VMError(info, msg)

defmethod print (o:OutputStream, e:VMError) :
  val info-str = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [info-str, msg(e)])

;============================================================
;================ Overall Instruction Buffer ================
;============================================================
deftype InsBuffer
defmulti get (b:InsBuffer, i:Int) -> VMIns
defmulti set (b:InsBuffer, i:Int, ins:VMIns) -> False
defmulti alloc (b:InsBuffer, size:Int) -> Int
defmulti free (b:InsBuffer, n:Int) -> False

defn InsBuffer () :
  val v = Vector<VMIns>()
  val segments = IntTable<InsSegment>()
  new InsBuffer :
    defmethod get (this, i:Int) :
      v[i]
    defmethod set (this, i:Int, ins:VMIns) :
      v[i] = ins
    defmethod alloc (this, size:Int) -> Int :
      val pos = length(v)
      lengthen(v, length(v) + size, NoOpIns())
      segments[pos] = InsSegment(size)
      pos
    defmethod free (this, n:Int) -> False :
      fatal("Not yet implemented")

defstruct InsSegment :
  size: Int      

;============================================================
;================= Class Display Analysis ===================
;============================================================
deftype ClassTable
defmulti class? (this, c:Int) -> True|False
defmulti instanceof? (t:ClassTable, child:Int, parent:Int) -> True|False

public defn ClassTable (classes:Tuple<VMClass>) :
  val class-table = to-inttable<VMClass> $
    for c in classes seq : id(c) => c
  val parent-table = IntTable<Tuple<Int>>()
  defn @all-parents (c:Int) :
    val rec = class-table[c]
    to-tuple(cat([c], seq-cat(all-parents, parents(rec))))
  defn all-parents (c:Int) :
    if not key?(parent-table, c) :
      parent-table[c] = @all-parents(c)
    parent-table[c]  
  new ClassTable :
    defmethod class? (this, c:Int) :
      key?(class-table, c)
    defmethod instanceof? (this, child:Int, parent:Int) :
      contains?(all-parents(child), parent)

;============================================================
;====================== Mappers =============================
;============================================================

deftype HasTargetLabel :
  GotoIns <: HasTargetLabel
  Branch1Ins <: HasTargetLabel
  Branch2Ins <: HasTargetLabel

defn map-labels (f:Int -> Int, ins:HasTargetLabel) -> VMIns&HasTargetLabel :
  match(ins) :
    (ins:GotoIns) : sub-n(ins, f(n(ins)))
    (ins:Branch1Ins) : sub-n(ins, f(n(ins)))
    (ins:Branch2Ins) : sub-n(ins, f(n(ins)))

;============================================================
;==================== Stack Layout ==========================
;============================================================

;STACK LAYOUT: [TAG | SIZE | SP | RETURN | FRAME-SIZE | FRAMES ...]
val INITIAL-STACK-SIZE = 512 * 8
val STACK-TYPE-TAG = -1
val STACK-TAG-POS = 0
val STACK-SIZE-POS = 8
val STACK-SP-POS = 16
val STACK-RETURN-POS = 24
val STACK-FRAME-SIZE-POS = 32
val STACK-FRAME-POS = 40

;============================================================
;==================== Interpretation ========================
;============================================================
defstruct FuncRecord :
  id: Int
  args: Tuple<VMType>
  local-size: Int
  pos: Int

deftype HeapValue :
  Int <: HeapValue
  Double <: HeapValue
  False <: HeapValue
defstruct TypeTag <: HeapValue :
  type: Int
with: (printer => true)
defstruct Reference <: HeapValue :
  address: Int
with: (printer => true)  

public defn interpret (prog:VMProg) :
  ;Instruction buffer
  val buffer = InsBuffer()
  val func-records = IntTable<FuncRecord>()
  val class-table = ClassTable(classes(prog))

  ;Load a function into the VM
  defn load-function (f:VMFunc) :
    val pos = alloc(buffer, length(ins(f)))
    val labels = IntTable<Int>()
    within (delay) = with-delay() :
      let loop (src:Int = 0, dst:Int = pos) :
        if src < length(ins(f)) :
          match(ins(f)[src]) :
            (ins:LabelIns) :
              labels[n(ins)] = dst
              loop(src + 1, dst)
            (ins:VMIns&HasTargetLabel) :
              delay $ fn () :
                buffer[dst] = map-labels({labels[_]}, ins)
              loop(src + 1, dst + 1)
            (ins) :
              buffer[dst] = ins
              match(ins:AllocIns) :
                fatal("Invalid type %_" % [type(ins)]) when not class?(class-table, type(ins))
              loop(src + 1, dst + 1)
    func-records[id(f)] = FuncRecord(id(f), args(f), local-size(f), pos)
  do(load-function, funcs(prog))

  ;Define machine quantities
  val registers = Array<HeapValue>(256, false)
  val heap = IntTable<HeapValue>()
  var heap-top:Int = 0
  var heap-size:Int = 0
  var current-stack:Reference
  var stack-pointer:Int
  var stack-end:Int
  var current-frame-size:Int

  ;Evaluation
  defn eval (op:VMOp, y) :
    match(op) :
      (op:NotOp) : bit-not(y)
      (op:NegOp) : negate(y)
      (op:InstanceofOp) : bool-to-int(eval-pred(op, y))

  defn eval (op:VMOp, y, z) :
    match(op) :
      (op:AddOp) : plus(y, z)
      (op:SubOp) : minus(y, z)
      (op:MulOp) : times(y, z)
      (op:DivOp) : divide(y, z)
      (op:ModOp) : modulo(y, z)
      (op:AndOp) : bit-and(y, z)
      (op:OrOp) : bit-or(y, z)
      (op:XorOp) : bit-xor(y, z)
      (op:ShlOp) : shift-left(y, z)
      (op:ShrOp) : shift-right(y, z)
      (op:AshrOp) : arithmetic-shift-right(y, z)
      (op:EqOp) : bool-to-int(eval-pred(op, y, z))
      (op:NeOp) : bool-to-int(eval-pred(op, y, z))
      (op:LtOp) : bool-to-int(eval-pred(op, y, z))
      (op:GtOp) : bool-to-int(eval-pred(op, y, z))
      (op:LeOp) : bool-to-int(eval-pred(op, y, z))
      (op:GeOp) : bool-to-int(eval-pred(op, y, z))
      (op:UleOp) : bool-to-int(eval-pred(op, y, z))
      (op:UltOp) : bool-to-int(eval-pred(op, y, z))
      (op:UgtOp) : bool-to-int(eval-pred(op, y, z))
      (op:UgeOp) : bool-to-int(eval-pred(op, y, z))

  defn eval-pred (op:VMOp, y) :
    match(op) :
      (op:InstanceofOp) :
        val tag = heap[address(y as Reference)] as TypeTag
        instanceof?(class-table, type(tag), type(op))

  defn eval-pred (op:VMOp, y, z) :
    match(op) :
      (op:EqOp) : equal?(y,z)
      (op:NeOp) : not equal?(y, z)
      (op:LtOp) : y < z
      (op:GtOp) : y > z
      (op:LeOp) : y <= z
      (op:GeOp) : y >= z
      (op:UleOp) : fatal("Not yet supported")
      (op:UltOp) : fatal("Not yet supported")
      (op:UgtOp) : fatal("Not yet supported")
      (op:UgeOp) : fatal("Not yet supported")

  ;Allocate a stack
  defn alloc-stack (fid:Int) :
    val s = Reference(heap-top)
    heap-size = heap-size + INITIAL-STACK-SIZE
    heap-top = heap-top + INITIAL-STACK-SIZE
    val rec = func-records[fid]
    store-field(s, STACK-TAG-POS, TypeTag(STACK-TYPE-TAG))
    store-field(s, STACK-SIZE-POS, INITIAL-STACK-SIZE)
    store-field(s, STACK-SP-POS, address(s) + STACK-FRAME-POS)
    store-field(s, STACK-RETURN-POS, pos(rec))
    store-field(s, STACK-FRAME-SIZE-POS, local-size(rec) + 16)
    store-field(s, STACK-FRAME-POS + 0, false)
    store-field(s, STACK-FRAME-POS + 8, false)
    s

  ;Load stack fields
  defn load-field (r:Reference, field:Int) :
    heap[address(r) + field]
  defn store-field (r:Reference, field:Int, value) :
    heap[address(r) + field] = value

  ;Interpretation loop
  defn* run (i:Int) :
    ;Assign a value to a register
    defn* assign (r:Reg, v:HeapValue) :
      registers[index(r)] = v
    defn eval-imm (imm:VMImm) :
      match(imm) :
        (r:Reg) : registers[index(r)]
        (x:IntConst) : value(x)
        (x:DoubleConst) : value(x)
        (x:CodeId) : fid(x)
    defn* step () : run(i + 1)
    defn* jump (n:Int) : run(n)

    val ins = buffer[i]
    println("Trace: %_ (sp = %_)" % [ins, stack-pointer])
    match(ins) :
      (ins:SetIns) :
        assign(x(ins), eval-imm(y(ins)))
        step()
      (ins:Op1Ins) :
        assign(x(ins), eval(op(ins), eval-imm(y(ins))))
        step()
      (ins:Op2Ins) :
        assign(x(ins), eval(op(ins), eval-imm(y(ins)), eval-imm(z(ins))))
        step()
      (ins:LabelIns) :
        step()
      (ins:GotoIns) :
        jump(n(ins))
      (ins:Branch1Ins) :
        val pred = eval-pred(op(ins), eval-imm(x(ins)))
        jump(n(ins)) when pred else step()
      (ins:Branch2Ins) :
        val pred = eval-pred(op(ins), eval-imm(x(ins)), eval-imm(y(ins)))
        jump(n(ins)) when pred else step()
      (ins:CallIns) :
        call-func(fid(ins), i + 1)
      (ins:CallClosureIns) :
        val ref = eval-imm(x(ins)) as Reference
        val fid = heap[address(ref) + 8 + 8] as Int
        call-func(fid, i + 1)
      (ins:ReturnIns) :
        val return = heap[stack-pointer]
        val old-sp = heap[stack-pointer + 8]
        match(return:Int) :
          current-frame-size = stack-pointer - old-sp as Int
          stack-pointer = old-sp as Int
          run(return)          
      (ins:YieldIns) :
        ;Save current context
        val s0 = current-stack
        store-field(s0, STACK-SP-POS, stack-pointer)
        store-field(s0, STACK-RETURN-POS, i + 1)
        store-field(s0, STACK-FRAME-SIZE-POS, current-frame-size)
        ;Load next context        
        val s = eval-imm(x(ins)) as Reference
        load-stack(s)
      (ins:NewStackIns) :
        assign(x(ins), alloc-stack(fid(ins)))
        step()
      (ins:ReserveIns) :
        val sz = eval-imm(size(ins)) as Int
        fatal("Size is not a multiple of 8.") when not multiple8?(sz)
        heap-size = heap-size + sz + 8 * num-objects(ins)
        step()
      (ins:AllocIns) :
        val sz = eval-imm(size(ins)) as Int
        val total-sz = sz + 8
        fatal("Size is not a multiple of 8.") when not multiple8?(sz)
        fatal("Beyond allocated limits.") when heap-top + total-sz > heap-size
        heap[heap-top] = TypeTag(type(ins))        
        assign(x(ins), Reference(heap-top))
        heap-top = heap-top + total-sz
        step()
      (ins:RefSetIns) :
        val ref = eval-imm(x(ins)) as Reference
        val offset = eval-imm(y(ins)) as Int
        val value = eval-imm(z(ins))
        val addr = address(ref) + 8 + offset
        fatal("Out of heap bounds.") when (addr + size(type(ins))) > heap-size
        heap[addr] = value
        step()
      (ins:RefGetIns) :
        val ref = eval-imm(y(ins)) as Reference
        val offset = eval-imm(z(ins)) as Int
        val addr = address(ref) + 8 + offset
        fatal("Out of heap bounds.") when (addr + size(type(ins))) > heap-size
        assign(x(ins), heap[addr])
        step()
      (ins:GetLocalIns) :
        val pos = stack-pointer + 16 + offset(ins)
        fatal("Out of stack bounds.") when pos >= stack-pointer + current-frame-size
        assign(x(ins), heap[pos])
        step()
      (ins:SetLocalIns) :
        val pos = stack-pointer + 16 + offset(ins)
        fatal("Out of stack bounds.") when pos >= stack-pointer + current-frame-size
        heap[pos] = eval-imm(x(ins))
        step()

  defn* call-func (fid:Int, return:Int) :
    val fp = stack-pointer + current-frame-size
    fatal("Stack overflow.") when (fp + 16) > stack-end
    heap[fp] = return
    heap[fp + 8] = stack-pointer
    stack-pointer = fp
    val rec = func-records[fid]
    current-frame-size = local-size(rec) + 16
    run(pos(rec))

  defn* load-stack (s:Reference) :
    current-stack = s
    stack-pointer = load-field(s, STACK-SP-POS) as Int
    val ret = load-field(s, STACK-RETURN-POS) as Int
    current-frame-size = load-field(s, STACK-FRAME-SIZE-POS) as Int
    val stack-size = load-field(current-stack, STACK-SIZE-POS) as Int
    stack-end = address(s) + stack-size
    run(ret)

  ;Start from main function 0
  load-stack(alloc-stack(0))

  ;Print result of registers
  for (v in registers, i in 0 to false) do :
    if v is-not False :
      println("R%_ = %_" % [i, v])

defn size (t:VMType) :
  match(t) :
    (t:VMInt) : 4
    (t:VMDouble) : 8
    (t:VMRef) : 8
    (t:VMPointer) : 8
  
;============================================================
;==================== Utilities =============================
;============================================================
defn ensure-length<?T> (v:Vector<?T>, len:Int, x:T) :
  lengthen(v, len, x) when length(v) < len

defn multiple8? (x:Int) :
  (x & 0x7) == 0

defn bool-to-int (x:True|False) :
  1 when x else 0

defn with-delay<?T> (f:((() -> ?) -> False) -> ?T) :
  val delays = Vector<(() -> ?)>()
  defn* delay (x:() -> ?) : add(delays, x)
  val result = f(delay)
  for d in delays do : d()
  result

;============================================================
;=================== Scratch Pad ============================
;============================================================

defn main () :
  val filename = command-line-arguments()[1]
  val forms = read-file(filename)
  val prog = parse-syntax[vmcode / #prog](forms)
  println(prog)
  interpret(prog)

main()














