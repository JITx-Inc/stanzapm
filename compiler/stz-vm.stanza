defpackage stz/vm :
  import core
  import collections
  import stz/vm-ir
  import stz/vm-table
  import stz/loaded-ids
  import stz/dl-ir
  import stz/basic-ops

;============================================================
;=================== Special Identifiers ====================
;============================================================

public val FALSE-TYPE = 0
public val TRUE-TYPE = 1
public val BYTE-TYPE = 2
public val CHAR-TYPE = 3
public val INT-TYPE = 4
public val FLOAT-TYPE = 5
public val STACK-TYPE = 6
public val FN-TYPE = 7
public val TYPE-TYPE = 8
public val NUM-BUILTIN-TYPES = 9

;============================================================
;==================== Linked Instructions ===================
;============================================================

public deftype LinkedIns :
  NewStackIns <: LinkedIns
  SetIns <: LinkedIns
  Op0Ins <: LinkedIns
  JumpIns <: LinkedIns
  CommentIns <: LinkedIns

public deftype JumpIns :
  GotoIns <: JumpIns
  Branch1Ins <: JumpIns  

public defstruct LinkedStoreIns <: LinkedIns :
  size: Int
  x: VMImm
  y: VMImm
  z: VMImm
  offset: Int
  class: Int|False
public defstruct LinkedLoadIns <: LinkedIns :
  size: Int
  x: Local
  y: VMImm
  z: VMImm
  offset: Int
  class: Int|False
public defstruct LinkedRefStoreIns <: LinkedIns :
  size: Int
  x: VMImm
  y: VMImm
  z: VMImm
  offset: Int
  class: Int|False
public defstruct LinkedRefLoadIns <: LinkedIns :
  size: Int
  x: Local
  y: VMImm
  z: VMImm
  offset: Int
  class: Int|False
public defstruct SetReg <: LinkedIns :
  reg: Int
  x: VMImm
public defstruct GetReg <: LinkedIns :
  x: Local
  reg: Int
  ref?: True|False
public defstruct PopFrameIns <: LinkedIns :
  frame-size: Int
public defstruct LinkedTCall <: LinkedIns :
  f: VMImm
public defstruct LinkedTCallClosure <: LinkedIns :
  f: VMImm  
public defstruct LinkedCall <: LinkedIns :
  f: VMImm
  frame-size: Int
public defstruct LinkedCallClosure <: LinkedIns :
  f: VMImm
  frame-size: Int
public defstruct LinkedCallC <: LinkedIns :
  f: VMImm
  launcher: Long
  frame-size: Int
public defstruct LinkedYield <: LinkedIns :
  f: VMImm
public defstruct LinkedReturn <: LinkedIns
public defstruct FunctionEntry <: LinkedIns :
  num-locals:Int
public defstruct LinkedDump <: LinkedIns :
  x: Local
  ref?: True|False
public defstruct LinkedVMCall <: LinkedIns :
  x: Local
  op: VMOp
  y: VMImm
public defstruct LinkedOp1Ins <: LinkedIns :
  type: VMType
  x: Local
  op: VMOp
  y: VMImm
public defstruct LinkedOp2Ins <: LinkedIns :
  type: VMType
  x: Local
  op: VMOp
  y: VMImm
  z: VMImm
public defstruct LinkedBranch2Ins <: LinkedIns :
  type: VMType
  n1: Int
  n2: Int
  op: VMOp
  x: VMImm
  y: VMImm
public defstruct LinkedConvIns <: LinkedIns :
  x: Local
  xtype: VMType
  op: VMOp
  y: VMImm
  ytype: VMType
public defstruct LinkedLiveIns <: LinkedIns :
  map: Int
public defstruct LinkedBranchRegIns <: LinkedIns :
  n: Int
  reg: Int
  value: Int  
public defstruct LinkedReserveIns <: LinkedIns :
  n: Int
  space: VMImm
  num-obj: Int
  frame-size: Int
public defstruct LinkedAllocIns <: LinkedIns :
  x: Local
  type: Int
  size: VMImm
public defstruct LinkedDispatchIns <: LinkedIns :
  format: Int
  ys: Tuple<VMImm>
  ns: Tuple<Int>
  default: Int
  amb: Int

;============================================================
;======================= Printer ============================
;============================================================
defmethod print (o:OutputStream, i:LinkedReserveIns) :
  print(o, "reserve %_, %_ and goto %_" % [space(i), num-obj(i), n(i)])

defmethod print (o:OutputStream, i:LinkedVMCall) :
  print(o, "%_ = callvm %_ %_" % [x(i), op(i), y(i)])

defmethod print (o:OutputStream, i:LinkedAllocIns) :
  print(o, "%_ = alloc<%_> %_" % [x(i), type(i), size(i)])

defmethod print (o:OutputStream, i:PopFrameIns) :
  print(o, "pop-frame %_" % [frame-size(i)])

defn class-str? (i:LinkedStoreIns|LinkedLoadIns|LinkedRefStoreIns|LinkedRefLoadIns) :
  match(class(i)) :
    (c:Int) : " (class = %_)" % [c]
    (c:False) : ""

defmethod print (o:OutputStream, i:LinkedStoreIns) :
  print(o, "%_[%_ + %_] = %_ (%_ bytes)%_" % [x(i), y(i), offset(i), z(i), size(i), class-str?(i)])

defmethod print (o:OutputStream, i:LinkedLoadIns) :
  print(o, "%_ = %_[%_ + %_] (%_ bytes)%_" % [x(i), y(i), z(i), offset(i), size(i), class-str?(i)])

defmethod print (o:OutputStream, i:LinkedRefStoreIns) :
  print(o, "ref %_[%_ + %_] = %_ (%_ bytes)%_" % [x(i), y(i), offset(i), z(i), size(i), class-str?(i)])

defmethod print (o:OutputStream, i:LinkedRefLoadIns) :
  print(o, "%_ = ref %_[%_ + %_] (%_ bytes)%_" % [x(i), y(i), z(i), offset(i), size(i), class-str?(i)])

defmethod print (o:OutputStream, i:LinkedOp1Ins) :
  print(o, "%_ = %_ %_ %_" % [x(i), type(i), op(i), y(i)])

defmethod print (o:OutputStream, i:LinkedOp2Ins) :
  print(o, "%_ = %_ %_ %_ %_" % [x(i), type(i), op(i), y(i), z(i)])

defmethod print (o:OutputStream, i:LinkedBranch2Ins) :
  print(o, "goto %_ when %_ %_ %_ %_ else %_" % [n1(i), type(i), op(i), x(i), y(i), n2(i)])

defmethod print (o:OutputStream, r:SetReg) :
  print(o, "reg %_ = %_" % [reg(r), x(r)])

defmethod print (o:OutputStream, r:GetReg) :
  print(o, "%_ = reg %_ (ref = %_)" % [x(r), reg(r), ref?(r)])

defmethod print (o:OutputStream, x:LinkedTCall) :
  print(o, "return call %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedTCallClosure) :
  print(o, "return call-closure %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedCall) :
  print(o, "call %_ (frame-size = %_)" % [f(x), frame-size(x)])

defmethod print (o:OutputStream, x:LinkedCallC) :
  print(o, "call-c %_ (launcher %_, frame-size = %_)" % [f(x), launcher(x), frame-size(x)])

defmethod print (o:OutputStream, x:LinkedCallClosure) :
  print(o, "call-closure %_ (frame-size = %_)" % [f(x), frame-size(x)])

defmethod print (o:OutputStream, x:LinkedYield) :
  print(o, "yield %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedReturn) :
  print(o, "return")

defmethod print (o:OutputStream, x:FunctionEntry) :
  print(o, "enter (num-locals = %_)" % [num-locals(x)])

defmethod print (o:OutputStream, ins:LinkedDump) :
  print(o, "dump %_ (ref? = %_))" % [x(ins), ref?(ins)])

defmethod print (o:OutputStream, ins:LinkedLiveIns) :
  print(o, "live %_" % [map(ins)])

defmethod print (o:OutputStream, ins:LinkedConvIns) :
  print(o, "%_ = %_ (%_ <- %_) %_" % [x(ins), op(ins), xtype(ins), ytype(ins), y(ins)])

defmethod print (o:OutputStream, ins:LinkedBranchRegIns) :
  print(o, "goto %_ when R%_ == %_" % [n(ins), reg(ins), value(ins)])

defmethod print (o:OutputStream, ins:LinkedDispatchIns) :
  print(o, "dispatch[%_](%,) => (%,) (default = %_, amb = %_)" % [
    format(ins), ys(ins), ns(ins), default(ins), amb(ins)])

;============================================================
;======================= Linker =============================
;============================================================

deftype Linker
defmulti link (l:Linker, f:VMFunction, pkgids:PackageIds) -> LinkedFunction
defmulti live-map-table (l:Linker) -> LiveMapTable

public defstruct FileInfoEntry :
  pc: Int
  fileinfo: FileInfo

public defstruct LinkedFunction :
  instructions: Tuple<LinkedIns>
  fileinfos: Tuple<FileInfoEntry>

defn Linker (branch-table:BranchTable) :
  ;===== Livemap Table =====
  val live-map-table = LiveMapTable()

  ;===== FileInformation Table =====
  val fileinfo-table = Vector<FileInfoEntry>()

  ;===== Temporary Linking Buffer =====
  val buffer = Vector<LinkedIns|False>()
  defn delayed-ins (f:Int -> LinkedIns) :
    val pos = length(buffer)
    add(buffer, false)
    within delay() :
      buffer[pos] = f(pos)

  ;Link the function
  defn link (f:VMFunction, pkgids:PackageIds) :
    ;Generate to temporary buffer
    match(f) :
      (f:VMMultifn) : link-multi(f, pkgids)
      (f:VMFunc) : link-func(f, pkgids)
    ;Return instructions and clear buffer
    val result = LinkedFunction(
                   to-tuple(buffer as Vector<LinkedIns>)
                   to-tuple(fileinfo-table))
    clear(buffer)
    clear(fileinfo-table)
    result

  ;Generate the code for a multi function
  defn link-multi (multi:VMMultifn, pkgids:PackageIds) :
    ;Get function position
    val function-pos = length(buffer)

    within delay-actions() :
      ;Fill in function position table
      val func-pos-table = IntTable<Int>()    
      ;Add branching instructions
      for entry in funcs(multi) do :
        within pos = delayed-ins() :
          val func-pos = func-pos-table[id(value(entry))]
          LinkedBranchRegIns(func-pos - pos, arg(multi), key(entry))
      ;Add default branch
      link-func(default(multi), pkgids)          
      ;Branches
      for func in seq(value,funcs(multi)) do :
        func-pos-table[id(func)] = link-func(func, pkgids)

    ;Return function position
    function-pos

  ;Generate the code for a single function
  defn link-func (func:VMFunc, pkgids:PackageIds) :
    ;Make an fileinfo entry
    defn record-info (info:FileInfo|False) :
      match(info:FileInfo) :
        val pos = length(buffer)
        add(fileinfo-table, FileInfoEntry(pos, info))        
    ;Create mapping from local ID to slot
    val deftable = to-inttable<VMDef> $
      for def in defs(func) seq :
        id(def) => def
    ;Retrieve the size of an immediate
    defn imm-size (x:VMImm) :
      match(x:Local) : size(type(deftable[index(x)]))
      else : size(x)
    defn imm-type (x:VMImm) :
      match(x:Local) : type(deftable[index(x)])
      else : type(x)
    defn imm-type (x:False) :
      x
    ;Create label table
    val label-table = IntTable<Int>()
    
    ;Compute relative locations
    ;Substitute a local's index with its slot
    defn sub-slot (x:False) : x
    defn sub-slot (x:Local) : Local(local(deftable[index(x)]))

    ;Link an instruction
    defn link-ins<?T> (ins:VMIns&?T, pos:Int) -> T :
      defn sub-label (n:Int) : label-table[n] - pos
      defn sub-id (n:Int) : pkgids[n]
      map(sub-label, sub-slot, sub-id, ins)
    defn link-imm<?T> (x:?T&VMImm) -> T :
      map(sub-slot, {pkgids[_]}, x)

    ;Register Instructions
    defn get-regs (xs:Tuple<Local|False>, oldxs:Tuple<Local|False>) :
      for (x in xs, xo in oldxs, i in 0 to false) do :
        match(x:Local, xo:Local) :
          add(buffer, GetReg(x, i, imm-type(xo) is VMRef))
    defn set-regs (xs:Tuple<VMImm>) :
      for (x in xs, i in 0 to false) do :
        add(buffer, SetReg(i, x))
        
    ;Get function position
    val function-pos = length(buffer)
    
    ;Link instructions
    within delay-actions() :
      ;Create entry instructions
      val num-locals = maximum(-1, seq(local, defs(func))) + 1
      val frame-size = SIZEOF-FRAME + num-locals * 8
      val empty-map = LivenessMap([], num-locals)
      add(buffer, FunctionEntry(num-locals))
      get-regs(map(sub-slot, args(func)), args(func))
      ;Link and add to buffer
      for ins in ins(func) do :
        val pos = length(buffer)        
        match(ins) :
          (ins:LabelIns) :
            label-table[n(ins)] = pos
          (ins:TCallIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, LinkedTCall(f(ins*)))
          (ins:TCallClosureIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, LinkedTCallClosure(f(ins*)))
          (ins:CallIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, LinkedCall(f(ins*), frame-size))
            record-info(info(ins))
            add(buffer, PopFrameIns(frame-size))
            get-regs(xs(ins*), xs(ins))
          (ins:EndCallIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, LinkedCall(f(ins*), frame-size))
            record-info(info(ins))
            add(buffer, PopFrameIns(frame-size))
          (ins:CallClosureIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, LinkedCallClosure(f(ins*), frame-size))
            record-info(info(ins))
            add(buffer, PopFrameIns(frame-size))
            get-regs(xs(ins*), xs(ins))
          (ins:CallCIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            val format = coalesce(CallFormat(xtypes, ytypes)) where :
              val xtypes = map(imm-type,xs(ins))
              val ytypes = map(imm-type,ys(ins))
            val launcher = FORMAT-TABLE[format]
            add(buffer, LinkedCallC(f(ins*), launcher, frame-size))
            record-info(info(ins))
            get-regs(xs(ins*), xs(ins))
          (ins:YieldIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, LinkedYield(f(ins*)))
            record-info(info(ins))
            get-regs(xs(ins*), xs(ins))
          (ins:ReturnIns) :
            val ins* = link-ins(ins, pos)
            set-regs(xs(ins*))
            add(buffer, LinkedReturn())
          (ins:DumpIns) :
            val ins* = link-ins(ins, pos)
            for (x in xs(ins*), xo in xs(ins)) do :
              add(buffer, LinkedDump(x, imm-type(xo) is VMRef))
          (ins:RecordLiveIns) :
            val ins* = link-ins(ins, pos)
            val map = LivenessMap(map(index, live(ins*)), num-locals)
            val map-i = map-index(live-map-table, map)
            add(buffer, LinkedLiveIns(map-i))
          (ins:StoreIns) :
            val ins* = link-ins(ins, pos)
            val size = imm-size(z(ins))
            defn zero? (x:VMImm|False) :
              match(x:VMImm) : x
              else : NumConst(0)
            match(imm-type(x(ins))) :
              (t:VMRef) : add(buffer, LinkedRefStoreIns(size, x(ins*), zero?(y(ins*)), z(ins*), offset(ins*), class(ins*)))
              (t) : add(buffer, LinkedStoreIns(size, x(ins*), zero?(y(ins*)), z(ins*), offset(ins*), class(ins*)))
          (ins:LoadIns) :
            val ins* = link-ins(ins, pos)
            val size = imm-size(x(ins))
            defn zero? (x:VMImm|False) :
              match(x:VMImm) : x
              else : NumConst(0)
            match(imm-type(y(ins))) :
              (t:VMRef) : add(buffer, LinkedRefLoadIns(size, x(ins*), y(ins*), zero?(z(ins*)), offset(ins*), class(ins*)))
              (t) : add(buffer, LinkedLoadIns(size, x(ins*), y(ins*), zero?(z(ins*)), offset(ins*), class(ins*)))
          (ins:Op1Ins) :
            val ins* = link-ins(ins, pos)
            match(op(ins*)) :
              (op:GCOp) :
                add(buffer, LinkedVMCall(x(ins*), op, y(ins*)))
              (op:ConvOp|InterpretOp) :
                val xt = imm-type(x(ins))
                val yt = imm-type(y(ins))
                add(buffer, LinkedConvIns(x(ins*), xt, op, y(ins*), yt))
              (op:DetagOp|TagOp|IntNotOp|IntNegOp|DerefOp) :
                add(buffer, LinkedOp1Ins(VMRef(), x(ins*), op, y(ins*)))
              (op:InstanceofOp|StackMapOp) :
                add(buffer, LinkedOp1Ins(VMLong(), x(ins*), op, y(ins*)))
              (op) :
                val t = imm-type(y(ins))
                add(buffer, LinkedOp1Ins(t, x(ins*), op, y(ins*)))
          (ins:Op2Ins) :
            val ins* = link-ins(ins, pos)
            match(op(ins*)) :
              (op:IntAddOp|IntSubOp|IntMulOp|IntDivOp|IntModOp|IntAndOp|IntOrOp|IntXorOp|
                  IntShlOp|IntShrOp|IntAshrOp|IntLtOp|IntGtOp|IntLeOp|IntGeOp|RefEqOp|RefNeOp) :
                add(buffer, LinkedOp2Ins(VMRef(), x(ins*), op, y(ins*), z(ins*)))
              (op) :
                val t = imm-type(y(ins))
                add(buffer, LinkedOp2Ins(t, x(ins*), op, y(ins*), z(ins*)))
          (ins:Branch2Ins) :
            within pos = delayed-ins() :
              val ins* = link-ins(ins, pos)
              val t = imm-type(y(ins))
              LinkedBranch2Ins(t, n1(ins*), n2(ins*), op(ins*), x(ins*), y(ins*))
          (ins:DispatchIns) :
            within pos = delayed-ins() :
              val ins* = link-ins(ins, pos)
              val [format, ns] = DispatchFormat(branches(ins*))
              val format-index = add(branch-table, format)
              LinkedDispatchIns(format-index, ys(ins*), ns, default(ins*), amb(ins*))
          (ins:MatchIns) :
            within pos = delayed-ins() :
              val ins* = link-ins(ins, pos)
              val [format, ns] = MatchFormat(branches(ins*))
              val format-index = add(branch-table, format)
              LinkedDispatchIns(format-index, ys(ins*), ns, default(ins*), -1)
          (ins:MethodDispatchIns) :
            set-regs(to-tuple(args)) where :
              val args = seq(link-imm, cat(ys(ins), zs(ins)))
            within pos = delayed-ins() :
              val ins* = link-ins(ins, pos)
              val format-index = add(branch-table, MultiFormat(multi(ins*)))
              LinkedDispatchIns(format-index, zs(ins*), [], default(ins*), amb(ins*))
          (ins:JumpIns&VMIns) :
            within pos = delayed-ins() :
              link-ins(ins, pos)
          (ins:NewStackIns) :
            val ins* = link-ins(ins, pos)
            add(buffer, LinkedReserveIns(2, NumConst(SIZEOF-STACK), 1, frame-size))
            record-info(info(ins))
            add(buffer, PopFrameIns(frame-size))
            add(buffer, ins*)            
          (ins:AllocIns) :
            val ins* = link-ins(ins, pos)
            if length(sizes(ins*)) == 1 :
              val x = xs(ins*)[0]
              val type = types(ins*)[0]
              val size = sizes(ins*)[0]
              add(buffer, LinkedReserveIns(2, size, 1, frame-size))
              record-info(info(ins))
              add(buffer, PopFrameIns(frame-size))
              add(buffer, LinkedAllocIns(x, type, size))
            else :
              val num-obj = length(sizes(ins*))
              val size = sum $
                for s in sizes(ins*) seq :
                  value(s as NumConst) as Int
              add(buffer, LinkedReserveIns(2, NumConst(size), num-obj, frame-size))
              record-info(info(ins))
              add(buffer, PopFrameIns(frame-size))
              for (x in xs(ins*), t in types(ins*), s in sizes(ins*)) do :
                add(buffer, LinkedAllocIns(x, t, s))
          (ins:LinkedIns&VMIns) :
            add(buffer, link-ins(ins, pos))
    ;Dump to instruction buffer
    function-pos

  new Linker :
    defmethod link (this, f:VMFunction, pkgids:PackageIds) : link(f, pkgids)
    defmethod live-map-table (this) : live-map-table

;============================================================
;================= Live Map Analysis ========================
;============================================================
deftype LiveMapTable
defmulti map-index (t:LiveMapTable, map:LivenessMap) -> Int
defmulti get (t:LiveMapTable, i:Int) -> LivenessMap
defmulti key? (t:LiveMapTable, i:Int) -> True|False
defmulti stackmap-buffer (t:LiveMapTable) -> Buffer
defmulti stackmap-entry (t:LiveMapTable, map:Int) -> Long

public defstruct LivenessMap <: Hashable&Equalable :
  live-slots: Tuple<Int>
  num-slots: Int
with:
  constructor => #LivenessMap
defn LivenessMap (slots:Tuple<Int>, num-slots:Int) :
  #LivenessMap(qsort(slots), num-slots)
defmethod hash (m:LivenessMap) :
  num-slots(m) + 7 * hash(live-slots(m))
defmethod equal? (a:LivenessMap, b:LivenessMap) :
  live-slots(a) == live-slots(b) and
  num-slots(a) == num-slots(b)

public defn LiveMapTable () :
  val maps = Vector<LivenessMap>()
  val entry-positions = Vector<Long>()
  val table = HashTable<LivenessMap,Int>()
  val buffer = Buffer()
  defn add-map (m:LivenessMap) :
    table[m] = length(maps)
    add(maps, m)
    val pos = write(buffer, m)
    add(entry-positions, pos)
  add-map(LivenessMap([], 0))
  new LiveMapTable :
    defmethod map-index (this, map:LivenessMap) :
      add-map(map) when not key?(table, map)
      table[map]
    defmethod get (this, i:Int) :
      maps[i]
    defmethod key? (this, i:Int) :
      i >= 0 and i < length(maps)
    defmethod stackmap-buffer (this) :
      buffer
    defmethod stackmap-entry (this, map:Int) :
      entry-positions[map]

public lostanza defn write (b:ref<Buffer>, m:ref<LivenessMap>) -> ref<Long> :
  val p = alloc(b, 4)
  [(b.mem + p) as ptr<int>] = num-slots(m).value
  return new Long{p}

lostanza defn stackmap-entry (t:ref<LiveMapTable>, map:long) -> ptr<?> :
  val b = stackmap-buffer(t)
  val p = stackmap-entry(t, new Int{map as int}).value
  return b.mem + p

;============================================================
;==================== Extern Table ==========================
;============================================================

public deftype ExternTable
public defmulti get (t:ExternTable, name:Symbol) -> Long
public defmulti set (t:ExternTable, name:Symbol, addr:Long) -> False

defn ExternTable () :
  val table = HashTable<Symbol,Long>()
  new ExternTable :
    defmethod get (this, name:Symbol) :
      table[name]
    defmethod set (this, name:Symbol, addr:Long) :
      table[name] = addr

public val EXTERN-TABLE = ExternTable()

;============================================================
;===================== Format Table =========================
;============================================================

public defstruct CallFormat <: Hashable&Equalable :
  xs: Tuple<VMType|False>
  ys: Tuple<VMType>
with :
  printer => true

defmethod hash (f:CallFormat) :
  hash(xs(f)) + 7 * hash(ys(f))
defmethod equal? (a:CallFormat, b:CallFormat) :
  xs(a) == xs(b) and ys(a) == ys(b)

public deftype FormatTable
public defmulti get (t:FormatTable, f:CallFormat) -> Long
public defmulti set (t:FormatTable, f:CallFormat, l:Long) -> False

defn FormatTable () :
  val table = HashTable<CallFormat,Long>()  
  new FormatTable :
    defmethod get (this, f:CallFormat) : table[f]
    defmethod set (this, f:CallFormat, l:Long) : table[f] = l

public val FORMAT-TABLE = FormatTable()

;============================================================
;=================== Format Coalescing ======================
;============================================================

defn exemplar-type (t:VMType) :
  match(t:VMRef) : VMLong()
  else : t

public defn coalesce (f:CallFormat) :
  ;New return result
  val x* =
    if empty?(xs(f)) :
      VMLong()
    else :
      match(xs(f)[0]) :
        (x:False) :
          VMLong()
        (x:VMType) :
          match(exemplar-type(x)) :
            (t:VMByte|VMInt) : VMLong()
            (t) : t

  ;New arguments
  val ys* = for y in ys(f) map :
    match(exemplar-type(y)) :
      (y:VMByte|VMInt) : VMLong()
      (y) : y

  ;Return coalesced call format
  CallFormat([x*], ys*)

;============================================================
;==================== Tag Bits ==============================
;============================================================

public lostanza val INT-TAG-BITS:long = 0L
public lostanza val REF-TAG-BITS:long = 1L
public lostanza val MARKER-TAG-BITS:long = 2L
public lostanza val BYTE-TAG-BITS:long = 3L
public lostanza val CHAR-TAG-BITS:long = 4L
public lostanza val FLOAT-TAG-BITS:long = 5L

;============================================================
;==================== VM Constants ==========================
;============================================================

lostanza defn untag (x:long) -> ptr<?> :
  val tagbits = x & 7L
  if tagbits != REF-TAG-BITS : fatal("Not a heap-allocated object!")
  return (x - REF-TAG-BITS + 8) as ptr<?>

lostanza defn tag (x:ptr<?>) -> long :
  return (x + REF-TAG-BITS) as long

public lostanza defn void-marker () -> long :
  return -1L << 3L + MARKER-TAG-BITS

public lostanza defn false-marker () -> long :
  return FALSE-TYPE.value << 3L + MARKER-TAG-BITS

;============================================================
;=================== VM Structures ==========================
;============================================================

public lostanza deftype VirtualMachine :
  vmtable: ref<VMTable>
  loaded-ids: ref<LoadedIds>
  linker: ref<Linker>
  registers: ptr<long>
  heap: ptr<long>                ;[semi-variable]
  heap-top: ptr<long>            ;[variable]
  heap-limit: ptr<long>          ;[semi-variable]
  free: ptr<long>                ;[semi-variable]
  free-limit: ptr<long>          ;[semi-variable]
  current-stack: long            ;[variable]
  stack-pointer: ptr<StackFrame> ;[variable]
  pc: int                        ;[variable]

lostanza deftype StackFrame :
  return: long
  liveness-map: long
  slots: long ...

lostanza deftype Stack :
  size: long
  frames: ptr<StackFrame>
  stack-pointer: ptr<StackFrame>
  pc: int

lostanza deftype Function :
  num-slots: long
  code: long
  slots: long ...

lostanza deftype ObjectLayout :
  tag: long
  slots: long ...

lostanza deftype BrokenHeartLayout :
  tag: long
  forward: long

lostanza val SIZEOF-FRAME:ref<Int> = new Int{sizeof(StackFrame) as int}
lostanza val SIZEOF-STACK:ref<Int> = new Int{sizeof(Stack) as int}

lostanza defn stack-end (stackref:long) -> ptr<StackFrame> :  
  val s:ptr<Stack> = untag(stackref)
  return s.frames + s.size

lostanza defn linker (vm:ref<VirtualMachine>) -> ref<Linker> :
  return vm.linker

lostanza defn loaded-ids (vm:ref<VirtualMachine>) -> ref<LoadedIds> :
  return vm.loaded-ids

lostanza defn vmtable (vm:ref<VirtualMachine>) -> ref<VMTable> :
  return vm.vmtable

;============================================================
;==================== VM Implementation =====================
;============================================================

public lostanza defn VirtualMachine () -> ref<VirtualMachine> :
  val registers = call-c clib/malloc(8 * 256)
  val heap-size = 4 * 1024  
  val heap = call-c clib/malloc(heap-size)
  val heap-limit = heap + heap-size
  val free = call-c clib/malloc(heap-size)
  val free-limit = free + heap-size
  val null = 0L as ptr<?>
  val class-table = ClassTable()
  val branch-table = BranchTable(class-table)
  val linker = Linker(branch-table)
  return new VirtualMachine{VMTable(class-table, branch-table), LoadedIds(), linker,
                            registers, heap, heap, heap-limit,
                            free, free-limit, void-marker(), null, 0}

lostanza defn alloc-stack (vm:ref<VirtualMachine>, pc:int) -> long :
  ;Allocate stack on heap
  val s = tag(vm.heap-top)
  [vm.heap-top] = STACK-TYPE.value
  vm.heap-top = vm.heap-top + 8 + sizeof(Stack)

  ;Allocate stack frames
  val stack-size = 4 * 1024
  val frames = call-c clib/malloc(stack-size)

  ;Fill in stack fields
  val sptr:ptr<Stack> = untag(s)
  sptr.size = stack-size
  sptr.frames = frames
  sptr.stack-pointer = frames
  sptr.pc = pc
  sptr.frames.return = -1L
  sptr.frames.liveness-map = 0L

  ;Return stack
  return s

lostanza defn eval-imm (x:ref<VMImm>, frame:ptr<StackFrame>, vmtable:ref<VMTable>) -> long :
  match(x) :
    (x:ref<Local>) :
      return frame.slots[index(x).value]
    (x:ref<NumConst>) :
      match(value(x)) :
        (v:ref<Char>) : return v.value
        (v:ref<Byte>) : return v.value
        (v:ref<Int>) : return v.value
        (v:ref<Long>) : return v.value
        (v:ref<Float>) : return float-to-bits(v.value)
        (v:ref<Double>) : return double-to-bits(v.value)
    (x:ref<CodeId>) :
      return id(x).value
    (x:ref<ExternId>) :
      return get(vmtable.extern-addresses, id(x)).value
    (x:ref<GlobalId>) :
      val offset = global-offset(vmtable, id(x)).value
      return (vmtable.globals.mem + offset) as long
    (x:ref<DataId>) :
      val pos = get(vmtable.data-positions, id(x)).value
      return addr!(vmtable.data.mem[pos]) as long
    (x:ref<ConstId>) :
      val pos = get(vmtable.const-positions, id(x)).value
      return addr!(vmtable.consts.mem[pos]) as long
    (x:ref<Marker>) :
      return (typeid(x).value << 3L) + MARKER-TAG-BITS
    (x:ref<VoidMarker>) :
      return (-1L << 3L) + MARKER-TAG-BITS
    (x:ref<Tag>) :
      return typeid(x).value

lostanza defn eval-op (op:ref<VMOp>, current-stack:long,
                       stack-pointer:ptr<StackFrame>, vmtable:ref<VMTable>) -> long :
  match(op) :
    (op:ref<CurrentStackOp>) : return current-stack
    (op:ref<CurrentFrameOp>) : return stack-pointer as long
    (op:ref<FileInfoTableOp>) : return vmtable.fileinfos.mem as long
    (op:ref<GlobalsOp>) : return vmtable.globals.mem as long
    (op:ref<ConstsDataOp>) : return vmtable.consts-data as long
    (op:ref<ConstsOp>) : return vmtable.new-consts as long
  return 0

lostanza defn eval-type (y:long) -> ref<Int> :
  val tagbits = y & 7L
  if tagbits == REF-TAG-BITS :
    return new Int{[(y - REF-TAG-BITS) as ptr<long>] as int}
  else if tagbits == MARKER-TAG-BITS :
    return new Int{(y >> 3L) as int}
  else if tagbits == INT-TAG-BITS :
    return INT-TYPE
  else if tagbits == BYTE-TAG-BITS :
    return BYTE-TYPE
  else if tagbits == CHAR-TAG-BITS :
    return CHAR-TYPE
  else if tagbits == FLOAT-TAG-BITS :
    return FLOAT-TYPE
  else :
    return fatal("Unrecognized tag bits.")    

lostanza defn eval-types (ys:ref<Tuple<VMImm>>, frame:ptr<StackFrame>, vmtable:ref<VMTable>) -> ref<Tuple<Int>> :
  ;Create void tuple
  val n = ys.length
  val ret = new Tuple{n}
  for (var i:int = 0, i < n, i = i + 1) :
    ret.items[i] = false
  ;Evaluate type of each y and store in tuple
  for (var i:int = 0, i < n, i = i + 1) :
    val t = eval-type(eval-imm(ys.items[i], frame, vmtable))
    ret.items[i] = t
  ;Return tuple
  return ret

lostanza defn eval-op (type:ref<VMType>, op:ref<VMOp>, y:long, vmtable:ref<VMTable>, livemap:ref<LiveMapTable>) -> long :  
  match(type) :
    (type:ref<VMByte>) :
      val y = y as byte
      match(op) :
        (op:ref<NotOp>) : return (~ y)
        (op) : (fatal("Illegal op."), return 0)
    (type:ref<VMInt>) :
      val y = y as int
      match(op) :
        (op:ref<NotOp>) : return (~ y)
        (op:ref<NegOp>) : return (- y)
        (op) : (fatal("Illegal op."), return 0)
    (type:ref<VMLong>) :
      match(op) :
        (op:ref<NotOp>) : return (~ y)
        (op:ref<NegOp>) : return (- y)
        (op:ref<InstanceofOp>) :
          val type = eval-type(y)
          return instanceof?(vmtable.class-table, type, /type(op)) == true
        (op:ref<StackMapOp>) :
          return stackmap-entry(livemap, y) as long
        (op) : (fatal("Illegal op."), return 0)
    (type:ref<VMFloat>) :
      val yint = y as int
      val y = ($ls-prim fnum yint)
      match(op) :
        (op:ref<NegOp>) : return float-to-bits((- y))
        (op) : (fatal("Illegal op."), return 0)
    (type:ref<VMDouble>) :
      val y = ($ls-prim fnum y)
      match(op) :
        (op:ref<NegOp>) : return double-to-bits((- y))
        (op) : (fatal("Illegal op."), return 0)
    (type:ref<VMRef>) :
      match(op) :
        (op:ref<TagOp>) :
          val t = /type(op).value
          if t == BYTE-TYPE.value :
            return y << 32L + BYTE-TAG-BITS
          else if t == CHAR-TYPE.value :
            return y << 32L + CHAR-TAG-BITS
          else if t == INT-TYPE.value :
            return y << 32L
          else if t == FLOAT-TYPE.value :
            return y << 32L + FLOAT-TAG-BITS
          else :
            fatal("Illegal op.")
            return 0
        (op:ref<DetagOp>) :
          return y >> 32L
        (op:ref<DerefOp>) :
          return untag(y) as long

lostanza defn bit-to-bool (x:long) -> long :
  return (x << 3L) + MARKER-TAG-BITS

lostanza defn eval-op (type:ref<VMType>, op:ref<VMOp>, y:long, z:long) -> long :
  match(type) :
    (type:ref<VMRef>) :
      match(op) :
        (op:ref<IntAddOp>) : return y + z
        (op:ref<IntSubOp>) : return y - z 
        (op:ref<IntMulOp>) : return (y >>> 32L) * z
        (op:ref<IntDivOp>) : return (y / z) << 32L
        (op:ref<IntModOp>) : return y % z
        (op:ref<IntAndOp>) : return y & z
        (op:ref<IntOrOp>) : return y | z
        (op:ref<IntXorOp>) : return y ^ z
        (op:ref<IntShlOp>) : return y << (z >>> 32L)
        (op:ref<IntShrOp>) : return ((y >> (z >>> 32L)) >> 32L) << 32L
        (op:ref<IntAshrOp>) : return ((y >>> (z >>> 32L)) >> 32L)
        (op:ref<IntLtOp>) : return bit-to-bool(y < z)
        (op:ref<IntGtOp>) : return bit-to-bool(y > z)
        (op:ref<IntLeOp>) : return bit-to-bool(y <= z)
        (op:ref<IntGeOp>) : return bit-to-bool(y >= z)
        (op:ref<RefEqOp>) : return bit-to-bool(y == z)
        (op:ref<RefNeOp>) : return bit-to-bool(y != z)
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
    (type:ref<VMByte>) :
      val y = y as byte
      val z = z as byte
      match(op) :
        (op:ref<AddOp>) : return y + z
        (op:ref<SubOp>) : return y - z 
        (op:ref<MulOp>) : return y * z
        (op:ref<DivOp>) : return y / z
        (op:ref<ModOp>) : return y % z
        (op:ref<AndOp>) : return y & z
        (op:ref<OrOp>) : return y | z
        (op:ref<XorOp>) : return y ^ z
        (op:ref<ShlOp>) : return y << z
        (op:ref<ShrOp>) : return y >> z
        (op:ref<AshrOp>) : return y >>> z
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<UleOp>) : return ($ls-prim ule y z)
        (op:ref<UltOp>) : return ($ls-prim ult y z)
        (op:ref<UgtOp>) : return ($ls-prim ugt y z)
        (op:ref<UgeOp>) : return ($ls-prim uge y z)
        (op) : (fatal("Illegal operand."), return 0)
    (type:ref<VMInt>) :
      val y = y as int
      val z = z as int
      match(op) :
        (op:ref<AddOp>) : return y + z
        (op:ref<SubOp>) : return y - z 
        (op:ref<MulOp>) : return y * z
        (op:ref<DivOp>) : return y / z
        (op:ref<ModOp>) : return y % z
        (op:ref<AndOp>) : return y & z
        (op:ref<OrOp>) : return y | z
        (op:ref<XorOp>) : return y ^ z
        (op:ref<ShlOp>) : return y << z
        (op:ref<ShrOp>) : return y >> z
        (op:ref<AshrOp>) : return y >>> z
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<LtOp>) : return y < z
        (op:ref<GtOp>) : return y > z
        (op:ref<LeOp>) : return y <= z
        (op:ref<GeOp>) : return y >= z
        (op:ref<UleOp>) : return ($ls-prim ule y z)
        (op:ref<UltOp>) : return ($ls-prim ult y z)
        (op:ref<UgtOp>) : return ($ls-prim ugt y z)
        (op:ref<UgeOp>) : return ($ls-prim uge y z)
    (type:ref<VMLong>) :
      match(op) :
        (op:ref<AddOp>) : return y + z
        (op:ref<SubOp>) : return y - z 
        (op:ref<MulOp>) : return y * z
        (op:ref<DivOp>) : return y / z
        (op:ref<ModOp>) : return y % z
        (op:ref<AndOp>) : return y & z
        (op:ref<OrOp>) : return y | z
        (op:ref<XorOp>) : return y ^ z
        (op:ref<ShlOp>) : return y << z
        (op:ref<ShrOp>) : return y >> z
        (op:ref<AshrOp>) : return y >>> z
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<LtOp>) : return y < z
        (op:ref<GtOp>) : return y > z
        (op:ref<LeOp>) : return y <= z
        (op:ref<GeOp>) : return y >= z
        (op:ref<UleOp>) : return ($ls-prim ule y z)
        (op:ref<UltOp>) : return ($ls-prim ult y z)
        (op:ref<UgtOp>) : return ($ls-prim ugt y z)
        (op:ref<UgeOp>) : return ($ls-prim uge y z)
    (type:ref<VMFloat>) :
      val yint = y as int
      val zint = z as int
      val y = ($ls-prim fnum yint)
      val z = ($ls-prim fnum zint)
      match(op) :
        (op:ref<AddOp>) : return float-to-bits(y + z)
        (op:ref<SubOp>) : return float-to-bits(y - z )
        (op:ref<MulOp>) : return float-to-bits(y * z)
        (op:ref<DivOp>) : return float-to-bits(y / z)
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<LtOp>) : return y < z
        (op:ref<GtOp>) : return y > z
        (op:ref<LeOp>) : return y <= z
        (op:ref<GeOp>) : return y >= z
        (op) : (fatal("Illegal operand."), return 0)      
    (type:ref<VMDouble>) :
      val y = ($ls-prim fnum y)
      val z = ($ls-prim fnum z)
      match(op) :
        (op:ref<AddOp>) : return double-to-bits(y + z)
        (op:ref<SubOp>) : return double-to-bits(y - z)
        (op:ref<MulOp>) : return double-to-bits(y * z)
        (op:ref<DivOp>) : return double-to-bits(y / z)
        (op:ref<EqOp>) : return y == z
        (op:ref<NeOp>) : return y != z
        (op:ref<LtOp>) : return y < z
        (op:ref<GtOp>) : return y > z
        (op:ref<LeOp>) : return y <= z
        (op:ref<GeOp>) : return y >= z
        (op) : (fatal("Illegal operand."), return 0)

lostanza defn eval-conv (op:ref<VMOp>, xtype:ref<VMType>, ytype:ref<VMType>, y:long) -> long :
  match(op) :
    (op:ref<ConvOp>) :
      match(xtype, ytype) :
        ;Integer <- Integer conversions
        (xtype:ref<VMByte|VMInt|VMLong>, ytype:ref<VMByte>) : return y as byte
        (xtype:ref<VMByte|VMInt|VMLong>, ytype:ref<VMInt>) : return y as int
        (xtype:ref<VMByte|VMInt|VMLong>, ytype:ref<VMLong>) : return y
        ;Float <- Integer conversions
        (xtype:ref<VMDouble>, ytype:ref<VMByte|VMInt|VMLong>) :
          val ylong = eval-conv(op, VMLong(), ytype, y)
          return double-to-bits(ylong as double)
        (xtype:ref<VMFloat>, ytype:ref<VMByte|VMInt|VMLong>) :
          val ylong = eval-conv(op, VMLong(), ytype, y)
          return float-to-bits(ylong as float)
        ;Integer <- Float conversions
        (xtype:ref<VMByte|VMInt|VMLong>, ytype:ref<VMFloat>) :
          val ylong = bits-to-float(y as int) as long
          return eval-conv(op, xtype, VMLong(), ylong)
        (xtype:ref<VMByte|VMInt|VMLong>, ytype:ref<VMDouble>) :
          val ylong = bits-to-double(y) as long
          return eval-conv(op, xtype, VMLong(), ylong)
        ;Float <- Float conversions          
        (xtype:ref<VMFloat>, ytype:ref<VMFloat>) : return y
        (xtype:ref<VMDouble>, ytype:ref<VMDouble>) : return y
        (xtype:ref<VMDouble>, ytype:ref<VMFloat>) :
          return double-to-bits(bits-to-float(y as int) as double)
        (xtype:ref<VMFloat>, ytype:ref<VMDouble>) :
          return float-to-bits(bits-to-double(y) as float)        
    (op:ref<InterpretOp>) :
      return y

defn print-ins (i:Int, ins:LinkedIns) :
  println("Trace (%_) %_" % [i, ins])

lostanza defn assign (frame:ptr<StackFrame>, l:ref<Local>, value:long) -> long :
  frame.slots[index(l).value] = value
  return 0

public defn run (vm:VirtualMachine, fid:Int) :
  run(vm, fid, false)

lostanza defn load-tag (y:long) -> ref<Int> :  
  val tagbits = y & 7L
  if tagbits != REF-TAG-BITS :
    fatal("Not a heap-allocated object!")
  return new Int{[(y - REF-TAG-BITS) as ptr<int>]}

lostanza defn object-size (y:long, c:ref<VMClass>) -> long :
  match(c) :
    (c:ref<VMLeafClass>) :
      return size(c).value
    (c:ref<VMArrayClass>) :
      val obj = (y - REF-TAG-BITS) as ptr<ObjectLayout>
      val length = obj.slots[0]
      if length < 0 : fatal("Negative length!")
      return base-size(c).value + length * item-size(c).value

public lostanza defn run (vm:ref<VirtualMachine>, start-func:ref<Int>, trace?:ref<True|False>) -> ref<False> :
  TRACE? = trace?
  ;Define machine quantities  
  val vmtable = vm.vmtable
  val instructions = vmtable.instructions
  val regs = vm.registers
  var heap-limit:ptr<long> = vm.heap-limit          ;[LOAD]
  var heap-top:ptr<long>                            ;[STORE/LOAD]
  var stack-pointer:ptr<StackFrame>                 ;[STORE/LOAD]
  var stack-end:ptr<StackFrame>                     ;[LOAD]
  var current-stack:long                            ;[STORE/LOAD]

  labels :
    begin :
      ;Retrieve pc of starting function
      val mainpc = get(vmtable.function-addresses, start-func).value
      
      ;Initialize starting stack
      if vm.current-stack == void-marker() :
        vm.current-stack = alloc-stack(vm, mainpc)
      else :
        val stk:ptr<Stack> = untag(vm.current-stack)
        stk.pc = mainpc

      ;Set heap-top
      heap-top = vm.heap-top
      goto load-stack(vm.current-stack)
    load-stack (stack:long) :
      current-stack = stack
      val sptr:ptr<Stack> = untag(current-stack)
      stack-pointer = sptr.stack-pointer
      stack-end = /stack-end(current-stack)
      goto step(sptr.pc)      
    call-function (fid:int, return:int) :
      stack-pointer.return = return
      val pos = get(vmtable.function-addresses, new Int{fid}).value
      goto step(pos)
    tcall-function (fid:int) :
      val pos = get(vmtable.function-addresses, new Int{fid}).value
      goto step(pos)      
    step (pc:int) :
      val ins = get(instructions, new Int{pc})
      if trace? == true :
        call-c clib/printf(" In frame %p: ", stack-pointer)
        print-ins(new Int{pc}, ins)
      match(ins) :
        (ins:ref<NewStackIns>) :
          val fid = eval-imm(fid(ins), stack-pointer, vmtable) as int
          val fpc = get(vmtable.function-addresses, new Int{fid}).value
          vm.heap-top = heap-top
          val stk = alloc-stack(vm, fpc)
          heap-top = vm.heap-top
          assign(stack-pointer, x(ins), stk)
          goto step(pc + 1)
        (ins:ref<SetIns>) :
          assign(stack-pointer, x(ins), eval-imm(y(ins), stack-pointer, vmtable))
          goto step(pc + 1)
        (ins:ref<Op0Ins>) :
          assign(stack-pointer, x(ins), eval-op(op(ins), current-stack, stack-pointer, vmtable))
          goto step(pc + 1)
        (ins:ref<LinkedVMCall>) :
          match(op(ins)) :
            (op:ref<GCOp>) :            
              ;Evaluate size
              val total-size = eval-imm(y(ins), stack-pointer, vmtable)
              ;Store required values
              vm.heap-top = heap-top
              vm.stack-pointer = stack-pointer
              vm.current-stack = current-stack
              ;Run garbage collector
              extend-heap(vm, total-size)
              ;Load required values
              heap-limit = vm.heap-limit
              heap-top = vm.heap-top
              stack-pointer = vm.stack-pointer
              current-stack = vm.current-stack
              stack-end = /stack-end(current-stack)
              ;Return 0
              regs[0] = 0L
              goto step(pc + 1)
            (op) :
              fatal("Unreachable")
        (ins:ref<LinkedOp1Ins>) :
          val y = eval-imm(y(ins), stack-pointer, vmtable)
          assign(stack-pointer, x(ins), eval-op(type(ins), op(ins), y, vmtable, live-map-table(vm.linker)))
          goto step(pc + 1)        
        (ins:ref<LinkedOp2Ins>) :
          val y = eval-imm(y(ins), stack-pointer, vmtable)
          val z = eval-imm(z(ins), stack-pointer, vmtable)
          assign(stack-pointer, x(ins), eval-op(type(ins), op(ins), y, z))
          goto step(pc + 1)
        (ins:ref<LinkedConvIns>) :
          val y = eval-imm(y(ins), stack-pointer, vmtable)
          val result = eval-conv(op(ins), xtype(ins), ytype(ins), y)
          assign(stack-pointer, x(ins), result)
          goto step(pc + 1)
        (ins:ref<LinkedReserveIns>) :
          ;Compute size to allocate
          val size = eval-imm(space(ins), stack-pointer, vmtable)
          if size & 0x7L : fatal("Size is not a multiple of 8.")
          val total-size = size + 8 * num-obj(ins).value

          ;If there is enough space
          if heap-top + total-size <= heap-limit :
            goto step(pc + n(ins).value)
          else :
            ;Set arguments
            regs[0] = false-marker()  ;Closure is false
            regs[1] = 1L              ;arity = 1
            regs[2] = total-size      ;size argument
            val fid = get(vm.loaded-ids, CORE-EXTEND-HEAP-ID).value
            stack-pointer = stack-pointer + frame-size(ins).value
            goto call-function(fid, pc + 1)          
        (ins:ref<LinkedAllocIns>) :
          val size = eval-imm(size(ins), stack-pointer, vmtable)
          if size < 8 : fatal("Invalid size for object.")
          val total-size = size + 8
          [heap-top] = type(ins).value
          val obj = tag(heap-top)
          if trace? == true : print-tag(obj)
          assign(stack-pointer, x(ins), obj)          
          heap-top = heap-top + total-size
          if heap-top > heap-limit : fatal("Beyond heap limits.")
          goto step(pc + 1)
        (ins:ref<LinkedRefStoreIns>) :
          val x = eval-imm(x(ins), stack-pointer, vmtable)
          val y = eval-imm(y(ins), stack-pointer, vmtable)
          val z = eval-imm(z(ins), stack-pointer, vmtable)
          val o = offset(ins).value
          val sz = size(ins).value

          ;Sanity checks
          ;- x is a heap-allocated reference.
          ;- x has the expected tag.
          ;- the store value has size 8, if a store to the length
          ;  field of an array.
          ;- the store offset is within bounds of the object (if not a
          ;   store to the length field of an array.)
          ;- the store offset is aligned with the size.
          val xtype = load-tag(x)
          if class(ins) != false :
            if xtype != class(ins) :
              fatal("Object has unexpected tag.")
          val class = get(vm.vmtable.class-table, xtype)
          if y + o < 0 : fatal("Load from negative index.")
          if (y + o) & (sz - 1) : fatal("Unaligned load.")         
          match(class) :
            (class:ref<VMArrayClass>) :
              if y + o == 0 :
                if sz != 8 : fatal("Inappropriate length field.")              
              else :
                val xsize = object-size(x, class)
                if y + o + sz > xsize : fatal("Load out of bounds.")
            (class:ref<VMLeafClass>) :
              val xsize = object-size(x, class)
              if y + o + sz > xsize : fatal("Load out of bounds.")

          ;Execution
          val xptr = untag(x)
          if sz == 1 : [xptr as ptr<byte> + y + o] = z as byte
          else if sz == 4 : [xptr as ptr<int> + y + o] = z as int
          else if sz == 8 : [xptr as ptr<long> + y + o] = z as long
          else : fatal("Invalid size.")
          goto step(pc + 1)
        (ins:ref<LinkedRefLoadIns>) :
          val y = eval-imm(y(ins), stack-pointer, vmtable)
          val z = eval-imm(z(ins), stack-pointer, vmtable)
          val o = offset(ins).value
          val sz = size(ins).value

          ;Sanity checks
          ;- y is a heap-allocated reference.
          ;- y has the expected tag.
          ;- the load offset is within bounds of the object.
          ;- the load offset is aligned with the size.
          val ytype = load-tag(y)
          if class(ins) != false :
            if ytype != class(ins) :
              fatal("Object has unexpected tag.")
          val ysize = object-size(y, get(vm.vmtable.class-table, ytype))
          if z + o < 0 : fatal("Load from negative index.")
          if z + o + sz > ysize : fatal("Load out of bounds.")
          if (z + o) & (sz - 1) : fatal("Unaligned load.")         

          ;Execution
          val yptr:ptr<long> = untag(y)
          var value:long
          if sz == 1 : value = [yptr as ptr<byte> + z + o]
          else if sz == 4 : value = [yptr as ptr<int> + z + o]
          else if sz == 8 : value = [yptr as ptr<long> + z + o]
          else : fatal("Invalid size.")
          assign(stack-pointer, x(ins), value)
          goto step(pc + 1)
        (ins:ref<LinkedStoreIns>) :
          val x = eval-imm(x(ins), stack-pointer, vmtable)
          val y = eval-imm(y(ins), stack-pointer, vmtable)
          val z = eval-imm(z(ins), stack-pointer, vmtable)
          val o = offset(ins).value
          val sz = size(ins).value

          ;Sanity checks
          ;- the store value has size 8, if a store to the length
          ;  field of an array.
          ;- the store offset is within bounds of the object (if not a
          ;   store to the length field of an array.)
          ;- the store offset is aligned with the size.
          if class(ins) != false :
            val xtype = class(ins) as ref<Int>
            val class = get(vm.vmtable.class-table, xtype)
            if y + o < 0 : fatal("Load from negative index.")
            if (y + o) & (sz - 1) : fatal("Unaligned load.")         
            match(class) :
              (class:ref<VMArrayClass>) :
                if y + o == 0 :
                  if sz != 8 : fatal("Inappropriate length field.")              
                else :
                  val xsize = object-size(x, class)
                  if y + o + sz > xsize : fatal("Load out of bounds.")
              (class:ref<VMLeafClass>) :
                val xsize = object-size(x, class)
                if y + o + sz > xsize : fatal("Load out of bounds.")
          

          ;Execution
          if sz == 1 : [x as ptr<byte> + y + o] = z as byte
          else if sz == 4 : [x as ptr<int> + y + o] = z as int
          else if sz == 8 : [x as ptr<long> + y + o] = z as long
          else : fatal("Invalid size.")
          goto step(pc + 1)
        (ins:ref<LinkedLoadIns>) :
          val y = eval-imm(y(ins), stack-pointer, vmtable)
          val z = eval-imm(z(ins), stack-pointer, vmtable)
          val o = offset(ins).value
          val sz = size(ins).value

          ;Sanity checks
          ;- the load offset is within bounds of the object.
          ;- the load offset is aligned with the size.
          if class(ins) != false :
            val ytype = class(ins) as ref<Int>
            val ysize = object-size(y, get(vm.vmtable.class-table, ytype))
            if z + o < 0 : fatal("Load from negative index.")
            if z + o + sz > ysize : fatal("Load out of bounds.")
            if (z + o) & (sz - 1) : fatal("Unaligned load.")         

          ;Execution
          var value:long
          if sz == 1 : value = [y as ptr<byte> + z + o]
          else if sz == 4 : value = [y as ptr<int> + z + o]
          else if sz == 8 : value = [y as ptr<long> + z + o]
          else : fatal("Invalid size.")
          assign(stack-pointer, x(ins), value)
          goto step(pc + 1)
        (ins:ref<GotoIns>) :
          goto step(pc + n(ins).value)
        (ins:ref<Branch1Ins>) :
          val x = eval-imm(x(ins), stack-pointer, vmtable)
          match(op(ins)) :
            (op:ref<VMOp>) :
              val r = eval-op(VMLong(), op, x, vmtable, live-map-table(vm.linker))
              if r : goto step(pc + n1(ins).value)
              else : goto step(pc + n2(ins).value)
            (op:ref<False>) :
              if x : goto step(pc + n1(ins).value)
              else : goto step(pc + n2(ins).value)
        (ins:ref<LinkedBranch2Ins>) :
          val x = eval-imm(x(ins), stack-pointer, vmtable)
          val y = eval-imm(y(ins), stack-pointer, vmtable)
          val r = eval-op(type(ins), op(ins), x, y)
          if r : goto step(pc + n1(ins).value)
          else : goto step(pc + n2(ins).value)
        (ins:ref<LinkedDispatchIns>) :
          val ytypes = eval-types(ys(ins), stack-pointer, vmtable)
          match(dispatch(vmtable.branch-table, format(ins), ytypes)) :
            (r:ref<Int>) : goto step(pc + get(ns(ins), r).value)
            (r:ref<CodeId>) : goto tcall-function(id(r).value)
            (r:ref<Default>) : goto step(pc + default(ins).value)
            (r:ref<Amb>) : goto step(pc + amb(ins).value)
        (ins:ref<SetReg>) :
          regs[reg(ins).value] = eval-imm(x(ins), stack-pointer, vmtable)
          goto step(pc + 1)
        (ins:ref<GetReg>) :
          assign(stack-pointer, x(ins), regs[reg(ins).value])
          if trace? == true and ref?(ins) == true :
            print-tag(regs[reg(ins).value])
          goto step(pc + 1)
        (ins:ref<PopFrameIns>) :
          stack-pointer = stack-pointer - frame-size(ins).value
          goto step(pc + 1)        
        (ins:ref<LinkedCall>) :          
          val fid = eval-imm(f(ins), stack-pointer, vmtable) as int
          stack-pointer = stack-pointer + frame-size(ins).value
          goto call-function(fid, pc + 1)
        (ins:ref<LinkedCallClosure>) :
          val fref = eval-imm(f(ins), stack-pointer, vmtable)

          ;Sanity check: Check that f is actually a function
          val ftype = load-tag(fref)
          if ftype != FN-TYPE and ftype != TYPE-TYPE :
            call-c clib/printf("ftype = %d, fref = %p\n", ftype, fref)
            fatal("Attempt to call non-closure.")

          val fptr = untag(fref) as ptr<Function>
          val fid = fptr.code as int
          stack-pointer = stack-pointer + frame-size(ins).value
          goto call-function(fid, pc + 1)
        (ins:ref<LinkedTCall>) :          
          val fid = eval-imm(f(ins), stack-pointer, vmtable) as int
          goto tcall-function(fid)
        (ins:ref<LinkedTCallClosure>) :
          val fref = eval-imm(f(ins), stack-pointer, vmtable)

          ;Sanity check: Check that f is actually a function
          val ftype = load-tag(fref)
          if ftype != FN-TYPE and ftype != TYPE-TYPE :
            call-c clib/printf("ftype = %d, fref = %p\n", ftype, fref)
            fatal("Attempt to call non-closure.")

          ;Execution
          val fptr = untag(fref) as ptr<Function>
          val fid = fptr.code as int
          goto tcall-function(fid)
        (ins:ref<LinkedCallC>) :
          val faddr = eval-imm(f(ins), stack-pointer, vmtable)
          val launcher = launcher(ins).value as ptr<((long, ptr<long>) -> long)>
          stack-pointer = stack-pointer + frame-size(ins).value
          [launcher](faddr, regs)
          stack-pointer = stack-pointer - frame-size(ins).value
          goto step(pc + 1)
        (ins:ref<LinkedYield>) :
          ;Save current stack
          val s:ptr<Stack> = untag(current-stack)
          s.stack-pointer = stack-pointer
          s.pc = pc + 1
          ;Load next next
          val sref = eval-imm(f(ins), stack-pointer, vmtable)
          ;Sanity check: Check that sref is a stack
          val stype = load-tag(sref)
          if stype != STACK-TYPE : fatal("Attempt to yield to non-stack.")          
          goto load-stack(sref)
        (ins:ref<LinkedReturn>) :
          val ret = stack-pointer.return as int
          if ret >= 0 : goto step(ret)          
        (ins:ref<FunctionEntry>) :
          val frame-size = (num-locals(ins).value * 8 + sizeof(StackFrame)) as int
          val size-required = frame-size + sizeof(StackFrame)
          if stack-pointer + size-required > stack-end :
            ;Store required values
            vm.heap-top = heap-top
            vm.stack-pointer = stack-pointer
            vm.current-stack = current-stack
            ;Run garbage collector
            extend-stack(vm, size-required)
            ;Load required values
            heap-limit = vm.heap-limit
            heap-top = vm.heap-top
            stack-pointer = vm.stack-pointer
            current-stack = vm.current-stack
            stack-end = /stack-end(current-stack)
          if trace? == true : call-c clib/printf("Entered with stack pointer = %p\n", stack-pointer)
          goto step(pc + 1)
        (ins:ref<LinkedDump>) :
          val xvalue = eval-imm(x(ins), stack-pointer, vmtable)
          val xint = xvalue as int
          val xvaluef = ($ls-prim fnum xint)
          val xvalued = ($ls-prim fnum xvalue)
          call-c clib/printf("> L%d = %ld (float = %f, double = %f)\n",
                             index(x(ins)).value, xvalue, xvaluef, xvalued)
          if trace? == true and ref?(ins) == true : print-tag(xvalue)
          goto step(pc + 1)
        (ins:ref<LinkedLiveIns>) :
          stack-pointer.liveness-map = map(ins).value
          if trace? == true : call-c clib/printf("Saved map to frame %p\n", stack-pointer)
          goto step(pc + 1)
        (ins:ref<LinkedBranchRegIns>) :
          val rvalue = regs[reg(ins).value] as int
          if rvalue == value(ins).value : goto step(pc + n(ins).value)
          else : goto step(pc + 1)
        (ins:ref<CommentIns>) :
          goto step(pc + 1)

  val stk:ptr<Stack> = untag(current-stack)
  vm.heap-top = heap-top
  vm.current-stack = current-stack
  vm.stack-pointer = stack-pointer
  stk.stack-pointer = stack-pointer
  return false

;============================================================
;==================== Dispatch ==============================
;============================================================

public deftype BranchTable
deftype BranchFormat <: Hashable&Equalable
defmulti add (t:BranchTable, f:BranchFormat) -> Int
defmulti dispatch (t:BranchTable, f:Int, types:Tuple<Int>) -> DispatchResult
defmulti update (t:BranchTable) -> False
defmulti load-methods (t:BranchTable, ms:Seqable<VMMethod>, package:Symbol) -> False

deftype DispatchResult :
  Int <: DispatchResult
  CodeId <: DispatchResult
defstruct Default <: DispatchResult
defstruct Amb <: DispatchResult

deftype DispatchAction
defmulti dispatch (a:DispatchAction, types:Tuple<Int>) -> DispatchResult

defstruct LoadedMethod :
  multi: Int
  types: Tuple<TypeSet>
  fid: Int
  package: Symbol
  instance-method?: True|False
with:
  printer => true

var TRACE?:True|False = false

defn BranchTable (ct:ClassTable) :
  ;Store formats in ctable
  val formats = Vector<BranchFormat>()
  val actions = Vector<DispatchAction|False>()
  val format-table = HashTable<BranchFormat,Int>()
  val methods = Vector<LoadedMethod>()

  ;Load new methods
  defn load-methods (ms:Seqable<VMMethod>, package-name:Symbol) :
    ;Remove old methods
    for m in methods remove-when :
      if not instance-method?(m) :
        package(m) == package-name
    ;Add new methods
    for m in ms do :
      add(methods, LoadedMethod(multi(m), types(m), fid(m), package-name, instance?(m)))

  ;Compute dispatch actions
  defn DispatchAction (f:BranchFormat) :
    defn match? (xtypes:Tuple<Int>, types:Tuple<TypeSet>) :
      all?(instanceof?{ct, _, _}, xtypes, types)
    match(f) :
      (f:DispatchFormat) :
        val indexed-branches = to-tuple $ seq(KeyValue, branches(f), 0 to false)
        val dispatch-branches = dispatch-ordering(ct, indexed-branches, key)
        new DispatchAction :
          defmethod dispatch (this, xtypes:Tuple<Int>) :
            if TRACE? :
              println("Execute Dispatch Branch using types: %_" % [xtypes])
              println("Branches are:\n%n" % [dispatch-branches])
            val result = label<DispatchResult> return :
              for b in dispatch-branches do :
                match(b) :
                  (b:KeyValue<Tuple<TypeSet>,Int>) :
                    return(value(b)) when match?(xtypes, key(b))
                  (bs:Tuple<KeyValue<Tuple<TypeSet>,Int>>) :
                    val c = for b in bs count :
                      match?(xtypes, key(b))
                    return(Amb()) when c > 1
              Default()
            if TRACE? :
              println("result = %_" % [result])
            result
      (f:MatchFormat) :
        new DispatchAction :
          defmethod dispatch (this, xtypes:Tuple<Int>) :
            if TRACE? :
              println("Execute Match Branch using types: %_" % [xtypes])
              println("Branches are:\n%n" % [branches(f)])          
            val result = label<DispatchResult> return :
              for (types in branches(f), i in 0 to false) do :
                return(i) when match?(xtypes, types)
              Default()
            if TRACE? :
              println("result = %_" % [result])
            result
      (f:MultiFormat) :
        val methods = to-tuple(filter({multi(_) == multi(f)}, methods))
        val dispatch-methods = dispatch-ordering(ct, methods, types)
        new DispatchAction :
          defmethod dispatch (this, xtypes:Tuple<Int>) :
            if TRACE? :
              println("Execute Multi Branch using types: %_" % [xtypes])
              println("Methods are:\n%n" % [dispatch-methods])          
            val result = label<DispatchResult> return :
              for m in dispatch-methods do :
                match(m) :
                  (m:LoadedMethod) :                  
                    return(CodeId(fid(m))) when match?(xtypes, types(m))
                  (ms:Tuple<LoadedMethod>) :
                    val c = for m in ms count :
                      match?(xtypes, types(m))
                    return(Amb()) when c > 1
              Default()
            if TRACE? :
              println("result = %_" % [result])
            result
  defn update-actions () :
    for (f in formats, i in 0 to false) do :
      actions[i] = DispatchAction(f)

  new BranchTable :
    defmethod add (this, f:BranchFormat) :
      match(get?(format-table, f)) :
        (i:Int) :
          i
        (_:False) :
          val i = length(formats)
          add(formats, f)
          add(actions, false)
          format-table[f] = i
          i
    defmethod dispatch (this, f:Int, types:Tuple<Int>) :
      dispatch(actions[f] as DispatchAction, types)
    defmethod update (this) :
      update-actions()
    defmethod load-methods (this, ms:Seqable<VMMethod>, package:Symbol) :
      load-methods(ms, package)

defstruct DispatchFormat <: BranchFormat :
  branches: Tuple<Tuple<TypeSet>>
with: (printer => true)
defmethod hash (f:DispatchFormat) : hash(branches(f))
defmethod equal? (a:DispatchFormat, b:DispatchFormat) : branches(a) == branches(b)

defn DispatchFormat (branches:Tuple<VMBranch>) -> [DispatchFormat, Tuple<Int>] :
  val bs = to-array<VMBranch> $
    for b in branches seq :
      val types* = map(normalize, types(b))
      VMBranch(types*, n(b))
  qsort!(types, bs)
  val format = DispatchFormat(to-tuple(seq(types,bs)))
  val targets = to-tuple(seq(n,bs))
  [format, targets]

defstruct MatchFormat <: BranchFormat :
  branches: Tuple<Tuple<TypeSet>>
with: (printer => true)
defmethod hash (f:MatchFormat) : hash(branches(f))
defmethod equal? (a:MatchFormat, b:MatchFormat) : branches(a) == branches(b)

defn MatchFormat (branches:Tuple<VMBranch>) -> [MatchFormat, Tuple<Int>] :
  val types* = for b in branches map :
    map(normalize, types(b))
  val format = MatchFormat(types*)
  val targets = map(n,branches)
  [format, targets]

defstruct MultiFormat <: BranchFormat :
  multi: Int
with: (printer => true)
defmethod hash (f:MultiFormat) : multi(f)
defmethod equal? (a:MultiFormat, b:MultiFormat) : multi(a) == multi(b)

lostanza defn branch-table (vm:ref<VirtualMachine>) -> ref<BranchTable> :
  return vm.vmtable.branch-table

;============================================================
;==================== Heap/Stack Extension ==================
;============================================================

extern memcpy : (ptr<?>, ptr<?>, long) -> int
lostanza defn extend-stack (vm:ref<VirtualMachine>, size:long) -> long :
  ;Retrieve current stack
  val s:ptr<Stack> = untag(vm.current-stack)
  ;Compute new size of stack
  val desired-size = vm.stack-pointer + size - s.frames
  var size*:long = s.size
  while size* < desired-size : size* = size* * 2
  ;Allocate new frames, and copy over old frames
  val frames* = call-c clib/malloc(size*)
  call-c memcpy(frames*, s.frames, s.size)
  ;Free old frames and swap in new frames
  val sp-pos = vm.stack-pointer - s.frames
  call-c clib/free(s.frames)
  s.size = size*
  s.frames = frames*
  vm.stack-pointer = s.frames + sp-pos
  ;Return  
  return 0

lostanza defn extend-heap (vm:ref<VirtualMachine>, size:long) -> long :
  ;First run the garbage collector,
  collect-garbage(vm)
  
  ;then check whether we're still out of space.
  if vm.heap-top + size > vm.heap-limit :
    ;Compute desired heap size
    val desired-space = vm.heap-top + size - vm.heap
    var space:long = vm.heap-limit - vm.heap    
    while space < desired-space : space = space * 2
    ;Resize the heap and use the GC to move contents over
    resize-freespace(vm, space)
    collect-garbage(vm)
    resize-freespace(vm, space)
    ;Now we have enough space.
    return 0

  ;at this point, we don't need to expand the heap,
  ;but we might want to for next time. 
  else :
    ;Expand the freeheap if we're using more than 50% of it,
    ;or if the heapspace is bigger than the freespace.
    val used-space = vm.heap-top - vm.heap
    val heap-space = vm.heap-limit - vm.heap
    val free-space = vm.free-limit - vm.free
    val usage-ratio = (used-space as float) / (heap-space as float)
    ;Resize free if the usage-ratio is too high
    if usage-ratio > 0.5f :
      resize-freespace(vm, heap-space * 2)
    ;Otherwise resize free if the heap is larger than free
    else if heap-space > free-space :
      resize-freespace(vm, heap-space)
    ;We have enough space to satisfy the request
    return 0  

lostanza defn resize-freespace (vm:ref<VirtualMachine>, space:long) -> int :
  call-c clib/free(vm.free)
  vm.free = call-c clib/malloc(space)
  vm.free-limit = vm.free + space
  return 0

;============================================================
;==================== Garbage Collector =====================
;============================================================

lostanza defn collect-garbage (vm:ref<VirtualMachine>) -> long :  
  ;Cap the current stack
  val s:ptr<Stack> = untag(vm.current-stack)
  s.stack-pointer = vm.stack-pointer
  
  ;Swap free with heap
  val heap = vm.heap
  val heap-limit = vm.heap-limit
  val free = vm.free
  val free-limit = vm.free-limit
  vm.heap = free
  vm.heap-top = free
  vm.heap-limit = free-limit
  vm.free = heap
  vm.free-limit = heap-limit

  ;Scan global roots
  val globals:ptr<long> = vm.vmtable.globals.mem
  val roots = to-seq(roots(vm.vmtable.global-table))
  while empty?(roots) == false :
    val i = next(roots).value
    globals[i] = post-gc-object(globals[i], vm)

  ;Scan const roots
  val nconsts = vm.vmtable.consts.size / 8
  val consts:ptr<long> = vm.vmtable.consts.mem
  for (var i:int = 0, i < nconsts, i = i + 1) :
    consts[i] = post-gc-object(consts[i], vm)

  ;Scan stack roots
  vm.current-stack = post-gc-object(vm.current-stack, vm)

  ;Scan heap
  scan-heap(vm)
  
  ;Return
  return 0

lostanza defn num-slots (f:ptr<StackFrame>, vm:ref<VirtualMachine>) -> int :
  val map = get(live-map-table(vm.linker), new Int{f.liveness-map as int})
  return num-slots(map).value

lostanza defn scan-frames (frames:ptr<StackFrame>, f-end:ptr<StackFrame>, vm:ref<VirtualMachine>) -> int :
  var f:ptr<StackFrame> = frames
  while f <= f-end :
    val map = get(live-map-table(vm.linker), new Int{f.liveness-map as int})
    val live-slots = live-slots(map)
    val num-live = length(live-slots).value
    for (var i:int = 0, i < num-live, i = i + 1) :
      val s = get(live-slots, new Int{i}).value
      f.slots[s] = post-gc-object(f.slots[s], vm)
    f = addr(f.slots[num-slots(map).value]) as ptr<StackFrame>
  return 0

lostanza defn scan-heap (vm:ref<VirtualMachine>) -> int :
  var p:ptr<long> = vm.heap
  val class-table = vm.vmtable.class-table
  while p < vm.heap-top :
    p = scan-object(p, vm, class-table)
  return 0

lostanza defn scan-object (p:ptr<long>, vm:ref<VirtualMachine>, class-table:ref<ClassTable>) -> ptr<long> :
  ;p is [tag, cells ...]
  val tag = [p] as int
  val class = get(class-table, new Int{tag})
  match(class) :
    (class:ref<VMLeafClass>) :
      ;Scan the frames of a stack
      if tag == STACK-TYPE.value :
        val s = (p + 8) as ptr<Stack>
        scan-frames(s.frames, s.stack-pointer, vm)
      ;Get properties
      val size = size(class).value
      val roots = roots(class)
      val num-roots = length(roots).value
      ;Scan slots
      val obj = p as ptr<ObjectLayout>      
      for (var i:int = 0, i < num-roots, i = i + 1) :
        val r = get(roots, new Int{i}).value
        obj.slots[r] = post-gc-object(obj.slots[r], vm)
      ;Return end of object
      return p + 8 + size
    (class:ref<VMArrayClass>) :
      ;Get properties
      val base-roots = base-roots(class)
      val item-roots = item-roots(class)
      val base-size = base-size(class).value
      val item-size = item-size(class).value
      val num-base-roots = length(base-roots).value
      val num-item-roots = length(item-roots).value
      ;Scan base roots
      val array = p as ptr<ObjectLayout>
      val len = array.slots[0]
      for (var i:int = 0, i < num-base-roots, i = i + 1) :
        val r = get(base-roots, new Int{i}).value
        array.slots[r] = post-gc-object(array.slots[r], vm)
      ;Scan item roots
      var items:ptr<long> = addr(array.slots) + base-size
      if num-item-roots > 0 :
        for (var n:long = 0, n < len, n = n + 1) :
          for (var i:int = 0, i < num-item-roots, i = i + 1) :
            val r = get(item-roots, new Int{i}).value
            items[r] = post-gc-object(items[r], vm)
          items = items + item-size
      ;Return end of array
      val size = (8 + base-size + item-size * len + 7L) & -8L
      return p + size

lostanza defn post-gc-object (ref:long, vm:ref<VirtualMachine>) -> long :
  val tagbits = ref & 7L
  if tagbits == REF-TAG-BITS :
    val obj = (ref - REF-TAG-BITS) as ptr<long>
    val obj-tag = [obj]
    ;Case: Broken Heart
    if obj-tag == -1L :
      val heart = obj as ptr<BrokenHeartLayout>
      return heart.forward
    ;Case: Uncopied object
    else :
      val obj* = tag(vm.heap-top)
      val class = get(vm.vmtable.class-table, new Int{obj-tag as int})
      copy-bytes-to-heap(obj, num-bytes(obj, class, vm), vm)
      set-broken-heart(obj, obj*)
      return obj*
  else :
    return ref

lostanza defn set-broken-heart (obj:ptr<long>, obj*:long) -> int :
  val heart = obj as ptr<BrokenHeartLayout>
  heart.tag = -1L
  heart.forward = obj*
  return 0

lostanza defn num-bytes (obj:ptr<?>, class:ref<VMClass>, vm:ref<VirtualMachine>) -> long :
  match(class) :
    (class:ref<VMLeafClass>) :
      return 8 + size(class).value
    (class:ref<VMArrayClass>) :
      val array = obj as ptr<ObjectLayout>
      val len = array.slots[0]
      val base-size = base-size(class).value
      val item-size = item-size(class).value
      return (8 + base-size + len * item-size + 7) & -8L
  
lostanza defn copy-bytes-to-heap (p:ptr<?>, n:long, vm:ref<VirtualMachine>) -> int :
  val heap = vm.heap-top
  val nwords = n >>> 3
  val src = p as ptr<long>
  for (var i:long = 0, i < nwords, i = i + 1) :
    heap[i] = src[i]
  vm.heap-top = heap + n
  return 0

;============================================================
;==================== Liveness Detector =====================
;============================================================

lostanza var LIVENESS-BUFFER:ptr<BrokenHeartLayout>
lostanza var LIVENESS-BUFFER-TOP:ptr<BrokenHeartLayout>

lostanza defn mark-in-liveness-buffer (obj:ptr<ObjectLayout>) -> int :
  if obj.tag == -1L : fatal("Already marked!")
  LIVENESS-BUFFER-TOP.tag = obj.tag
  LIVENESS-BUFFER-TOP.forward = obj as long
  LIVENESS-BUFFER-TOP = LIVENESS-BUFFER-TOP + sizeof(BrokenHeartLayout)
  obj.tag = -1L
  return 0

lostanza defn mark-ref (ref:long) -> int :
  val tagbits = ref & 7L
  if tagbits == REF-TAG-BITS :
    val obj = (ref - REF-TAG-BITS) as ptr<ObjectLayout>
    ;If object is not already marked
    if obj.tag != -1L :
      mark-in-liveness-buffer(obj)
  return 0

lostanza defn mark-frames (frames:ptr<StackFrame>, f-end:ptr<StackFrame>, vm:ref<VirtualMachine>) -> int :
  var f:ptr<StackFrame> = frames
  while f <= f-end :
    val map = get(live-map-table(vm.linker), new Int{f.liveness-map as int})
    val live-slots = live-slots(map)
    val num-live = length(live-slots).value
    for (var i:int = 0, i < num-live, i = i + 1) :
      val s = get(live-slots, new Int{i}).value
      mark-ref(f.slots[s])
    f = addr(f.slots[num-slots(map).value]) as ptr<StackFrame>
  return 0

lostanza defn mark-object (p:ptr<long>, tag:int, vm:ref<VirtualMachine>, class-table:ref<ClassTable>) -> int :
  ;p is [tag, cells ...]
  val class = get(class-table, new Int{tag})
  match(class) :
    (class:ref<VMLeafClass>) :
      ;Mark the frames of a stack
      if tag == STACK-TYPE.value :
        val s = (p + 8) as ptr<Stack>
        mark-frames(s.frames, s.stack-pointer, vm)
      ;Get properties
      val size = size(class).value
      val roots = roots(class)
      val num-roots = length(roots).value
      ;Mark slots
      val obj = p as ptr<ObjectLayout>      
      for (var i:int = 0, i < num-roots, i = i + 1) :
        val r = get(roots, new Int{i}).value
        mark-ref(obj.slots[r])
    (class:ref<VMArrayClass>) :
      ;Get properties
      val base-roots = base-roots(class)
      val item-roots = item-roots(class)
      val base-size = base-size(class).value
      val item-size = item-size(class).value
      val num-base-roots = length(base-roots).value
      val num-item-roots = length(item-roots).value
      ;Mark base roots
      val array = p as ptr<ObjectLayout>
      val len = array.slots[0]
      for (var i:int = 0, i < num-base-roots, i = i + 1) :
        val r = get(base-roots, new Int{i}).value
        mark-ref(array.slots[r])
      ;Mark item roots
      var items:ptr<long> = addr(array.slots) + base-size
      if num-item-roots > 0 :
        for (var n:long = 0, n < len, n = n + 1) :
          for (var i:int = 0, i < num-item-roots, i = i + 1) :
            val r = get(item-roots, new Int{i}).value
            mark-ref(items[r])
          items = items + item-size
  return 0

lostanza defn mark-liveness-buffer (vm:ref<VirtualMachine>) -> int :  
  val class-table = vm.vmtable.class-table
  var buffer:ptr<BrokenHeartLayout> = LIVENESS-BUFFER
  while buffer < LIVENESS-BUFFER-TOP :
    mark-object(buffer.forward as ptr<long>, buffer.tag as int, vm, class-table)
    buffer = buffer + sizeof(BrokenHeartLayout)
  return 0

lostanza defn restore-tag (heart:ptr<BrokenHeartLayout>) -> int :
  val obj = heart.forward as ptr<ObjectLayout>
  obj.tag = heart.tag
  return 0

public lostanza defn compute-live (vm:ref<VirtualMachine>, exclude:ref<Seqable<Symbol>>) -> ref<Tuple<Rec>> :
  ;Use free memory for liveness buffer
  ;(Guaranteed to be large enough)
  LIVENESS-BUFFER = vm.free as ptr<BrokenHeartLayout>
  LIVENESS-BUFFER-TOP = vm.free as ptr<BrokenHeartLayout>

  ;Scan global roots
  val globals:ptr<long> = vm.vmtable.globals.mem
  val roots = to-seq(roots(vm.vmtable.global-table, exclude))
  while empty?(roots) == false :
    val i = next(roots).value
    mark-ref(globals[i])

  ;Scan const roots
  val nconsts = vm.vmtable.consts.size / 8
  val consts:ptr<long> = vm.vmtable.consts.mem
  for (var i:int = 0, i < nconsts, i = i + 1) :
    mark-ref(consts[i])

  ;Scan stack roots
  mark-ref(vm.current-stack)

  ;Scan liveness buffer
  mark-liveness-buffer(vm)

  ;Get live set
  val live-recs = RecSet()
  for (var heart:ptr<BrokenHeartLayout> = LIVENESS-BUFFER,
       heart < LIVENESS-BUFFER-TOP,
       heart = heart + sizeof(BrokenHeartLayout)) :
    val tag = heart.tag as int
    if tag == FN-TYPE.value :
      val f = (heart.forward + 8L) as ptr<Function>
      val code = new Int{f.code as int}
      add-all(live-recs, function-dependencies(vm.loaded-ids, code))
    else :
      val tag = new Int{tag}
      add-all(live-recs, class-dependencies(vm.loaded-ids, tag))
    restore-tag(heart)

  ;Return ids
  return to-tuple(live-recs)

defn RecSet () :
  HashSet<Rec>(hash{id(_)}, {id(_) == id(_)})
  
;============================================================
;===================== Debugging ============================
;============================================================

lostanza defn dump-heap (vm:ref<VirtualMachine>) -> int :
  return dump-heap(vm.heap, vm.heap-top, vm)  

lostanza defn dump-heap (pstart:ptr<long>, pend:ptr<long>, vm:ref<VirtualMachine>) -> int :
  val stackrefs = Vector<Long>()
  call-c clib/printf("Heap:\n")
  var p:ptr<long> = pstart
  while p < pend :
    val tag = [p] as int
    if tag == STACK-TYPE.value :
      add(stackrefs, new Long{/tag(p)})      
    val class = get(vm.vmtable.class-table, new Int{tag})
    match(class) :
      (class:ref<VMLeafClass>) :
        val obj = p as ptr<ObjectLayout>
        val size = size(class).value
        call-c clib/printf("  %p: [Object %d, size = %d]", /tag(p), tag, size)
        for (var i:long = 0, i < size, i = i + 8) :
          call-c clib/printf("  %lx", [p + 8 + i])
        call-c clib/printf("\n")
        ;Advance to next object
        p = p + 8 + size
      (class:ref<VMArrayClass>) :
        val array = p as ptr<ObjectLayout>
        val len = array.slots[0]
        val base-size = base-size(class).value
        val item-size = item-size(class).value
        val size = base-size + item-size * len
        call-c clib/printf("  %p: [Array %d, length = %ld, base-size = %d, item-size = %d]",
                           /tag(p), tag, len, base-size, item-size)
        for (var i:long = 0, i < size, i = i + 8) :
          call-c clib/printf("  %lx", [p + 8 + i])
        call-c clib/printf("\n")
        ;Advance to next object
        p = p + (8 + size + 7) & -8L  
  ;Dump stacks
  for (var i:int = 0, i < length(stackrefs).value, i = i + 1) :
    val s = get(stackrefs, new Int{i})
    dump-stack(s.value, vm)
  return 0

lostanza defn dump-stack (stackref:long, vm:ref<VirtualMachine>) -> int :
  val stk:ptr<Stack> = untag(stackref)
  var f:ptr<StackFrame> = stk.frames
  val f-end = stk.stack-pointer
  call-c clib/printf("Stack %p:\n", stackref)
  while f <= f-end :
    ;Get frame properties
    val map-index = new Int{f.liveness-map as int}
    if key?(live-map-table(vm.linker), map-index) == true :
      val map = get(live-map-table(vm.linker), map-index)
      val live-slots = live-slots(map)
      val num-slots = num-slots(map).value
      ;Print properties
      val num-live = length(live-slots).value
      var slot-i:int = 0
      call-c clib/printf("  %p: [StackFrame %ld, num-slots = %d]\n", f, f.liveness-map, num-slots)
      for (var i:int = 0, i < num-slots, i = i + 1) :
        if slot-i < num-live and live-slots.items[slot-i].value == i :
          call-c clib/printf("    %d: [%lx]\n", i, f.slots[i])
          slot-i = slot-i + 1
        else :
          call-c clib/printf("    %d: %lx\n", i, f.slots[i])
      ;Advance to next frame
      f = addr(f.slots[num-slots]) as ptr<StackFrame>    
    else :
      call-c clib/printf("  %p: [BAD FRAME %x]\n", f, f.liveness-map)
      return 0
  return 0

lostanza defn print-tag (ref:long) -> int :
  call-c clib/printf("inspect tag of %p\n", ref)
  val tagbits = ref & 7L
  if tagbits == REF-TAG-BITS :
    val tag = [(ref - REF-TAG-BITS) as ptr<long>]
    if tag == FN-TYPE.value or tag == TYPE-TYPE.value :
      val f:ptr<Function> = untag(ref)
      call-c clib/printf("tagbits = %ld (REF), tag = %ld (FN/TYPE), code = %ld\n", tagbits, tag, f.code)
    else :
      call-c clib/printf("tagbits = %ld (REF), tag = %ld\n", tagbits, tag)
  else if tagbits == MARKER-TAG-BITS :
    val tag = ref >> 3L
    call-c clib/printf("tagbits = %ld (MARKER), tag = %ld\n", tagbits, tag)
  else if tagbits == INT-TAG-BITS :
    call-c clib/printf("tagbits = %ld (INT)\n", tagbits)
  else if tagbits == BYTE-TAG-BITS :
    call-c clib/printf("tagbits = %ld (BYTE)\n", tagbits)
  else if tagbits == CHAR-TAG-BITS :
    call-c clib/printf("tagbits = %ld (CHAR)\n", tagbits)
  else if tagbits == FLOAT-TAG-BITS :
    call-c clib/printf("tagbits = %ld (FLOAT)\n", tagbits)
  else :
    call-c clib/printf("Unrecognized tag bits.\n")
  return 0

defn dump-linked (vmt:VMTable) :
  val ins-buffer = instructions(vmt)
  val faddr = IntTable<Int>()
  for entry in function-addresses(vmt) do :
    faddr[value(entry)] = key(entry)  
  for (ins in ins-buffer, i in 0 to false) do :
    match(get?(faddr, i)) :
      (f:Int) : println("F%_ :" % [f])
      (_:False) : false
    println("  (%_) %_" % [i, ins])

lostanza defn instructions (vmt:ref<VMTable>) -> ref<Vector<LinkedIns>> :
  return vmt.instructions
lostanza defn function-addresses (vmt:ref<VMTable>) -> ref<IntTable<Int>> :
  return vmt.function-addresses

;============================================================
;===================== Resolving ============================
;============================================================

defn resolve (pkgids:PackageIds, vmp:VMPackage) :
  defn resolve (n:Int) : pkgids[n]
  defn resolve<?T> (x:?T&(VMGlobal|VMData|VMConst|VMClass|VMFunction|VMMethod|VMExtern)) :
    map-id(resolve,x) as T&(VMGlobal|VMData|VMConst|VMClass|VMFunction|VMMethod|VMExtern)
  VMPackage(
    packageio(vmp)
    resolve(init(vmp))
    map(resolve,globals(vmp))
    map(resolve,datas(vmp))
    map(resolve,consts(vmp))
    map(resolve,classes(vmp))
    map(resolve,funcs(vmp))
    map(resolve,methods(vmp))
    map(resolve,externs(vmp)))

;============================================================
;====================== Loading =============================
;============================================================

public defn load (vm:VirtualMachine, vmps:Collection<VMPackage>) :
  val new-consts = Vector<VMConst>()
  val vmt = vmtable(vm)
  
  ;Make global ids
  make-package-ids(loaded-ids(vm), vmps)
  
  for vmp0 in vmps do :
    ;Get package ids
    val pkgids = package-ids(loaded-ids(vm), vmp0)
    
    ;Register dependencies
    for f in funcs(vmp0) do :
      set-function-dependencies(pkgids, id(f), dependencies(f))
    for c in filter-by<VMLeafClass|VMArrayClass>(classes(vmp0)) do :        
      set-class-dependencies(pkgids, id(c), dependencies(c))

    ;Resolution
    val vmp = resolve(pkgids, vmp0)

    ;Link functions
    for f in funcs(vmp) do :
      val linked = link(linker(vm), f, pkgids)
      load-function(vmt, id(f), linked)

    ;Stage constants to be loaded
    add-all(new-consts, consts(vmp))

    ;Load definitions
    load-globals(vmt, globals(vmp), package(vmp))
    load-classes(vmt, classes(vmp))    
    load-datas(vmt, datas(vmp))
    load-externs(vmt, externs(vmp))
    load-methods(branch-table(vm), methods(vmp), package(vmp))

    ;Register initialization function
    set-init(vmt, package(vmp), init(vmp))

  ;TODO: Make update efficient
  update(branch-table(vm))

  ;Load constants
  load-consts(vmt, to-tuple(new-consts))

  ;Initialize constants
  if none?({package(_) == `core}, vmps) :
    val init-consts-id = loaded-ids(vm)[CORE-INIT-CONSTS-ID]
    run(vm, init-consts-id, false)

  ;TODO: Print out linked functions
  ;dump-linked(vmt)

public defn init-package (vm:VirtualMachine, package:Symbol) :
  val f = init(vmtable(vm), package)
  val trace? = contains?(command-line-arguments(), "-trace")
  run(vm, f, trace?)

;============================================================
;==================== Utilities =============================
;============================================================
lostanza defn float-to-bits (x:float) -> int :
  return ($ls-prim bits x)

lostanza defn double-to-bits (x:double) -> long :
  return ($ls-prim bits x)

lostanza defn bits-to-float (x:int) -> float :
  return ($ls-prim fnum x)

lostanza defn bits-to-double (x:long) -> double :
  return ($ls-prim fnum x)

var delay : (() -> ?) -> False =
  fn (f) : fatal("Not within delay-actions block.")
defn delay-actions<?T> (f:() -> ?T) :
  val delays = Vector<(() -> ?)>()
  defn delay-action (action:() -> ?)  : add(delays, action)
  val result = let-var delay = delay-action : f()
  for d in delays do : d()
  clear(delays)
  result