defpackage stz/vm :
  import core
  import collections
  import stz/vm-ir

;============================================================
;==================== Linked Instructions ===================
;============================================================

public deftype LinkedIns :
  NewStackIns <: LinkedIns
  SetIns <: LinkedIns
  Op0Ins <: LinkedIns
  ReserveIns <: LinkedIns
  AllocIns <: LinkedIns
  JumpIns <: LinkedIns

public deftype JumpIns :
  GotoIns <: JumpIns
  Branch1Ins <: JumpIns  

public defstruct LinkedStoreIns <: LinkedIns :
  size: Int
  x: VMImm
  y: VMImm
  z: VMImm
public defstruct LinkedLoadIns <: LinkedIns :
  size: Int
  x: Local
  y: VMImm
  z: VMImm  
public defstruct LinkedRefStoreIns <: LinkedIns :
  size: Int
  x: VMImm
  y: VMImm
  z: VMImm
public defstruct LinkedRefLoadIns <: LinkedIns :
  size: Int
  x: Local
  y: VMImm
  z: VMImm  
public defstruct SetReg <: LinkedIns :
  reg: Int
  x: VMImm
public defstruct GetReg <: LinkedIns :
  x: Local
  reg: Int
public defstruct LinkedCall <: LinkedIns :
  f: VMImm
public defstruct LinkedCallClosure <: LinkedIns :
  f: VMImm
public defstruct LinkedCallC <: LinkedIns :
  f: VMImm
  launcher: Long
public defstruct LinkedYield <: LinkedIns :
  f: VMImm
public defstruct LinkedReturn <: LinkedIns
public defstruct FunctionEntry <: LinkedIns :
  num-locals:Int
public defstruct LinkedDump <: LinkedIns :
  x: Local
public defstruct LinkedOp1Ins <: LinkedIns :
  type: VMType
  x: Local
  op: VMOp
  y: VMImm
public defstruct LinkedOp2Ins <: LinkedIns :
  type: VMType
  x: Local
  op: VMOp
  y: VMImm
  z: VMImm
public defstruct LinkedBranch2Ins <: LinkedIns :
  type: VMType
  n: Int with: (updater => sub-n)
  op: VMOp
  x: VMImm
  y: VMImm

;============================================================
;======================= Printer ============================
;============================================================

defmethod print (o:OutputStream, i:LinkedStoreIns) :
  print(o, "%_[%_] = %_ (%_ bytes)" % [x(i), y(i), z(i), size(i)])

defmethod print (o:OutputStream, i:LinkedLoadIns) :
  print(o, "%_ = %_[%_] (%_ bytes)" % [x(i), y(i), z(i), size(i)])

defmethod print (o:OutputStream, i:LinkedRefStoreIns) :
  print(o, "ref %_[%_] = %_ (%_ bytes)" % [x(i), y(i), z(i), size(i)])

defmethod print (o:OutputStream, i:LinkedRefLoadIns) :
  print(o, "%_ = ref %_[%_] (%_ bytes)" % [x(i), y(i), z(i), size(i)])

defmethod print (o:OutputStream, i:LinkedOp1Ins) :
  print(o, "%_ = %_ %_ %_" % [x(i), type(i), op(i), y(i)])

defmethod print (o:OutputStream, i:LinkedOp2Ins) :
  print(o, "%_ = %_ %_ %_ %_" % [x(i), type(i), op(i), y(i), z(i)])

defmethod print (o:OutputStream, i:LinkedBranch2Ins) :
  print(o, "goto %_ when %_ %_ %_" % [n(i), type(i), op(i), x(i), y(i)])

defmethod print (o:OutputStream, r:SetReg) :
  print(o, "reg %_ = %_" % [reg(r), x(r)])

defmethod print (o:OutputStream, r:GetReg) :
  print(o, "%_ = reg %_" % [x(r), reg(r)])

defmethod print (o:OutputStream, x:LinkedCall) :
  print(o, "call %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedCallC) :
  print(o, "call-c %_ (launcher %_)" % [f(x), launcher(x)])

defmethod print (o:OutputStream, x:LinkedCallClosure) :
  print(o, "call-closure %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedYield) :
  print(o, "yield %_" % [f(x)])

defmethod print (o:OutputStream, x:LinkedReturn) :
  print(o, "return")

defmethod print (o:OutputStream, x:FunctionEntry) :
  print(o, "enter (num-locals = %_)" % [num-locals(x)])

defmethod print (o:OutputStream, ins:LinkedDump) :
  print(o, "dump %_" % [x(ins)])

;============================================================
;======================= Linker =============================
;============================================================

deftype Linker
defmulti instructions (l:Linker) -> Tuple<LinkedIns>
defmulti link (l:Linker, f:VMFunc) -> Int

defn Linker () :
  ;===== Overall Buffer =====
  val ins-buffer = Vector<LinkedIns>()

  ;===== Temporary Linking Buffer =====
  val buffer = Vector<LinkedIns|False>()
  defn link (func:VMFunc) :
    ;Create mapping from local ID to slot
    val deftable = to-inttable<VMDef> $
      for def in defs(func) seq :
        id(def) => def
    ;Retrieve the size of an immediate
    defn imm-size (x:VMImm) :
      match(x:Local) : size(type(deftable[index(x)]))
      else : size(x)
    defn imm-type (x:VMImm) :
      match(x:Local) : type(deftable[index(x)])
      else : type(x)
    defn imm-type (x:False) :
      x
    defn simple-type (t:VMType) :
      match(t) :
        (t:VMRef) : VMLong()
        (t:VMPointer) : VMLong()
        (t) : t
    ;Create label table
    val label-table = IntTable<Int>()
    
    ;Compute relative locations
    defn link-ins<?T> (ins:VMIns&?T, pos:Int) -> T :
      defn sub-target (n:Int) :
        label-table[n] - pos
      defn sub-slot (x:Local) :
        Local(local(deftable[index(x)]))
      map(sub-target, sub-slot, ins) as VMIns&T

    ;Register Instructions
    defn get-regs (xs:Tuple<Local|False>) :
      for (x in xs, i in 0 to false) do :
        match(x:Local) :
          add(buffer, GetReg(x, i))
    defn set-regs (xs:Tuple<VMImm>) :
      for (x in xs, i in 0 to false) do :
        add(buffer, SetReg(i, x))
        
    ;Link instructions
    within delay-actions() :
      ;Create entry instructions
      val num-locals = maximum(-1, seq(local, defs(func))) + 1
      add(buffer, FunctionEntry(num-locals))
      get-regs(args(func))
      ;Link and add to buffer
      for ins in ins(func) do :
        val pos = length(buffer)        
        match(ins) :
          (ins:LabelIns) :
            label-table[n(ins)] = pos
          (ins:CallIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, LinkedCall(f(ins*)))
            get-regs(xs(ins*))
          (ins:CallCIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            val format = coalesce(CallFormat(xtypes, ytypes)) where :
              val xtypes = map(imm-type,xs(ins))
              val ytypes = map(imm-type,ys(ins))
            val launcher = FORMAT-TABLE[format]
            add(buffer, LinkedCallC(f(ins*), launcher))
            get-regs(xs(ins*))
          (ins:CallClosureIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, LinkedCallClosure(f(ins*)))
            get-regs(xs(ins*))
          (ins:YieldIns) :
            val ins* = link-ins(ins, pos)
            set-regs(ys(ins*))
            add(buffer, LinkedYield(f(ins*)))
            get-regs(xs(ins*))
          (ins:ReturnIns) :
            val ins* = link-ins(ins, pos)
            set-regs(xs(ins*))
            add(buffer, LinkedReturn())
          (ins:DumpIns) :
            val ins* = link-ins(ins, pos)
            for x in xs(ins*) do :
              add(buffer, LinkedDump(x))
          (ins:StoreIns) :
            val ins* = link-ins(ins, pos)
            val size = imm-size(z(ins))
            match(imm-type(x(ins))) :
              (t:VMRef) : add(buffer, LinkedRefStoreIns(size, x(ins*), y(ins*), z(ins*)))
              (t) : add(buffer, LinkedStoreIns(size, x(ins*), y(ins*), z(ins*)))
          (ins:LoadIns) :
            val ins* = link-ins(ins, pos)
            val size = imm-size(x(ins))
            match(imm-type(x(ins))) :
              (t:VMRef) : add(buffer, LinkedRefLoadIns(size, x(ins*), y(ins*), z(ins*)))
              (t) : add(buffer, LinkedLoadIns(size, x(ins*), y(ins*), z(ins*)))
          (ins:Op1Ins) :
            val ins* = link-ins(ins, pos)
            val t = simple-type(imm-type(y(ins)))
            add(buffer, LinkedOp1Ins(t, x(ins*), op(ins*), y(ins*)))
          (ins:Op2Ins) :
            val ins* = link-ins(ins, pos)
            val t = simple-type(imm-type(y(ins)))
            add(buffer, LinkedOp2Ins(t, x(ins*), op(ins*), y(ins*), z(ins*)))
          (ins:Branch2Ins) :
            add(buffer, false)
            within delay() :
              val ins* = link-ins(ins, pos)
              val t = simple-type(imm-type(y(ins)))
              buffer[pos] = LinkedBranch2Ins(t, n(ins*), op(ins*), x(ins*), y(ins*))
          (ins:JumpIns&VMIns) :
            add(buffer, false)
            within delay() :
              buffer[pos] = link-ins(ins, pos)
          (ins:LinkedIns&VMIns) :
            add(buffer, link-ins(ins, pos))
    ;Dump to instruction buffer
    val pos = length(ins-buffer)
    add-all(ins-buffer, buffer as Seqable<LinkedIns>)
    clear(buffer)
    ;Return instruction address of linked function
    pos

  new Linker :
    defmethod instructions (this) :
      to-tuple(ins-buffer)
    defmethod link (this, f:VMFunc) :
      link(f)

;============================================================
;================= Class Display Analysis ===================
;============================================================
deftype ClassTable
defmulti class? (this, c:Int) -> True|False
defmulti instanceof? (t:ClassTable, child:Int, parent:Int) -> True|False

public defn ClassTable (classes:Tuple<VMClass>) :
  val class-table = to-inttable<VMClass> $
    for c in classes seq : id(c) => c
  val parent-table = IntTable<Tuple<Int>>()
  defn @all-parents (c:Int) :
    val rec = class-table[c]
    to-tuple(cat([c], seq-cat(all-parents, parents(rec))))
  defn all-parents (c:Int) :
    if not key?(parent-table, c) :
      parent-table[c] = @all-parents(c)
    parent-table[c]
  new ClassTable :
    defmethod class? (this, c:Int) :
      key?(class-table, c)
    defmethod instanceof? (this, child:Int, parent:Int) :
      contains?(all-parents(child), parent)

;============================================================
;==================== Extern Table ==========================
;============================================================

public deftype ExternTable
public defmulti get (t:ExternTable, i:Int) -> Long
public defmulti set (t:ExternTable, i:Int, addr:Long) -> False

defn ExternTable () :
  val table = Vector<Long|False>()
  new ExternTable :
    defmethod get (this, i:Int) :
      table[i] as Long
    defmethod set (this, i:Int, addr:Long) :
      set-at(table, i, addr, false)

public val EXTERN-TABLE = ExternTable()

;============================================================
;===================== Format Table =========================
;============================================================

public defstruct CallFormat <: Hashable&Equalable :
  xs: Tuple<VMType|False>
  ys: Tuple<VMType>
with :
  printer => true

defmethod hash (f:CallFormat) :
  hash(xs(f)) + 7 * hash(ys(f))
defmethod equal? (a:CallFormat, b:CallFormat) :
  xs(a) == xs(b) and ys(a) == ys(b)

public deftype FormatTable
public defmulti get (t:FormatTable, f:CallFormat) -> Long
public defmulti set (t:FormatTable, f:CallFormat, l:Long) -> False

defn FormatTable () :
  val table = HashTable<CallFormat,Long>()  
  new FormatTable :
    defmethod get (this, f:CallFormat) : table[f]
    defmethod set (this, f:CallFormat, l:Long) : table[f] = l

public val FORMAT-TABLE = FormatTable()

;============================================================
;=================== Format Coalescing ======================
;============================================================

defn exemplar-type (t:VMType) :
  match(t:VMRef|VMPointer) : VMLong()
  else : t

public defn coalesce (f:CallFormat) :
  ;New return result
  val x* =
    if empty?(xs(f)) :
      VMLong()
    else :
      match(xs(f)[0]) :
        (x:False) :
          VMLong()
        (x:VMType) :
          match(exemplar-type(x)) :
            (t:VMByte|VMInt) : VMLong()
            (t) : t

  ;New arguments
  val ys* = for y in ys(f) map :
    match(exemplar-type(y)) :
      (y:VMByte|VMInt) : VMLong()
      (y) : y

  ;Return coalesced call format
  CallFormat([x*], ys*)
    

;============================================================
;==================== VM Constants ==========================
;============================================================

lostanza val REF-TAG:long = 1L

lostanza defn untag (x:long) -> ptr<?> :
  return (x - REF-TAG + 8) as ptr<?>

lostanza defn tag (x:ptr<?>) -> long :
  return (x + REF-TAG) as long

;============================================================
;=================== VM Structures ==========================
;============================================================

lostanza deftype VirtualMachine :
  registers: ptr<long>
  heap: ptr<long>
  heap-top: ptr<long>
  heap-end: ptr<long>
  heap-limit: ptr<long>
  current-stack: long
  stack-pointer: ptr<Frame>
  frame-size: int
  pc: int

lostanza deftype Frame :
  return: long
  sp: ptr<Frame>
  slots: long ...

lostanza deftype Stack :
  size: long
  frames: ptr<Frame>
  stack-pointer: ptr<Frame>
  frame-size: int
  pc: int

lostanza deftype Function :
  num-slots: long
  code: long
  slots: long ...

;============================================================
;==================== VM Implementation =====================
;============================================================

lostanza defn VirtualMachine () -> ref<VirtualMachine> :
  val registers = call-c clib/malloc(sizeof(ptr<?>) * 256)
  val heap = call-c clib/malloc(512 * 1024 * 1024)
  val heap-limit = heap + 512 * 1024 * 1024
  val null = 0L as ptr<?>
  return new VirtualMachine{registers, heap, heap, heap, heap-limit,
                            0L, null, 0, 0}

lostanza defn alloc-stack (vm:ref<VirtualMachine>, pc:int) -> long :
  val stack-size = 1024 * 1024
  val frames = call-c clib/malloc(stack-size)
  val s = tag(vm.heap-top)
  val null = 0L as ptr<?>
  vm.heap-top = vm.heap-top + 8 + sizeof(Stack)
  vm.heap-end = vm.heap-end + 8 + sizeof(Stack)
  val sptr:ptr<Stack> = untag(s)
  sptr.size = stack-size
  sptr.frames = frames
  sptr.stack-pointer = frames
  sptr.frame-size = 0
  sptr.pc = pc
  sptr.frames.return = -1L
  sptr.frames.sp = null
  return s

lostanza defn call-c-function (function:long, registers:ptr<long>, format:int) -> long :
  if format == 0 :
    val fptr = function as ptr<((long long long long long long) -> long)>
    val result = call-c [fptr](registers[0], registers[1], registers[2], registers[3], registers[4], registers[5])
    registers[0] = result
    return 0
  else :
    fatal("Unknown format.")
    return 0

lostanza defn eval-imm (frame:ptr<Frame>, x:ref<VMImm>) -> long :
  match(x) :
    (x:ref<Local>) :
      return frame.slots[index(x).value]
    (x:ref<NumConst>) :
      match(value(x)) :
        (v:ref<Byte>) : return v.value
        (v:ref<Int>) : return v.value
        (v:ref<Long>) : return v.value
        (v:ref<Float>) :
          val value = v.value
          return ($ls-prim bits value)
        (v:ref<Double>) :
          val value = v.value
          return ($ls-prim bits value)
    (x:ref<CodeId>) :
      return fid(x).value
    (x:ref<ExternId>) :
      return get(EXTERN-TABLE,eid(x)).value

lostanza defn eval-op (current-stack:long, op:ref<VMOp>) -> long :
  match(op) :
    (op:ref<CurrentStackOp>) : return current-stack
  return 0

lostanza defn eval-op (class-table:ref<ClassTable>, type:ref<VMType>, op:ref<VMOp>, y:long) -> long :
  match(op, type) :
    (op:ref<NotOp>, type:ref<VMByte|VMInt|VMLong>) : return (~ y)
    (op:ref<NotOp>, type) : fatal("Illegal type.")
    
    (op:ref<NegOp>, type:ref<VMInt|VMLong>) : return (- y)
    (op:ref<NegOp>, type:ref<VMFloat>) :
      val yint = y as int
      val yfloat = ($ls-prim fnum yint)
      val result = (- yfloat)
      return ($ls-prim bits result)
    (op:ref<NegOp>, type:ref<VMDouble>) : 
      val yfloat = ($ls-prim fnum y)
      val result = (- yfloat)
      return ($ls-prim bits result)
    (op:ref<NegOp>, type) : fatal("Illegal type.")
    
    (op:ref<InstanceofOp>, type:ref<VMLong>) :
      val tag = new Int{[(y - REF-TAG) as ptr<long>] as int}
      val instance? = instanceof?(class-table, tag, /type(op))
      if instance? == true : return 1
      else : return 0
    (op:ref<InstanceofOp>, type) : fatal("Illegal type.")
  return 0

lostanza defn eval-op (type:ref<VMType>, op:ref<VMOp>, y:long, z:long) -> long :
  match(type) :
    (type:ref<VMByte|VMInt|VMLong>) :
      match(op, type) :
        (op:ref<AddOp>, type) : return y + z
        (op:ref<SubOp>, type) : return y - z 
        (op:ref<MulOp>, type) : return y * z
        (op:ref<DivOp>, type) : return y / z
        (op:ref<ModOp>, type) : return y % z
        (op:ref<AndOp>, type) : return y & z
        (op:ref<OrOp>, type) : return y | z
        (op:ref<XorOp>, type) : return y ^ z
        (op:ref<ShlOp>, type) : return y << z
        (op:ref<ShrOp>, type) : return y >> z
        (op:ref<AshrOp>, type) : return y >>> z
        (op:ref<EqOp>, type) : return y == z
        (op:ref<NeOp>, type) : return y != z
        (op:ref<LtOp>, type:ref<VMInt|VMLong>) : return y < z
        (op:ref<GtOp>, type:ref<VMInt|VMLong>) : return y > z
        (op:ref<LeOp>, type:ref<VMInt|VMLong>) : return y <= z
        (op:ref<GeOp>, type:ref<VMInt|VMLong>) : return y >= z
        (op:ref<LtOp>, type:ref<VMByte>) : fatal("Illegal type.")
        (op:ref<GtOp>, type:ref<VMByte>) : fatal("Illegal type.")
        (op:ref<LeOp>, type:ref<VMByte>) : fatal("Illegal type.")
        (op:ref<GeOp>, type:ref<VMByte>) : fatal("Illegal type.")
        (op:ref<UleOp>, type) : return ($ls-prim ule y z)
        (op:ref<UltOp>, type) : return ($ls-prim ult y z)
        (op:ref<UgtOp>, type) : return ($ls-prim ugt y z)
        (op:ref<UgeOp>, type) : return ($ls-prim uge y z)
      return 0
    (type:ref<VMFloat>) :
      val yint = y as int
      val zint = z as int
      val yf = ($ls-prim fnum yint)
      val zf = ($ls-prim fnum zint)
      var result:float
      match(op) :
        (op:ref<AddOp>) : result = yf + zf
        (op:ref<SubOp>) : result = yf - zf 
        (op:ref<MulOp>) : result = yf * zf
        (op:ref<DivOp>) : result = yf / zf
        (op:ref<ModOp>) : fatal("Illegal type.")
        (op:ref<AndOp>) : fatal("Illegal type.")
        (op:ref<OrOp>) : fatal("Illegal type.")
        (op:ref<XorOp>) : fatal("Illegal type.")
        (op:ref<ShlOp>) : fatal("Illegal type.")
        (op:ref<ShrOp>) : fatal("Illegal type.")
        (op:ref<AshrOp>) : fatal("Illegal type.")
        (op:ref<EqOp>) : return yf == zf
        (op:ref<NeOp>) : return yf != zf
        (op:ref<LtOp>) : return yf < zf
        (op:ref<GtOp>) : return yf > zf
        (op:ref<LeOp>) : return yf <= zf
        (op:ref<GeOp>) : return yf >= zf
        (op:ref<UleOp>) : fatal("Illegal type.")
        (op:ref<UltOp>) : fatal("Illegal type.")
        (op:ref<UgtOp>) : fatal("Illegal type.")
        (op:ref<UgeOp>) : fatal("Illegal type.")
      return ($ls-prim bits result)
    (type:ref<VMDouble>) :
      val yf = ($ls-prim fnum y)
      val zf = ($ls-prim fnum z)
      var result:double
      match(op) :
        (op:ref<AddOp>) : result = yf + zf
        (op:ref<SubOp>) : result = yf - zf 
        (op:ref<MulOp>) : result = yf * zf
        (op:ref<DivOp>) : result = yf / zf
        (op:ref<ModOp>) : fatal("Illegal type.")
        (op:ref<AndOp>) : fatal("Illegal type.")
        (op:ref<OrOp>) : fatal("Illegal type.")
        (op:ref<XorOp>) : fatal("Illegal type.")
        (op:ref<ShlOp>) : fatal("Illegal type.")
        (op:ref<ShrOp>) : fatal("Illegal type.")
        (op:ref<AshrOp>) : fatal("Illegal type.")
        (op:ref<EqOp>) : return yf == zf
        (op:ref<NeOp>) : return yf != zf
        (op:ref<LtOp>) : return yf < zf
        (op:ref<GtOp>) : return yf > zf
        (op:ref<LeOp>) : return yf <= zf
        (op:ref<GeOp>) : return yf >= zf
        (op:ref<UleOp>) : fatal("Illegal type.")
        (op:ref<UltOp>) : fatal("Illegal type.")
        (op:ref<UgtOp>) : fatal("Illegal type.")
        (op:ref<UgeOp>) : fatal("Illegal type.")
      return ($ls-prim bits result)

defn print-ins (ins:LinkedIns) :
  println("Trace (%_)" % [ins])

lostanza defn assign (frame:ptr<Frame>, l:ref<Local>, value:long) -> long :
  frame.slots[index(l).value] = value
  return 0

;extern helloworld : (long long) -> long
;lostanza defn c-function-table () -> ref<Array<Long>> :
;  val a = Array<Long>(new Int{10})
;  set(a, new Int{0}, new Long{addr(helloworld) as long})
;  return a

lostanza defn run (vm:ref<VirtualMachine>,
                   instructions:ref<Tuple<LinkedIns>>,
                   functions:ref<Tuple<Int>>,
                   class-table:ref<ClassTable>,
                   trace?:ref<True|False>) -> ref<False> :
  ;Define machine quantities                 
  val regs = vm.registers
  var heap-limit:ptr<long> = vm.heap-limit
  var frame-size:int
  var heap-end:ptr<long>
  var heap-top:ptr<long>
  var stack-pointer:ptr<Frame>
  var stack-end:ptr<Frame>
  var current-stack:long
  
  labels :
    begin :
      val mainpc = get(functions, new Int{0}).value
      val main-stack = alloc-stack(vm, mainpc)
      heap-end = vm.heap-end
      heap-top = vm.heap-top
      goto load-stack(main-stack)
    load-stack (stack:long) :
      current-stack = stack
      val sptr:ptr<Stack> = untag(current-stack)
      stack-pointer = sptr.stack-pointer
      stack-end = sptr.frames + sptr.size
      frame-size = sptr.frame-size
      goto step(sptr.pc)      
    call-function (fid:int, return:int) :
      val old-sp = stack-pointer
      stack-pointer = stack-pointer + frame-size
      stack-pointer.return = return
      stack-pointer.sp = old-sp
      val pos = get(functions, new Int{fid}).value
      goto step(pos)
    step (pc:int) :
      val ins = get(instructions, new Int{pc})
      if trace? == true : print-ins(ins)
      match(ins) :
        (ins:ref<NewStackIns>) :
          val fid = eval-imm(stack-pointer, fid(ins)) as int
          val fpc = get(functions, new Int{fid}).value
          vm.heap-top = heap-top
          vm.heap-end = heap-end          
          val stk = alloc-stack(vm, fpc)
          heap-top = vm.heap-top
          heap-end = vm.heap-end
          assign(stack-pointer, x(ins), stk)
          goto step(pc + 1)
        (ins:ref<SetIns>) :
          assign(stack-pointer, x(ins), eval-imm(stack-pointer, y(ins)))
          goto step(pc + 1)
        (ins:ref<Op0Ins>) :
          assign(stack-pointer, x(ins), eval-op(current-stack, op(ins)))
          goto step(pc + 1)        
        (ins:ref<LinkedOp1Ins>) :
          val y = eval-imm(stack-pointer, y(ins))
          assign(stack-pointer, x(ins), eval-op(class-table, type(ins), op(ins), y))
          goto step(pc + 1)        
        (ins:ref<LinkedOp2Ins>) :
          val y = eval-imm(stack-pointer, y(ins))
          val z = eval-imm(stack-pointer, z(ins))
          assign(stack-pointer, x(ins), eval-op(type(ins), op(ins), y, z))
          goto step(pc + 1)
        (ins:ref<ReserveIns>) :
          val size = eval-imm(stack-pointer, size(ins))
          if size & 0x7L : fatal("Size is not a multiple of 8.")
          val total-size = size + 8 * num-objects(ins).value
          heap-end = heap-end + total-size
          if heap-end > heap-limit : fatal("Out of heap memory.")
          goto step(pc + 1)
        (ins:ref<AllocIns>) :
          val size = eval-imm(stack-pointer, size(ins))
          if size & 0x7L : fatal("Size is not a multiple of 8.")
          val total-size = size + 8
          [heap-top] = type(ins).value
          assign(stack-pointer, x(ins), tag(heap-top))
          heap-top = heap-top + total-size
          if heap-top > heap-end : fatal("Beyond allocated limits.")
          goto step(pc + 1)
        (ins:ref<LinkedRefStoreIns>) :
          val x = eval-imm(stack-pointer, x(ins))
          val y = eval-imm(stack-pointer, y(ins))
          val z = eval-imm(stack-pointer, z(ins))
          val xptr = untag(x)
          val sz = size(ins).value
          if sz == 1 : [xptr as ptr<byte> + y] = z as byte
          else if sz == 4 : [xptr as ptr<int> + y] = z as int
          else if sz == 8 : [xptr as ptr<long> + y] = z as long
          else : fatal("Invalid size.")
          goto step(pc + 1)
        (ins:ref<LinkedRefLoadIns>) :
          val y = eval-imm(stack-pointer, y(ins))
          val z = eval-imm(stack-pointer, z(ins))
          val yptr:ptr<long> = untag(y)
          val sz = size(ins).value
          var value:long
          if sz == 1 : value = [yptr as ptr<byte> + z]
          else if sz == 4 : value = [yptr as ptr<int> + z]
          else if sz == 8 : value = [yptr as ptr<long> + z]
          else : fatal("Invalid size.")
          assign(stack-pointer, x(ins), value)
          goto step(pc + 1)
        (ins:ref<LinkedStoreIns>) :
          val x = eval-imm(stack-pointer, x(ins))
          val y = eval-imm(stack-pointer, y(ins))
          val z = eval-imm(stack-pointer, z(ins))
          val sz = size(ins).value
          if sz == 1 : [x as ptr<byte> + y] = z as byte
          else if sz == 4 : [x as ptr<int> + y] = z as int
          else if sz == 8 : [x as ptr<long> + y] = z as long
          else : fatal("Invalid size.")
          goto step(pc + 1)
        (ins:ref<LinkedLoadIns>) :
          val y = eval-imm(stack-pointer, y(ins))
          val z = eval-imm(stack-pointer, z(ins))
          val sz = size(ins).value
          var value:long
          if sz == 1 : value = [y as ptr<byte> + z]
          else if sz == 4 : value = [y as ptr<int> + z]
          else if sz == 8 : value = [y as ptr<long> + z]
          else : fatal("Invalid size.")
          assign(stack-pointer, x(ins), value)
          goto step(pc + 1)
        (ins:ref<GotoIns>) :
          goto step(pc + n(ins).value)
        (ins:ref<Branch1Ins>) :
          val x = eval-imm(stack-pointer, x(ins))
          val r = eval-op(class-table, VMLong(), op(ins), x)
          if r : goto step(pc + n(ins).value)
          else : goto step(pc + 1)
        (ins:ref<LinkedBranch2Ins>) :
          val x = eval-imm(stack-pointer, x(ins))
          val y = eval-imm(stack-pointer, y(ins))
          val r = eval-op(type(ins), op(ins), x, y)
          if r : goto step(pc + n(ins).value)
          else : goto step(pc + 1)
        (ins:ref<SetReg>) :
          regs[reg(ins).value] = eval-imm(stack-pointer, x(ins))
          goto step(pc + 1)
        (ins:ref<GetReg>) :
          assign(stack-pointer, x(ins), regs[reg(ins).value])
          goto step(pc + 1)
        (ins:ref<LinkedCall>) :
          val fid = eval-imm(stack-pointer, f(ins)) as int
          goto call-function(fid, pc + 1)
        (ins:ref<LinkedCallC>) :
          val faddr = eval-imm(stack-pointer, f(ins))
          val launcher = launcher(ins).value as ptr<((long, ptr<long>) -> long)>
          [launcher](faddr, regs)
          goto step(pc + 1)
        (ins:ref<LinkedCallClosure>) :
          val fref = eval-imm(stack-pointer, f(ins))
          val fptr = untag(fref) as ptr<Function>
          val fid = fptr.code as int
          goto call-function(fid, pc + 1)
        (ins:ref<LinkedYield>) :
          ;Save current stack
          val s:ptr<Stack> = untag(current-stack)
          s.stack-pointer = stack-pointer
          s.frame-size = frame-size
          s.pc = pc + 1
          ;Load next next
          val sref = eval-imm(stack-pointer, f(ins))          
          goto load-stack(sref)
        (ins:ref<LinkedReturn>) :
          val ret = stack-pointer.return as int
          if ret >= 0 :
            frame-size = (stack-pointer - stack-pointer.sp) as int
            stack-pointer = stack-pointer.sp
            goto step(ret)          
        (ins:ref<FunctionEntry>) :
          frame-size = (num-locals(ins).value * 8 + sizeof(Frame)) as int
          val size-required = frame-size + sizeof(Frame)
          if stack-pointer + size-required > stack-end : fatal("Stack overflow.")
          goto step(pc + 1)
        (ins:ref<LinkedDump>) :
          val xvalue = eval-imm(stack-pointer, x(ins))
          val xint = xvalue as int
          val xvaluef = ($ls-prim fnum xint)
          val xvalued = ($ls-prim fnum xvalue)
          call-c clib/printf("> L%d = %ld (float = %f, double = %f)\n",
                             index(x(ins)).value, xvalue, xvaluef, xvalued)
          goto step(pc + 1)
  return false

;============================================================
;==================== Utilities =============================
;============================================================
defn ensure-length<?T> (v:Vector<?T>, len:Int, x:T) :
  lengthen(v, len, x) when length(v) < len

defn set-at<?T> (v:Vector<?T>, i:Int, x:T, default:T) :
  ensure-length(v, i + 1, default) when length(v) <= i
  v[i] = x

var delay : (() -> ?) -> False =
  fn (f) : fatal("Not within delay-actions block.")
val DELAYS = Vector<(() -> ?)>()
defn delay-actions<?T> (f:() -> ?T) :
  defn delay-action (action:() -> ?)  : add(DELAYS, action)
  val result = let-var delay = delay-action : f()
  for d in DELAYS do : d()
  clear(DELAYS)
  result

;============================================================
;======================= Driver =============================
;============================================================

public defn interpret (prog:VMProg, trace?:True|False) :
  ;Link functions
  val linker = Linker()
  val func-table = to-tuple(fs as Vector<Int>) where :
    val fs = Vector<Int|False>()
    for f in funcs(prog) do :
      set-at(fs, id(f), link(linker,f), false)

  ;Link classes
  val class-table = ClassTable(classes(prog))

  ;Run
  val vm = VirtualMachine()
  run(vm,
      instructions(linker),
      func-table,
      class-table,
      trace?)