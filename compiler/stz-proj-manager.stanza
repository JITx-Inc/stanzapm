defpackage stz/proj-manager :
  import core
  import collections
  import stz/pkg
  import stz/proj
  import stz/utils
  import stz/algorithms
  import stz/aux-file

;<doc>=======================================================
;=================== Project Manager ========================
;============================================================

### Purpose ###

The ProjManager handles all things related to Stanza packages:
  - Where packages are located.
  - Which packages are conditionally imported.
  - Whether package .pkg files are up-to-date.
  - Track whether package .pkg files are up-to-date.
  - What external dependencies are pulled in by packages.

### Looking for the source file of a package ###

Input: The name of the package

Output: The PkgLocation structure if the package is found. 

### Updating the Auxiliary File ###

Input:

The statistics corresponding to all the saved packages.

### Collect Conditional Imports From Current Load List ###

Input:

The names of the packages that have currently been loaded. 

Output:

The names of all the new packages that need to be loaded, based upon
the conditional dependencies.

### Collecting Build Parameters ###

Input:

The names of the compiled packages.

Output:

The files to pass to the C compiler.
The flags to pass to the C compiler.

;============================================================
;=======================================================<doc>

public deftype ProjManager
public defmulti find-package (l:ProjManager, name:Symbol) -> PkgLocation|False
public defmulti update-aux-file (l:ProjManager, pkgs:Seqable<SavedPkg>) -> False
public defmulti dependencies (l:ProjManager, packages:Seqable<Symbol>) -> ProjDependencies
public defmulti conditional-imports (l:ProjManager, packages:Seqable<Symbol>) -> Tuple<Symbol>

public defn ProjManager (proj:ProjFile, params:ProjParams) :
  ;Read the auxiliary file
  val auxfile = read-aux-file?("stanza.aux2")

  ;Build source file table
  val source-file-table = to-hashtable<Symbol,String> $
    for s in filter-by<DefinedInStmt>(stmts(proj)) seq :
      package(s) => filename(s)

  ;Build dependency table
  val dependency-table = to-hashtable<Symbol,ProjDependencies> $
    for s in filter-by<RequiresStmt>(stmts(proj)) seq :
      package(s) => ProjDependencies(ccfiles(s), ccflags(s))  

  ;Find a package
  defn find-package (name:Symbol) -> PkgLocation|False :
    val pkg-path = find-pkg(name, optimize?(params))
    val src-path = get?(source-file-table, name)
    val up-to-date? = 
      match(pkg-path:String, src-path:String) :
        if file-exists?(src-path) :
          val rec = PkgRecord(name,
                              filestamp(pkg-path), filestamp(src-path)
                              flags(params), optimize?(params))
          contains?(filter-by<PkgRecord>(records(auxfile)), rec)
    if pkg-path is-not False or src-path is-not False :
      PkgLocation(name, src-path, pkg-path, up-to-date?)

  ;Updating the auxiliary file
  defn update-aux-file (pkgs:Seqable<SavedPkg>) :
    val recs = for pkg in pkgs seq :
      PkgRecord(package(pkg), filestamp(pkg), source(pkg),
                flags(params), optimize?(params))
    val auxfile* = add(auxfile, recs)
    write-aux-file("stanza.aux2", auxfile*)

  ;Retrieving the collection of dependencies
  defn proj-dependencies (packages:Seqable<Symbol>) :
    val ccfiles = Vector<String>()
    val ccflags = Vector<String>()
    for name in packages do :
      val ds = get?(dependency-table, name)
      match(ds:ProjDependencies) :
        add-all(ccfiles, /ccfiles(ds))
        add-all(ccflags, /ccflags(ds))
    remove-duplicates!(ccfiles)
    remove-duplicates!(ccflags)
    ProjDependencies(to-tuple(ccfiles), to-tuple(ccflags))

  ;Retrieve conditional imports
  defn conditional-imports (packages:Seqable<Symbol>) :
    val load-set = to-hashset<Symbol>(packages)
    val next-load-set = HashSet<Symbol>()
    val import-stmts = to-tuple(filter-by<ImportWhenStmt>(stmts(proj)))
    within progress = fixpoint() :
      for s in import-stmts do :
        if all?({load-set[_]}, dependencies(s)) :
          if add(load-set, package(s)) :
            add(next-load-set, package(s))
            progress()
    to-tuple(next-load-set)

  ;Return new project manager
  new ProjManager :
    defmethod find-package (this, name:Symbol) : find-package(name)
    defmethod update-aux-file (this, pkgs:Seqable<SavedPkg>) : update-aux-file(pkgs)
    defmethod dependencies (this, packages:Seqable<Symbol>) : proj-dependencies(packages)
    defmethod conditional-imports (this, packages:Seqable<Symbol>) : conditional-imports(packages)

;============================================================
;===================== Structures ===========================
;============================================================

public defstruct ProjParams :
  flags: Tuple<Symbol>
  optimize?: True|False

public defstruct ProjDependencies :
  ccfiles: Tuple<String>
  ccflags: Tuple<String>

public defstruct PkgLocation :
  package: Symbol
  source-file: String|False
  pkg-file: String|False
  up-to-date?: True|False

public defstruct SavedPkg :
  package: Symbol
  filestamp: FileStamp
  source: FileStamp

public defn filename (l:PkgLocation) -> String :
  match(source-file(l), pkg-file(l), up-to-date?(l)) :
    (sf:False, pf:String, utd) : pf
    (sf:String, pf:False, utd) : sf
    (sf:String, pf:String, utd:True) : pf
    (sf:String, pf:String, utd:False) : sf