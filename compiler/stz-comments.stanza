defpackage stz/comments :
  import core
  import collections

;<doc>=======================================================
;====================== IR Definition =======================
;============================================================

## Possible Tags and Their Examples ##

BlockTag:
  ;+[Ray Partition Box](AFADE9901823)
  ;+[Ray Partition Box](outdated:AFADE9901823)
  ;+[Ray Partition Box]

BlockEnd
  ;/[Ray Partition Box]

Reference
  ;![Ray Partition Box](AFADE9901823)
  ;![Ray Partition Box](outdated:AFADE9901823)
  ;![Ray Partition Box]

FileReference
  ;![file:myfile.txt](outdated)
  ;![file:myfile.txt]

AnonymousBlock
  ;+(AFADE9901823)
  ;+(outdated:AFADE9901823)

Text
Indent
NewLine
Whitespace

## Matched Block Check ##



;============================================================
;=======================================================<doc>

public deftype CommentItem

public defstruct CommentDoc :
  path: String
  params: DocParams
  items: Tuple<CommentItem>

public defstruct DocParams :
  block-tag-marker: String
  block-end-marker: String
  reference-marker: String

public defstruct BlockTag <: CommentItem :
  info: FileInfo
  name: String  
  stamp: String|False
  outdated?: True|False
  indent: Int with: (init => 0, updater => sub-indent)
with:
  printer => true
  
public defstruct BlockEnd <: CommentItem :
  info: FileInfo
  name: String|Int
  implicit?: True|False with: (default => false)
with:
  printer => true
  
public defstruct Reference <: CommentItem :
  info: FileInfo
  name: String
  stamp: String|False
  outdated?: True|False
with:
  printer => true
  
public defstruct FileReference <: CommentItem :
  info: FileInfo
  file: String
  outdated: True|False
with:
  printer => true
  
public defstruct AnonymousBlock <: CommentItem :
  info: FileInfo
  id: Int
  stamp: String|False
  outdated?: True|False
  indent: Int with: (init => 0, updater => sub-indent)
with:
  printer => true
  
public defstruct Text <: CommentItem :
  string: String
with:
  printer => true
  
public defstruct Whitespace <: CommentItem :
  info: FileInfo
  string: String
  following-indent: Int|False with: (init => false, updater => sub-following-indent)
with:
  printer => true
  
public defstruct Indent <: CommentItem :
  info: FileInfo
  indent: Int  
with:
  printer => true
  
public defstruct NewLine <: CommentItem
with:
  printer => true

;============================================================
;========================= Parsing ==========================
;============================================================

defn parse-comment-doc (stream:StringInputStream, path:String, params:DocParams) -> CommentDoc :
  ;Compute statistics on markers
  val block-tag-marker-len = length(block-tag-marker(params))
  val block-end-marker-len = length(block-end-marker(params))
  val reference-marker-len = length(reference-marker(params))
  val outdated-str = "outdated:"
  val outdated-len = length(outdated-str)
  val fileref-str = "file:"
  val fileref-len = length(fileref-str)

  ;Eat the given number of characters.
  defn eat-chars (n:Int) -> False :
    for i in 0 to n do : get-char(stream)

  ;Return true if the given character is a newline
  defn newline? (c:Char|False) -> True|False :
    c == '\n'

  ;Return true if the given character is a whitespace character
  defn whitespace? (c:Char|False) -> True|False:
    c == ' ' or c == '\t' or c == '\r'
  
  ;Return true if 'string' appears at position 'i' in the stream.
  defn upcoming-string? (i:Int, string:String) -> True|False :
    if empty?(string) :
      true
    else if peek?(stream,i) == string[0] :
      for j in 1 to length(string) all? :
        peek?(stream,i + j) == string[j]

  ;Return true if 'char' appears at position 'i' in the stream.
  defn upcoming-char? (i:Int, char:Char) -> True|False :
    peek?(stream,i) == char

  ;Return the index in the stream where 'char' appears, or
  ;false otherwise. Newlines mark the end of the searchable region.
  defn index-of-line-char? (start:Int, char:Char) -> Int|False :
    val n = length(stream)
    let loop (i:Int = start) :
      if i < n :
        val c = peek(stream,i)
        if newline?(c) : false
        else if c == char : i
        else : loop(i + 1)

  ;Return the index past the end of the line. 
  defn index-of-line-end (start:Int) -> Int :
    val n = length(stream)
    let loop (i:Int = start) :
      if i < n :
        if newline?(peek?(stream,i)) : i
        else : loop(i + 1)
      else : n

  ;Return true if there is an upcoming block tag:
  ;e.g. ;+[port definition]
  defn upcoming-block-tag? () -> True|False :
    upcoming-string?(0, block-tag-marker(params)) and
    upcoming-char?(block-tag-marker-len, '[')
  ;Return true if there is an upcoming block end:
  ;e.g. ;/[port definition]
  defn upcoming-block-end? () -> True|False :
    upcoming-string?(0, block-end-marker(params)) and
    upcoming-char?(block-end-marker-len, '[')
  ;Return true if there is an upcoming reference:
  ;e.g. ;![port definition]
  defn upcoming-reference? () -> True|False :
    upcoming-string?(0, reference-marker(params)) and
    upcoming-char?(reference-marker-len, '[')
  ;Return true if there is an upcoming anonymous reference:
  ;e.g. ;+(AFAD1241F)
  defn upcoming-anonymous? () -> True|False :
    upcoming-string?(0, block-tag-marker(params)) and
    upcoming-char?(block-tag-marker-len, '(')
  ;Return true if there is a line with no characters
  ;except for whitespace.
  defn upcoming-whitespace? () -> True|False :
    val end = index-of-line-end(0)
    for i in 0 to end all? :
      whitespace?(peek(stream,i))
  ;Return true if the end of the file is upcoming.
  defn upcoming-eof? () -> True|False :
    peek?(stream,0) == false
  ;Return true if a new line is upcoming.
  defn upcoming-newline? () -> True|False :
    newline?(peek?(stream,0))

  ;Parse the [...] tag at the given index.
  defn parse-bracket (start:Int, start-char:Char, end-char:Char) -> String|False :
    if upcoming-char?(start, start-char) :
      val tag-end = index-of-line-char?(start, end-char)
      match(tag-end:Int) :
        ;Compute the number of chars within the bracketing characters.
        val num-chars = tag-end - (start + 1)
        ;Eat past opening [
        eat-chars(start + 1)
        ;Retrieve characters within [...]
        val tag-string = get-chars(stream, num-chars)
        ;Eat closing ]
        eat-chars(1)
        ;Return tag string
        tag-string
      else :
        fatal("Cannot parse bracket tag.")

  ;Parse the tag starting at index i.
  ;Assumes that character tag-start == '['.
  ;Returns [bracket-string, paren-string], where bracket-string
  ;is the string within the [...], and paren-string is the string
  ;within the following (...). 
  defn parse-tag (tag-start:Int) -> [String, String|False] :
    val bracket-str = parse-bracket(tag-start, '[', ']') as String
    val paren-str = parse-bracket(0, '(', ')')
    [bracket-str, paren-str]

  ;Parse the upcoming whitespace line.
  defn parse-whitespace () -> Whitespace :
    val info = info(stream)
    val end = index-of-line-end(0)
    val str = get-chars(stream, end)
    Whitespace(info, str)

  ;Split up an outdated tag into a flag and a string.
  defn split-outdated-tag (string:String|False) -> [String|False, True|False] :
    match(string:String) :
      if prefix?(string, outdated-str) :
        val stamp = string[outdated-len to false]
        [stamp, true]
      else : [string, false]      
    else : [false, true]

  ;Parse the upcoming block tag.
  defn parse-block-tag () -> BlockTag :
    val info = info(stream)
    val [name, paren-str] = parse-tag(block-tag-marker-len)
    val [stamp, outdated?] = split-outdated-tag(paren-str)
    BlockTag(info, name, stamp, outdated?)      

  ;Parse the upcoming block end tag.
  defn parse-block-end () -> BlockEnd :
    val info = info(stream)
    val string = parse-bracket(block-end-marker-len, '[', ']') as String
    BlockEnd(info, string)

  ;Parse the upcoming reference or file reference.
  defn parse-reference () -> Reference|FileReference :
    val info = info(stream)
    val [bracket-str, paren-str] = parse-tag(reference-marker-len)
    if prefix?(bracket-str, fileref-str) :
      val filename = bracket-str[fileref-len to false]
      val outdated? = 
        match(paren-str:String) :
          if paren-str != "outdated" :
            fatal("Invalid paren string")
          true
      FileReference(info, filename, outdated?)
    else :
      val [stamp, outdated?] = split-outdated-tag(paren-str)
      Reference(info, bracket-str, stamp, outdated?)

  ;Parse the upcoming anonymous block.
  defn parse-anonymous () -> AnonymousBlock :
    val info = info(stream)
    val string = parse-bracket(block-tag-marker-len, '(', ')') as String
    val [stamp, outdated?] = split-outdated-tag(string)
    AnonymousBlock(info, genid(), stamp, outdated?)

  ;Eat the upcoming character in the input stream.
  defn parse-char () -> Char :
    get-char(stream) as Char

  ;Parse the upcoming new line
  defn parse-newline () -> NewLine :
    get-char(stream)
    NewLine()

  ;Parse the upcoming indent
  defn parse-indent () -> Indent :
    val info = info(stream)
    val num-whitespace =
      for i in 0 to false find! :
        not whitespace?(peek?(stream,i))
    Indent(info, num-whitespace)

  ;Accumulate parsed items
  val item-accum = Vector<CommentItem>()
  val char-accum = StringBuffer()

  ;Add a new character to the accumulator.
  defn add-item (c:Char) :
    add(char-accum, c)
  ;Add a new comment item to the accumulator.
  defn add-item (item:CommentItem) :
    flush-chars()
    add(item-accum, item)
  ;Retrieve all parsed items in the accumulator.
  defn parsed-items () -> Tuple<CommentItem> :
    flush-chars()
    to-tuple(item-accum)
  ;Helper: Empty the character accumulator and create a Text item.
  defn flush-chars () :
    if not empty?(char-accum) :
      add(item-accum, Text(to-string(char-accum)))
      clear(char-accum)

  ;Launch!
  defn main () :
    ;Starting line
    if upcoming-whitespace?() :
      add-item(parse-whitespace())
    else :
      add-item(parse-indent())

    ;Preconditions for starting loop
    ;  Any indents/whitespace at the beginning of the file has been parsed.
    let loop () :
      if upcoming-block-tag?() :
        add-item(parse-block-tag())
        loop()
      else if upcoming-block-end?() :
        add-item(parse-block-end())
        loop()
      else if upcoming-reference?() :
        add-item(parse-reference())
        loop()
      else if upcoming-anonymous?() :
        add-item(parse-anonymous())
        loop()
      else if upcoming-newline?() :
        add-item(parse-newline())
        if upcoming-whitespace?() :
          add-item(parse-whitespace())
          loop()
        else :
          add-item(parse-indent())
          loop()
      else if upcoming-eof?() :
        false
      else :
        add-item(parse-char())
        loop()

    ;Return items
    CommentDoc(path, params, parsed-items())

  ;Launch!
  main()

;<doc>=======================================================
;================ Find Implicit Block Ends ==================
;============================================================
Example of Computed Ends:

  ;+[A]
  asdf asdf :
    asdf asdf
    ;+[B]
    asdf asdf :
      asdf
      asdf

      asdf
      sadf       <-- End of block [B]

    ;+[C]
    asdfasdf :
      asdf
      asdf

      asdf
      asdf       <-- End of block [C]
                 <-- End of block [A]
  ;+[D]
  asdf asdf :
    asdf asdf
    asdf         <-- End of block [D]   

  ;+[E]
  asdf
  asdf           <-- End of block [E]

  ;+[F]
  asdf asdf :
    ;+[G]
    asdf :
      asdf
      asdf       <-- End of block [G]

    ;+[H]
    asdf :
      asdf
      asdf       <-- End of block [H]
  asdf asdf
  asdf asdf
  asdf           <-- End of block [F]

  ;+[I]
  asfd asdf :
    asdf         <-- End of block [I]    
;============================================================
;=======================================================<doc>

defn compute-implicit-ends (doc:CommentDoc) -> CommentDoc :
  ;Compute set of all ending tags in document.
  defn compute-block-end-set () -> HashSet<String> :
    val ends = filter-by<BlockEnd>(items(doc))
    val end-names = seq({name(_) as String}, ends)
    to-hashset<String>(end-names)

  ;Returns true if the given block marker requires an implicit end.
  val block-end-set = compute-block-end-set()
  defn requires-implicit-end? (item:BlockTag|AnonymousBlock) -> True|False :
    match(item) :
      ;Named blocks have an implicit end only if they do not have
      ;an explicit end.
      (item:BlockTag) :
        not block-end-set[name(item)]
      ;Anonymous blocks always have an implicit end.
      (item:AnonymousBlock) :
        true

  ;Compute indent information for items
  defn compute-indent-annotations (items:Tuple<CommentItem>) -> Collection<CommentItem> :
    ;Cache in vector for compute.
    val item-list = to-vector<CommentItem>(items)
    val num-items = length(item-list)
    
    ;First compute indents of blocks
    var prev-indent:Int = 0
    for i in 0 to num-items do :
      match(item-list[i]) :
        (item:BlockTag|AnonymousBlock) : item-list[i] = sub-indent(item, prev-indent)
        (item:Indent) : prev-indent = indent(item)
        (item) : false

    ;Then compute following indents of whitespace
    var next-indent:Int|False = false
    for i in reverse(0 to num-items) do :
      match(item-list[i]) :
        (item:Whitespace) : item-list[i] = sub-following-indent(item, next-indent)
        (item:Indent) : next-indent = indent(item)
        (item) : false

    ;Return items
    item-list

  ;Scan through each item, and generate implicit ends.
  defn generate-implicit-ends (items:Collection<CommentItem>) -> Tuple<CommentItem> :
    ;Track new items containing newly generated implicit ends.
    val item-list = Vector<CommentItem>()

    ;Track stack of opened blocks.
    val block-stack = Vector<BlockTag|AnonymousBlock>()

    ;Find the index of the corresponding opening block on the block-stack.
    ;Returns false if there is no corresponding block.
    defn index-of-block-on-stack (end:BlockEnd) -> Int|False :
      for block in block-stack index-when :
        match(block:BlockTag) :
          name(block) == name(end)

    ;Returns the corresponding implicit end for the given block.
    defn implicit-end (block:BlockTag|AnonymousBlock, info:FileInfo) -> BlockEnd :
      val name = match(block) :
        (block:BlockTag) : name(block)
        (block:AnonymousBlock) : id(block)
      BlockEnd(info, name, true)

    ;Assumes block-stack is not empty. Pops the top block
    ;off, and inserts the appropriate implicit ends if required.
    ;The given info is the FileInfo to use for any generated implicit ends.
    defn pop-block (info:FileInfo) :
      val block = pop(block-stack)
      if requires-implicit-end?(block) :
        add(item-list, implicit-end(block, info))

    ;If the top block requires an implicit end, and the given
    ;whitespace line or indent ends it, then pop it off using pop-block.
    ;Returns true if a block has been popped off.
    defn pop-implicit-block? (item:Whitespace|Indent) -> True|False :
      if not empty?(block-stack) :
        val block = peek(block-stack)
        if requires-implicit-end?(block) :
          val block-ends? = match(item) :
            (item:Whitespace) :
              match(following-indent(item)) :
                (i:Int) : i <= indent(block)
                (f:False) : true
            (item:Indent) :
              indent(item) < indent(block)
          if block-ends? :
            pop-block(info(item))
            true
            
    ;Scan through each item
    for item in items do :
      match(item) :
        (item:BlockTag|AnonymousBlock) :
          add(block-stack, item)
        (item:BlockEnd) :
          val index = index-of-block-on-stack(item)
          match(index:Int) :          
            ;Pop blocks including matched block.
            while length(block-stack) > index : pop-block(info(item))
          else :
            fatal("Mismatched block end.")
        (item:Whitespace|Indent) :
          while pop-implicit-block?(item) : ()          
        (item) :
          false
      ;Add original item  
      add(item-list, item)

    ;Return new items
    to-tuple(item-list)

  ;Main algorithm
  defn main () :
    val annotated = compute-indent-annotations(items(doc))
    val items* = generate-implicit-ends(annotated)
    CommentDoc(path(doc), params(doc), items*)

  ;Launch!
  main()

;============================================================
;=================== Stamp Computation ======================
;============================================================

defn compute-stamps (doc:CommentDoc) -> HashTable<String|Int,String> :
  ;Utility for computing the stamp string.
  val stamp-buffer = StringBuffer()

  ;Convert an integer code into a string
  defn to-hex (code:Int) -> String :
    defn letter (i:Int) :
      to-char $
        if i < 10 : to-int('0') + i
        else : to-int('A') + i - 10
    defn bits (i:Int) :
      (code >> i) & 0xF
    String $
      for i in reverse(0 to 32 by 4) seq :
        letter(bits(i))

  ;Return true if character represents a whitespace character.
  ;Ignored during stamp computation.
  defn whitespace? (c:Char) -> True|False :
    c == ' ' or c == '\t' or c == '\r'

  ;Add string into stamp buffer for use in computing stamps.
  defn add-stamp-buffer (str:String) :
    for c in str do :
      add(stamp-buffer, c) when not whitespace?(c)

  ;Utility for executing a body and then computing the
  ;total stamp for all calls to add-stamp-buffer.
  defn compute-stamp-string (body:() -> ?) -> String :
    clear(stamp-buffer)
    body()
    val hashcode = hash(to-string(stamp-buffer))
    to-hex(hashcode)
      
  ;Compute stamp for items from start (exclusive) to end (exclusive). 
  defn stamp (start:Int, end:Int) -> String :
    within compute-stamp-string() :
      for i in (start + 1) through (end - 1) do :
        match(items(doc)[i]) :
          (item:Reference) : add-stamp-buffer(name(item))
          (item:FileReference) : add-stamp-buffer(file(item))
          (item:Text) : add-stamp-buffer(string(item))
          (item) : false

  ;Return the identifier of the given block
  defn block-id (b:BlockTag|AnonymousBlock) -> String|Int :
    match(b) :
      (b:BlockTag) : name(b)
      (b:AnonymousBlock) : id(b)

  ;Sanity check: Blocks should be properly nested.
  defn ensure-matched! (b:BlockTag|AnonymousBlock, e:BlockEnd) :
    fatal("Mismatched blocks!") when block-id(b) != name(e)

  ;Compute
  defn main () :
    ;Each entry is [block, index]
    val block-stack = Vector<[BlockTag|AnonymousBlock,Int]>()
    val items* = to-vector<CommentItem>(items(doc))
    val stamp-table = HashTable<String|Int, String>()
    for (item in items(doc), i in 0 to false) do :
      match(item) :
        (item:BlockTag|AnonymousBlock) :
          add(block-stack, [item, i])
        (item:BlockEnd) :
          val [block, index] = pop(block-stack)
          ensure-matched!(block, item)
          stamp-table[block-id(block)] = stamp(index,i)
        (item) : false
    stamp-table

  ;Launch!
  main()

;============================================================
;==================== Parameter Sets ========================
;============================================================

defn DefaultCommentBasedParams (comment-header:String) :
  defn commented (s:String) :
    string-join $ [comment-header, s]
  DocParams(
    commented("+")
    commented("/")
    commented("!"))
    
;============================================================
;========================= Scratch ==========================
;============================================================

let :
  val filename = "testfile.txt"
  ;val filename = "testfile2.txt"
  val stream = StringInputStream(slurp(filename), filename)
  val default-params = DefaultCommentBasedParams(";")
  var doc:CommentDoc = parse-comment-doc(stream, filename, default-params)
  println("===== Parsed =====")
  do(println, items(doc))
  println("===== Implicit Ends ====")
  doc = compute-implicit-ends(doc)
  do(println, items(doc))
  println("===== Stamp Table =====")
  do(println, compute-stamps(doc))