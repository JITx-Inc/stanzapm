defpackage stz/comments :
  import core
  import reader
  import collections
  import stz/parsed-path

;============================================================
;====================== Main Driver =========================
;============================================================

;Check the project document consistency.
;Returns true if documents are consistent, or false otherwise.
public defn check-project-doc-consistency (structure-file:String, accepts:Tuple<String>) -> True|False :
  ;Throw the given exception if given.
  defn throw? (e:CommentDocErrors) : throw(e)
  defn throw? (f:False) : false
  defn throw? (d:CommentDocs) : d
  defn throw? (d:CommentDoc) : d

  ;Read in the structure file and exit if not well formed.
  val sfile = read-structure-file(structure-file)
  throw?(check-structure-file(sfile))

  ;Use the following set of default parameters.
  val default-params = DefaultCommentBasedParams("")

  ;Parse the root document and all linked files
  val root-doc = throw?(parse-comment-doc(file(root(sfile)), default-params))
  val cdocs = throw?(read-linked-files(root-doc))

  ;Retrieve project directory listing
  val dir-files = list-dir-files(map(file, files(sfile)))

  ;Check that all documents are well formed
  throw?(check-doc-wellformed(cdocs, dir-files, accepts))

  ;Update stamps on all documents, and collect any out-of-date errors.
  val stamps = compute-stamps(cdocs)
  val [cdocs*, out-of-date-errors] = update-stamps(cdocs, stamps, accepts)

  ;Write back new stacks back to disk.
  write-back-to-disk(cdocs*)

  ;If there are any out-of-date errors, then report them.
  match(out-of-date-errors:CommentDocErrors) :
    ;Notify users of out-of-date errors, and return false
    ;to indicate that some documents are inconsistent.
    println(out-of-date-errors)
    false
  else :
    ;Return true to indicate all documents are consistent
    true

;<doc>=======================================================
;====================== IR Definition =======================
;============================================================

## Possible Tags and Their Examples ##

BlockTag:
  ;+[Ray Partition Box](AFADE9901823)
  ;+[Ray Partition Box](outdated:AFADE9901823)
  ;+[Ray Partition Box]

BlockEnd
  ;/[Ray Partition Box]

Reference
  ;![Ray Partition Box](AFADE9901823)
  ;![Ray Partition Box](outdated:AFADE9901823)
  ;![Ray Partition Box]

FileReference
  ;![file:myfile.txt](outdated)
  ;![file:myfile.txt]

AnonymousBlock
  ;+(AFADE9901823)
  ;+(outdated:AFADE9901823)

Text
Indent
NewLine
Whitespace


## TODO:
- Some files should not be scanned because they are binary files.
- Referencing multiple sections at once.
- The system needs to output the set of files.
  - Possibly after backing them up first.
- We need to check that files are properly formed.
  - Tags are properly nested.
  - No duplicate blocks.
  - No duplicate block ends.
  - All blocks are referenced at least once.
  - All references are to blocks that exist.
  - All files in directory are reachable.

;============================================================
;=======================================================<doc>

public deftype CommentItem

public defstruct CommentDocs :
  root-path: String
  docs: Tuple<CommentDoc>

public defstruct CommentDoc :
  path: String
  full-path: String
  params: DocParams
  items: Tuple<CommentItem> with: (updater => sub-items)
  outdated?: True|False with: (init => false, updater => sub-outdated?)

public defstruct DocParams :
  block-tag-marker: String
  block-end-marker: String
  reference-marker: String

public defstruct BlockTag <: CommentItem :
  info: FileInfo
  name: String
  stamp: String|False
  outdated?: True|False
  indent: Int with: (init => 0, updater => sub-indent)
with:
  printer => true

public defstruct BlockEnd <: CommentItem :
  info: FileInfo
  name: String|Int
  implicit?: True|False with: (default => false)
with:
  printer => true

public defstruct Reference <: CommentItem :
  info: FileInfo
  name: String
  stamp: String|False
  outdated?: True|False
with:
  printer => true

public defstruct FileReference <: CommentItem :
  info: FileInfo
  file: String
  outdated?: True|False
with:
  printer => true

public defstruct AnonymousBlock <: CommentItem :
  info: FileInfo
  id: Int
  stamp: String
  outdated?: True|False
  indent: Int with: (init => 0, updater => sub-indent)
with:
  printer => true

public defstruct Text <: CommentItem :
  string: String
with:
  printer => true

public defstruct Whitespace <: CommentItem :
  info: FileInfo
  string: String
  following-indent: Int|False with: (init => false, updater => sub-following-indent)
with:
  printer => true

public defstruct Indent <: CommentItem :
  info: FileInfo
  indent: Int
  following-block: True|False with: (init => false, updater => sub-following-block)
with:
  printer => true

public defstruct NewLine <: CommentItem
with:
  printer => true

;============================================================
;======================= Printers ===========================
;============================================================

defmethod print (o:OutputStream, cdocs:CommentDocs) :
  val items = to-tuple $ cat-all $ [
    ["root-path = %~" % [root-path(cdocs)]]
    docs(cdocs)]  
  print(o, "CommentDocs(%_)" % [indented-list(items)])

defmethod print (o:OutputStream, doc:CommentDoc) :
  val items = [
    "path = %~" % [path(doc)]
    "full-path = %~" % [full-path(doc)]
    "outdated? = %~" % [outdated?(doc)]
    "items = [%_]" % [indented-list(items(doc))]]
  print(o, "CommentDoc(%_)" % [indented-list(items)])

defn indented-list (xs:Collection) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      val o2 = IndentedStream(o)
      do(lnprint{o2, _}, xs)

;============================================================
;================== Check Structure File ====================
;============================================================
defn check-structure-file (f:StructureFile) -> CommentDocErrors|False :
  val errors = Vector<CommentDocError>()
  defn rootfile? (f:DocFile) -> True|False :
    file-type(file(f)) is FileType
  defn exists? (f:DocFile) -> True|False :
    file-exists?(file(f))

  ;Ensure root file consistent.
  if exists?(root(f)) :
    if not rootfile?(root(f)) :
      add(errors, CouldNotReadRootFile(info(root(f)), file(root(f))))
  else :
    add(errors, CouldNotFindRootFile(info(root(f)), file(root(f))))

  ;Ensure each doc file consistent.
  for f in files(f) do :
    if not exists?(f) :
      add(errors, CouldNotFindDocFile(info(f), file(f)))

  ;Return errors
  if not empty?(errors) :
    CommentDocErrors(to-tuple(errors))

;============================================================
;========================= Parsing ==========================
;============================================================

defn parse-comment-doc (path:String, params:DocParams) -> CommentDoc|CommentDocErrors :
  parse-comment-doc(path, resolve-path!(path), params)

defn parse-comment-doc (path:String, full-path:String, params:DocParams) -> CommentDoc|CommentDocErrors :
  val string = slurp(path)
  val stream = StringInputStream(string, path)
  parse-comment-doc(stream, path, full-path, params)

defn parse-comment-doc (stream:StringInputStream, path:String, full-path:String, params:DocParams) -> CommentDoc|CommentDocErrors :
  ;Compute statistics on markers
  val block-tag-marker-len = length(block-tag-marker(params))
  val block-end-marker-len = length(block-end-marker(params))
  val reference-marker-len = length(reference-marker(params))
  val outdated-str = "outdated:"
  val outdated-len = length(outdated-str)
  val fileref-str = "file:"
  val fileref-len = length(fileref-str)

  ;Accumulate errors
  val errors = Vector<CommentDocError>()

  ;Eat the given number of characters.
  defn eat-chars (n:Int) -> False :
    for i in 0 to n do : get-char(stream)

  ;Return true if the given character is a newline
  defn newline? (c:Char|False) -> True|False :
    c == '\n'

  ;Return true if the given character is a whitespace character
  defn whitespace? (c:Char|False) -> True|False:
    c == ' ' or c == '\t' or c == '\r'

  ;Return true if 'string' appears at position 'i' in the stream.
  defn upcoming-string? (i:Int, string:String) -> True|False :
    if empty?(string) :
      true
    else if peek?(stream,i) == string[0] :
      for j in 1 to length(string) all? :
        peek?(stream,i + j) == string[j]

  ;Return true if 'char' appears at position 'i' in the stream.
  defn upcoming-char? (i:Int, char:Char) -> True|False :
    peek?(stream,i) == char

  ;Return the index in the stream where 'char' appears, or
  ;false otherwise. Newlines mark the end of the searchable region.
  defn index-of-line-char? (start:Int, char:Char) -> Int|False :
    val n = length(stream)
    let loop (i:Int = start) :
      if i < n :
        val c = peek(stream,i)
        if newline?(c) : false
        else if c == char : i
        else : loop(i + 1)

  ;Return the index past the end of the line.
  defn index-of-line-end (start:Int) -> Int :
    val n = length(stream)
    let loop (i:Int = start) :
      if i < n :
        if newline?(peek?(stream,i)) : i
        else : loop(i + 1)
      else : n

  ;Return true if there is an upcoming block tag:
  ;e.g. ;+[port definition]
  defn upcoming-block-tag? () -> True|False :
    upcoming-string?(0, block-tag-marker(params)) and
    upcoming-char?(block-tag-marker-len, '[')
  ;Return true if there is an upcoming block end:
  ;e.g. ;/[port definition]
  defn upcoming-block-end? () -> True|False :
    upcoming-string?(0, block-end-marker(params)) and
    upcoming-char?(block-end-marker-len, '[')
  ;Return true if there is an upcoming reference:
  ;e.g. ;![port definition]
  defn upcoming-reference? () -> True|False :
    upcoming-string?(0, reference-marker(params)) and
    upcoming-char?(reference-marker-len, '[')
  ;Return true if there is an upcoming anonymous reference:
  ;e.g. ;+(AFAD1241F)
  defn upcoming-anonymous? () -> True|False :
    upcoming-string?(0, block-tag-marker(params)) and
    upcoming-char?(block-tag-marker-len, '(')
  ;Return true if there is a line with no characters
  ;except for whitespace.
  defn upcoming-whitespace? () -> True|False :
    val end = index-of-line-end(0)
    for i in 0 to end all? :
      whitespace?(peek(stream,i))
  ;Return true if the end of the file is upcoming.
  defn upcoming-eof? () -> True|False :
    peek?(stream,0) == false
  ;Return true if a new line is upcoming.
  defn upcoming-newline? () -> True|False :
    newline?(peek?(stream,0))

  ;Parse the [...] tag at the given index.
  ;If the closing character cannot be found, then an error is added
  ;to the error-list, the rest of the line is eaten, and fail() is called. 
  defn parse-bracket (start:Int, start-char:Char, end-char:Char) -> String|False :
    if upcoming-char?(start, start-char) :
      val tag-end = index-of-line-char?(start, end-char)
      match(tag-end:Int) :
        ;Compute the number of chars within the bracketing characters.
        val num-chars = tag-end - (start + 1)
        ;Eat past opening [
        eat-chars(start + 1)
        ;Retrieve characters within [...]
        val tag-string = get-chars(stream, num-chars)
        ;Eat closing ]
        eat-chars(1)
        ;Return tag string
        tag-string
      else :
        ;Report error
        val info = info(stream)
        add(errors, NoEndingBracket(info, end-char))
        ;Eat rest of line, and fail.
        eat-chars(index-of-line-end(start))
        fail()

  ;Parse the tag starting at index i.
  ;Assumes that character tag-start == '['.
  ;Returns [bracket-string, paren-string], where bracket-string
  ;is the string within the [...], and paren-string is the string
  ;within the following (...).
  ;Calls fail() if any bracket is unclosed.
  defn parse-tag (tag-start:Int) -> [String, String|False] :
    val bracket-str = parse-bracket(tag-start, '[', ']') as String
    val paren-str = parse-bracket(0, '(', ')')
    [bracket-str, paren-str]

  ;Parse the upcoming whitespace line.
  defn parse-whitespace () -> Whitespace :
    val info = info(stream)
    val end = index-of-line-end(0)
    val str = get-chars(stream, end)
    Whitespace(info, str)

  ;Split up an outdated tag into a flag and a string.
  defn split-outdated-tag (string:String|False) -> [String|False, True|False] :
    match(string:String) :
      if prefix?(string, outdated-str) :
        val stamp = string[outdated-len to false]
        [stamp, true]
      else : [string, false]
    else : [false, true]

  ;Parse the upcoming block tag.
  ;Calls fail() if bracket is unclosed.
  defn parse-block-tag () -> BlockTag :
    val info = info(stream)
    val [name, paren-str] = parse-tag(block-tag-marker-len)
    val [stamp, outdated?] = split-outdated-tag(paren-str)
    BlockTag(info, name, stamp, outdated?)

  ;Parse the upcoming block end tag.
  ;Calls fail() bracket is not closed.
  defn parse-block-end () -> BlockEnd :
    val info = info(stream)
    val string = parse-bracket(block-end-marker-len, '[', ']') as String
    BlockEnd(info, string)

  ;Parse the upcoming reference or file reference.
  ;Reports an error if file status is invalid.
  ;Calls fail() if bracket is unclosed.
  defn parse-reference () -> Reference|FileReference :
    val info = info(stream)
    val [bracket-str, paren-str] = parse-tag(reference-marker-len)
    if prefix?(bracket-str, fileref-str) :
      val filename = bracket-str[fileref-len to false]
      val outdated? =
        match(paren-str:String) :
          if paren-str != "outdated" :
            add(errors, InvalidFileStatus(info, paren-str))
          true
      FileReference(info, filename, outdated?)
    else :
      val [stamp, outdated?] = split-outdated-tag(paren-str)
      Reference(info, bracket-str, stamp, outdated?)

  ;Parse the upcoming anonymous block.
  ;Calls fail() if any bracket is unclosed.
  defn parse-anonymous () -> AnonymousBlock :
    val info = info(stream)
    val string = parse-bracket(block-tag-marker-len, '(', ')') as String
    val [stamp, outdated?] = split-outdated-tag(string)
    AnonymousBlock(info, genid(), stamp as String, outdated?)

  ;Eat the upcoming character in the input stream.
  defn parse-char () -> Char :
    get-char(stream) as Char

  ;Parse the upcoming new line
  defn parse-newline () -> NewLine :
    get-char(stream)
    NewLine()

  ;Parse the upcoming indent
  defn parse-indent () -> Indent :
    val info = info(stream)
    val num-whitespace =
      for i in 0 to false find! :
        not whitespace?(peek?(stream,i))
    Indent(info, num-whitespace)

  ;Accumulate parsed items
  val item-accum = Vector<CommentItem>()
  val char-accum = StringBuffer()

  ;Add a new character to the accumulator.
  defn add-item (c:Char) :
    add(char-accum, c)
  ;Add a new comment item to the accumulator.
  defn add-item (item:CommentItem) :
    flush-chars()
    add(item-accum, item)
  ;Retrieve all parsed items in the accumulator.
  defn parsed-items () -> Tuple<CommentItem> :
    flush-chars()
    to-tuple(item-accum)
  ;Helper: Empty the character accumulator and create a Text item.
  defn flush-chars () :
    if not empty?(char-accum) :
      add(item-accum, Text(to-string(char-accum)))
      clear(char-accum)

  ;Launch!
  defn main () :
    ;Starting line
    if upcoming-whitespace?() :
      add-item(parse-whitespace())
    else :
      add-item(parse-indent())

    ;Preconditions for starting loop
    ;  Any indents/whitespace at the beginning of the file has been parsed.
    let loop () :
      if upcoming-block-tag?() :
        attempt: add-item(parse-block-tag())
        loop()
      else if upcoming-block-end?() :
        attempt: add-item(parse-block-end())
        loop()
      else if upcoming-reference?() :
        attempt: add-item(parse-reference())
        loop()
      else if upcoming-anonymous?() :
        attempt: add-item(parse-anonymous())
        loop()
      else if upcoming-newline?() :
        add-item(parse-newline())
        if upcoming-whitespace?() :
          add-item(parse-whitespace())
          loop()
        else :
          add-item(parse-indent())
          loop()
      else if upcoming-eof?() :
        false
      else :
        add-item(parse-char())
        loop()

    ;Return items
    if empty?(errors) : CommentDoc(path, full-path, params, parsed-items())
    else : CommentDocErrors(to-tuple(errors))

  ;Launch!
  main()

;============================================================
;==================== Read Linked Files =====================
;============================================================
  
defn read-linked-files (root-doc:CommentDoc) -> CommentDocs|CommentDocErrors :
  ;Table to keep track of all documents.
  val files = HashTable<String,CommentDoc|CommentDocErrors>()
  defn add-file (full-path:String, doc:CommentDoc|CommentDocErrors) :
    files[full-path] = doc

  ;Track all errors
  val errors = Vector<CommentDocError>()

  ;Track all dependencies
  val link-table = HashTable<String,Tuple<Link>>()  

  ;Read in and scan linked files in the given comment doc, unless
  ;the doc has already been scanned.
  ;The path and full-path to the comment doc is given.
  defn scan-doc (path:String, full-path:String) :
    if not key?(files, full-path) :
      ;[TODO]: Change params according to extension.
      val doc = parse-comment-doc(path, full-path, params(root-doc))   
      add-file(full-path, doc)
      match(doc:CommentDoc) :
        scan-doc(doc)

  ;Scan all linked files in the given comment doc.
  defn scan-doc (doc:CommentDoc) :
    ;Returns the full path to the given filepath, assuming that it is
    ;defined relative to the current doc.
    ;Returns [full-path, resolved-path].
    ;Throws:
    ;  PathResolutionError - if file does not exist.
    ;  UpPastRoot - if joining the file path fails.
    defn relative-to-doc-file (filepath:String) -> [String, String] :
      val ppath = parse-path(filepath)
      val dirpath = enclosing-dir(parse-path(path(doc)))
      val fullpath = to-string(relative-to-dir(dirpath, ppath))
      [fullpath, resolve-path!(fullpath)]

    ;Track all linked files
    val links = Vector<Link>()

    ;Scan each file reference
    for ref in filter-by<FileReference>(items(doc)) do :
      try :
        val [path, full-path] = relative-to-doc-file(file(ref))
        add(links, Link(full-path, outdated?(ref)))
        scan-doc(path, full-path)
      catch (e:PathResolutionError|UpPastRoot) :
        add(errors, UnresolvedFile(info(ref), file(ref)))

    ;Record links
    link-table[full-path(doc)] = to-tuple(links)

  ;Compute status of files.
  ;  An up-to-date file is a file that is reachable through only
  ;  up-to-date references.
  defn compute-outdated (cdocs:CommentDocs) -> CommentDocs :
    ;Compute set of up-to-date files.
    val up-to-date = HashSet<String>()
    defn mark-up-to-date (path:String) :
      if add(up-to-date, path) :
        for link in link-table[path] do :
          mark-up-to-date(/path(link)) when not outdated?(link)
    mark-up-to-date(full-path(root-doc))
    ;Annotate a doc with its status
    defn annotate (doc:CommentDoc) -> CommentDoc :
      val outdated? = not up-to-date[full-path(doc)]
      sub-outdated?(doc, outdated?)
    ;Annotate all docs
    val docs* = map(annotate, docs(cdocs))
    CommentDocs(root-path(cdocs), docs*)

  ;If any errors occurred during linking, then collect them
  ;into a single CommentDocErrors structure.
  defn collect-errors () -> CommentDocErrors|False :
    val errors? = not empty?(errors) or
                  any?({value(_) is CommentDocErrors}, files)
    if errors? :
      val file-errors = filter-by<CommentDocErrors>(values(files))
      CommentDocErrors $ cat(
        [CommentDocErrors(to-tuple(errors))],
        file-errors)

  ;Launch!
  add-file(full-path(root-doc), root-doc)
  scan-doc(root-doc)
  match(collect-errors()) :
    (e:CommentDocErrors) :
      e
    (f:False) :
      val docs* = to-tuple(values(files)) as Tuple<CommentDoc>
      val cdocs = CommentDocs(full-path(root-doc), docs*)
      compute-outdated(cdocs)

defstruct Link :
  path: String
  outdated?: True|False

;============================================================
;================ Read all Files in Directory ===============
;============================================================
defstruct DirFiles :
  paths: Tuple<DirFile>
  
defstruct DirFile :
  path: String
  full-path: String
with:
  printer => true

defn list-dir-files (files:Tuple<String>) -> DirFiles :
  val accum = Vector<DirFile>()
  defn join-path (dir:ParsedPath, file:String) -> ParsedPath :
    relative-to-dir(dir, parse-path(file))
  defn scan (path:ParsedPath) :
    val file = to-string(path)
    match(file-type(file)) :
      (dir-type:DirectoryType) :
        for filename in dir-files(file) do :
          scan(join-path(path, filename))
      (file-type) :
        val full-path = resolve-path!(file)
        add(accum, DirFile(file, full-path))
  do(scan{parse-path(_)}, files)
  DirFiles(to-tuple(accum))    

;============================================================
;================== Check Docs Wellformedness ===============
;============================================================

;Check that the given documents are well-formed.
;Returns CommentDocErrors if there are errors or False otherwise.
defn check-doc-wellformed (cdocs:CommentDocs, files:DirFiles, accepts:Tuple<String>) -> CommentDocErrors|False :
  ;Accumulate all errors
  val errors = Vector<CommentDocError>()

  ;Staged checking utility.
  ;Calling stop-if-errors will exit the block defined by
  ;staged-checking if any errors has been added since
  ;the block started.
  var stop-if-errors: () -> False = fatal{"Not in staged-checking block."}
  defn staged-checking (body:() -> ?) -> False :
    val num-errors = length(errors)
    label return :
      defn return-if-errors () :
        return() when length(errors) > num-errors
      let-var stop-if-errors = return-if-errors :
        body()    

  ;Scan document for any duplicate blocks or block ends.
  defn scan-for-duplicate-blocks (doc:CommentDoc) :
    val block-table = HashTable<String,BlockTag>()
    val end-table = HashTable<String,BlockEnd>()
    for item in items(doc) do :
      match(item) :
        (block:BlockTag) :
          if key?(block-table, name(block)) :
            val old-block = block-table[name(block)]
            add(errors, DuplicateBlockInFile(name(block), info(block), info(old-block)))
          else :
            block-table[name(block)] = block
        (end:BlockEnd) :
          val name = name(end) as String
          if key?(end-table, name) :
            val old-end = end-table[name]
            add(errors, DuplicateEndInFile(name, info(end), info(old-end)))
          else :
            end-table[name] = end
        (item) :
          false

  ;Scan document to ensure that ending tags are properly nested.
  ;Assumes that 'scan-for-duplicate-blocks' does not detect any errors.
  defn scan-for-invalid-nesting (doc:CommentDoc) :
    ;Stack of opened blocks seen thus far.
    val block-stack = Vector<BlockTag>()
    
    ;Returns the index of the block with the given name.
    defn index-of-block-on-stack! (block-name:String) -> Int :
      for b in block-stack index-when! :
        name(b) == block-name
        
    ;Block end set
    val block-end-set = to-hashset<String> $
      for item in filter-by<BlockEnd>(items(doc)) seq :
        name(item) as String
        
    ;Scan through each item, and process each
    ;BlockTag and BlockEnd.
    for item in items(doc) do :
      match(item) :
        (item:BlockTag) :
          add(block-stack, item) when block-end-set[name(item)]
        (item:BlockEnd) :
          val end-name = name(item) as String
          val index = index-of-block-on-stack!(end-name)
          if index != length(block-stack) - 1 :
            val skipped-block-names = to-tuple $
              seq(name, block-stack[(index + 1) to false])
            add(errors, InvalidNestedBlock(info(item), end-name, skipped-block-names))
          remove(block-stack, index)
        (item) : false

  ;Scan document for within-document errors.
  defn scan (doc:CommentDoc) :
    within staged-checking() :
      scan-for-duplicate-blocks(doc)
      stop-if-errors()
      scan-for-invalid-nesting(doc)

  ;Build table of all defined blocks and references in all up-to-date docs.
  ;If there are any duplicate blocks, these errors are added to the error buffer.
  defn defined-blocks-and-references () :
    val block-table = HashTable<String,BlockTag>()
    val ref-table = HashTable<String,List<Reference>>(List())
    for doc in up-to-date-docs(cdocs) do :
      for item in items(doc) do :
        match(item) :
          (block:BlockTag) :
            if key?(block-table, name(block)) :
              val old-block = block-table[name(block)]
              add(errors, DuplicateBlock(name(block), info(block), info(old-block)))
            else :
              block-table[name(block)] = block
          (ref:Reference) :
            update(ref-table, cons{ref, _}, name(ref))
          (item) :
            false
    [block-table, ref-table]

  ;Check for the following:
  ;  - All references are to a defined block.
  ;  - All blocks are referenced at least once.
  defn check-consistent-references (blocks:HashTable<String,BlockTag>,
                                    references:HashTable<String,List<Reference>>) :
    ;Detect any references to undefined blocks.
    for entry in references do :
      if not key?(blocks, key(entry)) :
        val infos = to-tuple(seq(info, value(entry)))
        add(errors, UnresolvedBlock(key(entry), infos))
    ;Detect any blocks without a reference.
    for block in values(blocks) do :
      if not key?(references, name(block)) :
        add(errors, UnreferencedBlock(info(block), name(block)))

  ;Check that all blocks marked as accepted are defined.
  defn check-accepts-defined (blocks:HashTable<String,BlockTag>) :
    for accept in accepts do :
      if not key?(blocks, accept) :
        add(errors, UnresolvedAccept(accept))

  ;Check that all registered files are described by root document.
  defn check-all-files-described () :
    ;Compute set of all documents described by root.
    val doc-set = to-hashset<String> $
      seq(full-path, docs(cdocs))
    for file in paths(files) do :
      if not doc-set[full-path(file)] :
        add(errors, UndescribedFile(path(file)))

  ;Main algorithm
  defn main () :
    within staged-checking() :
      ;Check individual doc consistency.
      do(scan, docs(cdocs))
      stop-if-errors()
      ;Check project consistency.
      val [blocks, references] = defined-blocks-and-references()
      check-consistent-references(blocks, references)
      check-all-files-described()
      check-accepts-defined(blocks)
    ;Return errors if there are errors
    if not empty?(errors) :
      CommentDocErrors(to-tuple(errors))

  ;Launch!
  main()    

;Return sequence of all up-to-date documents.
defn up-to-date-docs (cdocs:CommentDocs) -> Seqable<CommentDoc> :
  for doc in docs(cdocs) filter :
    not outdated?(doc)

;<doc>=======================================================
;================ Find Implicit Block Ends ==================
;============================================================
Example of Computed Ends:

  ;+[A]
  asdf asdf :
    asdf asdf
    ;+[B]
    asdf asdf :
      asdf
      asdf

      asdf
      sadf       <-- End of block [B]

    ;+[C]
    asdfasdf :
      asdf
      asdf

      asdf
      asdf       <-- End of block [C]
                 <-- End of block [A]
  ;+[D]
  asdf asdf :
    asdf asdf
    asdf         <-- End of block [D]

  ;+[E]
  asdf
  asdf           <-- End of block [E]

  ;+[F]
  asdf asdf :
    ;+[G]
    asdf :
      asdf
      asdf       <-- End of block [G]

    ;+[H]
    asdf :
      asdf
      asdf       <-- End of block [H]
  asdf asdf
  asdf asdf
  asdf           <-- End of block [F]

  ;+[I]
  asfd asdf :
    asdf         <-- End of block [I]
    
;============================================================
;=======================================================<doc>

defn compute-implicit-ends (doc:CommentDoc) -> CommentDoc :
  ;Compute set of all ending tags in document.
  defn compute-block-end-set () -> HashSet<String> :
    val ends = filter-by<BlockEnd>(items(doc))
    val end-names = seq({name(_) as String}, ends)
    to-hashset<String>(end-names)

  ;Returns true if the given block marker requires an implicit end.
  val block-end-set = compute-block-end-set()
  defn requires-implicit-end? (item:BlockTag|AnonymousBlock) -> True|False :
    match(item) :
      ;Named blocks have an implicit end only if they do not have
      ;an explicit end.
      (item:BlockTag) :
        not block-end-set[name(item)]
      ;Anonymous blocks always have an implicit end.
      (item:AnonymousBlock) :
        true

  ;Compute indent information for items
  defn compute-indent-annotations (items:Tuple<CommentItem>) -> Collection<CommentItem> :
    ;Cache in vector for compute.
    val item-list = to-vector<CommentItem>(items)
    val num-items = length(item-list)

    ;First compute indents of blocks
    var prev-indent:Int = 0
    for i in 0 to num-items do :
      match(item-list[i]) :
        (item:BlockTag|AnonymousBlock) : item-list[i] = sub-indent(item, prev-indent)
        (item:Indent) : prev-indent = indent(item)
        (item) : false

    ;Then compute following indents of whitespace, and following blocks of indents.
    var next-indent:Int|False = false
    var next-block:True|False = false
    for i in reverse(0 to num-items) do :
      match(item-list[i]) :
        (item:BlockTag|AnonymousBlock) : next-block = true
        (item:NewLine) : next-block = false
        (item:Whitespace) :
          item-list[i] = sub-following-indent(item, next-indent)
        (item:Indent) :
          item-list[i] = sub-following-block(item, next-block)
          next-indent = indent(item)
        (item) : false

    ;Return items
    item-list

  ;Scan through each item, and generate implicit ends.
  defn generate-implicit-ends (items:Collection<CommentItem>) -> Tuple<CommentItem> :
    ;Track new items containing newly generated implicit ends.
    val item-list = Vector<CommentItem>()

    ;Track stack of opened blocks.
    val block-stack = Vector<BlockTag|AnonymousBlock>()

    ;Find the index of the corresponding opening block on the block-stack.
    defn index-of-block-on-stack (end:BlockEnd) -> Int :
      for block in block-stack index-when! :
        match(block:BlockTag) :
          name(block) == name(end)

    ;Returns the corresponding implicit end for the given block.
    defn implicit-end (block:BlockTag|AnonymousBlock, info:FileInfo) -> BlockEnd :
      val name = match(block) :
        (block:BlockTag) : name(block)
        (block:AnonymousBlock) : id(block)
      BlockEnd(info, name, true)

    ;Assumes block-stack is not empty. Pops the top block
    ;off, and inserts the appropriate implicit ends if required.
    ;The given info is the FileInfo to use for any generated implicit ends.
    defn pop-block (info:FileInfo) :
      val block = pop(block-stack)
      if requires-implicit-end?(block) :
        add(item-list, implicit-end(block, info))

    ;If the top block requires an implicit end, and the given
    ;whitespace line or indent ends it, then pop it off using pop-block.
    ;Returns true if a block has been popped off.
    defn pop-implicit-block? (item:Whitespace|Indent) -> True|False :
      if not empty?(block-stack) :
        val block = peek(block-stack)
        if requires-implicit-end?(block) :
          val block-ends? = match(item) :
            (item:Whitespace) :
              match(following-indent(item)) :
                (i:Int) : i <= indent(block)
                (f:False) : true
            (item:Indent) :
              if following-block(item) : indent(item) <= indent(block)
              else : indent(item) < indent(block)
          if block-ends? :
            pop-block(info(item))
            true

    ;Scan through each item
    for item in items do :
      match(item) :
        (item:BlockTag|AnonymousBlock) :
          add(block-stack, item)
        (item:BlockEnd) :
          val index = index-of-block-on-stack(item)
          ;Pop blocks including matched block.
          while length(block-stack) > index : pop-block(info(item))
        (item:Whitespace|Indent) :
          while pop-implicit-block?(item) : ()
        (item) :
          false
      ;Add original item
      add(item-list, item)

    ;Return new items
    to-tuple(item-list)

  ;Main algorithm
  defn main () :
    val annotated = compute-indent-annotations(items(doc))
    val items* = generate-implicit-ends(annotated)
    sub-items(doc, items*)

  ;Launch!
  main()

;============================================================
;=================== Stamp Computation ======================
;============================================================

defn compute-stamps (cdocs:CommentDocs) -> HashTable<String|Int,String> :
  to-hashtable<String|Int,String> $
    seq-cat(compute-stamps, docs(cdocs))

defn compute-stamps (doc:CommentDoc) -> HashTable<String|Int,String> :
  ;Utility for computing the stamp string.
  val stamp-buffer = StringBuffer()

  ;Convert an integer code into a string
  defn to-hex (code:Int) -> String :
    defn letter (i:Int) :
      to-char $
        if i < 10 : to-int('0') + i
        else : to-int('A') + i - 10
    defn bits (i:Int) :
      (code >> i) & 0xF
    String $
      for i in reverse(0 to 32 by 4) seq :
        letter(bits(i))

  ;Return true if character represents a whitespace character.
  ;Ignored during stamp computation.
  defn whitespace? (c:Char) -> True|False :
    c == ' ' or c == '\t' or c == '\r'

  ;Add string into stamp buffer for use in computing stamps.
  defn add-stamp-buffer (str:String) :
    for c in str do :
      add(stamp-buffer, c) when not whitespace?(c)

  ;Utility for executing a body and then computing the
  ;total stamp for all calls to add-stamp-buffer.
  defn compute-stamp-string (body:() -> ?) -> String :
    clear(stamp-buffer)
    body()
    val hashcode = hash(to-string(stamp-buffer))
    to-hex(hashcode)

  ;Compute stamp for items from start (exclusive) to end (exclusive).
  defn stamp (start:Int, end:Int) -> String :
    within compute-stamp-string() :
      for i in (start + 1) through (end - 1) do :
        match(items(doc)[i]) :
          (item:Reference) : add-stamp-buffer(name(item))
          (item:FileReference) : add-stamp-buffer(file(item))
          (item:Text) : add-stamp-buffer(string(item))
          (item) : false

  ;Return the identifier of the given block
  defn block-id (b:BlockTag|AnonymousBlock) -> String|Int :
    match(b) :
      (b:BlockTag) : name(b)
      (b:AnonymousBlock) : id(b)

  ;Sanity check: Blocks should be properly nested.
  defn ensure-matched! (b:BlockTag|AnonymousBlock, e:BlockEnd) :
    fatal("Mismatched blocks!") when block-id(b) != name(e)

  ;Compute
  defn main () :
    ;Each entry is [block, index]
    val block-stack = Vector<[BlockTag|AnonymousBlock,Int]>()
    val items* = to-vector<CommentItem>(items(doc))
    val stamp-table = HashTable<String|Int, String>()
    for (item in items(doc), i in 0 to false) do :
      match(item) :
        (item:BlockTag|AnonymousBlock) :
          add(block-stack, [item, i])
        (item:BlockEnd) :
          val [block, index] = pop(block-stack)
          ensure-matched!(block, item)
          stamp-table[block-id(block)] = stamp(index,i)
        (item) : false
    stamp-table

  ;Launch!
  main()

;============================================================
;===================== Stamp Updating =======================
;============================================================

defn update-stamps (cdocs:CommentDocs,
                    stamp-table:HashTable<String|Int,String>,
                    accepts:Tuple<String>) -> [CommentDocs, CommentDocErrors|False] :
  ;Compute set of blocks to accept.
  val accept-set = to-hashset<String>(accepts)

  ;Accumulate out-of-date errors
  val errors = Vector<CommentDocError>()

  ;Returns true if the given reference is out-of-date.
  defn ref-outdated? (id:String|Int,
                      new-stamp:String,
                      old-stamp:String|False,
                      previously-outdated?:True|False) -> True|False :
    val accepted? = match(id:String) :
      accept-set[id]
    ;If block is marked to be accepted, then it is not
    ;out-of-date.
    if accepted? :
      false
    ;Otherwise, it is outdated if either
    ;  it was previously out-of-date,
    ;  or if the new-stamp is not equal to the old stamp.
    else :
      previously-outdated? or new-stamp != old-stamp    
  
  ;Update the comment item by filling in new hash information.
  defn update (item:CommentItem) -> CommentItem :
    match(item) :
      (item:BlockTag) :
        match(stamp(item)) :
          (item-stamp:String) :
            val stamp* = stamp-table[name(item)]
            val outdated?* = ref-outdated?(name(item), stamp*, item-stamp, outdated?(item))
            add(errors, OutdatedBlock(info(item), name(item))) when outdated?*
            BlockTag(info(item), name(item), stamp*, outdated?*)
          (f:False) :
            item
      (item:AnonymousBlock) :
        val stamp* = stamp-table[id(item)]
        val outdated?* = ref-outdated?(id(item), stamp*, stamp(item), outdated?(item))
        add(errors, OutdatedBlock(info(item), false)) when outdated?*
        AnonymousBlock(info(item), id(item), stamp*, outdated?*)
      (item:Reference) :
        val stamp* = stamp-table[name(item)]
        val outdated?* = ref-outdated?(name(item), stamp*, stamp(item), outdated?(item))
        add(errors, OutdatedReference(info(item), name(item))) when outdated?*
        Reference(info(item), name(item), stamp*, outdated?*)
      (item) : item

  ;Update the given document.
  defn update (doc:CommentDoc) -> CommentDoc :
    sub-items(doc, map(update, items(doc)))

  ;Launch!
  val cdocs* = CommentDocs(root-path(cdocs), map(update,docs(cdocs)))
  val errors* = CommentDocErrors(to-tuple(errors)) when not empty?(errors)
  [cdocs*, errors*]

;============================================================
;======================== Export ============================
;============================================================

defn export (doc:CommentDoc) -> Printable :
  val params = params(doc)
  new Printable :
    defmethod print (o:OutputStream, this) :
      defn print-tag (prefix:String, start:Char, tag, end:Char) :
        print(o, prefix)
        print(o, start)
        print(o, tag)
        print(o, end)
      defn outdated-tag (str:String, outdated?:True|False) :
        if outdated? : "outdated:%_" % [str]
        else : str
      for item in items(doc) do :
        match(item) :
          (item:BlockTag) :
            print-tag(block-tag-marker(params), '[', name(item), ']')
            if stamp(item) is String :
              val tag = outdated-tag(stamp(item) as String, outdated?(item))
              print-tag("", '(', tag, ')')
          (item:BlockEnd) :
            if not implicit?(item) :
              print-tag(block-end-marker(params), '[', name(item), ']')
          (item:Reference) :
            print-tag(reference-marker(params), '[', name(item), ']')
            val tag = outdated-tag(stamp(item) as String, outdated?(item))
            print-tag("", '(', tag, ')')
          (item:FileReference) :
            val tag = "file:%_" % [file(item)]
            print-tag(reference-marker(params), '[', tag, ']')
            if outdated?(item) :
              print(o, "(outdated)")
          (item:AnonymousBlock) :
            val tag = outdated-tag(stamp(item), outdated?(item))
            print-tag(block-tag-marker(params), '(', tag, ')')
          (item:Text) :
            print(o, string(item))
          (item:Whitespace) :
            print(o, string(item))
          (item:Indent) :
            false
          (item:NewLine) :
            print(o, '\n')

;============================================================
;============== Write Updated Docs Back Out =================
;============================================================
defn write-back-to-disk (cdocs:CommentDocs) :
  for doc in docs(cdocs) do :
    spit(path(doc), export(doc))

;============================================================
;==================== Structure File ========================
;============================================================

public defstruct StructureFile :
  root: DocFile
  files: Tuple<DocFile>

defstruct DocFile :
  info: FileInfo
  file: String

defsyntax stanza-doc-structure-file :
  public defproduction structure-file: StructureFile
  defrule structure-file = (?stmts:#stmt! ...) :
    val stmt-table = HashTable<Symbol,List>(List())
    for stmt in stmts do :
      update(stmt-table, cons{value(stmt), _}, key(stmt))
    val root-file = switch(length(stmt-table[`root])) :
      0 : throw(DocFileError(false, "No root document listed in structure file."))
      1 : head(stmt-table[`root])
      else : throw(DocFileError(false, "Multiple root documents listed in structure file."))
    val files = switch(length(stmt-table[`files])) :
      0 : throw(DocFileError(false, "No files listed in structure file."))
      1 : head(stmt-table[`files])
      else : throw(DocFileError(false, "Multiple sets of files listed in structure file."))
    StructureFile(root-file, files)

  defproduction stmt!: KeyValue<Symbol,?>
  defrule stmt! = (root: ?f:#one-docfile!) : `root => f
  defrule stmt! = (files: ?fs:#docfiles!) : `files => fs
  fail-if stmt! = () :
    DocFileError(closest-info(), "Invalid statement in document structure file.")

  defproduction one-docfile! : DocFile
  defrule one-docfile! = ((?f:#docfile!)) : f
  defrule one-docfile! = (?f:#docfile!) : f
  fail-if one-docfile! = ((#docfile! _)) : DocFileError(closest-info(), "Expected a single filename here.")

  defproduction docfiles! : Tuple<DocFile>
  defrule docfiles! = ((?fs:#docfile! ...)) : to-tuple(fs)
  defrule docfiles! = (?f:#docfile!) : [f]
  
  ;Read a document file listing
  defproduction docfile! : DocFile
  defrule docfile! = (?s) when unwrap-token(s) is String :
    DocFile(closest-info() as FileInfo, unwrap-token(s) as String)
  fail-if docfile! = () :
    DocFileError(closest-info(), "Expected a filename here.")

defn read-structure-file (filename:String) -> StructureFile :
  parse-syntax[stanza-doc-structure-file / #structure-file](read-file(filename))

;============================================================
;==================== Parameter Sets ========================
;============================================================

defn DefaultCommentBasedParams (comment-header:String) :
  defn commented (s:String) :
    string-join $ [comment-header, s]
  DocParams(
    commented("+")
    commented("/")
    commented("!"))

;============================================================
;======================= Errors =============================
;============================================================
defstruct CommentDocErrors <: Exception :
  errors: Tuple<CommentDocError>

defn CommentDocErrors (es:Seqable<CommentDocErrors>) :
  CommentDocErrors $ to-tuple $ seq-cat(errors, es)

defmethod print (o:OutputStream, e:CommentDocErrors) :
  print(o, "%n" % [errors(e)])
  
deftype CommentDocError <: Exception

defstruct DuplicateBlockInFile <: CommentDocError :
  name: String
  info: FileInfo
  old-info: FileInfo

defmethod print (o:OutputStream, e:DuplicateBlockInFile) :
  print(o, "%_: Duplicate definition of block %~ in file. Previous definition \
            at %_." % [info(e), name(e), old-info(e)])

defstruct DuplicateEndInFile <: CommentDocError :
  name: String
  info: FileInfo
  old-info: FileInfo
  
defmethod print (o:OutputStream, e:DuplicateEndInFile) :
  print(o, "%_: Duplicate ending tag for block %~ in file. Previous definition \
            at %_." % [info(e), name(e), old-info(e)])

defstruct DuplicateBlock <: CommentDocError :
  name: String
  info: FileInfo
  old-info: FileInfo

defmethod print (o:OutputStream, e:DuplicateBlock) :
  print(o, "%_: Duplicate definition of block %~ in project. Previous definition \
            at %_." % [info(e), name(e), old-info(e)])

defstruct InvalidNestedBlock <: CommentDocError :
  info: FileInfo
  name: String
  skipped-blocks: Tuple<String>

defmethod print (o:OutputStream, e:InvalidNestedBlock) :
  defn fmt (s:String) : "%~" % [s]
  print(o, "%_: Invalid block nesting. Cannot end block %~ before ending block(s) %*." % [
    info(e), name(e), seq(fmt, skipped-blocks(e))])

defstruct UnresolvedBlock <: CommentDocError :
  name: String
  infos: Tuple<FileInfo>

defmethod print (o:OutputStream, e:UnresolvedBlock) :
  val info0 = infos(e)[0]
  val infon = infos(e)[1 to false]
  print(o, "%_: Cannot resolve reference to block %~." % [info0, name(e)])
  if not empty?(infon) :
    print(o, " Other references to block %~ at:" % [name(e)])
    val o2 = IndentedStream(o)
    do(lnprint{o2, _}, infon)

defstruct UnreferencedBlock <: CommentDocError :
  info: FileInfo
  name: String  

defmethod print (o:OutputStream, e:UnreferencedBlock) :
  print(o, "%_: Block %~ is never referenced in the project." % [info(e), name(e)])

defstruct OutdatedBlock <: CommentDocError :
  info: FileInfo
  name: String|False

defmethod print (o:OutputStream, e:OutdatedBlock) :
  match(name(e)) :
    (name:String) :
      print(o, "%_: Block %~ has been changed and is now out-of-date." % [info(e), name])
    (name:False) :
      print(o, "%_: Unnamed block has been changed and is now out-of-date." % [info(e)])

defstruct OutdatedReference <: CommentDocError :
  info: FileInfo
  name: String  

defmethod print (o:OutputStream, e:OutdatedReference) :
  print(o, "%_: Reference to changed block %~ is now out-of-date." % [info(e), name(e)])

defstruct UnresolvedAccept <: CommentDocError :
  name: String  

defmethod print (o:OutputStream, e:UnresolvedAccept) :
  print(o, "Block %~ is marked to be accepted but is not defined in the project." % [name(e)])

defstruct UndescribedFile <: CommentDocError :
  path: String

defmethod print (o:OutputStream, e:UndescribedFile) :
  print(o, "Project file %~ is not described in project comments." % [path(e)])

defstruct DocFileError <: CommentDocError :
  info: FileInfo|False
  msg: String

defmethod print (o:OutputStream, e:DocFileError) :
  val info-str = "" when info(e) is False
            else "%_: " % [info(e)]
  print(o, "%_%_" % [info-str, msg(e)])

defstruct CouldNotFindRootFile <: CommentDocError :
  info: FileInfo
  name: String  

defmethod print (o:OutputStream, e:CouldNotFindRootFile) :
  print(o, "%_: Root document %~ does not exist." % [info(e), name(e)])

defstruct CouldNotReadRootFile <: CommentDocError :
  info: FileInfo
  name: String  

defmethod print (o:OutputStream, e:CouldNotReadRootFile) :
  print(o, "%_: Root document %~ is not a valid file." % [info(e), name(e)])

defstruct CouldNotFindDocFile <: CommentDocError :
  info: FileInfo
  name: String  

defmethod print (o:OutputStream, e:CouldNotFindDocFile) :
  print(o, "%_: Project file %~ does not exist." % [info(e), name(e)])

defstruct NoEndingBracket <: CommentDocError :
  info: FileInfo
  end-char: Char

defmethod print (o:OutputStream, e:NoEndingBracket) :
  print(o, "%_: No closing character %~ found." % [info(e), end-char(e)])

defstruct InvalidFileStatus <: CommentDocError :
  info: FileInfo
  status: String  

defmethod print (o:OutputStream, e:InvalidFileStatus) :
  print(o, "%_: The string %~ is not a valid file status." % [info(e), status(e)])

defstruct UnresolvedFile <: CommentDocError :
  info: FileInfo
  filename: String

defmethod print (o:OutputStream, e:UnresolvedFile) :
  print(o, "%_: Referenced project file %~ does not exist.")

;============================================================
;========================= Scratch ==========================
;============================================================

;let :
;  ;val filename = "testfile.txt"
;  val filename = "testfile2.txt"
;  val stream = StringInputStream(slurp(filename), filename)
;  val default-params = DefaultCommentBasedParams(";")
;  val full-filename = resolve-path(filename) as String
;  val root-doc = parse-comment-doc(stream, filename, full-filename, default-params)
;  println("===== Root Document =====")
;  println(root-doc)
;  val docs = read-linked-files(root-doc)
;  println("===== Linked Documents =====")
;  println(docs)
;  println("===== All Files =====")
;  val dir-files = list-dir-files(["compiler"])
;  do(println, paths(dir-files))
;  println("===== Errors =====")
;  val errors = check-doc-wellformed(docs, dir-files, ["Node"])
;  println(errors)
;
;  var doc:CommentDoc = parse-comment-doc("testfile2.txt", default-params)
;  println("\n\n\n===== Implicit Ends ====")
;  doc = compute-implicit-ends(doc)
;  do(println, items(doc))
;  ;println("\n\n\n===== Stamp Table =====")
;  ;val stamp-table = compute-stamps(doc)
;  ;do(println, stamp-table)
;  ;println("\n\n\n===== Updated Stamps ====")
;  ;doc = update-stamps(doc, stamp-table)
;  ;do(println, items(doc))
;  ;println("\n\n\n===== Export =====")
;  ;println(export(doc))