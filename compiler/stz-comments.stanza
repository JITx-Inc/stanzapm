defpackage stz/comments :
  import core
  import collections
  import stz/parsed-path

;<doc>=======================================================
;====================== IR Definition =======================
;============================================================

## Possible Tags and Their Examples ##

BlockTag:
  ;+[Ray Partition Box](AFADE9901823)
  ;+[Ray Partition Box](outdated:AFADE9901823)
  ;+[Ray Partition Box]

BlockEnd
  ;/[Ray Partition Box]

Reference
  ;![Ray Partition Box](AFADE9901823)
  ;![Ray Partition Box](outdated:AFADE9901823)
  ;![Ray Partition Box]

FileReference
  ;![file:myfile.txt](outdated)
  ;![file:myfile.txt]

AnonymousBlock
  ;+(AFADE9901823)
  ;+(outdated:AFADE9901823)

Text
Indent
NewLine
Whitespace


## TODO:
- Some files should not be scanned because they are binary files.
- Referencing multiple sections at once.
- The system needs to output the set of files.
  - Possibly after backing them up first.
- We need to check that files are properly formed.
  - Tags are properly nested.
  - No duplicate blocks.
  - No duplicate block ends.
  - All blocks are referenced at least once.
  - All references are to blocks that exist.
  - All files in directory are reachable.

;============================================================
;=======================================================<doc>

public deftype CommentItem

public defstruct CommentDocs :
  root-path: String
  docs: Tuple<CommentDoc>

public defstruct CommentDoc :
  path: String
  full-path: String
  params: DocParams
  items: Tuple<CommentItem> with: (updater => sub-items)
  outdated?: True|False with: (init => false, updater => sub-outdated?)

public defstruct DocParams :
  block-tag-marker: String
  block-end-marker: String
  reference-marker: String

public defstruct BlockTag <: CommentItem :
  info: FileInfo
  name: String
  stamp: String|False
  outdated?: True|False
  indent: Int with: (init => 0, updater => sub-indent)
with:
  printer => true

public defstruct BlockEnd <: CommentItem :
  info: FileInfo
  name: String|Int
  implicit?: True|False with: (default => false)
with:
  printer => true

public defstruct Reference <: CommentItem :
  info: FileInfo
  name: String
  stamp: String|False
  outdated?: True|False
with:
  printer => true

public defstruct FileReference <: CommentItem :
  info: FileInfo
  file: String
  outdated?: True|False
with:
  printer => true

public defstruct AnonymousBlock <: CommentItem :
  info: FileInfo
  id: Int
  stamp: String
  outdated?: True|False
  indent: Int with: (init => 0, updater => sub-indent)
with:
  printer => true

public defstruct Text <: CommentItem :
  string: String
with:
  printer => true

public defstruct Whitespace <: CommentItem :
  info: FileInfo
  string: String
  following-indent: Int|False with: (init => false, updater => sub-following-indent)
with:
  printer => true

public defstruct Indent <: CommentItem :
  info: FileInfo
  indent: Int
with:
  printer => true

public defstruct NewLine <: CommentItem
with:
  printer => true

;============================================================
;======================= Printers ===========================
;============================================================

defmethod print (o:OutputStream, cdocs:CommentDocs) :
  val items = to-tuple $ cat-all $ [
    ["root-path = %~" % [root-path(cdocs)]]
    docs(cdocs)]  
  print(o, "CommentDocs(%_)" % [indented-list(items)])

defmethod print (o:OutputStream, doc:CommentDoc) :
  val items = [
    "path = %~" % [path(doc)]
    "full-path = %~" % [full-path(doc)]
    "outdated? = %~" % [outdated?(doc)]
    "items = [%_]" % [indented-list(items(doc))]]
  print(o, "CommentDoc(%_)" % [indented-list(items)])

defn indented-list (xs:Collection) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      val o2 = IndentedStream(o)
      do(lnprint{o2, _}, xs)

;============================================================
;========================= Parsing ==========================
;============================================================

defn parse-comment-doc (path:String, params:DocParams) -> CommentDoc :
  parse-comment-doc(path, resolve-path!(path), params)

defn parse-comment-doc (path:String, full-path:String, params:DocParams) -> CommentDoc :
  val string = slurp(path)
  val stream = StringInputStream(string, path)
  parse-comment-doc(stream, path, full-path, params)

defn parse-comment-doc (stream:StringInputStream, path:String, full-path:String, params:DocParams) -> CommentDoc :
  ;Compute statistics on markers
  val block-tag-marker-len = length(block-tag-marker(params))
  val block-end-marker-len = length(block-end-marker(params))
  val reference-marker-len = length(reference-marker(params))
  val outdated-str = "outdated:"
  val outdated-len = length(outdated-str)
  val fileref-str = "file:"
  val fileref-len = length(fileref-str)

  ;Eat the given number of characters.
  defn eat-chars (n:Int) -> False :
    for i in 0 to n do : get-char(stream)

  ;Return true if the given character is a newline
  defn newline? (c:Char|False) -> True|False :
    c == '\n'

  ;Return true if the given character is a whitespace character
  defn whitespace? (c:Char|False) -> True|False:
    c == ' ' or c == '\t' or c == '\r'

  ;Return true if 'string' appears at position 'i' in the stream.
  defn upcoming-string? (i:Int, string:String) -> True|False :
    if empty?(string) :
      true
    else if peek?(stream,i) == string[0] :
      for j in 1 to length(string) all? :
        peek?(stream,i + j) == string[j]

  ;Return true if 'char' appears at position 'i' in the stream.
  defn upcoming-char? (i:Int, char:Char) -> True|False :
    peek?(stream,i) == char

  ;Return the index in the stream where 'char' appears, or
  ;false otherwise. Newlines mark the end of the searchable region.
  defn index-of-line-char? (start:Int, char:Char) -> Int|False :
    val n = length(stream)
    let loop (i:Int = start) :
      if i < n :
        val c = peek(stream,i)
        if newline?(c) : false
        else if c == char : i
        else : loop(i + 1)

  ;Return the index past the end of the line.
  defn index-of-line-end (start:Int) -> Int :
    val n = length(stream)
    let loop (i:Int = start) :
      if i < n :
        if newline?(peek?(stream,i)) : i
        else : loop(i + 1)
      else : n

  ;Return true if there is an upcoming block tag:
  ;e.g. ;+[port definition]
  defn upcoming-block-tag? () -> True|False :
    upcoming-string?(0, block-tag-marker(params)) and
    upcoming-char?(block-tag-marker-len, '[')
  ;Return true if there is an upcoming block end:
  ;e.g. ;/[port definition]
  defn upcoming-block-end? () -> True|False :
    upcoming-string?(0, block-end-marker(params)) and
    upcoming-char?(block-end-marker-len, '[')
  ;Return true if there is an upcoming reference:
  ;e.g. ;![port definition]
  defn upcoming-reference? () -> True|False :
    upcoming-string?(0, reference-marker(params)) and
    upcoming-char?(reference-marker-len, '[')
  ;Return true if there is an upcoming anonymous reference:
  ;e.g. ;+(AFAD1241F)
  defn upcoming-anonymous? () -> True|False :
    upcoming-string?(0, block-tag-marker(params)) and
    upcoming-char?(block-tag-marker-len, '(')
  ;Return true if there is a line with no characters
  ;except for whitespace.
  defn upcoming-whitespace? () -> True|False :
    val end = index-of-line-end(0)
    for i in 0 to end all? :
      whitespace?(peek(stream,i))
  ;Return true if the end of the file is upcoming.
  defn upcoming-eof? () -> True|False :
    peek?(stream,0) == false
  ;Return true if a new line is upcoming.
  defn upcoming-newline? () -> True|False :
    newline?(peek?(stream,0))

  ;Parse the [...] tag at the given index.
  defn parse-bracket (start:Int, start-char:Char, end-char:Char) -> String|False :
    if upcoming-char?(start, start-char) :
      val tag-end = index-of-line-char?(start, end-char)
      match(tag-end:Int) :
        ;Compute the number of chars within the bracketing characters.
        val num-chars = tag-end - (start + 1)
        ;Eat past opening [
        eat-chars(start + 1)
        ;Retrieve characters within [...]
        val tag-string = get-chars(stream, num-chars)
        ;Eat closing ]
        eat-chars(1)
        ;Return tag string
        tag-string
      else :
        fatal("Cannot parse bracket tag.")

  ;Parse the tag starting at index i.
  ;Assumes that character tag-start == '['.
  ;Returns [bracket-string, paren-string], where bracket-string
  ;is the string within the [...], and paren-string is the string
  ;within the following (...).
  defn parse-tag (tag-start:Int) -> [String, String|False] :
    val bracket-str = parse-bracket(tag-start, '[', ']') as String
    val paren-str = parse-bracket(0, '(', ')')
    [bracket-str, paren-str]

  ;Parse the upcoming whitespace line.
  defn parse-whitespace () -> Whitespace :
    val info = info(stream)
    val end = index-of-line-end(0)
    val str = get-chars(stream, end)
    Whitespace(info, str)

  ;Split up an outdated tag into a flag and a string.
  defn split-outdated-tag (string:String|False) -> [String|False, True|False] :
    match(string:String) :
      if prefix?(string, outdated-str) :
        val stamp = string[outdated-len to false]
        [stamp, true]
      else : [string, false]
    else : [false, true]

  ;Parse the upcoming block tag.
  defn parse-block-tag () -> BlockTag :
    val info = info(stream)
    val [name, paren-str] = parse-tag(block-tag-marker-len)
    val [stamp, outdated?] = split-outdated-tag(paren-str)
    BlockTag(info, name, stamp, outdated?)

  ;Parse the upcoming block end tag.
  defn parse-block-end () -> BlockEnd :
    val info = info(stream)
    val string = parse-bracket(block-end-marker-len, '[', ']') as String
    BlockEnd(info, string)

  ;Parse the upcoming reference or file reference.
  defn parse-reference () -> Reference|FileReference :
    val info = info(stream)
    val [bracket-str, paren-str] = parse-tag(reference-marker-len)
    if prefix?(bracket-str, fileref-str) :
      val filename = bracket-str[fileref-len to false]
      val outdated? =
        match(paren-str:String) :
          if paren-str != "outdated" :
            fatal("Invalid paren string")
          true
      FileReference(info, filename, outdated?)
    else :
      val [stamp, outdated?] = split-outdated-tag(paren-str)
      Reference(info, bracket-str, stamp, outdated?)

  ;Parse the upcoming anonymous block.
  defn parse-anonymous () -> AnonymousBlock :
    val info = info(stream)
    val string = parse-bracket(block-tag-marker-len, '(', ')') as String
    val [stamp, outdated?] = split-outdated-tag(string)
    AnonymousBlock(info, genid(), stamp as String, outdated?)

  ;Eat the upcoming character in the input stream.
  defn parse-char () -> Char :
    get-char(stream) as Char

  ;Parse the upcoming new line
  defn parse-newline () -> NewLine :
    get-char(stream)
    NewLine()

  ;Parse the upcoming indent
  defn parse-indent () -> Indent :
    val info = info(stream)
    val num-whitespace =
      for i in 0 to false find! :
        not whitespace?(peek?(stream,i))
    Indent(info, num-whitespace)

  ;Accumulate parsed items
  val item-accum = Vector<CommentItem>()
  val char-accum = StringBuffer()

  ;Add a new character to the accumulator.
  defn add-item (c:Char) :
    add(char-accum, c)
  ;Add a new comment item to the accumulator.
  defn add-item (item:CommentItem) :
    flush-chars()
    add(item-accum, item)
  ;Retrieve all parsed items in the accumulator.
  defn parsed-items () -> Tuple<CommentItem> :
    flush-chars()
    to-tuple(item-accum)
  ;Helper: Empty the character accumulator and create a Text item.
  defn flush-chars () :
    if not empty?(char-accum) :
      add(item-accum, Text(to-string(char-accum)))
      clear(char-accum)

  ;Launch!
  defn main () :
    ;Starting line
    if upcoming-whitespace?() :
      add-item(parse-whitespace())
    else :
      add-item(parse-indent())

    ;Preconditions for starting loop
    ;  Any indents/whitespace at the beginning of the file has been parsed.
    let loop () :
      if upcoming-block-tag?() :
        add-item(parse-block-tag())
        loop()
      else if upcoming-block-end?() :
        add-item(parse-block-end())
        loop()
      else if upcoming-reference?() :
        add-item(parse-reference())
        loop()
      else if upcoming-anonymous?() :
        add-item(parse-anonymous())
        loop()
      else if upcoming-newline?() :
        add-item(parse-newline())
        if upcoming-whitespace?() :
          add-item(parse-whitespace())
          loop()
        else :
          add-item(parse-indent())
          loop()
      else if upcoming-eof?() :
        false
      else :
        add-item(parse-char())
        loop()

    ;Return items
    CommentDoc(path, full-path, params, parsed-items())

  ;Launch!
  main()

;============================================================
;==================== Read Linked Files =====================
;============================================================
  
defn read-linked-files (root-doc:CommentDoc) -> CommentDocs :
  ;Table to keep track of all documents.
  val files = HashTable<String,CommentDoc>()
  defn add-file (doc:CommentDoc) :
    files[full-path(doc)] = doc

  ;Track all dependencies
  val link-table = HashTable<String,Tuple<Link>>()  

  ;Read in and scan linked files in the given comment doc, unless
  ;the doc has already been scanned.
  ;The path and full-path to the comment doc is given.
  defn scan-doc (path:String, full-path:String) :
    if not key?(files, full-path) :
      ;[TODO]: What params should we use? Doesn't it depend on extension?
      val doc = parse-comment-doc(path, full-path, params(root-doc))   
      add-file(doc)
      scan-doc(doc)

  ;Scan all linked files in the given comment doc.
  defn scan-doc (doc:CommentDoc) :
    ;Returns the full path to the given filepath, assuming that it is
    ;defined relative to the current doc.
    ;Returns [full-path, resolved-path].
    ;Throws:
    ;  PathResolutionError - if file does not exist.
    ;  UpPastRoot - if joining the file path fails.
    defn relative-to-doc-file (filepath:String) -> [String, String] :
      val ppath = parse-path(filepath)
      val dirpath = enclosing-dir(parse-path(path(doc)))
      val fullpath = to-string(relative-to-dir(dirpath, ppath))
      [fullpath, resolve-path!(fullpath)]

    ;Track all linked files
    val links = Vector<Link>()

    ;Scan each file reference
    for ref in filter-by<FileReference>(items(doc)) do :
      try :
        val [path, full-path] = relative-to-doc-file(file(ref))
        add(links, Link(full-path, outdated?(ref)))
        scan-doc(path, full-path)
      catch (e:PathResolutionError) :
        fatal("Handle missing file.")
      catch (e:UpPastRoot) :
        fatal("Handle this.")

    ;Record links
    link-table[full-path(doc)] = to-tuple(links)

  ;Compute status of files.
  ;  An up-to-date file is a file that is reachable through only
  ;  up-to-date references.
  defn compute-outdated (cdocs:CommentDocs) -> CommentDocs :
    ;Compute set of up-to-date files.
    val up-to-date = HashSet<String>()
    defn mark-up-to-date (path:String) :
      if add(up-to-date, path) :
        for link in link-table[path] do :
          mark-up-to-date(/path(link)) when not outdated?(link)
    mark-up-to-date(full-path(root-doc))
    ;Annotate a doc with its status
    defn annotate (doc:CommentDoc) -> CommentDoc :
      val outdated? = not up-to-date[full-path(doc)]
      sub-outdated?(doc, outdated?)
    ;Annotate all docs
    val docs* = map(annotate, docs(cdocs))
    CommentDocs(root-path(cdocs), docs*)

  ;Launch!
  add-file(root-doc)
  scan-doc(root-doc)
  val cdocs = CommentDocs(full-path(root-doc), to-tuple(values(files)))
  compute-outdated(cdocs)

defstruct Link :
  path: String
  outdated?: True|False

;============================================================
;================== Check Docs Wellformedness ===============
;============================================================

;Check that the given documents are well-formed.
;Returns CommentDocErrors if there are errors or False otherwise.
defn check-doc-wellformed (cdocs:CommentDocs) -> CommentDocErrors|False :
  ;Accumulate all errors
  val errors = Vector<CommentDocError>()

  ;Staged checking utility.
  ;Calling stop-if-errors will exit the block defined by
  ;staged-checking if any errors has been added since
  ;the block started.
  var stop-if-errors: () -> False
  defn staged-checking (body:() -> ?) -> False :
    val num-errors = length(errors)
    label return :
      defn return-if-errors () :
        return() when length(errors) > num-errors
      println("CACHING STOP-IF-ERRORS")
      println(stop-if-errors)
      let-var stop-if-errors = return-if-errors :
        body()    

  ;Scan document for any duplicate blocks or block ends.
  defn scan-for-duplicate-blocks (doc:CommentDoc) :
    val block-table = HashTable<String,BlockTag>()
    val end-table = HashTable<String,BlockEnd>()
    for item in items(doc) do :
      match(item) :
        (block:BlockTag) :
          if key?(block-table, name(block)) :
            val old-block = block-table[name(block)]
            add(errors, DuplicateBlockInFile(name(block), info(block), info(old-block)))
          else :
            block-table[name(block)] = block
        (end:BlockEnd) :
          val name = name(end) as String
          if key?(end-table, name) :
            val old-end = end-table[name]
            add(errors, DuplicateEndInFile(name, info(end), info(old-end)))
          else :
            end-table[name] = end
        (item) :
          false

  ;Scan document to ensure that ending tags are properly nested.
  ;Assumes that 'scan-for-duplicate-blocks' does not detect any errors.
  defn scan-for-invalid-nesting (doc:CommentDoc) :
    ;Stack of opened blocks seen thus far.
    val block-stack = Vector<BlockTag>()
    
    ;Returns the index of the block with the given name.
    defn index-of-block-on-stack! (block-name:String) -> Int :
      for b in block-stack index-when! :
        name(b) == block-name
        
    ;Block end set
    val block-end-set = to-hashset<String> $
      for item in filter-by<BlockEnd>(items(doc)) seq :
        name(item) as String
        
    ;Scan through each item, and process each
    ;BlockTag and BlockEnd.
    for item in items(doc) do :
      match(item) :
        (item:BlockTag) :
          add(block-stack, item) when block-end-set[name(item)]
        (item:BlockEnd) :
          val end-name = name(item) as String
          val index = index-of-block-on-stack!(end-name)
          if index != length(block-stack) - 1 :
            val skipped-block-names = to-tuple $
              seq(name, block-stack[(index + 1) to false])
            add(errors, InvalidNestedBlock(info(item), end-name, skipped-block-names))
          remove(block-stack, index)
        (item) : false

  ;Scan document for within-document errors.
  defn scan (doc:CommentDoc) :
    within staged-checking() :
      scan-for-duplicate-blocks(doc)
      stop-if-errors()
      scan-for-invalid-nesting(doc)

  ;Build table of all defined blocks and references in all up-to-date docs.
  ;If there are any duplicate blocks, these errors are added to the error buffer.
  defn defined-blocks-and-references () :
    val block-table = HashTable<String,BlockTag>()
    val ref-table = HashTable<String,List<Reference>>(List())
    for doc in up-to-date-docs(cdocs) do :
      for item in items(doc) do :
        match(item) :
          (block:BlockTag) :
            if key?(block-table, name(block)) :
              val old-block = block-table[name(block)]
              add(errors, DuplicateBlock(name(block), info(block), info(old-block)))
            else :
              block-table[name(block)] = block
          (ref:Reference) :
            update(ref-table, cons{ref, _}, name(ref))
          (item) :
            false
    [block-table, ref-table]

  ;Check for the following:
  ;  - All references are to a defined block.
  ;  - All blocks are referenced at least once.
  defn check-consistent-references (blocks:HashTable<String,BlockTag>,
                                    references:HashTable<String,List<Reference>>) :
    ;Detect any references to undefined blocks.
    for entry in references do :
      if not key?(blocks, key(entry)) :
        val infos = to-tuple(seq(info, value(entry)))
        add(errors, UnresolvedBlock(key(entry), infos))
    ;Detect any blocks without a reference.
    for block in values(blocks) do :
      if not key?(references, name(block)) :
        add(errors, UnreferencedBlock(info(block), name(block)))

  ;Main algorithm
  defn main () :
    println("STARTING STAGED CHECKING")
    within staged-checking() :
      println("WITHIN BODY OF STAGED CHECKING")
      ;Check individual doc consistency.
      do(scan, docs(cdocs))
      stop-if-errors()
      ;Check project consistency.
      val [blocks, references] = defined-blocks-and-references()
      check-consistent-references(blocks, references)
      ;Return errors if there are errors
      if not empty?(errors) :
        CommentDocErrors(to-tuple(errors))

  ;Launch!
  main()    

;Return sequence of all up-to-date documents.
defn up-to-date-docs (cdocs:CommentDocs) -> Seqable<CommentDoc> :
  for doc in docs(cdocs) filter :
    not outdated?(doc)

;<doc>=======================================================
;================ Find Implicit Block Ends ==================
;============================================================
Example of Computed Ends:

  ;+[A]
  asdf asdf :
    asdf asdf
    ;+[B]
    asdf asdf :
      asdf
      asdf

      asdf
      sadf       <-- End of block [B]

    ;+[C]
    asdfasdf :
      asdf
      asdf

      asdf
      asdf       <-- End of block [C]
                 <-- End of block [A]
  ;+[D]
  asdf asdf :
    asdf asdf
    asdf         <-- End of block [D]

  ;+[E]
  asdf
  asdf           <-- End of block [E]

  ;+[F]
  asdf asdf :
    ;+[G]
    asdf :
      asdf
      asdf       <-- End of block [G]

    ;+[H]
    asdf :
      asdf
      asdf       <-- End of block [H]
  asdf asdf
  asdf asdf
  asdf           <-- End of block [F]

  ;+[I]
  asfd asdf :
    asdf         <-- End of block [I]
;============================================================
;=======================================================<doc>

defn compute-implicit-ends (doc:CommentDoc) -> CommentDoc :
  ;Compute set of all ending tags in document.
  defn compute-block-end-set () -> HashSet<String> :
    val ends = filter-by<BlockEnd>(items(doc))
    val end-names = seq({name(_) as String}, ends)
    to-hashset<String>(end-names)

  ;Returns true if the given block marker requires an implicit end.
  val block-end-set = compute-block-end-set()
  defn requires-implicit-end? (item:BlockTag|AnonymousBlock) -> True|False :
    match(item) :
      ;Named blocks have an implicit end only if they do not have
      ;an explicit end.
      (item:BlockTag) :
        not block-end-set[name(item)]
      ;Anonymous blocks always have an implicit end.
      (item:AnonymousBlock) :
        true

  ;Compute indent information for items
  defn compute-indent-annotations (items:Tuple<CommentItem>) -> Collection<CommentItem> :
    ;Cache in vector for compute.
    val item-list = to-vector<CommentItem>(items)
    val num-items = length(item-list)

    ;First compute indents of blocks
    var prev-indent:Int = 0
    for i in 0 to num-items do :
      match(item-list[i]) :
        (item:BlockTag|AnonymousBlock) : item-list[i] = sub-indent(item, prev-indent)
        (item:Indent) : prev-indent = indent(item)
        (item) : false

    ;Then compute following indents of whitespace
    var next-indent:Int|False = false
    for i in reverse(0 to num-items) do :
      match(item-list[i]) :
        (item:Whitespace) : item-list[i] = sub-following-indent(item, next-indent)
        (item:Indent) : next-indent = indent(item)
        (item) : false

    ;Return items
    item-list

  ;Scan through each item, and generate implicit ends.
  defn generate-implicit-ends (items:Collection<CommentItem>) -> Tuple<CommentItem> :
    ;Track new items containing newly generated implicit ends.
    val item-list = Vector<CommentItem>()

    ;Track stack of opened blocks.
    val block-stack = Vector<BlockTag|AnonymousBlock>()

    ;Find the index of the corresponding opening block on the block-stack.
    defn index-of-block-on-stack (end:BlockEnd) -> Int :
      for block in block-stack index-when! :
        match(block:BlockTag) :
          name(block) == name(end)

    ;Returns the corresponding implicit end for the given block.
    defn implicit-end (block:BlockTag|AnonymousBlock, info:FileInfo) -> BlockEnd :
      val name = match(block) :
        (block:BlockTag) : name(block)
        (block:AnonymousBlock) : id(block)
      BlockEnd(info, name, true)

    ;Assumes block-stack is not empty. Pops the top block
    ;off, and inserts the appropriate implicit ends if required.
    ;The given info is the FileInfo to use for any generated implicit ends.
    defn pop-block (info:FileInfo) :
      val block = pop(block-stack)
      if requires-implicit-end?(block) :
        add(item-list, implicit-end(block, info))

    ;If the top block requires an implicit end, and the given
    ;whitespace line or indent ends it, then pop it off using pop-block.
    ;Returns true if a block has been popped off.
    defn pop-implicit-block? (item:Whitespace|Indent) -> True|False :
      if not empty?(block-stack) :
        val block = peek(block-stack)
        if requires-implicit-end?(block) :
          val block-ends? = match(item) :
            (item:Whitespace) :
              match(following-indent(item)) :
                (i:Int) : i <= indent(block)
                (f:False) : true
            (item:Indent) :
              indent(item) < indent(block)
          if block-ends? :
            pop-block(info(item))
            true

    ;Scan through each item
    for item in items do :
      match(item) :
        (item:BlockTag|AnonymousBlock) :
          add(block-stack, item)
        (item:BlockEnd) :
          val index = index-of-block-on-stack(item)
          ;Pop blocks including matched block.
          while length(block-stack) > index : pop-block(info(item))
        (item:Whitespace|Indent) :
          while pop-implicit-block?(item) : ()
        (item) :
          false
      ;Add original item
      add(item-list, item)

    ;Return new items
    to-tuple(item-list)

  ;Main algorithm
  defn main () :
    val annotated = compute-indent-annotations(items(doc))
    val items* = generate-implicit-ends(annotated)
    sub-items(doc, items*)

  ;Launch!
  main()

;============================================================
;=================== Stamp Computation ======================
;============================================================

defn compute-stamps (doc:CommentDoc) -> HashTable<String|Int,String> :
  ;Utility for computing the stamp string.
  val stamp-buffer = StringBuffer()

  ;Convert an integer code into a string
  defn to-hex (code:Int) -> String :
    defn letter (i:Int) :
      to-char $
        if i < 10 : to-int('0') + i
        else : to-int('A') + i - 10
    defn bits (i:Int) :
      (code >> i) & 0xF
    String $
      for i in reverse(0 to 32 by 4) seq :
        letter(bits(i))

  ;Return true if character represents a whitespace character.
  ;Ignored during stamp computation.
  defn whitespace? (c:Char) -> True|False :
    c == ' ' or c == '\t' or c == '\r'

  ;Add string into stamp buffer for use in computing stamps.
  defn add-stamp-buffer (str:String) :
    for c in str do :
      add(stamp-buffer, c) when not whitespace?(c)

  ;Utility for executing a body and then computing the
  ;total stamp for all calls to add-stamp-buffer.
  defn compute-stamp-string (body:() -> ?) -> String :
    clear(stamp-buffer)
    body()
    val hashcode = hash(to-string(stamp-buffer))
    to-hex(hashcode)

  ;Compute stamp for items from start (exclusive) to end (exclusive).
  defn stamp (start:Int, end:Int) -> String :
    within compute-stamp-string() :
      for i in (start + 1) through (end - 1) do :
        match(items(doc)[i]) :
          (item:Reference) : add-stamp-buffer(name(item))
          (item:FileReference) : add-stamp-buffer(file(item))
          (item:Text) : add-stamp-buffer(string(item))
          (item) : false

  ;Return the identifier of the given block
  defn block-id (b:BlockTag|AnonymousBlock) -> String|Int :
    match(b) :
      (b:BlockTag) : name(b)
      (b:AnonymousBlock) : id(b)

  ;Sanity check: Blocks should be properly nested.
  defn ensure-matched! (b:BlockTag|AnonymousBlock, e:BlockEnd) :
    fatal("Mismatched blocks!") when block-id(b) != name(e)

  ;Compute
  defn main () :
    ;Each entry is [block, index]
    val block-stack = Vector<[BlockTag|AnonymousBlock,Int]>()
    val items* = to-vector<CommentItem>(items(doc))
    val stamp-table = HashTable<String|Int, String>()
    for (item in items(doc), i in 0 to false) do :
      match(item) :
        (item:BlockTag|AnonymousBlock) :
          add(block-stack, [item, i])
        (item:BlockEnd) :
          val [block, index] = pop(block-stack)
          ensure-matched!(block, item)
          stamp-table[block-id(block)] = stamp(index,i)
        (item) : false
    stamp-table

  ;Launch!
  main()

;============================================================
;===================== Stamp Updating =======================
;============================================================

defn update-stamps (doc:CommentDoc, stamp-table:HashTable<String|Int,String>) -> CommentDoc :
  ;Update the comment item by filling in new hash information.
  defn update (item:CommentItem) -> CommentItem :
    match(item) :
      (item:BlockTag) :
        match(stamp(item)) :
          (item-stamp:String) :
            val stamp* = stamp-table[name(item)]
            val outdated?* = outdated?(item) or item-stamp != stamp*
            BlockTag(info(item), name(item), stamp*, outdated?*)
          (f:False) :
            item
      (item:AnonymousBlock) :
        val stamp* = stamp-table[id(item)]
        val outdated?* = outdated?(item) or stamp(item) != stamp*
        AnonymousBlock(info(item), id(item), stamp*, outdated?*)
      (item:Reference) :
        val stamp* = stamp-table[name(item)]
        val outdated?* = outdated?(item) or stamp(item) != stamp*
        Reference(info(item), name(item), stamp*, outdated?*)
      (item) : item

  ;Launch!
  sub-items(doc, map(update, items(doc)))

;============================================================
;======================== Export ============================
;============================================================

defn export (doc:CommentDoc) -> Printable :
  val params = params(doc)
  new Printable :
    defmethod print (o:OutputStream, this) :
      defn print-tag (prefix:String, start:Char, tag, end:Char) :
        print(o, prefix)
        print(o, start)
        print(o, tag)
        print(o, end)
      defn outdated-tag (str:String, outdated?:True|False) :
        if outdated? : "outdated:%_" % [str]
        else : str
      for item in items(doc) do :
        match(item) :
          (item:BlockTag) :
            print-tag(block-tag-marker(params), '[', name(item), ']')
            if stamp(item) is String :
              val tag = outdated-tag(stamp(item) as String, outdated?(item))
              print-tag("", '(', tag, ')')
          (item:BlockEnd) :
            if not implicit?(item) :
              print-tag(block-end-marker(params), '[', name(item), ']')
          (item:Reference) :
            print-tag(reference-marker(params), '[', name(item), ']')
            val tag = outdated-tag(stamp(item) as String, outdated?(item))
            print-tag("", '(', tag, ')')
          (item:FileReference) :
            val tag = "file:%_" % [file(item)]
            print-tag(reference-marker(params), '[', tag, ']')
            if outdated?(item) :
              print(o, "(outdated)")
          (item:AnonymousBlock) :
            val tag = outdated-tag(stamp(item), outdated?(item))
            print-tag(block-tag-marker(params), '(', tag, ')')
          (item:Text) :
            print(o, string(item))
          (item:Whitespace) :
            print(o, string(item))
          (item:Indent) :
            false
          (item:NewLine) :
            print(o, '\n')

;============================================================
;==================== Parameter Sets ========================
;============================================================

defn DefaultCommentBasedParams (comment-header:String) :
  defn commented (s:String) :
    string-join $ [comment-header, s]
  DocParams(
    commented("+")
    commented("/")
    commented("!"))

;============================================================
;======================= Errors =============================
;============================================================
defstruct CommentDocErrors <: Exception :
  errors: Tuple<CommentDocError>

defmethod print (o:OutputStream, e:CommentDocErrors) :
  print(o, "%n" % [errors(e)])
  
deftype CommentDocError <: Exception

defstruct DuplicateBlockInFile <: CommentDocError :
  name: String
  info: FileInfo
  old-info: FileInfo

defmethod print (o:OutputStream, e:DuplicateBlockInFile) :
  print(o, "%_: Duplicate definition of block %~ in file. Previous definition \
            at %_." % [info(e), name(e), old-info(e)])

defstruct DuplicateEndInFile <: CommentDocError :
  name: String
  info: FileInfo
  old-info: FileInfo
  
defmethod print (o:OutputStream, e:DuplicateEndInFile) :
  print(o, "%_: Duplicate ending tag for block %~ in file. Previous definition \
            at %_." % [info(e), name(e), old-info(e)])

defstruct DuplicateBlock <: CommentDocError :
  name: String
  info: FileInfo
  old-info: FileInfo

defmethod print (o:OutputStream, e:DuplicateBlock) :
  print(o, "%_: Duplicate definition of block %~ in project. Previous definition \
            at %_." % [info(e), name(e), old-info(e)])

defstruct InvalidNestedBlock <: CommentDocError :
  info: FileInfo
  name: String
  skipped-blocks: Tuple<String>

defmethod print (o:OutputStream, e:InvalidNestedBlock) :
  defn fmt (s:String) : "%~" % [s]
  print(o, "%_: Invalid block nesting. Cannot end block %~ before ending block(s) %*." % [
    info(e), name(e), seq(fmt, skipped-blocks(e))])

defstruct UnresolvedBlock <: CommentDocError :
  name: String
  infos: Tuple<FileInfo>

defmethod print (o:OutputStream, e:UnresolvedBlock) :
  val info0 = infos(e)[0]
  val infon = infos(e)[1 to false]
  print(o, "%_: Cannot resolve reference to block %~." % [info0, name(e)])
  if not empty?(infon) :
    print(o, " Other references to block %~ at:" % [name(e)])
    val o2 = IndentedStream(o)
    do(lnprint{o2, _}, infon)

defstruct UnreferencedBlock <: CommentDocError :
  info: FileInfo
  name: String  

defmethod print (o:OutputStream, e:UnreferencedBlock) :
  print(o, "%_: Block %~ is never referenced in the project." % [info(e), name(e)])


;============================================================
;========================= Scratch ==========================
;============================================================

let :
  ;val filename = "testfile.txt"
  val filename = "testfile2.txt"
  val stream = StringInputStream(slurp(filename), filename)
  val default-params = DefaultCommentBasedParams(";")
  val full-filename = resolve-path(filename) as String
  val root-doc = parse-comment-doc(stream, filename, full-filename, default-params)
  println("===== Root Document =====")
  println(root-doc)
  val docs = read-linked-files(root-doc)
  println("===== Linked Documents =====")
  println(docs)
  println("===== Errors =====")
  val errors = check-doc-wellformed(docs)
  println(errors)
  ;println("\n\n\n===== Implicit Ends ====")
  ;doc = compute-implicit-ends(doc)
  ;do(println, items(doc))
  ;println("\n\n\n===== Stamp Table =====")
  ;val stamp-table = compute-stamps(doc)
  ;do(println, stamp-table)
  ;println("\n\n\n===== Updated Stamps ====")
  ;doc = update-stamps(doc, stamp-table)
  ;do(println, items(doc))
  ;println("\n\n\n===== Export =====")
  ;println(export(doc))