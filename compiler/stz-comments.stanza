defpackage stz/comments :
  import core
  import collections

;<doc>=======================================================
;====================== IR Definition =======================
;============================================================

Here are the possible tags:

BlockTag:
  ;+[Ray Partition Box](AFADE9901823)
  ;+[Ray Partition Box](outdated:AFADE9901823)
  ;+[Ray Partition Box]

BlockEnd
  ;/[Ray Partition Box]

Reference
  ;![Ray Partition Box](AFADE9901823)
  ;![Ray Partition Box](outdated:AFADE9901823)
  ;![Ray Partition Box]

FileReference
  ;![file:myfile.txt](outdated)
  ;![file:myfile.txt]

AnonymousReference
  ;+(AFADE9901823)
  ;+(outdated:AFADE9901823)

Text
Indent
NewLine

;============================================================
;=======================================================<doc>

public deftype CommentItem

public defstruct CommentDoc :
  path: String
  params: DocParams
  items: Tuple<CommentItem>

public defstruct DocParams :
  block-tag-marker: String
  block-end-marker: String
  reference-marker: String
  anonymous-marker: String

public defstruct BlockTag <: CommentItem :
  info: FileInfo
  name: String  
  stamp: String|False
  outdated?: True|False
with:
  printer => true
  
public defstruct BlockEnd <: CommentItem :
  info: FileInfo
  name: String
with:
  printer => true
  
public defstruct Reference <: CommentItem :
  info: FileInfo
  name: String
  stamp: String|False
  outdated?: True|False
with:
  printer => true
  
public defstruct FileReference <: CommentItem :
  info: FileInfo
  file: String
  outdated: True|False
with:
  printer => true
  
public defstruct AnonymousReference <: CommentItem :
  info: FileInfo
  stamp: String|False
  outdated?: True|False
with:
  printer => true
  
public defstruct Text <: CommentItem :
  string: String
with:
  printer => true
  
public defstruct Whitespace <: CommentItem :
  string: String
with:
  printer => true
  
public defstruct Indent <: CommentItem :
  indent: Int
with:
  printer => true
  
public defstruct NewLine <: CommentItem
with:
  printer => true

;============================================================
;========================= Parsing ==========================
;============================================================

defn parse-comment-doc (stream:StringInputStream, path:String, params:DocParams) -> CommentDoc :
  ;Compute statistics on markers
  val block-tag-marker-len = length(block-tag-marker(params))
  val block-end-marker-len = length(block-end-marker(params))
  val reference-marker-len = length(reference-marker(params))
  val anonymous-marker-len = length(anonymous-marker(params))
  val outdated-str = "outdated:"
  val outdated-len = length(outdated-str)
  val fileref-str = "file:"
  val fileref-len = length(fileref-str)

  ;Eat the given number of characters.
  defn eat-chars (n:Int) -> False :
    for i in 0 to n do : get-char(stream)

  ;Return true if the given character is a newline
  defn newline? (c:Char|False) -> True|False :
    c == '\n'

  ;Return true if the given character is a whitespace character
  defn whitespace? (c:Char|False) -> True|False:
    c == ' ' or c == '\t' or c == '\r'
  
  ;Return true if 'string' appears at position 'i' in the stream.
  defn upcoming-string? (i:Int, string:String) -> True|False :
    if empty?(string) :
      true
    else if peek?(stream,i) == string[0] :
      for j in 1 to length(string) all? :
        peek?(stream,i + j) == string[j]

  ;Return true if 'char' appears at position 'i' in the stream.
  defn upcoming-char? (i:Int, char:Char) -> True|False :
    peek?(stream,i) == char

  ;Return the index in the stream where 'char' appears, or
  ;false otherwise. Newlines mark the end of the searchable region.
  defn index-of-line-char? (start:Int, char:Char) -> Int|False :
    val n = length(stream)
    let loop (i:Int = start) :
      if i < n :
        val c = peek(stream,i)
        if newline?(c) : false
        else if c == char : i
        else : loop(i + 1)

  ;Return the index past the end of the line. 
  defn index-of-line-end (start:Int) -> Int :
    val n = length(stream)
    let loop (i:Int = start) :
      if i < n :
        if newline?(peek?(stream,i)) : i
        else : loop(i + 1)
      else : n

  ;Return true if there is an upcoming block tag:
  ;e.g. ;+[port definition]
  defn upcoming-block-tag? () -> True|False :
    upcoming-string?(0, block-tag-marker(params)) and
    upcoming-char?(block-tag-marker-len, '[')
  ;Return true if there is an upcoming block end:
  ;e.g. ;/[port definition]
  defn upcoming-block-end? () -> True|False :
    upcoming-string?(0, block-end-marker(params)) and
    upcoming-char?(block-end-marker-len, '[')
  ;Return true if there is an upcoming reference:
  ;e.g. ;![port definition]
  defn upcoming-reference? () -> True|False :
    upcoming-string?(0, reference-marker(params)) and
    upcoming-char?(reference-marker-len, '[')
  ;Return true if there is an upcoming anonymous reference:
  ;e.g. ;+(AFAD1241F)
  defn upcoming-anonymous? () -> True|False :
    upcoming-string?(0, anonymous-marker(params)) and
    upcoming-char?(anonymous-marker-len, '(')
  ;Return true if there is a line with no characters
  ;except for whitespace.
  defn upcoming-whitespace? () -> True|False :
    val end = index-of-line-end(0)
    for i in 0 to end all? :
      whitespace?(peek(stream,i))
  ;Return true if the end of the file is upcoming.
  defn upcoming-eof? () -> True|False :
    peek?(stream,0) == false
  ;Return true if a new line is upcoming.
  defn upcoming-newline? () -> True|False :
    newline?(peek?(stream,0))

  ;Parse the [...] tag at the given index.
  defn parse-bracket (start:Int, start-char:Char, end-char:Char) -> String|False :
    if upcoming-char?(start, start-char) :
      val tag-end = index-of-line-char?(start, end-char)
      match(tag-end:Int) :
        ;Compute the number of chars within the bracketing characters.
        val num-chars = tag-end - (start + 1)
        ;Eat past opening [
        eat-chars(start + 1)
        ;Retrieve characters within [...]
        val tag-string = get-chars(stream, num-chars)
        ;Eat closing ]
        eat-chars(1)
        ;Return tag string
        tag-string
      else :
        fatal("Cannot parse bracket tag.")

  ;Parse the tag starting at index i.
  ;Assumes that character tag-start == '['.
  ;Returns [bracket-string, paren-string], where bracket-string
  ;is the string within the [...], and paren-string is the string
  ;within the following (...). 
  defn parse-tag (tag-start:Int) -> [String, String|False] :
    val bracket-str = parse-bracket(tag-start, '[', ']') as String
    val paren-str = parse-bracket(0, '(', ')')
    [bracket-str, paren-str]

  ;Parse the upcoming whitespace line.
  defn parse-whitespace () -> Whitespace :
    val end = index-of-line-end(0)
    val str = get-chars(stream, end)
    Whitespace(str)

  ;Split up an outdated tag into a flag and a string.
  defn split-outdated-tag (string:String|False) -> [String|False, True|False] :
    match(string:String) :
      if prefix?(string, outdated-str) :
        val stamp = string[outdated-len to false]
        [stamp, true]
      else : [string, false]      
    else : [false, true]

  ;Parse the upcoming block tag.
  defn parse-block-tag () -> BlockTag :
    val info = info(stream)
    val [name, paren-str] = parse-tag(block-tag-marker-len)
    val [stamp, outdated?] = split-outdated-tag(paren-str)
    BlockTag(info, name, stamp, outdated?)      

  ;Parse the upcoming block end tag.
  defn parse-block-end () -> BlockEnd :
    val info = info(stream)
    val string = parse-bracket(block-end-marker-len, '[', ']') as String
    BlockEnd(info, string)

  ;Parse the upcoming reference or file reference.
  defn parse-reference () -> Reference|FileReference :
    val info = info(stream)
    val [bracket-str, paren-str] = parse-tag(reference-marker-len)
    if prefix?(bracket-str, fileref-str) :
      val filename = bracket-str[fileref-len to false]
      val outdated? = 
        match(paren-str:String) :
          if paren-str != "outdated" :
            fatal("Invalid paren string")
          true
      FileReference(info, filename, outdated?)
    else :
      val [stamp, outdated?] = split-outdated-tag(paren-str)
      Reference(info, bracket-str, stamp, outdated?)

  ;Parse the upcoming anonymous block.
  defn parse-anonymous () -> AnonymousReference :
    val info = info(stream)
    val string = parse-bracket(anonymous-marker-len, '(', ')') as String
    val [stamp, outdated?] = split-outdated-tag(string)
    AnonymousReference(info, stamp, outdated?)

  ;Eat the upcoming character in the input stream.
  defn parse-char () -> Char :
    get-char(stream) as Char

  ;Parse the upcoming new line
  defn parse-newline () -> NewLine :
    get-char(stream)
    NewLine()

  ;Parse the upcoming indent
  defn parse-indent () -> Indent :
    val num-whitespace =
      for i in 0 to false find! :
        not whitespace?(peek?(stream,i))
    Indent(num-whitespace)

  ;Accumulate parsed items
  val item-accum = Vector<CommentItem>()
  val char-accum = StringBuffer()

  ;Add a new character to the accumulator.
  defn add-item (c:Char) :
    add(char-accum, c)
  ;Add a new comment item to the accumulator.
  defn add-item (item:CommentItem) :
    flush-chars()
    add(item-accum, item)
  ;Retrieve all parsed items in the accumulator.
  defn parsed-items () -> Tuple<CommentItem> :
    flush-chars()
    to-tuple(item-accum)
  ;Helper: Empty the character accumulator and create a Text item.
  defn flush-chars () :
    if not empty?(char-accum) :
      add(item-accum, Text(to-string(char-accum)))
      clear(char-accum)

  ;Launch!
  defn main () :
    ;Starting line
    if upcoming-whitespace?() :
      add-item(parse-whitespace())
    else :
      add-item(parse-indent())

    ;Preconditions for starting loop
    ;  Any indents/whitespace at the beginning of the file has been parsed.
    let loop () :
      if upcoming-block-tag?() :
        add-item(parse-block-tag())
        loop()
      else if upcoming-block-end?() :
        add-item(parse-block-end())
        loop()
      else if upcoming-reference?() :
        add-item(parse-reference())
        loop()
      else if upcoming-anonymous?() :
        add-item(parse-anonymous())
        loop()
      else if upcoming-newline?() :
        add-item(parse-newline())
        if upcoming-whitespace?() :
          add-item(parse-whitespace())
          loop()
        else :
          add-item(parse-indent())
          loop()
      else if upcoming-eof?() :
        false
      else :
        add-item(parse-char())
        loop()

    ;Return items
    CommentDoc(path, params, parsed-items())

  ;Launch!
  main()

;============================================================
;==================== Parameter Sets ========================
;============================================================

defn DefaultCommentBasedParams (comment-header:String) :
  defn commented (s:String) :
    string-join $ [comment-header, s]
  DocParams(
    commented("+")
    commented("/")
    commented("!")
    commented("+"))
    
;============================================================
;========================= Scratch ==========================
;============================================================

let :
  val filename = "testfile2.txt"
  val stream = StringInputStream(slurp(filename), filename)
  val default-params = DefaultCommentBasedParams(";")
  val doc = parse-comment-doc(stream, filename, default-params)
  do(println, items(doc))