defpackage stz/el-driver :
  import core
  import collections
  import stz/el-ir  
  import stz/el-to-vm
  import stz/vm-ir
  import stz/dl-ir
  import stz/loaded-ids
  import stz/dl
  import stz/vm

defstruct EUnit :
  packageio: PackageIO
  epackage: EPackage

defsyntax el-driver :
  import epackage from el-ir
  import packageio from dl-ir
  
  defproduction eunit : EUnit
  defrule eunit = (?io:#packageio, ?ep:#epackage) : EUnit(io, ep)
  
  public defproduction stage : Tuple<EUnit>
  defrule stage = (load : (?units:#eunit ...)) : to-tuple(units)
  
defn main () :
  val filename = command-line-arguments()[1]
  val forms = reader/read-file(filename)
  val stages = parse-syntax[el-driver / #stage ...](forms)

  val denv = DEnv()
  val ids = LoadedIds()
  val vm = VirtualMachine()

  for stage in stages do :
    match(load(denv, map(packageio, stage))) :
      (lr:LoadSuccess) :
        println("Packages %, can be loaded." % [seq(name{epackage(_)}, stage)])

        ;Make VM identifiers for all definitions
        for unit in stage do :
          for e in exports(packageio(unit)) do :
            make-id(ids, rec(e))
        
        ;Compile and load into virtual machine
        for unit in stage do :
          val pkg-ids = package-ids(ids, packageio(unit), epackage(unit))
          val prog = compile(epackage(unit), packageio(unit), pkg-ids)
          println("===== Compiler Input =====")
          within indented() :
            println(epackage(unit))
          println("===== Compiler Output =====")
          within indented() :
            println(prog)
          load(vm, prog)

        ;Run initializers
        for unit in stage do :
          val init = init(ids, name(epackage(unit)))
          run(vm, id(init))
      (lr:LoadErrors) :
        println("Packages %, cannot be loaded." % [seq(name{epackage(_)}, stage)])
        do(println, errors(lr))  

main()