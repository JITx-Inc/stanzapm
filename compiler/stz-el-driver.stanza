defpackage stz/el-driver :
  import core
  import collections
  import stz/el-ir
  import stz/dl-ir
  import stz/vm-ir
  import stz/el
  import stz/el-to-vm
  import stz/dl
  import stz/vm

defstruct Unit :
  packageio: PackageIO
  epackage: EPackage

defstruct LoadStage :
  init?: True|False
  units: Tuple<Unit>
  
defsyntax el-driver :
  import packageio from dl-ir
  import epackage from el-ir

  defproduction unit : Unit
  defrule unit = (?io:#packageio ?ep:#epackage) : Unit(io,ep)

  defproduction loadstage : LoadStage
  defrule loadstage = (load : (?us:#unit ...)) : LoadStage(true, to-tuple(us))
  defrule loadstage = (update : (?us:#unit ...)) : LoadStage(false, to-tuple(us))

  public defproduction prog : Tuple<LoadStage>
  defrule prog = (?ss:#loadstage ...) : to-tuple(ss) 

defn read-stages () :
  val filename = command-line-arguments()[1]
  val forms = reader/read-file(filename)
  parse-syntax[el-driver / #prog](forms)

defn main () :
  if contains?(command-line-arguments(), "-vmir") :
    val filename = command-line-arguments()[1]
    val forms = reader/read-file(filename)    
    val vmps = to-tuple(parse-syntax[vmcode / #vmpackage ...](forms))
    val vm = VirtualMachine()
    load(vm, vmps)
    do(init-package{vm, package(_)}, vmps)
    val liveset = compute-live(vm)
    println("Live set: %," % [liveset])
    
  else :
    ;Read in stages
    val stages = read-stages()

    ;Create virtual machine
    val vm = VirtualMachine()
    val denv = DEnv()

    for stage in stages do :
      load-into-denv() where :
        defn* load-into-denv () :
          val ios = map(packageio, units(stage))
          val live = compute-live(vm)
          match(load(denv, ios, live)) :
            (result:LoadSuccess) :
              compile-packages()
            (result:LoadErrors) :
              do(println, errors(result))
              
        defn* compile-packages () :
          ;Compile VM packages
          val vmps = for u in units(stage) map :
            val lowered = lower(packageio(u), epackage(u))
            compile(lowered, packageio(u))

          ;Debugging
          val filename* = string-join([command-line-arguments()[1], ".vm"])
          spit(filename*, "%n" % [vmps])
          
          load-into-vm(vmps)
          
        defn* load-into-vm (vmps:Tuple<VMPackage>) :
          load(vm, vmps)
          if init?(stage) :
            for vmp in vmps do :
              init-package(vm, package(vmp))
              
main()

