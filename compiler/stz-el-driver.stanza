defpackage stz/el-driver :
  import core
  import collections
  import stz/el-ir
  import stz/dl-ir
  import stz/vm-ir
  import stz/el
  import stz/el-to-vm
  ;import stz/dl
  import stz/vm
  ;import stz/loaded-ids

defstruct Unit :
  packageio: PackageIO
  epackage: EPackage

defstruct LoadStage :
  units: Tuple<Unit>
  
defsyntax el-driver :
  import packageio from dl-ir
  import epackage from el-ir

  defproduction unit : Unit
  defrule unit = (?io:#packageio ?ep:#epackage) : Unit(io,ep)

  defproduction loadstage : LoadStage
  defrule loadstage = (load : (?us:#unit ...)) : LoadStage(to-tuple(us))

  public defproduction prog : Tuple<LoadStage>
  defrule prog = (?ss:#loadstage ...) : to-tuple(ss) 

defn read-stages () :
  val filename = command-line-arguments()[1]
  val forms = reader/read-file(filename)
  parse-syntax[el-driver / #prog](forms)

defn main () :
  ;Read in stages
  val stages = read-stages()

  ;Create virtual machine
  val vm = VirtualMachine()  

  for stage in stages do :
    ;Compile vmpackages
    val vmps = for u in units(stage) map :
      val lowered = lower(packageio(u), epackage(u))
      compile(lowered, packageio(u))

    ;Print out
    println("Compiled:")
    within indented() :
      do(println, vmps)
      
    ;Load into virtual machine
    load(vm, vmps)

    ;Run all the initializers
    for vmp in vmps do :
      init-package(vm, package(vmp))

    ;Print out the live set
    val liveset = compute-live(vm)
    println("Live closures: %," % [closures(liveset)])
    println("Live objects: %," % [objects(liveset)])    
    


  ;val ep* = lower(io, ep)
  ;val vmp = compile(ep*, io)
  ;println("===== Compiled to VM =====")
  ;within indented() :
  ;  println(vmp)
  ;
  ;val vm = VirtualMachine()
  ;load(vm, [vmp])
  ;init-package(vm, package(vmp))

main()

;defstruct EUnit :
;  packageio: PackageIO
;  epackage: EPackage
;
;defsyntax el-driver :
;  import epackage from el-ir
;  import packageio from dl-ir
;  
;  defproduction eunit : EUnit
;  defrule eunit = (?io:#packageio, ?ep:#epackage) : EUnit(io, ep)
;  
;  public defproduction stage : Tuple<EUnit>
;  defrule stage = (load : (?units:#eunit ...)) : to-tuple(units)
;  
;defn main () :
;  val filename = command-line-arguments()[1]
;  val forms = reader/read-file(filename)
;  val stages = parse-syntax[el-driver / #stage ...](forms)
;
;  val denv = DEnv()
;  val ids = LoadedIds()
;  val vm = VirtualMachine()
;
;  for stage in stages do :
;    match(load(denv, map(packageio, stage))) :
;      (lr:LoadSuccess) :
;        println("Packages %, can be loaded." % [seq(name{epackage(_)}, stage)])
;
;        ;Make VM identifiers for all definitions
;        for unit in stage do :
;          for e in exports(packageio(unit)) do :
;            make-id(ids, rec(e))
;        
;        ;Compile and load into virtual machine
;        for unit in stage do :
;          val pkg-ids = package-ids(ids, packageio(unit), epackage(unit))
;          val prog = compile(epackage(unit), packageio(unit), pkg-ids)
;          println("===== Compiler Input =====")
;          within indented() :
;            println(epackage(unit))
;          println("===== Compiler Output =====")
;          within indented() :
;            println(prog)
;          load(vm, prog)
;
;        ;Run initializers
;        for unit in stage do :
;          val init = init(ids, name(epackage(unit)))
;          run(vm, id(init))
;      (lr:LoadErrors) :
;        println("Packages %, cannot be loaded." % [seq(name{epackage(_)}, stage)])
;        do(println, errors(lr))  
;
;main()