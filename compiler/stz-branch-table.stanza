defpackage stz/branch-table :
  import core
  import collections
  import stz/vm-ir
  import stz/dyn-tree
  import stz/dyn-bi-table
  import stz/utils
  import stz/vm-table
  import stz/trie

;============================================================
;=================== Public Interface =======================
;============================================================

public deftype BranchTable
public defmulti add (t:BranchTable, f:BranchFormat) -> Int
public defmulti get (t:BranchTable, f:Int) -> BranchFormat
public defmulti load-package-methods (t:BranchTable, package:Symbol, ms:Seqable<VMMethod>) -> False
public defmulti dispatch (t:BranchTable, f:Int, types:Tuple<Int>) -> DispatchResult
public defmulti update (t:BranchTable) -> False

public deftype DispatchResult :
  Int <: DispatchResult
  CodeId <: DispatchResult
public defstruct Default <: DispatchResult
public defstruct Amb <: DispatchResult

;============================================================
;==================== Dispatch Formats ======================
;============================================================

public deftype BranchFormat <: Hashable&Equalable

public defstruct MatchFormat <: BranchFormat :
  branches: Tuple<Tuple<TypeSet>>
with: (printer => true)

public defstruct DispatchFormat <: BranchFormat :
  branches: Tuple<Tuple<TypeSet>>
with: (printer => true)

public defstruct MultiFormat <: BranchFormat :
  multi: Int
  num-header-args: Int
  num-args: Int
with: (printer => true)

;============================================================
;================= Dispatch Format Creators  ================
;============================================================

public defn MatchFormat (branches:Tuple<VMBranch>) -> [MatchFormat, Tuple<Int>] :
  val types* = for b in branches map :
    map(normalize, types(b))
  val format = MatchFormat(types*)
  val targets = map(n,branches)
  [format, targets]

public defn DispatchFormat (branches:Tuple<VMBranch>) -> [DispatchFormat, Tuple<Int>] :
  val bs = to-array<VMBranch> $
    for b in branches seq :
      val types* = map(normalize, types(b))
      VMBranch(types*, n(b))
  qsort!(types, bs)
  val format = DispatchFormat(to-tuple(seq(types,bs)))
  val targets = to-tuple(seq(n,bs))
  [format, targets]

;============================================================
;==================== Hashing and Equality ==================
;============================================================

defmethod hash (f:DispatchFormat) : hash(branches(f))
defmethod equal? (a:DispatchFormat, b:DispatchFormat) : branches(a) == branches(b)

defmethod hash (f:MatchFormat) : hash(branches(f))
defmethod equal? (a:MatchFormat, b:MatchFormat) : branches(a) == branches(b)

defmethod hash (f:MultiFormat) :
  hash $ [multi(f), num-header-args(f), num-args(f)]
defmethod equal? (a:MultiFormat, b:MultiFormat) :
  multi(a) == multi(b) and
  num-header-args(a) == num-header-args(b) and
  num-args(a) == num-args(b)

;============================================================
;================= Table Implementation =====================
;============================================================

public defn BranchTable (ct:ClassTable) :
  ;Store formats in ctable
  val formats = Vector<BranchFormat>()
  val format-table = HashTable<BranchFormat,Int>()
  val methods = Vector<LoadedMethod|False>()

  ;All compiled actions corresponding to each format
  val actions = Vector<DispatchAction|False>()
  val stale-actions = Vector<Int>()

  ;Format dependencies
  val format-class-dependencies = Vector<Tuple<Int>>()  
  val method-class-dependencies = Vector<Tuple<Int>>()
  val multi-formats = IntListTable<Int>()

  ;Record an action as invalidated, so that it is updated next cycle
  defn invalidate-action (i:Int) :
    if i == length(actions) or actions[i] is-not False :
      actions[i] = false
      add(stale-actions, i)
  defn invalidate-actions-of-multi (multi:Int) :
    do(invalidate-action, multi-formats[multi])

  ;Adding a new format
  defn add-format (bf:BranchFormat) -> Int :
    add(formats, bf)
    add(format-class-dependencies, to-tuple(class-dependencies(bf)))
    val i = length(formats) - 1
    println("Format %_ depends on classes %_" % [i, peek(format-class-dependencies)])
    format-table[bf] = i
    match(bf:MultiFormat) :
      add(multi-formats, multi(bf), i)
    invalidate-action(i)
    i

  ;Adding and removing methods
  defn add-method (package-name:Symbol, m:VMMethod) :
    val m* = LoadedMethod(multi(m), types(m), fid(m), package-name, instance?(m))
    add(methods, m*)
    val id = length(methods) - 1
    method-class-dependencies[id] = to-tuple(class-dependencies(m))
    invalidate-actions-of-multi(multi(m))
  defn remove-method (i:Int) :
    val m = methods[i] as LoadedMethod
    invalidate-actions-of-multi(multi(m))
    method-class-dependencies[i] = []
    methods[i] = false

  ;Formats depending upon a multi
  defn class-formats (c:Int) :
    for i in 0 to length(formats) filter :
      val cs = format-class-dependencies[i]
      contains?(cs, c)
  defn class-multis (c:Int) :
    for i in 0 to length(methods) seq? :
      val cs = method-class-dependencies[i]
      if contains?(cs,c) : One(multi(methods[i] as LoadedMethod))
      else : None()

  add(ct, listener) where :
    val listener = new TreeListener :
      defmethod children-changed (this, c:Int) :
        println("Children of %_ changed." % [c])
        do(invalidate-action, class-formats(c))
        do(invalidate-actions-of-multi, class-multis(c))
      defmethod parents-changed (this, c:Int) :
        println("Parents of %_ changed." % [c])
      defmethod node-added (this, c:Int) :
        println("Class %_ added." % [c])

  ;Load new methods
  defn load-package-methods (package-name:Symbol, ms:Seqable<VMMethod>) :
    ;Return true if method i is a top-level method from package p
    defn top-level-method? (i:Int, p:Symbol) :
      val m = methods[i]
      match(m:LoadedMethod) :
        not instance-method?(m) and package(m) == p
    ;Remove old methods
    for i in 0 to length(methods) do :
      remove-method(i) when top-level-method?(i, package-name)
    ;Add new methods
    do(add-method{package-name, _}, ms)

  defn lookup-methods (multi:Int) :
    to-tuple $ for m in methods seq? :
      match(m:LoadedMethod) :
        One(m) when /multi(m) == multi else None()
      else : None()

  defn update-actions () :
    for (f in formats, i in 0 to false) do :
      if actions[i] is False :
        println("Computing action for format %_" % [f])
        actions[i] = DispatchAction(ct, f, lookup-methods)

  new BranchTable :
    defmethod get (this, f:Int) :
      formats[f]
    defmethod add (this, f:BranchFormat) :
      match(get?(format-table, f)) :
        (i:Int) : i
        (_:False) : add-format(f)
    defmethod dispatch (this, f:Int, types:Tuple<Int>) :
      dispatch(actions[f] as DispatchAction, types)
    defmethod update (this) :
      update-actions()
    defmethod load-package-methods (this, package:Symbol, ms:Seqable<VMMethod>) :
      load-package-methods(package, ms)

;============================================================
;==================== Dispatch Actions ======================
;============================================================

val DEFAULT-ACTION = fn (xtypes:Tuple<Int>, t:Int) : Default()

defn compile-trie (t:MTrie) -> (Tuple<Int>, Int) -> DispatchResult :
  match(t) :
    (t:IfTrie) :
      var default = DEFAULT-ACTION
      val action-table = IntTable<((Tuple<Int>, Int) -> DispatchResult)>()
      for entry in branches(t) do :
        val t = compile-trie(value(entry))
        match(key(entry)) :
          (s:IAll) :
            default = t
          (s:ISubset) :
            for x in xs(s) do :
              action-table[x] = t
      ;Add cache
      var last-x:Int|False = false
      var last-a:((Tuple<Int>, Int) -> DispatchResult)|False = false
      fn (xtypes:Tuple<Int>, i:Int) :
        val x = xtypes[i]
        val a =
          if x == last-x :
            last-a as (Tuple<Int>, Int) -> DispatchResult
          else :
            val a = get?(action-table, xtypes[i], default)
            last-x = x
            last-a = a
            a
        a(xtypes, i + 1)
    (t:EndTrie) :
      ;Return target
      fn (xtypes:Tuple<Int>, i:Int) :
        target(t)
        
defn compile-action (bs:Seq<IDispatchBranch>) :
  val f = DEFAULT-ACTION when empty?(bs)
     else compile-trie(to-trie(bs))
  new DispatchAction :
    defmethod dispatch (this, xtypes:Tuple<Int>) :
      f(xtypes, 0)

defn DispatchAction (ct:ClassTable, f:BranchFormat,
                     methods:Int -> Tuple<LoadedMethod>) :
  defn isets-list (ts:Seqable<TypeSet>) :
    to-list(seq(to-iset{ct, _}, ts))
  defn isets-tuple (ts:Seqable<TypeSet>) :
    to-tuple(seq(to-iset{ct, _}, ts))
    
  compile-action $ match(f) :
    (f:MatchFormat) :
      seq(IBranch{isets-list(_), _}, branches(f), 0 to false)
    (f:DispatchFormat) :
      val indexed-branches = to-tuple $ seq(KeyValue, branches(f), 0 to false)
      val dispatch-branches = dispatch-ordering(ct, indexed-branches, key)
      for b in dispatch-branches seq :
        match(b) :
          (b:KeyValue<Tuple<TypeSet>,Int>) :
            IBranch(isets-list(key(b)), value(b))
          (bs:Tuple<KeyValue<Tuple<TypeSet>,Int>>) :
            val sets = map(isets-tuple{key(_)}, bs)
            IAmb(sets, Amb())
    (f:MultiFormat) :
      val dispatch-methods = dispatch-ordering(ct, methods(multi(f)), types)
      for m in dispatch-methods seq :
        match(m) :
          (m:LoadedMethod) :
            IBranch(isets-list(types(m)), CodeId(fid(m)))
          (ms:Tuple<LoadedMethod>) :
            val sets = map(isets-tuple{types(_)}, ms)
            IAmb(sets, Amb())

;============================================================
;==================== Utilities =============================
;============================================================

deftype DispatchAction
defmulti dispatch (a:DispatchAction, types:Tuple<Int>) -> DispatchResult

defstruct LoadedMethod :
  multi: Int
  types: Tuple<TypeSet>
  fid: Int
  package: Symbol
  instance-method?: True|False
with:
  printer => true

;Compute the class dependencies of all branch formats and methods
defn class-dependencies (ts:Seqable<TypeSet>) -> Tuple<Int> :
  val ds = Vector<Int>()
  let loop (ts:Seqable<TypeSet> = ts) :
    for t in ts do :
      match(t) :
        (t:AndType) : loop(types(t))
        (t:OrType) : loop(types(t))
        (t:TopType) : false
        (t:SingleType) : add(ds, type(t))
  qsort!(ds)
  remove-duplicates!(ds)
  to-tuple(ds)
  
defn class-dependencies (f:BranchFormat) :
  match(f) :
    (f:DispatchFormat|MatchFormat) : class-dependencies $ cat-all(branches(f))
    (f:MultiFormat) : []
    
defn class-dependencies (f:VMMethod) :
  class-dependencies(types(f))

;Compute all the multi dependencies of a format  
defn multi-dependencies (f:BranchFormat) :
  match(f) :
    (f:MultiFormat) : [multi(f)]
    (f:DispatchFormat|MatchFormat) : []

;Convert a typeset to an iset
defn to-iset (ct:ClassTable, t:TypeSet) :
  defn union (a:ISet, b:ISet) :
    a-or-b(compare(a,b))
  defn intersection (a:ISet, b:ISet) :
    a-and-b(compare(a,b))
  let loop (t:TypeSet = t) :
    match(t) :
      (t:AndType) : reduce(intersection, seq(loop, types(t)))
      (t:OrType) : reduce(union, seq(loop, types(t)))
      (t:TopType) : IAll()
      (t:SingleType) : ISubset(children(ct, type(t)))