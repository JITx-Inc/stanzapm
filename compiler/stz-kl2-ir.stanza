defpackage stz/kl2-ir :
  import core
  import collections
  import stz/ids
  import stz/primitives
  import stz/pl-ir
  import stz/tgt-ir

#use-added-syntax(stz-ast-lang, stz-printer-lang)

;============================================================
;=================== Structures =============================
;============================================================

public defast :
  deftype KType <: Hashable & Equalable
  defnodes KType :
    ;LoStanza Types
    KByteT
    KIntT
    KLongT
    KFloatT
    KDoubleT
    KUnknownT
    KPtrT: (type:KType)
    KFnT: (a:List<KType>, r:False|KType, b:KType)
    KStructT: (n:Int)
    
    ;HiStanza Types
    KOf: (n:Int)
    KTVar: (n:Int)
    KAnd: (a:KType, b:KType)
    KOr: (a:KType, b:KType)
    KTop
    KBot
    
  ;Top Level Expressions
  deftype KTExp
  defnodes KTExp :
    ;Input Expressions
    KDef*: (n:Int, type:KType, value:KExp, info:False|FileInfo)
    KDefVar*: (n:Int, type:KType, value:False|KExp, info:False|FileInfo)
    KDefmethod*: (multi:Int, targs:List<KType>, value:KExp)
    
    ;Standard Expressions
    KDef: (n:Int, type:KType, value:KExp)
    KDefVar: (n:Int, type:KType, value:False|KExp)
    KDefn: (n:Int, value:KExp)
    KDefmulti: (n:Int, tail?:True|False, targs:List<Int>,
                a1:List<KType>, a2:KType, info:False|FileInfo)  
    KDefmethod: (n:Int, multi:Int, value:KExp)
    KDefType: (n:Int, name:String, parent:False|KType, children:List<KChild>)
    KDefStruct: (n:Int, name:String, parent:False|KType,
                 fields:List<KStructField>, rfield:False|KStructField)
    KExternFn: (n:Int, lbl:Symbol, value:KExp)
    KExtern: (n:Int, lbl:Symbol, type:KType)
    KInit: (exp:KExp)

    ;Working Expressions
    KDefConst: (n:Int, value:?)

  deftype KExp
  defnodes KExp :
    ;Input Expressions
    KFn*: (tail?:True|False, targs:List<Int>,
           a1:List<KType>, a2:KType, args:List<Int>, body:KExp, info:False|FileInfo)
    KDo*: (func:KExp, args:List<KExp>, a1:List<KType>, a2:KType, info:False|FileInfo)
    KVar*: (n:Int, info:False|FileInfo)
    KLet*: (n:Int, type:KType, value:KExp, body:KExp, info:False|FileInfo)
    KLetVar*: (n:Int, type:KType, value:False|KExp, body:KExp, info:False|FileInfo)
    KSet*: (exp:KExp, type:KType, value:KExp, info:False|FileInfo)
    KMethod*: (multi:Int, targs:List<KType>, thisn:Int, value:KExp)
    KBranch*: (args:List<Int>, types:List<KType>, body:KExp, info:False|FileInfo)
    
    ;Standard Expressions
    KLet: (n:Int, value:KExp, body:KExp)
    KLetVar: (n:Int, type:KType, value:False|KExp, body:KExp)
    KLetRec: (ns:List<Int>, values:List<KExp>, body:KExp)
    KVar: (n:Int)
    KSet: (exp:KExp, type:KType, value:KExp)
    KNew: (type:KType, name:String, methods:List<KExp>, info:False|FileInfo)
    KTuple: (exps:List<KExp>, info:False|FileInfo)
    KTupleGet: (exp:KExp, index:Int)
    KEnsureLength: (exp:KExp, length:Int, info:False|FileInfo)
    KObject: (n:Int, args:List<KExp>, info:False|FileInfo)
    KArray: (n:Int, length:KExp, args:List<KExp>, info:False|FileInfo)
    KStruct: (n:Int, args:List<KExp>)
    KPtr: (loc:KExp)
    KDo: (func:KExp, args:List<KExp>, type:KType, info:False|FileInfo)
    KDoC: (func:KExp, args:List<KExp>, varargs:List<KExp>, type:KType)
    KLSLiteral: (value:?)
    KLiteral: (value:?)
    KMix: (exps:List<KExp>)
    KCurry: (n:Int, targs:List<KType>)
    KInterpret: (exp:KExp, type:KType)
    KCheck: (exp:KExp, type:KType, option:Int, info:False|FileInfo)
    KConv: (exp:KExp, type:KType)
    KAndExp: (a:KExp, b:KExp)
    KOrExp: (a:KExp, b:KExp)
    KPrim: (op:LSPrimitive|Primitive, args:List<KExp>)
    KSizeof: (type:KType)
    KTagof: (n:Int)
    KMatch: (args:List<KExp>, branches:List<KExp>, info:False|FileInfo)    
    KBranch: (args:List<Int>, types:List<KType>, body:KExp)
    KLabels: (blocks:List<KExp>)
    KBlock: (n:Int, args:List<Int>, types:List<KType>, body:KExp)
    KIf: (pred:KExp, conseq:KExp, alt:KExp)
    KSeq: (a:KExp, b:KExp)
    KGoto: (n:Int, args:List<KExp>)
    KReturn: (exp:KExp)
    KDeref: (exp:KExp)
    KDeptr: (exp:KExp)
    KField: (exp:KExp, n:Int)
    KSlot: (exp:KExp, index:KExp, type:KType)
    KFn: (tail?:True|False, targs:List<Int>,
          a1:List<KType>, a2:KType, args:List<Int>, body:KExp, info:False|FileInfo, stats:False|KFnStat)
    KMultifn: (funcs:List<KExp>)
    KMethod: (multi:Int, thisn:Int, value:KExp)

    ;Working Expressions
    KDispatch: (args:List<KExp>, branches:List<KExp>, info:False|FileInfo)
    KEnsureSet: (exp:KExp, info:False|FileInfo)

  ;==========================
  ;==== Mapper Functions ====
  ;==========================
  defmapper (f:KExp -> KExp) :
    (x:KExp) : f(x)
    (x:List<KExp>) : map(f,x)
    (x:False|KExp) : attempt: f(x as? KExp)
  defdoer (f:KExp -> ?) :
    (x:KExp) : f(x)
    (x:List<KExp>) : do(f,x)
    (x:False|KExp) : attempt: f(x as? KExp)

  defmapper (f:KType -> KType) :
    (x:KType) : f(x)
    (x:List<KType>) : map(f,x)
    (x:False|KType) : attempt: f(x as? KType)
    (x:List<KChild>) : for c in x map : KChild(n(c), f(parent(c)))
    (x:False|KStructField) : match(x:KStructField) : KStructField(n(x), f(type(x)))
    (x:List<KStructField>) : for c in x map : KStructField(n(c), f(type(c)))
  defdoer (f:KType -> ?) :
    (x:KType) : f(x)
    (x:List<KType>) : do(f,x)
    (x:False|KType) : attempt: f(x as? KType)
    (x:List<KChild>) : for c in x do : f(parent(c))
    (x:False|KStructField) : match(x:KStructField) : f(type(x))
    (x:List<KStructField>) : for c in x do : f(type(c))

  ignore :
    Symbol
    String
    True|False
    Int
    List<Int>
    False|Int
    LSPrimitive|Primitive
    False|FileInfo
    False|KFnStat
    ?

  ;===================
  ;===== Mappers =====
  ;===================
  make-mapper(f:KExp -> KExp, e:KExp)
  make-doer(f:KExp -> ?, e:KExp)
  make-mapper(f:KType -> KType, e:KExp)
  make-doer(f:KType -> ?, e:KExp)
  make-mapper(f:KType -> KType, t:KType)
  make-doer(f:KType -> ?, t:KType)
  make-mapper(f:KExp -> KExp, e:KTExp)
  make-doer(f:KExp -> ?, e:KTExp)
  make-mapper(f:KType -> KType, e:KTExp)
  make-doer(f:KType -> ?, e:KTExp)


;Structures
public defstruct KChild: (n:Int, parent:KType)
public defstruct KStructField: (n:Int, type:KType)
public defstruct KPackage: (name:Symbol, ids:PkgIds,
                            exps:List<KTExp>, loaded?:True|False)
public defstruct KFnStat : (freevars: List<Int>, freetypes:List<Int>)
defmethod print (o:OutputStream, s:KFnStat) :
  print(o, "freevars:%, freetypes:%," % [freevars(s), freetypes(s)])

public deftype KPkgComm :
  TGPackage <: KPkgComm
  KPackage <: KPkgComm

;============================================================
;===================== Convenience ==========================
;============================================================
public defn KFn (tail?:True|False, targs:List<Int>, a1:List<KType>, a2:KType,
                 args:List<Int>, body:KExp, info:False|FileInfo) :
  KFn(tail?, targs, a1, a2, args, body, info, false)

public defn freevars (f:KFn) : freevars(stats(f) as KFnStat)
public defn freetypes (f:KFn) : freetypes(stats(f) as KFnStat)

public defn attach (f:KFn, s:KFnStat) :
  KFn(tail?(f), targs(f), a1(f), a2(f), args(f), body(f), info(f), s)

;============================================================
;===================== Mapping ==============================
;============================================================

public defn map (f:KTExp -> KTExp, pkg:KPackage) :
  KPackage(name(pkg), ids(pkg), map(f,exps(pkg)), loaded?(pkg))
public defn do (f:KTExp -> ?, pkg:KPackage) :
  do(f, exps(pkg))

;============================================================
;====================== Printing ============================
;============================================================

#use-added-syntax(stz-printer-lang)

defprinter (p:KPackage) :
  KPackage :
    ($package name ids exps ...)

defprinter (c:KChild) :
  KChild :
    ($child n parent)

defprinter (c:KStructField) :
  KStructField :
    ($field n type)

defprinter (t:KType) :
  KByteT :
    custom{"$byte"}
  KIntT :
    custom{"$int"}
  KLongT :
    custom{"$long"}
  KFloatT :
    custom{"$float"}
  KDoubleT :
    custom{"$double"}
  KUnknownT :
    custom{"$unknown"}
  KPtrT:
    ($ptr type)
  KFnT:
    ($fn a r b)
  KStructT:
    ($struct n)
  KOf:
    ($of n)
  KTVar:
    custom{"$v%_" % [n(t)]}
  KAnd:
    ($and a b)
  KOr:
    ($or a b)
  KTop :
    custom{"$top"}
  KBot :
    custom{"$bot"}

defprinter (e:KTExp) :
  KDef* :
    ($def* n type value)
  KDefVar* :
    ($defvar* n type value)
  KDefmethod* :
    ($defmethod multi targs value)  
  KDef :
    ($def n type value)
  KDefVar :
    ($defvar n type value)
  KDefn :
    ($defn n value)
  KDefmulti :
    ($defmulti n tail? targs a1 a2 info)  
  KDefmethod :
    ($defmethod n multi value)
  KDefType :
    ($deftype n name parent children ...)
  KDefStruct :
    ($defstruct n name parent fields rfield)
  KExternFn :
    ($externfn n lbl value)
  KExtern :
    ($extern n lbl type)
  KInit :
    ($init exp)  
  KDefConst : 
    ($defconst n value)

defprinter (e:KExp) :
  KFn* :
    ($fn* tail? targs a1 a2 args body info)
  KDo* :
    ($do* func args a1 a2 info)
  KVar* :
    ($var* n info)
  KLet* :
    ($let* n type value body info)
  KLetVar* :
    ($letvar* n type value body info)
  KSet* :
    ($set* exp type value info)
  KMethod* :
    ($method* multi targs thisn value)
  KBranch* :
    ($branch* args types body)
  KLet :
    ($let n value body)
  KLetVar :
    ($letvar n type value body)
  KLetRec :
    ($letrec ns values body)
  KVar :
    custom{"$v%_" % [n(e)]}
  KSet :
    ($set exp type value)
  KNew :
    ($new type name methods ...)
  KTuple :
    ($tuple exps ...)
  KTupleGet :
    ($tuple-get exp index)
  KEnsureLength :
    ($ensure-length exp length)
  KObject :
    ($object n args ...)
  KArray :
    ($array n length args ...)
  KStruct :
    ($struct n args ...)
  KPtr :
    ($ptr loc)
  KDo :
    ($do func args type)
  KDoC :
    ($do-c func args varargs type)
  KLSLiteral :
    ($ls-literal value)
  KLiteral :
    ($literal value)
  KMix :
    ($mix exps ...)
  KCurry :
    ($curry n targs ...)
  KInterpret :
    ($interpret exp type)
  KCheck :
    ($check exp type option)
  KConv :
    ($conv exp type)
  KAndExp :
    ($and a b)
  KOrExp :
    ($or a b)
  KPrim :
    ($prim op args ...)
  KSizeof :
    ($sizeof type)
  KTagof :
    ($tagof n)
  KMatch :
    ($match args branches ...)
  KBranch :
    ($branch args types body)
  KLabels :
    ($labels blocks ...)
  KBlock :
    ($block n args types body)
  KIf :
    ($if pred conseq alt)
  KSeq :
    ($seq a b)
  KGoto :
    ($goto n args ...)
  KReturn :
    ($return exp)
  KDeref :
    ($deref exp)
  KDeptr :
    ($deptr exp)
  KField :
    ($field exp n)
  KSlot :
    ($slot exp index type)
  KFn :
    ($fn tail? targs a1 a2 args body stats)
  KMultifn :
    ($multi funcs ...)
  KMethod :
    ($method multi thisn value)
  KDispatch :
    ($dispatch args branches ...)
  KEnsureSet :
    ($ensure-set exp)

;============================================================
;================== Convenience Functions ===================
;============================================================

public defn attach-exps (pkg:KPackage, exps:List<KTExp>) :
  KPackage(name(pkg), ids(pkg), exps, loaded?(pkg))

public defn KVars (ns:List<Int>) :
  map(KVar,ns)

public defn KTops (ns:List) :
  map(KTop{}, ns)

public defn KLet (defs:Seqable<KeyValue<Int,KExp>>, body:KExp) :
  reduce-right{_, defs, body} $ fn (def, body) :
    KLet(key(def), value(def), body)

public defn KSeq (xs:Seqable<KExp>, y:KExp) :
  reduce-right(KSeq, xs, y)

;============================================================
;==================== Simplification ========================
;============================================================

;Trivial Simplifications
public defn trivial-simplify (t:KType) :
  match(map(trivial-simplify, t)) :
    (t:KAnd) :
      match(a(t), b(t)) :
        (a:KBot, b) : a
        (a, b:KBot) : b
        (a:KTop, b) : b
        (a, b:KTop) : a
        (a, b) : a when a == b else t
    (t:KOr) :
      match(a(t), b(t)) :
        (a:KBot, b) : b
        (a, b:KBot) : a
        (a:KTop, b) : a
        (a, b:KTop) : b
        (a, b) : t
    (t) : t

;============================================================
;==================== Utilities =============================
;============================================================

public defn n+targs (e:KExp) -> [Int, List<KType>] :
  match(e) :
    (e:KVar|KVar*) : [n(e), List()]
    (e:KCurry) : [n(e), targs(e)]

public defn replace-tvars (t:KType, entries:Table<Int,KType>) :
  defn ft (t:KType) :
    match(t:KTVar) : get?(entries, n(t), t)
    else : map(ft,t)
  trivial-simplify(ft(t))

public defn histanza? (t:KType) :
  t is KOf|KTVar|KAnd|KOr|KTop|KBot
  
public defn lostanza? (t:KType) :
  not histanza?(t)

public defn any? (f:KType -> True|False, t:KType) :
  var result = false
  for ti in t do :
    (result = true) when f(ti)
  result

public defn has-var? (t:KType) :
  match(t) :
    (t:KTVar) : true
    (t) : any?(has-var?, t)

public defn has-body? (e:KExp) :
  e is KLet*|KLetVar*|KBranch*|KLet|KLetVar|KLetRec|KMatch|
       KBranch|KLabels|KBlock|KIf|KSeq|KDispatch
