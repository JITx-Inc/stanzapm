defpackage stz/kl2-ir :
  import core
  import collections
  import stz/ids
  import stz/primitives
  import stz/pl-ir
  import stz/tgt-ir

#use-added-syntax(stz-ast-lang, stz-printer-lang)

;============================================================
;=================== Structures =============================
;============================================================

public defast :
  deftype KType <: Hashable & Equalable
  defnodes KType :
    ;LoStanza Types
    KByteT
    KIntT
    KLongT
    KFloatT
    KDoubleT
    KUnknownT
    KPtrT: (type:KType)
    KFnT: (a:List<KType>, r:False|KType, b:KType)
    KStructT: (n:Int)
    
    ;HiStanza Types
    KOf: (n:Int)
    KTVar: (n:Int)
    KAnd: (a:KType, b:KType)
    KOr: (a:KType, b:KType)
    KTop
    KBot

    ;Reified
    KTypeObject: (n:Int, targs:List<KType>)
    
  ;Top Level Expressions
  deftype KTExp
  defnodes KTExp :
    ;Input Expressions
    KDef*: (n:Int, type:KType, value:KExp, info:False|FileInfo)
    KDefVar*: (n:Int, type:KType, value:False|KExp, info:False|FileInfo)
    KDefmethod*: (multi:Int, targs:List<KType>, value:KExp)
    
    ;Standard Expressions
    KDef: (n:Int, type:KType, value:KExp)
    KDefVar: (n:Int, type:KType, value:False|KExp)
    KDefn: (n:Int, value:KExp)
    KDefmulti: (n:Int, tail?:True|False, targs:List<Int>,
                a1:List<KType>, a2:KType, info:False|FileInfo)  
    KDefmethod: (n:Int, multi:Int, value:KExp)
    KDefType: (n:Int, name:String, parent:False|KType, children:List<KChild>)
    KDefStruct: (n:Int, name:String, parent:False|KType,
                 fields:List<KStructField>, rfield:False|KStructField)
    KExternFn: (n:Int, lbl:Symbol, value:KExp)
    KExtern: (n:Int, lbl:Symbol, type:KType)
    KInit: (exp:KExp)

    ;Working Expressions
    KDefConst: (n:Int, value:?)
    KDefObject: (n:Int, name:String, parent:KType, tarity:Int, arity:Int)
    KDefClosure: (n:Int, closure:Int, freetypes:List<Int>, freevars:List<Int>, func:KExp)
    KDefTypeObject: (n:Int, args:List<Int>, type:KType)

  deftype KExp
  defnodes KExp :
    ;Input Expressions
    KFn*: (tail?:True|False, targs:List<Int>,
           a1:List<KType>, a2:KType, args:List<Int>, body:KExp, info:False|FileInfo)
    KDo*: (func:KExp, args:List<KExp>, a1:List<KType>, a2:KType, info:False|FileInfo)
    KVar*: (n:Int, info:False|FileInfo)
    KLet*: (n:Int, type:KType, value:KExp, body:KExp, info:False|FileInfo)
    KLetVar*: (n:Int, type:KType, value:False|KExp, body:KExp, info:False|FileInfo)
    KSet*: (exp:KExp, type:KType, value:KExp, info:False|FileInfo)
    KMethod*: (multi:Int, targs:List<KType>, thisn:Int, value:KExp)
    KBranch*: (args:List<Int>, types:List<KType>, body:KExp, info:False|FileInfo)
    
    ;Standard Expressions
    KLet: (n:Int, value:KExp, body:KExp)
    KLetVar: (n:Int, type:KType, value:False|KExp, body:KExp)
    KLetRec: (ns:List<Int>, values:List<KExp>, body:KExp)
    KVar: (n:Int)
    KSet: (exp:KExp, type:KType, value:KExp)
    KNew: (type:KType, name:String, methods:List<KExp>, info:False|FileInfo)
    KTuple: (exps:List<KExp>, info:False|FileInfo)
    KTupleGet: (exp:KExp, index:Int)
    KEnsureLength: (exp:KExp, length:Int, info:False|FileInfo)
    KObject: (n:Int, args:List<KExp>, info:False|FileInfo)
    KArray: (n:Int, length:KExp, args:List<KExp>, info:False|FileInfo)
    KStruct: (n:Int, args:List<KExp>)
    KPtr: (loc:KExp)
    KDo: (func:KExp, args:List<KExp>, type:KType, info:False|FileInfo)
    KDoC: (func:KExp, args:List<KExp>, varargs:List<KExp>, type:KType)
    KLSLiteral: (value:?)
    KLiteral: (value:?)
    KMix: (exps:List<KExp>)
    KCurry: (n:Int, targs:List<KType>)
    KInterpret: (exp:KExp, type:KType)
    KCheck: (exp:KExp, type:KType, option:Int, info:False|FileInfo)
    KConv: (exp:KExp, type:KType)
    KAndExp: (a:KExp, b:KExp)
    KOrExp: (a:KExp, b:KExp)
    KPrim: (op:LSPrimitive|Primitive, args:List<KExp>)
    KSizeof: (type:KType)
    KTagof: (n:Int)
    KMatch: (args:List<KExp>, branches:List<KExp>, info:False|FileInfo)    
    KBranch: (args:List<Int>, types:List<KType>, body:KExp)
    KLabels: (blocks:List<KExp>)
    KBlock: (n:Int, args:List<Int>, types:List<KType>, body:KExp)
    KIf: (pred:KExp, conseq:KExp, alt:KExp)
    KSeq: (a:KExp, b:KExp)
    KGoto: (n:Int, args:List<KExp>)
    KReturn: (exp:KExp)
    KDeref: (exp:KExp)
    KDeptr: (exp:KExp)
    KField: (exp:KExp, n:Int)
    KSlot: (exp:KExp, index:KExp, type:KType)
    KFn: (tail?:True|False, stack-properties:StackProperties, targs:List<Int>,
          a1:List<KType>, a2:KType, args:List<Int>, body:KExp, info:False|FileInfo, stats:False|KFnStat)
    KMultifn: (funcs:List<KExp>)
    KMethod: (multi:Int, thisn:Int, value:KExp)

    ;Working Expressions
    KDispatch: (args:List<KExp>, branches:List<KExp>, info:False|FileInfo)
    KEnsureSet: (exp:KExp, info:False|FileInfo)
    KNewObject: (n:Int, targs:List<KType>, args:List<KExp>, info:False|FileInfo)
    KObjectGet: (object:KExp, index:Int)
    KObjectTGet: (object:KExp, index:Int)    
    KLetType: (n:Int, value:KExp, body:KExp)
    KBox: (exp:False|KExp)
    KBoxGet: (exp:KExp)
    KBoxSet: (exp:KExp, value:KExp)
    KClosure: (n:Int, targs:List<KType>, args:List<KExp>, info:False|FileInfo)
    KTagPrim: (n:Int, exp:KExp)
    KDetagPrim: (n:Int, exp:KExp)

  ;==========================
  ;==== Mapper Functions ====
  ;==========================
  defmapper (f:KExp -> KExp) :
    (x:KExp) : f(x)
    (x:List<KExp>) : map(f,x)
    (x:False|KExp) : attempt: f(x as? KExp)
  defdoer (f:KExp -> ?) :
    (x:KExp) : f(x)
    (x:List<KExp>) : do(f,x)
    (x:False|KExp) : attempt: f(x as? KExp)

  defmapper (f:KType -> KType) :
    (x:KType) : f(x)
    (x:List<KType>) : map(f,x)
    (x:False|KType) : attempt: f(x as? KType)
    (x:List<KChild>) : for c in x map : KChild(n(c), f(parent(c)))
    (x:False|KStructField) : match(x:KStructField) : KStructField(n(x), f(type(x)))
    (x:List<KStructField>) : for c in x map : KStructField(n(c), f(type(c)))
  defdoer (f:KType -> ?) :
    (x:KType) : f(x)
    (x:List<KType>) : do(f,x)
    (x:False|KType) : attempt: f(x as? KType)
    (x:List<KChild>) : for c in x do : f(parent(c))
    (x:False|KStructField) : match(x:KStructField) : f(type(x))
    (x:List<KStructField>) : for c in x do : f(type(c))

  ignore :
    Symbol
    String
    True|False
    Int
    List<Int>
    False|Int
    LSPrimitive|Primitive
    False|FileInfo
    False|KFnStat
    StackProperties
    ?

  ;===================
  ;===== Mappers =====
  ;===================
  make-mapper(f:KExp -> KExp, e:KExp)
  make-doer(f:KExp -> ?, e:KExp)
  make-mapper(f:KType -> KType, e:KExp)
  make-doer(f:KType -> ?, e:KExp)
  make-mapper(f:KType -> KType, t:KType)
  make-doer(f:KType -> ?, t:KType)
  make-mapper(f:KExp -> KExp, e:KTExp)
  make-doer(f:KExp -> ?, e:KTExp)
  make-mapper(f:KType -> KType, e:KTExp)
  make-doer(f:KType -> ?, e:KTExp)


;Structures
public defstruct KChild: (n:Int, parent:KType)
public defstruct KStructField: (n:Int, type:KType)
public defstruct KPackage: (name:Symbol, ids:PkgIds,
                            exps:List<KTExp>, loaded?:True|False)
public defstruct KFnStat : (freevars: List<Int>, freetypes:List<Int>)
defmethod print (o:OutputStream, s:KFnStat) :
  print(o, "freevars:%, freetypes:%," % [freevars(s), freetypes(s)])

public deftype StackProperties
public defstruct NewStack <: StackProperties
public defstruct LastStack <: StackProperties
public defstruct CheckStack <: StackProperties
defmethod print (o:OutputStream, sp:StackProperties) :
  print{o, _} $ match(sp) :
    (sp:NewStack) : "new-stack"
    (sp:LastStack) : "last-stack"
    (sp:CheckStack) : "check-stack"

public deftype KPkgComm :
  TGPackage <: KPkgComm
  KPackage <: KPkgComm

;============================================================
;===================== Convenience ==========================
;============================================================
public defn KFn (tail?:True|False, stack-properties:StackProperties, targs:List<Int>, a1:List<KType>, a2:KType,
                 args:List<Int>, body:KExp, info:False|FileInfo) :
  KFn(tail?, stack-properties, targs, a1, a2, args, body, info, false)

public defn freevars (f:KFn) : freevars(stats(f) as KFnStat)
public defn freetypes (f:KFn) : freetypes(stats(f) as KFnStat)

public defn attach (f:KFn, s:KFnStat) :
  KFn(tail?(f), stack-properties(f), targs(f), a1(f), a2(f), args(f), body(f), info(f), s)

public defn attach-a1-a2-body (f:KFn, a1:List<KType>, a2:KType, body:KExp) :
  KFn(tail?(f), stack-properties(f), targs(f), a1, a2, args(f), body, info(f), stats(f))

public defn attach-sp-body (f:KFn, sp:StackProperties, body:KExp) :
  KFn(tail?(f), sp, targs(f), a1(f), a2(f), args(f), body, info(f), stats(f))

;============================================================
;===================== Mapping ==============================
;============================================================

public defn map (f:KTExp -> KTExp, pkg:KPackage) :
  KPackage(name(pkg), ids(pkg), map(f,exps(pkg)), loaded?(pkg))
public defn do (f:KTExp -> ?, pkg:KPackage) :
  do(f, exps(pkg))

;============================================================
;====================== Printing ============================
;============================================================

#use-added-syntax(stz-printer-lang)

defprinter (p:KPackage) :
  KPackage :
    ($package name ids exps ...)

defprinter (c:KChild) :
  KChild :
    ($child n parent)

defprinter (c:KStructField) :
  KStructField :
    ($field n type)

defprinter (t:KType) :
  KByteT :
    custom{"$byte"}
  KIntT :
    custom{"$int"}
  KLongT :
    custom{"$long"}
  KFloatT :
    custom{"$float"}
  KDoubleT :
    custom{"$double"}
  KUnknownT :
    custom{"$unknown"}
  KPtrT:
    ($ptr type)
  KFnT:
    ($fn a r b)
  KStructT:
    ($struct n)
  KOf:
    ($of n)
  KTVar:
    custom{"$v%_" % [n(t)]}
  KAnd:
    ($and a b)
  KOr:
    ($or a b)
  KTop :
    custom{"$top"}
  KBot :
    custom{"$bot"}
  KTypeObject :
    ($tobj n targs ...)

defprinter (e:KTExp) :
  KDef* :
    ($def* n type value)
  KDefVar* :
    ($defvar* n type value)
  KDefmethod* :
    ($defmethod multi targs value)  
  KDef :
    ($def n type value)
  KDefVar :
    ($defvar n type value)
  KDefn :
    ($defn n value)
  KDefmulti :
    ($defmulti n tail? targs a1 a2 info)  
  KDefmethod :
    ($defmethod n multi value)
  KDefType :
    ($deftype n name parent children ...)
  KDefStruct :
    ($defstruct n name parent fields rfield)
  KExternFn :
    ($externfn n lbl value)
  KExtern :
    ($extern n lbl type)
  KInit :
    ($init exp)  
  KDefConst : 
    ($defconst n value)
  KDefObject :
    ($defobject n name parent tarity arity)
  KDefClosure :
    ($defclosure n closure freetypes freevars func)
  KDefTypeObject :
    ($deftypeobject n args type)

defprinter (e:KExp) :
  KFn* :
    ($fn* tail? targs a1 a2 args body info)
  KDo* :
    ($do* func args a1 a2 info)
  KVar* :
    ($var* n info)
  KLet* :
    ($let* n type value body info)
  KLetVar* :
    ($letvar* n type value body info)
  KSet* :
    ($set* exp type value info)
  KMethod* :
    ($method* multi targs thisn value)
  KBranch* :
    ($branch* args types body)
  KLet :
    ($let n value body)
  KLetVar :
    ($letvar n type value body)
  KLetRec :
    ($letrec ns values body)
  KVar :
    custom{"$v%_" % [n(e)]}
  KSet :
    ($set exp type value)
  KNew :
    ($new type name methods ...)
  KTuple :
    ($tuple exps ...)
  KTupleGet :
    ($tuple-get exp index)
  KEnsureLength :
    ($ensure-length exp length)
  KObject :
    ($object n args ...)
  KArray :
    ($array n length args ...)
  KStruct :
    ($struct n args ...)
  KPtr :
    ($ptr loc)
  KDo :
    ($do func args type)
  KDoC :
    ($do-c func args varargs type)
  KLSLiteral :
    ($ls-literal value)
  KLiteral :
    ($literal value)
  KMix :
    ($mix exps ...)
  KCurry :
    ($curry n targs ...)
  KInterpret :
    ($interpret exp type)
  KCheck :
    ($check exp type option)
  KConv :
    ($conv exp type)
  KAndExp :
    ($and a b)
  KOrExp :
    ($or a b)
  KPrim :
    ($prim op args ...)
  KSizeof :
    ($sizeof type)
  KTagof :
    ($tagof n)
  KMatch :
    ($match args branches ...)
  KBranch :
    ($branch args types body)
  KLabels :
    ($labels blocks ...)
  KBlock :
    ($block n args types body)
  KIf :
    ($if pred conseq alt)
  KSeq :
    ($seq a b)
  KGoto :
    ($goto n args ...)
  KReturn :
    ($return exp)
  KDeref :
    ($deref exp)
  KDeptr :
    ($deptr exp)
  KField :
    ($field exp n)
  KSlot :
    ($slot exp index type)
  KFn :
    ($fn tail? stack-properties targs a1 a2 args body stats)
  KMultifn :
    ($multi funcs ...)
  KMethod :
    ($method multi thisn value)
  KDispatch :
    ($dispatch args branches ...)
  KEnsureSet :
    ($ensure-set exp)
  KNewObject :
    ($new-object n targs args)
  KObjectGet :
    ($object-get object index)
  KObjectTGet :
    ($object-tget object index)
  KLetType :
    ($let-type n value body)
  KBox :
    ($box exp)
  KBoxGet :
    ($box-get exp)
  KBoxSet :
    ($box-set exp value)
  KClosure :
    ($closure n targs args info)
  KTagPrim :
    ($tag n exp)
  KDetagPrim :
    ($detag n exp)

;============================================================
;================== Convenience Functions ===================
;============================================================

public defn attach-exps (pkg:KPackage, exps:List<KTExp>) :
  KPackage(name(pkg), ids(pkg), exps, loaded?(pkg))

public defn KVars (ns:List<Int>) : map(KVar,ns)
public defn KTops (ns:List) : map(KTop{}, ns)
public defn KTVars (ns:List<Int>) : map(KTVar, ns)

public defn KLet (defs:Seqable<KeyValue<Int,KExp>>, body:KExp) :
  reduce-right{_, defs, body} $ fn (def, body) :
    KLet(key(def), value(def), body)

public defn KSeq (xs:Seqable<KExp>, y:KExp) :
  reduce-right(KSeq, xs, y)

;============================================================
;==================== Simplification ========================
;============================================================

;Trivial Simplifications
public defn trivial-simplify (t:KType) :
  match(map(trivial-simplify, t)) :
    (t:KAnd) :
      match(a(t), b(t)) :
        (a:KBot, b) : a
        (a, b:KBot) : b
        (a:KTop, b) : b
        (a, b:KTop) : a
        (a, b) : a when a == b else t
    (t:KOr) :
      match(a(t), b(t)) :
        (a:KBot, b) : b
        (a, b:KBot) : a
        (a:KTop, b) : a
        (a, b:KTop) : b
        (a, b) : t
    (t) : t

;============================================================
;==================== Utilities =============================
;============================================================

public defn n+targs (e:KExp) -> [Int, List<KType>] :
  match(e) :
    (e:KVar|KVar*) : [n(e), List()]
    (e:KCurry) : [n(e), targs(e)]

public defn replace-tvars (t:KType, entries:Table<Int,KType>) :
  defn ft (t:KType) :
    match(t:KTVar) : get?(entries, n(t), t)
    else : map(ft,t)
  trivial-simplify(ft(t))

public defn erase-tvars (t:KType) :
  match(t) :
    (t:KTVar) : KTop()
    (t) : map(erase-tvars, t)

public defn erase-tvars (t:KType, vs:Seqable<Int>) :
  replace-tvars(t, to-hashtable<Int,KType>(vs, repeat(KTop())))

public defn histanza? (t:KType) :
  t is KOf|KTVar|KAnd|KOr|KTop|KBot
  
public defn lostanza? (t:KType) :
  not histanza?(t)

public defn any? (f:KType -> True|False, t:KType) :
  var result = false
  for ti in t do :
    (result = true) when f(ti)
  result

public defn has-var? (t:KType) :
  match(t) :
    (t:KTVar) : true
    (t) : any?(has-var?, t)

public defn has-body? (e:KExp) :
  e is KLet*|KLetVar*|KBranch*|KLet|KLetVar|KLetRec|KMatch|
       KBranch|KLabels|KBlock|KIf|KSeq|KDispatch|KLetType

public defn freevars (t:KType) :
  unique $ generate<Int> :
    let loop (t:KType = t) :
      match(t:KTVar) : yield(n(t))
      else : do(loop, t)

;============================================================
;=================== Hashing and Equality ===================
;============================================================

defmethod hash (t:KType) :
  hash $ match(t) :
    (t:KByteT) : [0]
    (t:KIntT) : [1]
    (t:KLongT) : [2]
    (t:KFloatT) : [3]
    (t:KDoubleT) : [4]
    (t:KUnknownT) : [5]    
    (t:KPtrT) : [6 type(t)]
    (t:KFnT) : [7 a(t) r(t) b(t)]
    (t:KStructT) : [8 n(t)]
    (t:KOf) : [9 n(t)]
    (t:KTVar) : [10 n(t)]
    (t:KAnd) : [11 a(t) b(t)]
    (t:KOr) : [12 a(t) b(t)]
    (t:KTop) : [13]
    (t:KBot) : [14]
    (t:KTypeObject) : [15 n(t) targs(t)]

defmethod equal? (x:KType, y:KType) :
  match(x, y) :
    (x:KByteT, y:KByteT) : true
    (x:KIntT, y:KIntT) : true
    (x:KLongT, y:KLongT) : true
    (x:KFloatT, y:KFloatT) : true
    (x:KDoubleT, y:KDoubleT) : true
    (x:KUnknownT, y:KUnknownT) : true
    (x:KPtrT, y:KPtrT) : type(x) == type(y)
    (x:KFnT, y:KFnT) : a(x) == a(y) and r(x) == r(y) and b(x) == b(y)
    (x:KStructT, y:KStructT) : n(x) == n(y)
    (x:KOf, y:KOf) : n(x) == n(y)
    (x:KTVar, y:KTVar) : n(x) == n(y)
    (x:KAnd, y:KAnd) : a(x) == a(y) and b(x) == b(y)
    (x:KOr, y:KOr) : a(x) == a(y) and b(x) == b(y)
    (x:KTop, y:KTop) : true
    (x:KBot, y:KBot) : true
    (x:KTypeObject, y:KTypeObject) : n(x) == n(y) and targs(x) == targs(y)
    (x, y) : false

;============================================================
;==================== Normalization =========================
;============================================================

public defn normalize (t:KType) :
  val counter = to-seq(0 to false)
  val ids = HashTable-init<Int,Int>(next{counter})
  let loop (t:KType = t) :
    match(t) :
      (t:KTVar) : KTVar(ids[n(t)])
      (t) : map(loop, t)

public defn normalized-hash (t:KType) :
  hash(normalize(t))

public defn normalized-equal? (a:KType, b:KType) :
  normalize(a) == normalize(b)