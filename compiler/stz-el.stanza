defpackage stz/el :
  import core
  import collections
  import stz/dl-ir
  import stz/el-ir
  import stz/ids

;============================================================
;========================= Lowering =========================
;============================================================

public defn lower (packageio:PackageIO, epackage:EPackage) :
  println("===== PACKAGE IO =====")
  println(packageio)
  println("===== EPACKAGE =====")
  println(epackage)
  
  val epackage2 = map-methods(epackage)
  println("===== EPACKAGE2 =====")
  println(epackage2)
  

;============================================================
;================== Method TArg Mapping =====================
;============================================================

defn inverse-solve (input-xs:Tuple<Int>, targs:Tuple<EType>) -> [Tuple<Int>, Tuple<EType>] :
  ;Created targs
  val ys = map(fresh-id{}, targs)
  ;Initialize solved table
  val solved = IntTable<ETVar>()
  ;Precise Solutions
  for (t in targs, y in ys) do :
    match(t:ETVar) : set?(solved, n(t), ETVar{y})
  ;Approximate Solutions
  for (t in targs, y in ys) do :
    let loop (t:ELItem = t) :
      match(t) :
        (t:ETVar) : set?(solved, n(t), ETVar{y})
        (t:EOr) : do(loop, t)
        (t) : false
  ;Return solutions
  val solns = map(get?{solved, _, ETop()}, input-xs)
  [ys, solns]

defn replace-tvars (f:EFn, xs:Tuple<Int>, ys:Tuple<EType>) :
  val table = to-inttable<EType>(xs,ys)
  defn loop (x:ELItem) :
    match(x) :
      (x:ETVar) : get?(table, n(x), ETop())
      (x) : map(loop, x)
  loop(f) as EFn

defn map-methods (e:EPackage) :
  defn loop (x:ELItem) :
    val x* = match(x) :      
      (m:EDefmethod) :
        val [targs*, tvals] = inverse-solve(targs(func(m)), targs(m))
        val func* = sub-targs(replace-tvars(func(m), targs(func(m)), tvals), targs*)
        EDefmethod(n(m), multi(m), [], func*, lostanza?(m))
      (m:EMethod) :
        val [targs*, tvals] = inverse-solve(targs(func(m)), targs(m))
        val func* = sub-targs(replace-tvars(func(m), targs(func(m)), tvals), targs*)
        EMethod(multi(m), [], thisn(m), func*)
      (x) :
        x
    match(x*) :
      (x:EType|ELocal|EImm|ELoc|EIns) : x
      (x) : map(loop, x)
  loop(e) as EPackage  

