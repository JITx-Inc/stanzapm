defpackage stz/el :
  import core
  import collections
  import stz/dl-ir
  import stz/el-ir
  import stz/ids

;============================================================
;========================= Lowering =========================
;============================================================

public defn lower (packageio:PackageIO, epackage:EPackage) :
  println("===== PACKAGE IO =====")
  println(packageio)
  println("===== EPACKAGE =====")
  println(epackage)
  
  ;val epackage2 = map-methods(epackage)
  ;println("===== EPACKAGE2 =====")
  ;println(epackage2)
  

;============================================================
;================== Method TArg Mapping =====================
;============================================================

defn inverse-solve (input-xs:Tuple<Int>, targs:Tuple<EType>) -> [Tuple<Int>, Tuple<EType>] :
  ;Created targs
  val ys = map(fresh-id{}, targs)
  ;Initialize solved table
  val solved = IntTable<ETVar>()
  ;Precise Solutions
  for (t in targs, y in ys) do :
    match(t:ETVar) : set?(solved, n(t), ETVar{y})
  ;Approximate Solutions
  for (t in targs, y in ys) do :
    let loop (t:ELItem = t) :
      match(t) :
        (t:ETVar) : set?(solved, n(t), ETVar{y})
        (t:EOr) : do(loop, t)
        (t) : false
  ;Return solutions
  val solns = map(get?{solved, _, ETop()}, input-xs)
  [ys, solns]
  
;defn map-methods (m:EDefmethod) :
;  val [targs*, tvals] = inverse-solve(targs(func(m)), targs(m))
;  val tvtable = to-inttable<EType>(targs(func(m)), tvals)
;  defn replace-type (t:EType) :
;    match(t) :
;      (t:ETVar) : get?(tvtable, n(t), t)
;      (t) : map(replace-type, t)
;  val func* = mapr(replace-type, func(m))
;  EDefmethod(n(m), multi(m), [], func*, lostanza?(m))
;
;defn map-methods (m:EMethod) :
;  val [targs*, tvals] = inverse-solve(targs(func(m)), targs(m))
;  val tvtable = to-inttable<EType>(targs(func(m)), tvals)
;  defn replace-type (t:EType) :
;    match(t) :
;      (t:ETVar) : get?(tvtable, n(t), t)
;      (t) : map(replace-type, t)
;  val func* = mapr(replace-type, func(m))
;  EMethod(multi(m), [], thisn(m), func*)
;
;defn map-methods (e:ETExp) :
;  defn ff (e:EFn) :
;    val e* = 
;      sub-localobjs{e, _} $ for obj in localobjs(e) map :
;        sub-methods(obj, map(map-methods, methods(obj)))
;    apply(Mapper(ff), e*)
;  val e* = match(e) :
;    (e:EDefmethod) :
;      map-methods(e)
;    (e:EInit) :
;      sub-localobjs{e, _} $ for obj in localobjs(e) map :
;        sub-methods(obj, map(map-methods, methods(obj)))
;    (e) : e
;  apply(Mapper(ff), e*)
;
;defn map-methods (e:EPackage) :
;  EPackage(name(e), map(map-methods, exps(e)))
;
;;============================================================
;;======================= Mapper =============================
;;============================================================
;
;deftype Mapper
;defmulti apply<?T> (m:Mapper, e:EFunction&?T) -> T
;defmulti apply (m:Mapper, e:ETExp) -> ETExp
;
;defn Mapper (f:EFn -> EFn) :
;  defn g<?T> (e:EFunction&?T) :
;    {_ as EFunction&T} $ match(e) :
;      (e:EMultifn) : EMultifn(map(f,funcs(e)))
;      (e:EFn) : f(e)
;  defn g (e:ELocalFn) : sub-func(e, g(func(e)))
;  defn g (e:ELocalObj) : sub-methods(e, g(methods(e)))
;  defn g (e:EMethod) : sub-func(e, g(func(e)))
;  defn g (e:Tuple<ELocalFn>) : map(g,e)
;  defn g (e:Tuple<ELocalObj>) : map(g,e)
;  defn g (e:Tuple<EMethod>) : map(g,e)
;  defn g<?T> (e:Tuple<EFunction&?T>) : map(g, e)
;  new Mapper :
;    defmethod apply<?T> (this, e:EFunction&?T) : g(e)
;    defmethod apply (this, e:ETExp) :
;      match(e) :
;        (e:EDefn) : sub-func(e, g(func(e)))
;        (e:EDefmethod) : sub-func(e, g(func(e)))
;        (e:EExternFn) : sub-func(e, g(func(e)))
;        (e:EInit) : sub-localobjs(sub-localfns(e, g(localfns(e))), g(localobjs(e)))
;        (e) : e
;
;;============================================================
;;======================== Mappers ===========================
;;============================================================
;
;defn map (f:EType -> EType, e:EFn) :
;  defn f* (e:EType) : f(e)
;  defn f* (e:Tuple<EType>) : map(f,e)
;  defn f* (e:ELocal) : ELocal(n(e), f(type(e)), mutable?(e))
;  defn f* (e:Tuple<ELocal>) : map(f*,e)
;  defn f* (e:ELocalObj) : ELocalObj(n(e), type(e), f(methods(e)))
;  defn f* (e:Tuple<ELocalObj>) : map(f*,e)
;  defn f* (e:EIns) : mapr(f,e)
;  defn f* (e:Tuple<EIns>) : map(f*,e)
;  defn f* (e:EMethod) : EMethod(multi(e), f*(targs(e)), thisn(e), func(e))
;  defn f* (e:Tuple<EMethod>) : map(f*,e)  
;  EFn(targs(e), args(e), f*(a1(e)), f*(a2(e)), f*(locals(e)), 
;      localfns(e), f*(localobjs(e)), f*(ins(e)))
;
;defn mapr (f:EType -> EType, e:EFn) :
;  defn ff (e:EFn) : mapr(f,e)
;  apply(Mapper(ff), map(f,e))
;
;defn do (f:EType -> ?, t:EType) :
;  defn f* (t:EType) : f(t)
;  defn f* (t:False) : false
;  defn f* (ts:Tuple<EType>) : do(f,ts)
;  match(t) :
;    (t:EPtrT) : (f*(type(t)))
;    (t:EFnT) : (f*(a(t)), f*(r(t)), f*(b(t)))
;    (t:EAnd) : (f*(a(t)), f*(b(t)))
;    (t:EOr) : (f*(a(t)), f*(b(t)))
;    (t) : false
;
;defn map (f:EType -> EType, ins:EIns) :
;  defn f* (x:False) : false
;  defn f* (x:EType) : f(x)
;  defn f* (x:Tuple<EType>) : map(f,x)
;  defn f* (x:EBranch) : sub-types(x, f*(types(x)))
;  defn f* (x:Tuple<EBranch>) : map(f*, x)
;  match(ins) :
;    (ins:ECheckedDo) : sub-ytypes(sub-xtype(ins, f*(xtype(ins))), f*(ytypes(ins)))
;    (ins:ELoad) : sub-xtype(ins, f*(xtype(ins)))
;    (ins:EStore) : sub-ytype(ins, f*(ytype(ins)))
;    (ins:EDo) : sub-xtype(ins, f*(xtype(ins)))
;    (ins:EDoC) : sub-xtype(ins, f*(xtype(ins)))
;    (ins:EMatch) : sub-branches(ins, f*(branches(ins)))
;    (ins) : ins
;
;;Recursively replaces all EImms within EIns
;defn mapr (f:EImm -> EImm, ins:EIns) :
;  defn f* (x:False) : false
;  defn f* (x:EImm) -> ? : f(x)
;  defn f* (x:Tuple<EImm>) -> Tuple : map(f,x)
;  defn f* (x:ELoc) : mapr(f,x)
;
;  match(ins) :
;    (ins:ESet) : ESet(f*(x(ins)), f*(y(ins)))
;    (ins:EShuffle) : EShuffle(f*(xs(ins)), f*(ys(ins)))
;    (ins:ELetRec) : ELetRec(f*(xs(ins)), closures(ins))
;    (ins:ECheckedDo) : ECheckedDo(f*(x(ins)), xtype(ins), f*(/f(ins)), f*(ys(ins)), ytypes(ins))
;    (ins:ENew) : ENew(f*(x(ins)), n(ins))
;    (ins:ETuple) : ETuple(f*(x(ins)), f*(ys(ins)))
;    (ins:EVoidTuple) : EVoidTuple(f*(x(ins)), length(ins))
;    (ins:ETupleGet) : ETupleGet(f*(x(ins)), f*(y(ins)), index(ins))
;    (ins:ETupleSet) : ETupleSet(f*(y(ins)), index(ins), f*(z(ins)))
;    (ins:ECheckLength) : ECheckLength(f*(y(ins)), length(ins))
;    (ins:EObject) : EObject(f*(x(ins)), n(ins), f*(ys(ins)))
;    (ins:EArray) : EArray(f*(x(ins)), n(ins), f*(ys(ins)))
;    (ins:EStruct) : EStruct(f*(x(ins)), n(ins), f*(ys(ins)))
;    (ins:EPtr) : EPtr(f*(x(ins)), f*(loc(ins)))
;    (ins:ELoad) : ELoad(f*(x(ins)), xtype(ins), f*(loc(ins)))
;    (ins:EStore) : EStore(f*(loc(ins)), f*(y(ins)), ytype(ins))
;    (ins:ELabel) : ELabel(n(ins))
;    (ins:EDo) : EDo(f*(x(ins)), xtype(ins), f*(/f(ins)), f*(ys(ins)))
;    (ins:EDoC) : EDoC(f*(x(ins)), xtype(ins), f*(/f(ins)), f*(ys(ins)))
;    (ins:EDump) : EDump(f*(ys(ins)))
;    (ins:EInterpret) : EInterpret(f*(x(ins)), f*(y(ins)))
;    (ins:EConv) : EConv(f*(x(ins)), f*(y(ins)))
;    (ins:ECheck) : ECheck(f*(x(ins)), f*(y(ins)))
;    (ins:EGoto) : EGoto(n(ins))
;    (ins:EPrim) : EPrim(f*(x(ins)), op(ins), f*(ys(ins)))
;    (ins:EIf) : EIf(n1(ins), n2(ins), op(ins), f*(ys(ins)))
;    (ins:EMatch) : EMatch(f*(ys(ins)), branches(ins))
;    (ins:ECheckSet) : ECheckSet(f*(y(ins)))
;    (ins:EBox) : EBox(f*(x(ins)), f*(y(ins)))
;    (ins:EBoxGet) : EBoxGet(f*(x(ins)), f*(y(ins)))
;    (ins:EBoxSet) : EBoxSet(f*(y(ins)), f*(z(ins)))
;    (ins:EReturn) : EReturn(f*(y(ins)))
;
;;Recursively replaces all ETypes within EImm
;defn mapr (f:EType -> EType, x:EImm) :
;  defn f* (x:EType) : f(x)
;  defn f* (x:ECurry) : mapr(f,x) as ECurry
;  defn f* (xs:Tuple<ECurry>) : map(f*,xs)
;  defn f* (x:Tuple<EType>) : map(f,x)
;
;  match(x) :
;    (x:ELSLiteral) : x
;    (x:ELiteral) : x
;    (x:EVar) : x
;    (x:EMix) : EMix(f*(funcs(x)))
;    (x:ECurry) : ECurry(n(x), f*(targs(x)))
;    (x:ESizeof) : ESizeof(f*(type(x)))
;    (x:ETagof) : x
;
;;Recursively replaces all EImms within ELoc
;defn mapr (f:EImm -> EImm, l:ELoc) :
;  defn f* (x:EImm) -> ? : f(x)
;  defn f* (x:ELoc) : mapr(f, x)  
;  match(l) :
;    (l:EVarLoc) : EVarLoc(f*(x(l)))
;    (l:EDeref) : EDeref(f*(y(l)))
;    (l:EDeptr) : EDeptr(f*(y(l)))
;    (l:EField) : EField(f*(loc(l)), n(l), index(l))
;    (l:ESlot) : ESlot(f*(loc(l)), type(l), f*(index(l)))
;
;;NOTE:Recurses through ELoc
;;Does not recurse through EImm
;defn map (f:EType -> EType, l:ELoc) :
;  defn f* (x:ELoc) : mapr(f,x)
;  defn f* (x:EType) : f(x)
;  match(l) :
;    (l:EVarLoc) : l
;    (l:EDeref) : l
;    (l:EDeptr) : l
;    (l:EField) : EField(f*(loc(l)), n(l), index(l))
;    (l:ESlot) : ESlot(f*(loc(l)), f*(type(l)), index(l))
;
;;Recursively replaces all ETypes within ELoc
;defn mapr (f:EType -> EType, loc:ELoc) :
;  defn fimm (x:EImm) : mapr(f,x)
;  mapr(fimm, map(f, loc))