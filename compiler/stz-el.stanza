defpackage stz/el :
  import core
  import collections
  import stz/dl-ir
  import stz/el-ir
  import stz/utils

;============================================================
;========================= Lowering =========================
;============================================================

public defn lower (epackage:EPackage) -> EPackage :  
  ;Reset id generation
  take-ids(epackage)  
  
  ;Retrieve core types
  val iotable = IOTable(packageio(epackage))

  var cur-package:EPackage = epackage
  ensure-unique-identifiers!(cur-package)
  
  defn report (name:String) :
    ;println("===== %_ =====" % [name])
    ;println(cur-package)
    false

  within time-ms!("Map Methods") :
    cur-package = map-methods(cur-package)
  report("Mapped Methods")
  ensure-unique-identifiers!(cur-package)

  val global-vt = GlobalVarTable(cur-package)

  within time-ms!("Create Closures") :
    cur-package = create-closures(cur-package, global-vt)
  report("Created Closures")
  ensure-unique-identifiers!(cur-package)

  within time-ms!("Convert Mixes") :
    cur-package = convert-mixes(cur-package, global-vt)
  report("Converted Mixes")
  ensure-unique-identifiers!(cur-package)

  within time-ms!("Insert Guards") :
    cur-package = insert-guards(cur-package, global-vt, iotable)
  report("Inserted Guards")
  ensure-unique-identifiers!(cur-package)

  within time-ms!("Box Mutables") :
    cur-package = box-mutables(cur-package, global-vt, iotable)
  report("Boxed Mutables")
  ensure-unique-identifiers!(cur-package)

  within time-ms!("Lift Objects") :
    cur-package = lift-objects(cur-package, global-vt, iotable)
  report("Lifting Objects")
  ensure-unique-identifiers!(cur-package)

  within time-ms!("Lift Closures") :
    cur-package = lift-closures(cur-package, global-vt, iotable)
  report("Lifting Closures")
  ensure-unique-identifiers!(cur-package)

  within time-ms!("Lift Type Objects") :
    cur-package = lift-type-objects(cur-package)
  report("Reify Types")
  ensure-unique-identifiers!(cur-package)

  cur-package

;============================================================
;================= Sanity Check =============================
;============================================================

defn ensure-unique-identifiers! (epackage:EPackage) :
  ;Track used and nonused identifiers
  val idset = IntSet()
  val non-unique = IntSet()
  within id = used-ids(epackage) :
    if not add(idset, id) :
      add(non-unique, id)

  ;Issue errors
  if not empty?(non-unique) :
    fatal $ new Printable :
      defmethod print (o:OutputStream, this) :
        print(o, "The following identifiers are declared more than once: %," % [non-unique])
        print(o, "\nThe program is as follows:\n%_" % [epackage])

;============================================================
;====================== Unique IDs ==========================
;============================================================
defn take-ids (epackage:EPackage) :
  take-ids $ generate<Int> :
    used-ids(yield, epackage)

val TAKEN-IDS = IntSet()
var ID-COUNTER:Seq<Int> = to-seq(0 to false)

defn take-ids (ids:Seqable<Int>) :
  clear(TAKEN-IDS)
  add-all(TAKEN-IDS, ids)
  ID-COUNTER = to-seq(0 to false)
  
defn used-ids (return:Int -> ?, epackage:EPackage) :
  ;Overloading
  defn def (n:Int) : return(n)
  defn def (ns:Tuple<Int>) : do(return, ns)

  ;Look at imports
  for import in imports(packageio(epackage)) do :
    def(n(import))

  ;Look at definitions
  defn scan (e:ELItem) :
    do(scan, e)
    match(e) :
      ;Top Level
      (e:EDefGlobal) : def(n(e))
      (e:EDefn) : def(n(e))
      (e:EDefClosure) : (def(n(e)), def(closure(e)))
      (e:EDefmulti) : (def(n(e)), def(targs(e)))
      (e:EDefmethod) : def(n(e))
      (e:EDefStruct) : def(n(e))
      (e:EExternFn) : def(n(e))
      (e:EDefType) : def(n(e))
      (e:EDefObject) : def(n(e))
      (e:EDefTypeObject) : def(n(e))
      ;Locals
      (e:EFn) : (def(targs(e)), def(args(e)))
      (e:ELocal) : def(n(e))
      (e:ELocalType) : def(n(e))
      (e:ELocalFn) : def(n(e))
      (e:ELocalObj) : def(n(e))
      ;Remaining      
      (e) : false
  do(scan, exps(epackage))

;Generates a globally unique id.
defn uniqueid () -> Int :
  for i in ID-COUNTER find! :
    not TAKEN-IDS[i]

;============================================================
;================== Method TArg Mapping =====================
;============================================================

;INPUT:
;  input-xs: The type variables for the method.
;  targs: The types passed to the multi
;OUTPUT: [ys, ytypes]
;  ys: The new type variables for the method
;  xtypes: The values for the old input-xs, expressed in terms of ys.
defn inverse-solve (input-xs:Tuple<Int>, targs:Tuple<EType>) -> [Tuple<Int>, Tuple<EType>] :
  ;Created targs
  val ys = map(uniqueid{}, targs)

  ;Initialize solved table
  val solved = IntTable<ETVar>()
  ;Precise Solutions
  for (t in targs, y in ys) do :
    match(t:ETVar) : set?(solved, n(t), ETVar{y})
  ;Approximate Solutions
  for (t in targs, y in ys) do :
    let loop (t:EType = t) :
      match(t) :
        (t:ETVar) : set?(solved, n(t), ETVar{y})
        (t:EOr) : do*(loop, t)
        (t) : false
  ;Return solutions
  val solns = map(get?{solved, _, ETop()}, input-xs)
  [ys, solns]

defn replace-tvars (f:EFn, xs:Tuple<Int>, ys:Tuple<EType>) :
  val table = to-inttable<EType>(xs,ys)
  defn loop (x:EType) :
    match(x) :
      (x:ETVar) : get?(table, n(x), ETop())
      (x) : map(loop, x)
  map(loop, f)

defn map-methods (e:EPackage) :
  defn loop (x:ELBigItem) :
    map{loop, _} $ match(x) :
      (m:EDefmethod) :
        val [targs*, tvals] = inverse-solve(targs(func(m)), targs(m))
        val func* = sub-targs(replace-tvars(func(m), targs(func(m)), tvals), targs*)
        EDefmethod(n(m), multi(m), [], func*, lostanza?(m), transient?(m))
      (m:EMethod) :
        val [targs*, tvals] = inverse-solve(targs(func(m)), targs(m))
        val func* = sub-targs(replace-tvars(func(m), targs(func(m)), tvals), targs*)
        EMethod(multi(m), [], thisn(m), func*)
      (x) :
        x
  map(loop, e)

;============================================================
;===================== Body Buffer ==========================
;============================================================

deftype BodyBuffer
defmulti emit (b:BodyBuffer, x:ELocal|ELocalType|ELocalFn|ELocalObj|EIns) -> False
defmulti to-body (b:BodyBuffer, append-locals?:True|False, append-fns?:True|False, append-objs?:True|False) -> EBody

defn BodyBuffer (body:EBody) :
  val new-locals = Vector<ELocal>()
  val new-localtypes = Vector<ELocalType>()
  val new-localfns = Vector<ELocalFn>()
  val new-localobjs = Vector<ELocalObj>()
  val new-ins = Vector<EIns>()
  new BodyBuffer :
    defmethod emit (this, x:ELocal|ELocalType|ELocalFn|ELocalObj|EIns) :
      val xs = match(x) :
        (x:ELocal) : new-locals
        (x:ELocalType) : new-localtypes
        (x:ELocalFn) : new-localfns
        (x:ELocalObj) : new-localobjs
        (x:EIns) : new-ins
      add(xs, x)
    defmethod to-body (this, append-locals?:True|False, append-fns?:True|False, append-objs?:True|False) :
      defn append?<?T> (append?:True|False, xs:Tuple<?T>, ys:Vector<?T>) :      
        if not append? : to-tuple(ys)
        else if empty?(ys) : xs
        else : to-tuple(cat(xs,ys))
      val locals* = append?(append-locals?, locals(body), new-locals)
      val localtypes* = append?(append-locals?, localtypes(body), new-localtypes)
      val localfns* = append?(append-fns?, localfns(body), new-localfns)
      val localobjs* = append?(append-objs?, localobjs(body), new-localobjs)
      val ins* = to-tuple(new-ins)
      EBody(locals*, localtypes*, localfns*, localobjs*, ins*)

defn emit-all (b:BodyBuffer, xs:Seqable<ELocal|ELocalType|ELocalFn|ELocalObj|EIns>) :
  do(emit{b, _}, xs)

defn to-body (b:BodyBuffer) :
  to-body(b, true, true, true)

;============================================================
;=================== Closure Creation =======================
;============================================================
;TODO: Do not create closures for local functions
defn create-closures (epackage:EPackage, gvt:VarTable) -> EPackage :
  ;Retrieve an info from the given immediate
  defn first-info (f:EVar|ECurry|EMix) :
    match(f) :
      (f:EVar) : info(f)
      (f:ECurry) : info(x(f))
      (f:EMix) : find({_ is FileInfo}, seq(first-info, funcs(f)))
          
  ;Create a trampoline function that calls the given immediate
  ;with known arity.
  defn trampoline-fn (f:EVar|ECurry|EMix, arity:Int, vt:VarTable) :
    defn times<?T> (n:Int, f:() -> ?T) :
      to-tuple(repeatedly(f,n))
    val ret = uniqueid()
    val args = arity * uniqueid
    val [a1, a2] = match(f) :
      (f:EVar|ECurry) : fn-types(vt, f, arity)
      (f:EMix) : [arity * ETop, ETop()]
    val locals = [
      ELocal(ret, a2, false)]
    EFn([], args, arity * ETop, ETop(),
      EBody(locals, [], [], [], [
        ECall(EVarLoc(ret), f, map(EVar,args), CallGuarded(a1, a2), first-info(f))
        EReturn(EVar(ret))])
      false)

  ;Create a trampoline function that calls the given immediate
  ;with unknown (and potentially multiple) arities.
  defn trampoline-fn (f:EVar|ECurry|EMix, vt:VarTable) :
    ;Gather all branches
    val branches = Vector<KeyValue<Int,EVar|ECurry>>()
    let loop (f:EImm = f) :
      match(f) :
        (f:EVar) :
          for a in arities(vt,n(f)) do :
            add(branches, a => f)
        (f:ECurry) : 
          for a in arities(vt,n(x(f))) do :
            add(branches, a => f)
        (f:EMix) :
          do(loop, funcs(f))

    ;If there's only one
    if length(branches) == 1 :
      val b = branches[0]
      trampoline-fn(value(b), key(b), vt)
    else :
      EMultifn $ to-tuple $
        for group in group-by(key, value, branches) seq :
          trampoline-fn{_, key(group), vt} $
            switch(length(value(group))) :
              1 : head(value(group))
              else : EMix(to-tuple(value(group)))

  ;Lift all first-class functions in body
  defn analyze-body (body:EBody, vt:VarTable) :    
    ;New definitions
    val buffer = BodyBuffer(body)

    ;Lift a reference to a closure
    defn lift (x:EVar|ECurry|EMix) -> EVar :
      val v = uniqueid()
      emit(buffer, ELocalFn(v, trampoline-fn(x, vt)))
      emit(buffer, EInitClosures([EVarLoc(v)], first-info(x)))
      EVar(v)

    ;Analyze an immediate, lifting when necessary
    defn lift-imm (x:EImm) :
      match(x) :
        (x:EVar) : lift(x) when function?(vt,n(x)) else x
        (x:ECurry|EMix) : lift(x)
        (x) : x
    defn lift-imms (xs:Tuple<EImm>) :
      map(lift-imm, xs)

    ;Analyze all instructions
    for i in ins(body) do :
      emit{buffer, _} $ match(i) :
        (i:ECall|ETCall) : sub-ys(i, lift-imms(ys(i)))
        (i) : map(lift-imm, i)

    ;Return analyzed function
    to-body(buffer)

  ;Recursive Analysis
  defn analyze (x:ELBigItem, vt:VarTable) :
    match(map(analyze{_, vt},x)) :
      (x:EBody) : analyze-body(x, vt)
      (x) : x
  map-with-var-table({analyze(_, _) as ETExp}, gvt, epackage)

;============================================================
;===================== Mix Conversion =======================
;============================================================

public defn convert-mixes (epackage:EPackage, gvt:VarTable) :
  ;Analyze a given body
  defn analyze-body (body:EBody, vt:VarTable) :
    ;Create buffer
    val buffer = BodyBuffer(body)

    ;Split a call into a dispatch branch
    defn make-dispatch (Call:(EVarLoc|False, EImm, Tuple<EImm>, CallGuarded, False|FileInfo) -> EIns,
                        x:EVarLoc|False, f:EMix, ys:Tuple<EImm>, info:False|FileInfo, end?:True|False) :
      ;Construct branches and blocks
      val branches = Vector<EBranch>()
      val blocks = Vector<(() -> False)>()
      val refmask = map(reftype?, a1) where :
        val [a1, a2] = fn-types(vt, funcs(f)[0], length(ys))
      val end-lbl = uniqueid()
      for f in funcs(f) do :
        val [a1, a2] = fn-types(vt, f, length(ys))
        val lbl = uniqueid()
        add(branches, EBranch(select(a1,refmask), lbl, false))
        add{blocks, _} $ fn () :
          emit(buffer, ELabel(lbl))
          emit(buffer, Call(x, f, ys, CallGuarded(a1, a2), info))
          emit(buffer, EGoto(end-lbl)) when not end?
      ;Yield branches
      emit(buffer, EDispatch(select(ys,refmask), to-tuple(branches), info))
      for b in blocks do : b()
      emit(buffer, ELabel(end-lbl)) when not end?

    ;Scan through instructions
    for i in ins(body) do :
      ;Dispatch needed?
      val dispatch? = match(i:ECall|ETCall) : f(i) is EMix                        
      if dispatch? :
        match(i) :
          (i:ECall) :
            within (x, f, ys, g, info) = make-dispatch(x(i), f(i) as EMix, ys(i), info(i), false) :
              match(calltype(i):CallGuarded) : ECall(x, f, ys, g, info)
              else : ECall(x, f, ys, calltype(i), info)
          (i:ETCall) :
            within (_, f, ys, g, info) = make-dispatch(false, f(i) as EMix, ys(i), info(i), true) :
              match(calltype(i):CallGuarded) : ETCall(f, ys, g, info)
              else : ETCall(f, ys, calltype(i), info)
      else :
        emit(buffer, i)

    ;Yield new body
    to-body(buffer)

  ;Recursively analyze body
  defn analyze (x:ELBigItem, vt:VarTable) :
    match(map(analyze{_, vt}, x)) :
      (x:EBody) : analyze-body(x,vt)
      (x) : x
  map-with-var-table({analyze(_, _) as ETExp}, gvt, epackage)    

;============================================================
;===================== Boundary Guards ======================
;============================================================

public defn insert-guards (epackage:EPackage, gvt:VarTable, iotable:IOTable) :
  ;Insert guards for HiStanza body
  defn guard-histanza-body (body:EBody, prelude:Collection<EIns>, vt:VarTable) :
    ;Buffer for holding generated instructions
    val buffer = BodyBuffer(body)
    defn emit (i:EIns) : /emit(buffer,i)

    ;Buffer for holding label entrance guards
    val entry-blocks = IntTable<List<EIns>>(List())
    defn add-entry (b:Int, i:EIns) : update(entry-blocks, cons{i, _}, b)
    defn entry (b:Int) : reverse(entry-blocks[b])

    ;Add prelude
    do(emit, prelude)

    ;Check that all used variables have been set
    defn check-vars (x:EImm) :
      match(x) :
        (x:EVar) :
          if variable?(vt, n(x)) and (mutable?(vt, n(x)) or global?(vt, n(x))) :
            emit(ECheckSet(x, info(x)))
        (x) : false

    ;Emit instructions for checks
    for i in ins(body) do :
      do*(check-vars, i)
      match(i) :
        ;TODO: Fix boundary guards
        (i:ECall|ETCall) :
          val ct = match(calltype(i)) :
            (ct:CallGuarded) : CallStanza()
            (ct) : ct
          emit(sub-calltype(i, ct))
        (i:EDef) :
          match(y(i):EImm) :
            emit(ECheck(y(i) as EImm, type(vt, n(x(i))), info(i)))
          emit(i)
        (i:EStore) :
          val x = loc(i) as EVarLoc
          emit(ECheck(y(i), type(vt, n(x)), info(i)))
          emit(i)          
        (i:ELabel) :
          emit(i)
          do(emit, entry(n(i)))
        (i:EMatch|EDispatch) :
          for b in branches(i) do :
            for (t in types(b), y in ys(i)) do :
              add-entry(n(b), ECheck(y,t,info(b))) when has-tvar?(t)
          emit(remove-tvars(i))
        (i:ECheckLength) :
          emit(ECheck(y(i), EOf(n(iotable,CORE-TUPLE-ID)), info(i)))
          emit(i)
        (i) :
          emit(i)

    ;Return new body
    to-body(buffer)

  ;Transform instructions for LoStanza body
  defn analyze-lostanza-body (body:EBody) :
    val ins* = for i in ins(body) map :
      match(i) :
        (i:EMatch|EDispatch) :
          remove-tvars(i)
        (i:ECall|ETCall) :
          val ct* = match(calltype(i)) :
            (ct:CallGuarded) : CallStanza()
            (ct) : ct
          sub-calltype(i, ct*)
        (i) : i
    sub-ins(body, ins*)

  ;General analysis for bodies
  defn guard-bodies<?T> (e:?T&ELBigItem, histanza?:True|False, vt:VarTable) :
    defn loop (e:ELBigItem) :
      match(e) :
        (e:EBody) : 
          if histanza? : guard-histanza-body(e, [], vt)
          else : analyze-lostanza-body(e)
        (e) : map(loop, e)
    loop(e) as T&ELBigItem

  ;Analysis for Methods
  defn guard-method (f:EFn, histanza?:True|False, vt:VarTable) -> EFn :
    val a1* = map(remove-tvars,a1(f))
    val body* =
      if histanza? :
        val prelude = Vector<EIns>()
        for (x in args(f), t in a1(f)) do :
          add(prelude, ECheck(EVar(x),t,info(f))) when has-tvar?(t)
        guard-histanza-body(body(f), prelude, vt)
      else :
        analyze-lostanza-body(body(f))
    EFn(targs(f), args(f), a1*, a2(f), body*, info(f))

  ;Overall driver
  defn analyze (e:ELBigItem, vt:VarTable) -> ELBigItem :
    match(map(analyze{_, vt},e)) :
      (e:EDefmethod) : sub-func(e, guard-method(func(e), not lostanza?(e), vt))
      (e:EMethod) : sub-func(e, guard-method(func(e), true, vt))
      (e:EDefn) : guard-bodies(e, not lostanza?(e), vt)
      (e:EExternFn) : guard-bodies(e, false, vt)
      (e:ELocalFn) : guard-bodies(e, true, vt)
      (e:EInit) : guard-bodies(e, not lostanza?(e), vt)
      (e) : e
  map-with-var-table({analyze(_, _) as ETExp}, gvt, epackage)

;============================================================
;=================== Freevar Analysis =======================
;============================================================

defn analyze-freevars<?T> (el:ELBigItem&?T, vt:VarTable) -> T :
  defn analyze-usages (e:EFn) -> EFn :
    ;Gather all uses in the function
    val var-uses = IntSet()
    val tvar-uses = IntSet()

    defn loop (e:ELItem) :
      match(e) :
        (e:EVar|EVarLoc) :
          add(var-uses, n(e))
        (e:ETVar|ETVarLoc) :
          add(tvar-uses, n(e))
        (e:EFn) :
          val free = free(e)
          add-all(var-uses, vars(free))
          add-all(tvar-uses, tvars(free))
        (e) :
          do(loop, e)
    do(loop,e)

    ;Remove all locally defined quantities
    defn remove-all (xs:IntSet, ys:Seqable<Int>) : do(remove{xs, _}, ys)
    remove-all(tvar-uses, targs(e))
    remove-all(tvar-uses, seq(n, localtypes(body(e))))
    remove-all(var-uses, args(e))
    remove-all(var-uses, seq(n, locals(body(e))))
    remove-all(var-uses, seq(n, localfns(body(e))))

    ;Record free
    defn local? (x:Int) : not global?(vt,x)
    defn local? (xs:Seqable<Int>) : to-tuple(filter(local?,xs))
    sub-free(e, Free(local?(var-uses), to-tuple(tvar-uses)))

  ;Recursively analyze usages
  defn analyze (e:ELBigItem) :
    match(map(analyze, e)) :
      (e:EFn) : analyze-usages(e)
      (e) : e
  analyze(el) as ELBigItem&T

;============================================================
;===================== Mutable Boxing =======================
;============================================================

defn box-mutables (epackage:EPackage, gvt:VarTable, iotable:IOTable) -> EPackage :
  val boxed = IntSet()
  defn box (e:ELBigItem, vt:VarTable) -> ELBigItem :
    match(e) :
      (e0:EBody) :
        ;Find all closed-over variables
        val closed-over = IntSet()
        defn add-to-closed (e:ELBigItem) :
          match(e:EFn) : add-all(closed-over, vars(free(e)))
          else : do*(add-to-closed, e)
        do*(add-to-closed, e0)

        ;Add all locally closed-over mutable items to boxed set
        for l in locals(e0) do :
          if mutable?(l) and closed-over[n(l)] :
            add(boxed, n(l))

        ;Recursively analyze sub-bodies
        val e = map(box{_, vt}, e0)

        ;Perform boxing
        val buffer = BodyBuffer(e)

        ;Convert a boxed var retrieval into a BoxGet instruction
        defn retrieve-var (e:EImm) :
          match(e:EVar) :
            if boxed[n(e)] :
              val x = uniqueid()
              emit(buffer, ELocal(x, type(vt, n(e)), false))
              emit(buffer, EBoxGet(EVarLoc(x), e))
              EVar(x)
            else : e
          else : e

        ;Convert instructions for operating with boxed variables
        for i in ins(e) do :
          match(map(retrieve-var, i)) :
            (i:EDef) :
              if boxed[n(x(i))] : emit(buffer,EBox(x(i), y(i)))
              else : emit(buffer,i)
            (i:EStore) :
              match(loc(i)) :
                (x:EVarLoc) : box-store(x) when boxed[n(x)] else std-store()             
                (x) : std-store()
              where :
                defn box-store (x:EVarLoc) : emit(buffer,EBoxSet(EVar(n(x)), y(i)))
                defn std-store () : emit(buffer, i)
            (i) :
              emit(buffer,i)

        ;Change local types
        defn change-to-box-type (e:EBody) :
          val locals* = for x in locals(e) map :
            if boxed[n(x)] : ELocal(n(x), EOf(n(iotable,CORE-BOX-ID)), false)
            else : x
          sub-locals(e, locals*)

        ;Return new body
        change-to-box-type(to-body(buffer))
      (e) :
        map(box{_, vt}, e)

  ;Perform freevar analysis and then boxing
  within (texp, vt) = map-with-var-table(gvt, epackage) :
    box(analyze-freevars(texp, vt), vt) as ETExp

;============================================================
;=================== Object Lifting =========================
;============================================================

defn lift-objects (epackage:EPackage, gvt:VarTable, iotable:IOTable) -> EPackage :
  ;Buffer for new top level expressions
  val new-texps = Vector<ETExp>()

  ;Lift an instance method to the top level
  ;objfree contains the freevars stored in the object
  ;obj-n is the identifier of the EDefObject of the object declaration
  ;Returns the method id
  defn lift-method (obj-n:Int, m:EMethod, objfree:Free, vt:VarTable, transient?:True|False) -> Int :
    val fbody = body(func(m))
    val buffer = BodyBuffer(fbody)

    ;Track necessary renames
    val rename-table = IntTable<Int>()
    defn rename-var (v:Int) :
      val v* = uniqueid()
      rename-table[v] = v*
      v*

    ;Emit freevars for variables
    for v in vars(free(func(m))) do :
      val i = index-of(vars(objfree), v)
      match(i:Int) :
        val v* = rename-var(v)
        val t = EOf(n(iotable,CORE-FN-ID)) when function?(vt,v)
           else type(vt,v)               
        emit(buffer, ELocal(v*, t, false))
        emit(buffer, EObjectGet(EVarLoc(v*), EVar(thisn(m)), obj-n, i))
    ;Emit freetypes
    for v in tvars(free(func(m))) do :
      val i = index-of!(tvars(objfree), v)
      val v* = rename-var(v)
      emit(buffer, ELocalType(v*))
      emit(buffer, EObjectTGet(ETVarLoc(v*), EVar(thisn(m)), obj-n, i))

    ;Check that recursion has been done
    fatal("Objects not yet lifted!") when not empty?(localobjs(fbody))
    
    ;Emit renamed function and body
    for f in localfns(fbody) do :
      emit(buffer, rename-vars+tvars(f, rename-table))
    for i in ins(fbody) do :
      emit(buffer, rename-vars+tvars(i, rename-table))

    ;Push new method to top level
    val f = func(m)
    val a1* = to-tuple $
      for (x in args(f), t in a1(f)) seq :
        EOf(obj-n) when x == thisn(m) else remove-tvars(t)
    val a2* = remove-tvars(a2(f))
    val f* = EFn(targs(f), args(f), a1*, a2*, to-body(buffer, true, false, false), info(f))
    val method-id = uniqueid()
    add(new-texps, EDefmethod(method-id, multi(m), [], f*, false, transient?))
    method-id

  ;Sweep through the body and lift out declarations of local objects.
  defn lift-body (e:EBody, vt:VarTable, transient?:True|False) :
    ;For each object, which we will lift to obj-n:
    ;- calculate the freevars stored in the object
    ;- then generate the object declaration
    ;- then lift each instance method to the top level
    ;- then sweep through instructions and replace ENew with ENewObject

    ;Keep track of computed object freevars
    val objfree-table = IntTable<Free>()

    ;Lift each object
    for obj in localobjs(e) do :
      ;Compute object freevars
      val objfree = join-free(seq(free{func(_)}, methods(obj)))
      objfree-table[n(obj)] = objfree

      ;Lift instance methods
      val methods = map(lift-method{n(obj), _, objfree, vt, transient?}, methods(obj))

      ;Generate object declaration
      add(new-texps, EDefObject(n(obj), type(obj), ntargs, nargs, methods, transient?)) where :
        val ntargs = length(tvars(objfree))
        val nargs = length(vars(objfree))

    ;Generate new instructions
    val ins* = for i in ins(e) map :
      match(i:ENew) :
        val objfree = objfree-table[n(i)]
        val ys = map(EVar, vars(objfree))
        val targs = map(ETVar, tvars(objfree))
        ENewObject(x(i), n(i), targs, ys, info(i))
      else : i

    ;Return new body
    sub-localobjs{_, []} $
    sub-ins(e, ins*)

  ;Recursively analyze each body
  defn analyze (e:ELBigItem, vt:VarTable, transient?:True|False) -> ELBigItem :
    match(map(analyze{_, vt, transient?}, e)) :
      (e:EBody) : lift-body(e, vt, transient?)
      (e) : e
        
  val epackage* = within (texp, vt) = map-with-var-table(gvt, epackage) :
    val texp* = analyze-freevars(texp,vt)
    analyze(texp*, vt, transient?(texp*)) as ETExp
  sub-exps(epackage*, to-tuple(cat(exps(epackage*), new-texps)))

;============================================================
;=================== Closure Lifting ========================
;============================================================

defn lift-closures (epackage:EPackage, gvt:VarTable, iotable:IOTable) -> EPackage :
  ;Track new top level expressions
  val new-texps = Vector<ETExp>()

  ;Lift the given function with the computed free vars to the top-level.
  ;- Use closure as the identifier of the closure argument.
  ;- Write a recursive function to compute translated EFn.
  ;  - For every EFn:
  ;    - Retrieve the free variables from closure argument
  ;    - Retrieve the type variables from closure argument
  ;    - Rename all instructions, input types, and output types
  ;- Construct EDefClosure expression and add to top level.
  ;- Returns the identifier used for the DefClosure expression.
  defn lift-function (f:EFunction, fnfree:Free, vt:VarTable, transient?:True|False) -> Int :
    ;DefClosure identifier
    val fid = uniqueid()
    
    ;Closure argument
    val closure = uniqueid()

    ;Helper function for processing the body of an EFunction
    defn lift (e:ELBigItem) -> ELBigItem :
      match(e:EFn) :
        ;Track necessary renames
        val rename-table = IntTable<Int>()
        defn rename-var (v:Int) :
          val v* = uniqueid()
          rename-table[v] = v*
          v*

        ;Create buffer
        val buffer = BodyBuffer(body(e))

        ;Retrieve free variables from closure argument
        for v in vars(free(e)) do :
          val i = index-of(vars(fnfree), v)
          match(i:Int) :
            val v* = rename-var(v)
            val t = EOf(n(iotable,CORE-FN-ID)) when function?(vt,v)
               else type(vt,v)
            emit(buffer, ELocal(v*, t, false))
            emit(buffer, EClosureGet(EVarLoc(v*), EVar(closure), fid, i))

        ;Retrieve type variables from closure argument
        for v in tvars(free(e)) do :
          val i = index-of!(tvars(fnfree), v)
          val v* = rename-var(v)
          emit(buffer, ELocalType(v*))
          emit(buffer, EClosureTGet(ETVarLoc(v*), EVar(closure), fid, i))

        ;Check that recursion has been done
        fatal("Closures not yet lifted!") when not empty?(localfns(body(e)))
        fatal("Objects not yet lifted!") when not empty?(localobjs(body(e)))

        ;Emit renamed body
        for i in ins(body(e)) do :
          emit(buffer, rename-vars+tvars(i,rename-table))

        ;Return new function
        defn remove-nonlocal-tvars (t:EType) -> EType :
          match(t:ETVar) : ETop() when key?(rename-table,n(t)) else t
          else : map(remove-nonlocal-tvars, t)
        val a1* = map(remove-nonlocal-tvars, a1(e))
        val a2* = rename-vars+tvars(a2(e), rename-table)
        EFn(targs(e), args(e), a1*, a2*, to-body(buffer), info(e))
      else :
        map(lift, e)

    ;Construct EDefClosure and push to top level
    val ntargs = length(tvars(fnfree))
    val nargs = length(vars(fnfree))
    val func* = lift(f) as EFunction
    add(new-texps, EDefClosure(fid, closure, ntargs, nargs, func*, transient?))
    
    ;Return the DefClosure identifier
    fid

  ;Sweep through the body and lift out declarations of local functions
  ;- Lift each function to the top level
  ;- Sweep through instructions, and convert EInitClosures into ELetRec statements.
  ;  - Create each closure by looking up its freevars in free-table
  ;- Return new function
  ;  - The local functions are now empty, and moved over to local definitions
  ;  - Use the new instructions
  defn lift-body (e:EBody, vt:VarTable, transient?:True|False) :
    ;Track the freevars for each function
    val free-table = IntTable<Free>()
    
    ;Track the identifiers for each function
    val closureid-table = IntTable<Int>()

    ;Lift each function to the top level
    for f in localfns(e) do :
      ;Compute freevars
      val fnfree = match(func(f)) :
        (f:EFn) : free(f)
        (f:EMultifn) : join-free(seq(free, funcs(f)))
      free-table[n(f)] = fnfree
      ;Lift function
      closureid-table[n(f)] = lift-function(func(f), fnfree, vt, transient?)

    ;Generate new instructions
    val ins* = for i in ins(e) map :
      match(i) :
        (i:EInitClosures) :
          val closures = for x in xs(i) map :
            val free = free-table[n(x)]
            val closureid = closureid-table[n(x)]
            val targs = map(ETVar, tvars(free))
            val ys = map(EVar, vars(free))
            EClosure(closureid, targs, ys)
          ELetRec(xs(i), closures, info(i))
        (i) : i

    ;Return new function
    defn to-local (e:ELocalFn) : ELocal(n(e), EOf(n(iotable,CORE-FN-ID)), false)
    val locals* = to-tuple(cat(locals(e), seq(to-local, localfns(e))))
    EBody(locals*, localtypes(e), [], localobjs(e), ins*)

  defn analyze (e:ELBigItem, vt:VarTable, transient?:True|False) -> ELBigItem :
    match(map(analyze{_, vt, transient?},e)) :
      (e:EBody) : lift-body(e,vt,transient?)
      (e) : e
  val epackage* = within (texp, vt) = map-with-var-table(gvt, epackage) :
    val texp* = analyze-freevars(texp,vt)
    analyze(texp*, vt, transient?(texp*)) as ETExp
  sub-exps(epackage*, to-tuple(cat(exps(epackage*), new-texps)))

;============================================================
;================= Lifting Type Objects =====================
;============================================================

defn lift-type-objects (epackage:EPackage) :
  ;Store lifted types
  val type-table = HashTable<EType,EDefTypeObject>()

  ;Lift a type to the top level
  defn lift-type (t:EType, nargs:Int, transient?:True|False) :
    match(get?(type-table, t)) :
      (deft:EDefTypeObject) :
        ;Promote to persistent if requested
        if not transient? and /transient?(deft) :
          type-table[t] = sub-transient?(deft, false)
        n(deft)
      (_:False) :
        val n = uniqueid()
        type-table[t] = EDefTypeObject(n, nargs, t, transient?)
        n

  ;Reindex a type
  defn reindex (t:EType) -> [EType, Tuple<ETVar>] :  
    val table = IntTable<Int>()
    val tvars = Vector<Int>()
    val t* = let loop (t:EType = t) :
      match(t:ETVar) :
        if not key?(table, n(t)) :
          val i = length(tvars)
          table[n(t)] = i
          add(tvars, n(t))
        ETVar(table[n(t)])
      else : map(loop, t)
    [normalize(t*), to-tuple(seq(ETVar,tvars))]

  ;Lift all first-class types in body
  defn lift-body (e:EBody, transient?:True|False) :
    val buffer = BodyBuffer(e)

    ;Reify a type
    defn reify-type (t:EType) -> EType :
      match(t) :
        (t:ETVar) :
          t
        (t) :
          val [t*, tvars] = reindex(t)
          val n = lift-type(t*, length(tvars), transient?)
          val x = uniqueid()
          emit(buffer, ELocalType(x))
          emit(buffer, ETypeObject(ETVarLoc(x), n, tvars))
          ETVar(x)          
    defn reify-type (e:EImm) -> EImm :
      match(e:ECurry) : ECurry(x(e), map(reify-type,targs(e)))
      else : e
    defn reify-type (e:EClosure) :
      sub-targs(e, map(reify-type,targs(e)))

    ;Reify all type arguments in instructions
    for i in ins(e) do :
      emit{buffer, _} $ match(i) :
        (i:ECall|ETCall) : sub-f(i, reify-type(f(i)))
        (i:ELetRec) : sub-ys(i, map(reify-type,ys(i)))
        (i:ENewObject) : sub-targs(i, map(reify-type, targs(i)))
        (i) : i

    ;Return new body
    to-body(buffer)

  ;Recursively lift all bodies
  defn analyze (e:ELBigItem, transient?:True|False) -> ELBigItem :
    match(map(analyze{_, transient?},e)) :
      (e:EBody) : lift-body(e, transient?)
      (e) : e
  sub-exps(epackage, exps*) where :
    val analyzed-exps = for e in exps(epackage) map :
      analyze(e, transient?(e)) as ETExp
    val exps* = to-tuple(cat(analyzed-exps, values(type-table)))  

;============================================================
;====================== Type Table ==========================
;============================================================

public deftype DTypeTable
public defmulti to-etype (t:DTypeTable, d:DType, targs:Tuple<EType>) -> EType

public defn DTypeTable (io:PackageIO) :  
  val type-ids = HashTable<TypeId,Int>()
  for e in cat(imports(io), exports(io)) do :
    match(rec(e):TypeRec|StructRec|TypeDecl) :
      type-ids[id(rec(e)) as TypeId] = n(e)
  defn to-etype (d:DType, targs:Tuple<EType>) :
    defn conv (f:False) : false
    defn conv (ds:Tuple<DType>) : map(conv, ds)
    defn conv (d:DType) :
      match(d) :
        (d:DByte) : EByte()
        (d:DInt) : EInt()
        (d:DLong) : ELong()
        (d:DFloat) : EFloat()
        (d:DDouble) : EDouble()
        (d:DUnknown) : EUnknown()
        (d:DPtrT) : EPtrT()
        (d:DFnT) : EFnT(conv(a(d)), conv(r(d)), conv(b(d)))
        (d:DStructT) : EStructT(type-ids[id(d)])
        (d:DOf) : EOf(type-ids[id(d)])
        (d:DTVar) : targs[index(d)]
        (d:DCap) : conv(tvar(d))
        (d:DAnd) : reduce(EAnd, seq(conv, types(d)))
        (d:DOr) : reduce(EOr, seq(conv, types(d)))
        (d:DTop) : ETop()
        (d:DBot) : EBot()
        (d:DArrow) : EOf(type-ids[CORE-FN-ID])
        (d:DTuple) : EOf(type-ids[CORE-TUPLE-ID])
    conv(d)

  new DTypeTable :
    defmethod to-etype (this, d:DType, targs:Tuple<EType>) :
      to-etype(d, targs)

;============================================================
;======================== VarTable ==========================
;============================================================

;For representing entries to declared functions
deftype FnEntry
defstruct EFnEntry <: FnEntry :
  targs: Tuple<Int>
  a1: Tuple<EType>
  r: EType|False
  a2: EType
with:
  printer => true

defstruct DFnEntry <: FnEntry :
  ntargs: Int
  a1: Tuple<DType>
  r: DType|False
  a2: DType
with:
  printer => true

defstruct EMultifnEntry <: FnEntry :
  funcs: Tuple<EFnEntry>
with:
  printer => true

;For representing entries to declared variables
defstruct VarEntry :
  mutable?: True|False
  type: EType|DType
with:
  printer => true

;Basic table for holding VTEntry
deftype VarTable
defmulti get (e:VarTable, n:Int) -> VTRecord
defmulti type-table (e:VarTable) -> DTypeTable
defn VarTable (records:Seqable<VTRecord>, type-table:DTypeTable, parent:VarTable|False) :
  ;Initialize table, convert varentry if necessary
  val table = to-inttable<VTRecord> $
    for r in records seq :
      n(r) => match(entry(r)) :
        (e:VarEntry) :
          match(type(e)) :
            (t:DType) :
              val et = to-etype(type-table, t, [])
              sub-entry(r, VarEntry(mutable?(e), et))
            (t:EType) : r
        (e) : r
  new VarTable :
    defmethod get (this, n:Int) :
      match(get?(table, n), parent) :
        (r:VTRecord, p) : r
        (r:False, p:VarTable) : p[n]
        (r:False, p:False) : fatal("No entry for %_" % [n])
    defmethod type-table (this) :
      type-table

defstruct VTRecord :
  global?: True|False
  n: Int
  entry: FnEntry|VarEntry with: (updater => sub-entry)

;Convenience Functions
defn function? (vt:VarTable, n:Int) :
  entry(vt[n]) is FnEntry

defn variable? (vt:VarTable, n:Int) :
  entry(vt[n]) is VarEntry

defn global? (vt:VarTable, n:Int) :
  global?(vt[n])

defn mutable? (vt:VarTable, n:Int) :
  mutable?(entry(vt[n]) as VarEntry)

defn type (vt:VarTable, n:Int) :
  type(entry(vt[n]) as VarEntry) as EType

defn arities (vt:VarTable, n:Int) :
  match(entry(vt[n])) :
    (e:DFnEntry) : [length(a1(e))]
    (e:EFnEntry) : [length(a1(e))]
    (e:EMultifnEntry) : map(length{a1(_)}, funcs(e))  

;Retrieve the argument and return types of a function
defn fn-types (vt:VarTable, f:EVar|ECurry, arity:Int) :
  val [n, targs] = match(f) :
    (f:EVar) : [n(f), []]
    (f:ECurry) : [n(x(f)), targs(f)]

  let loop (e:FnEntry = entry(vt[n]) as FnEntry) :
    match(e) :
      (e:DFnEntry) :
        fatal("Incorrect type arity.") when ntargs(e) != length(targs)            
        fatal("Unexpected variable-arity function.") when r(e) is-not False
        val a1* = for t in a1(e) map :
          to-etype(type-table(vt), t, targs)
        val a2* = to-etype(type-table(vt), a2(e), targs)
        [a1*, a2*]
      (e:EFnEntry) :
        fatal("Incorrect type arity.") when length(/targs(e)) != length(targs)
        fatal("Unexpected variable-arity function.") when r(e) is-not False
        val table = to-inttable<EType>(/targs(e), targs)
        val a1* = map(sub-tvars{_, table}, a1(e))
        val a2* = sub-tvars(a2(e), table)
        [a1*, a2*]
      (e:EMultifnEntry) :
        loop(find!({length(a1(_)) == arity}, funcs(e)))      

defn GlobalVarTable (epackage:EPackage) -> VarTable :
  val type-table = DTypeTable(packageio(epackage))
  
  ;Find records
  val imported-records = for import in imports(packageio(epackage)) seq? :
    val e = match(rec(import)) :
      (r:FnRec|MultiRec|ExternFnRec) :
        val id = id(r) as FnId
        DFnEntry(ntargs(id) + ncargs(id), a1(id), false, a2(r))
      (r:ValRec) :
        VarEntry(mutable?(r), type(r))
      (r:ExternRec) :
        match(type(r)) :
          (t:DFnT) : DFnEntry(0, a(t), /r(t), b(t))
          (t) : VarEntry(true, type(r))
      (r) : false
    match(e:FnEntry|VarEntry) : One(VTRecord(true, n(import), e))
    else : None()
  val exported-records = for exp in exps(epackage) seq? :
    val [n, e] = match(exp) :
      (e:EDefn) : [n(e) FnEntry(func(e))]
      (e:EDefmulti) : [n(e), EFnEntry(targs(e), a1(e), false, a2(e))]
      (e:EExternFn) : [n(e), FnEntry(func(e))]
      (e:EDefGlobal) : [n(e), VarEntry(mutable?(e), type(e))]
      (e:EExtern) :
        match(type(e)) :
          (t:EFnT) : [n(e), EFnEntry([], a(t), r(t), b(t))]
          (t) : [n(e), VarEntry(true, type(e))]
      (e) : [0, false]
    match(e:FnEntry|VarEntry) : One(VTRecord(true, n, e))
    else : None()

  ;Return populated vartable
  VarTable(cat(imported-records, exported-records), type-table, false)

defn LocalVarTable (gvt:VarTable, e:ELBigItem) -> VarTable :
  ;Find records
  val records = generate<VTRecord> :
    defn found (n:Int, e:FnEntry|VarEntry) :
      yield(VTRecord(false, n, e))
    let loop (e:ELBigItem = e) :
      match(e) :
        (e:EFn) :
          for (x in args(e), t in a1(e)) do :
            found(x, VarEntry(false, t))
        (e:EBody) :
          for e in localfns(e) do :
            found(n(e), FnEntry(func(e)))
          for e in locals(e) do :
            found(n(e), VarEntry(mutable?(e), type(e)))
        (e) : false
      do*(loop, e)

  ;Return populated table
  VarTable(records, type-table(gvt), gvt)

defn FnEntry (e:EFunction) :
  match(e) :
    (e:EFn) : EFnEntry(targs(e), a1(e), false, a2(e))
    (e:EMultifn) : EMultifnEntry(map({FnEntry(_) as EFnEntry}, funcs(e)))

;============================================================
;====================== Utilities ===========================
;============================================================

;Join the sequence of Free structures.
defn join-free (fs:Seqable<Free>) :
  val var-set = IntSet()
  val tvar-set = IntSet()
  for f in fs do :
    add-all(var-set, vars(f))
    add-all(tvar-set, tvars(f))
  Free(to-tuple(var-set), to-tuple(tvar-set))

;Compute a local var table for each top level definition
defn map-with-var-table (f:(ETExp, VarTable) -> ETExp, gvt:VarTable, epackage:EPackage) :
  val exps* = for e in exps(epackage) map :
    f(e, LocalVarTable(gvt, e))
  sub-exps(epackage, exps*)

;Rename all variables and type variables
defn rename-vars+tvars<?T> (e:ELItem&?T, table:IntTable<Int>) -> T :
  defn rename (e:ELItem) :
    defn f (x:Int) : get?(table, x, x)
    match(map(rename,e)) :
      (e:EVar) : EVar(f(n(e)))
      (e:EVarLoc) : EVarLoc(f(n(e)))
      (e:ETVar) : ETVar(f(n(e)))
      (e:ETVarLoc) : ETVarLoc(f(n(e)))
      (e) : e
  rename(e) as ELItem&T

;Substitute tvars for types
defn sub-tvars (t:EType, table:IntTable<EType>) :
  let loop (t:EType = t) :
    match(t:ETVar) : get?(table, n(t), t)
    else : map(loop, t)

;Type variable removal
defn remove-tvars<?T> (e:ELItem&?T) :
  defn loop (e:ELItem) -> ELItem :
    match(e) :
      (e:ETVar) : ETop()
      (e:ELItem) : map(loop, e)
  loop(e) as ELItem&T

;Check whether type has type variable
defn has-tvar? (t:EType) :
  var tvar? = false
  let loop (t:EType = t) :
    match(t:ETVar) : tvar? = true
    else : do*(loop, t)
  tvar?

public defn select<?T> (xs:Tuple<?T>, mask:Tuple<True|False>) -> Tuple<T> :
  to-tuple(filter(xs, mask))