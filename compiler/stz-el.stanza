defpackage stz/el :
  import core
  import collections
  import stz/dl-ir
  import stz/el-ir
  import stz/ids
  import stz/built-ins with:
    prefix => VM-

;============================================================
;========================= Lowering =========================
;============================================================

public defn lower (packageio:PackageIO, epackage:EPackage) :
  println("===== PACKAGE IO =====")
  println(packageio)
  println("===== EPACKAGE =====")
  println(epackage)

  var cur-package:EPackage = epackage
  defn report (name:String) :
    println("===== %_ =====" % [name])
    println(cur-package)
  
  cur-package = map-methods(cur-package)
  report("Mapped Methods")
  
  val type-table = TypeTable(packageio)
  val function-table = FunctionTable(type-table, packageio, cur-package)
  cur-package = create-closures(function-table, cur-package)
  report("Created Closures")
  
  cur-package = convert-mixes(function-table, cur-package)
  report("Converted Mixes")
  
  val var-table = VarTable(type-table, packageio, cur-package)
  cur-package = insert-guards(var-table, cur-package)
  report("Inserted Guards")
  
  cur-package = box-mutables(VarTable(type-table, packageio, cur-package), cur-package)
  report("Boxed Mutables")

  cur-package = lift-objects(
                  VarTable(type-table, packageio, cur-package),
                  function-table,
                  cur-package)
  report("Lifting Objects")

;============================================================
;================== Consistency Check =======================
;============================================================

;============================================================
;================== Method TArg Mapping =====================
;============================================================

defn inverse-solve (input-xs:Tuple<Int>, targs:Tuple<EType>) -> [Tuple<Int>, Tuple<EType>] :
  ;Created targs
  val ys = map(fresh-id{}, targs)
  ;Initialize solved table
  val solved = IntTable<ETVar>()
  ;Precise Solutions
  for (t in targs, y in ys) do :
    match(t:ETVar) : set?(solved, n(t), ETVar{y})
  ;Approximate Solutions
  for (t in targs, y in ys) do :
    let loop (t:EType = t) :
      match(t) :
        (t:ETVar) : set?(solved, n(t), ETVar{y})
        (t:EOr) : do*(loop, t)
        (t) : false
  ;Return solutions
  val solns = map(get?{solved, _, ETop()}, input-xs)
  [ys, solns]

defn replace-tvars (f:EFn, xs:Tuple<Int>, ys:Tuple<EType>) :
  val table = to-inttable<EType>(xs,ys)
  defn loop (x:EType) :
    match(x) :
      (x:ETVar) : get?(table, n(x), ETop())
      (x) : map(loop, x)
  map(loop, f)

defn map-methods (e:EPackage) :
  defn loop (x:ELBigItem) :
    map{loop, _} $ match(x) :      
      (m:EDefmethod) :
        val [targs*, tvals] = inverse-solve(targs(func(m)), targs(m))
        val func* = sub-targs(replace-tvars(func(m), targs(func(m)), tvals), targs*)
        EDefmethod(n(m), multi(m), [], func*, lostanza?(m))
      (m:EMethod) :
        val [targs*, tvals] = inverse-solve(targs(func(m)), targs(m))
        val func* = sub-targs(replace-tvars(func(m), targs(func(m)), tvals), targs*)
        EMethod(multi(m), [], thisn(m), func*)
      (x) :
        x
  map(loop, e)

;============================================================
;====================== Type Table ==========================
;============================================================
deftype TypeTable
defmulti to-etype (t:TypeTable, d:DType, targs:Tuple<EType>) -> EType

defn TypeTable (io:PackageIO) :
  val type-ids = HashTable<TypeId,Int>()
  for e in cat(imports(io), exports(io)) do :
    match(rec(e):TypeRec|StructRec) :
      type-ids[id(rec(e)) as TypeId] = n(e)
  defn to-etype (d:DType, targs:Tuple<EType>) :
    defn conv (f:False) : false
    defn conv (ds:Tuple<DType>) : map(conv, ds)
    defn conv (d:DType) :
      match(d) :
        (d:DByte) : EByte()
        (d:DInt) : EInt()
        (d:DLong) : ELong()
        (d:DFloat) : EFloat()
        (d:DDouble) : EDouble()
        (d:DUnknown) : EUnknown()
        (d:DPtrT) : EPtrT(conv(type(d)))
        (d:DFnT) : EFnT(conv(a(d)), conv(r(d)), conv(b(d)))
        (d:DStructT) : EStructT(type-ids[id(d)])
        (d:DOf) : EOf(type-ids[id(d)])
        (d:DTVar) : targs[index(d)]
        (d:DAnd) : reduce(EAnd, seq(conv, types(d)))
        (d:DOr) : reduce(EOr, seq(conv, types(d)))
        (d:DTop) : ETop()
        (d:DBot) : EBot()
    conv(d)
         
  new TypeTable :
    defmethod to-etype (this, d:DType, targs:Tuple<EType>) :
      to-etype(d, targs)

;============================================================
;==================== Function Table ========================
;============================================================

deftype FnEntry
defstruct EFnEntry <: FnEntry :
  targs: Tuple<Int>
  a1: Tuple<EType>
  a2: EType
defstruct DFnEntry <: FnEntry :
  ntargs: Int
  a1: Tuple<DType>
  a2: DType
defstruct EMultifnEntry <: FnEntry :
  funcs: Tuple<EFnEntry>

deftype FunctionTable
defmulti register (t:FunctionTable, e:ELocalFn) -> False
defmulti function? (t:FunctionTable, n:Int) -> True|False
defmulti arity (t:FunctionTable, n:Int) -> Int
defmulti fn-types (t:FunctionTable, f:EVar|ECurry) -> [Tuple<EType>, EType]

defn FunctionTable (type-table:TypeTable, io:PackageIO, ep:EPackage) :
  val entries = IntTable<FnEntry>()

  ;Create entry
  defn FnEntry (e:EFunction) :
    match(e) :
      (e:EFn) : EFnEntry(targs(e), a1(e), a2(e))
      (e:EMultifn) : EMultifnEntry(map({FnEntry(_) as EFnEntry}, funcs(e)))

  ;Initialize table using global definitions
  for import in imports(io) do :
    val r = rec(import)
    match(r:FnRec|MultiRec) :
      val id = id(r) as FnId
      entries[n(import)] = DFnEntry(ntargs(id), a1(id), a2(r))
  for e in exps(ep) do :
    match(e) :
      (e:EDefn) :
        entries[n(e)] = FnEntry(func(e))
      (e:EDefmulti) :
        entries[n(e)] = EFnEntry(targs(e), a1(e), a2(e))
      (e) : false

  ;Retrieve the argument and return types of a function
  defn fn-types (f:EVar|ECurry) :
    val [n, targs] = match(f) :
      (f:EVar) : [n(f), []]
      (f:ECurry) : [n(x(f)), targs(f)]
    match(entries[n]) :
      (e:DFnEntry) :
        fatal("Incorrect type arity.") when ntargs(e) != length(targs)
        val a1* = for t in a1(e) map :
          to-etype(type-table, t, targs)
        val a2* = to-etype(type-table, a2(e), targs)
        [a1*, a2*]
      (e:EFnEntry) :
        fatal("Incorrect type arity.") when length(/targs(e)) != length(targs)
        val table = to-inttable<EType>(/targs(e), targs)
        val a1* = map(sub-tvars{_, table}, a1(e))
        val a2* = sub-tvars(a2(e), table)
        [a1*, a2*]

  new FunctionTable :
    defmethod register (this, e:ELocalFn) :
      entries[n(e)] = FnEntry(func(e))
    defmethod function? (this, n:Int) :
      key?(entries, n)
    defmethod arity (this, n:Int) :
      match(entries[n]) :
        (e:EFnEntry) : length(a1(e))
        (e:DFnEntry) : length(a1(e))
    defmethod fn-types (this, f:EVar|ECurry) :
      fn-types(f)

defn sub-tvars (t:EType, table:IntTable<EType>) :
  let loop (t:EType = t) :
    match(t:ETVar) : get?(table, n(t), t)
    else : map(loop, t)

;============================================================
;===================== Variable Table =======================
;============================================================

defstruct VarEntry :
  mutable?: True|False
  global?: True|False
  type: EType

deftype VarTable
defmulti register (vt:VarTable, e:ELocal) -> False
defmulti variable? (vt:VarTable, n:Int) -> True|False
defmulti mutable? (vt:VarTable, n:Int) -> True|False
defmulti global? (vt:VarTable, n:Int) -> True|False
defmulti type (vt:VarTable, n:Int) -> EType

defn VarTable (type-table:TypeTable, io:PackageIO, ep:EPackage) :
  val entries = IntTable<VarEntry>()
  for import in imports(io) do :
    match(rec(import)) :
      (r:ValRec) :
        entries[n(import)] = VarEntry(mutable?(r), true, to-etype(type-table, type(r), []))
      (r:ExternRec) :
        entries[n(import)] = VarEntry(true, true, to-etype(type-table, type(r), []))
      (r) : false
  for e in exps(ep) do :
    match(e) :
      (e:EDef) :
        entries[n(e)] = VarEntry(mutable?(e), true, type(e))
      (e:EExtern) :
        entries[n(e)] = VarEntry(true, true, type(e))
      (e) : false
  new VarTable :
    defmethod register (this, e:ELocal) :
      entries[n(e)] = VarEntry(mutable?(e), false, type(e))
    defmethod variable? (this, n:Int) : key?(entries,n)
    defmethod mutable? (this, n:Int) : mutable?(entries[n])
    defmethod global? (this, n:Int) : global?(entries[n])
    defmethod type (this, n:Int) : type(entries[n])

;============================================================
;===================== Body Buffer ==========================
;============================================================

deftype BodyBuffer
defmulti emit (b:BodyBuffer, x:ELocal|ELocalType|ELocalFn|ELocalObj|EIns) -> False
defmulti to-body (b:BodyBuffer) -> EBody

defn BodyBuffer (body:EBody) :
  val new-locals = Vector<ELocal>()
  val new-localtypes = Vector<ELocalType>()
  val new-localfns = Vector<ELocalFn>()
  val new-localobjs = Vector<ELocalObj>()
  val new-ins = Vector<EIns>()
  new BodyBuffer :
    defmethod emit (this, x:ELocal|ELocalType|ELocalFn|ELocalObj|EIns) :
      val xs = match(x) :
        (x:ELocal) : new-locals
        (x:ELocalType) : new-localtypes
        (x:ELocalFn) : new-localfns
        (x:ELocalObj) : new-localobjs
        (x:EIns) : new-ins
      add(xs, x)
    defmethod to-body (this) :
      defn append?<?T> (xs:Tuple<?T>, ys:Vector<?T>) :
        if empty?(ys) : xs
        else : to-tuple(cat(xs,ys))
      val locals* = append?(locals(body), new-locals)
      val localtypes* = append?(localtypes(body), new-localtypes)
      val localfns* = append?(localfns(body), new-localfns)
      val localobjs* = append?(localobjs(body), new-localobjs)
      val ins* = to-tuple(new-ins)
      EBody(locals*, localtypes*, localfns*, localobjs*, ins*)

defn emit-all (b:BodyBuffer, xs:Seqable<ELocal|ELocalType|ELocalFn|ELocalObj|EIns>) :
  do(emit{b, _}, xs)

;============================================================
;=================== Closure Creation =======================
;============================================================
defn create-closures (ft:FunctionTable, epackage:EPackage) -> EPackage :
  ;Create a trampoline function that calls the given immediate
  ;with known arity.
  defn trampoline-fn (f:EVar|ECurry|EMix, arity:Int) :
    defn times<?T> (n:Int, f:() -> ?T) :
      to-tuple(repeatedly(f,n))
    val ret = fresh-id()
    val args = arity * fresh-id
    val [a1, a2] = match(f) :
      (f:EVar|ECurry) : fn-types(ft, f)
      (f:EMix) : [arity * ETop, ETop()]    
    val locals = [
      ELocal(ret, ETop(), false)]
    EFn([], args, arity * ETop, ETop(),
      EBody(locals, [], [], [], [
        ECheckedDo(EVarLoc(ret), a2, f, map(EVar,args), a1)
        EReturn(EVar(ret))]))
      
  ;Create a trampoline function that calls the given immediate
  ;with unknown (and potentially multiple) arities.
  defn trampoline-fn (f:EVar|ECurry|EMix) :
    defn num-args (e:EVar|ECurry) :
      arity{ft, _} $ match(e) :
        (e:EVar) : n(e)
        (e:ECurry) : n(x(e))
    match(f) :
      (f:EVar|ECurry) :
        trampoline-fn(f, num-args(f))
      (f:EMix) :
        val funcs = to-tuple $
          for group in group-by(num-args, funcs(f)) seq :
            trampoline-fn{_, key(group)} $
              switch(length(value(group))) :
                1 : head(value(group))
                else : EMix(to-tuple(value(group)))
        EMultifn(funcs)
        
  ;Lift
  defn analyze-body (body:EBody) :    
    ;Register all local functions first
    do(register{ft, _}, localfns(body))

    ;New definitions
    val buffer = BodyBuffer(body)

    ;Lift a reference to a closure
    defn lift (x:EVar|ECurry|EMix) -> EVar :
      val v = fresh-id()
      emit(buffer, ELocalFn(v, trampoline-fn(x)))
      emit(buffer, EInitClosures([EVarLoc(v)]))
      EVar(v)

    ;Analyze an immediate, lifting when necessary
    defn lift-imm (x:EImm) :
      match(x) :
        (x:EVar) : lift(x) when function?(ft,n(x)) else x
        (x:ECurry|EMix) : lift(x)
        (x) : x
    defn lift-imms (xs:Tuple<EImm>) :
      map(lift-imm, xs)

    ;Analyze all instructions
    for i in ins(body) do :
      emit{buffer, _} $ match(i) :
        (i:ECheckedDo) : ECheckedDo(x(i), xtype(i), f(i), lift-imms(ys(i)), ytypes(i))
        (i:EDo) : EDo(x(i), xtype(i), f(i), lift-imms(ys(i)))
        (i) : map(lift-imm, i)

    ;Return analyzed function
    to-body(buffer)

  ;Recursive Analysis
  defn analyze (x:ELBigItem) :
    match(map(analyze,x)) :
      (x:EBody) : analyze-body(x)
      (x) : x
  map(analyze, epackage)


;============================================================
;===================== Mix Conversion =======================
;============================================================

public defn convert-mixes (ft:FunctionTable, epackage:EPackage) :
  ;Analyze a given body
  defn analyze-body (body:EBody) :
    ;Create buffer
    val buffer = BodyBuffer(body)

    ;Split a call into a dispatch branch
    defn make-dispatch (Do:(EType, EImm, Tuple<EImm>, Tuple<EType>) -> EIns, f:EMix, ys:Tuple<EImm>) :
      ;Construct branches and blocks
      val branches = Vector<EBranch>()
      val blocks = Vector<Tuple<EIns>>()
      val refmask = map(reftype?, a1) where :
        val [a1, a2] = fn-types(ft, funcs(f)[0])
      for f in funcs(f) do :
        val [a1, a2] = fn-types(ft, f)
        val lbl = fresh-id()
        add(branches, EBranch(select(a1,refmask), lbl))
        add(blocks, [
          ELabel(lbl)
          Do(a2, f, ys, a1)])
      ;Yield branches
      emit(buffer, EDispatch(select(ys,refmask), to-tuple(branches)))
      val end-lbl = fresh-id()
      for b in blocks do :
        emit-all(buffer, b)
        emit(buffer, EGoto(end-lbl))
      emit(buffer, ELabel(end-lbl))

    ;Scan through instructions
    for i in ins(body) do :
      ;Construct Do call
      defn Do (xtype:EType, f:EImm, ys:Tuple<EImm>, ytypes:Tuple<EType>) :
        match(i) :
          (i:ECheckedDo) : ECheckedDo(x(i), xtype, f, ys, ytypes)
          (i:EDo) : EDo(x(i), xtype, f, ys)
      ;Dispatch-on
      defn make-dispatch? (f:EImm, ys:Tuple<EImm>) :
        match(f:EMix) : make-dispatch(Do, f, ys)
        else : emit(buffer, i)        
      ;Analyze
      match(i) :
        (i:ECheckedDo) : make-dispatch?(f(i), ys(i))
        (i:EDo) : make-dispatch?(f(i), ys(i))
        (i) : emit(buffer, i)
        
    ;Yield new body
    to-body(buffer)

  ;Recursively analyze body
  defn analyze (x:ELBigItem) :
    match(map(analyze, x)) :
      (x:EBody) : analyze-body(x)
      (x) : x
  map(analyze, epackage)


;============================================================
;===================== Boundary Guards ======================
;============================================================

public defn insert-guards (vt:VarTable, epackage:EPackage) :
  ;Insert guards for HiStanza body
  defn guard-histanza-body (body:EBody, prelude:Collection<EIns>) :
    ;Buffer for holding generated instructions
    val buffer = BodyBuffer(body)
    defn emit (i:EIns) : /emit(buffer,i)

    ;Buffer for holding label entrance guards
    val entry-blocks = IntTable<List<EIns>>(List())
    defn add-entry (b:Int, i:EIns) : update(entry-blocks, cons{i, _}, b)
    defn entry (b:Int) : reverse(entry-blocks[b])

    ;Register locals
    do(register{vt, _}, locals(body))

    ;Add prelude    
    do(emit, prelude)

    ;Check that all used variables have been set
    defn check-vars (x:EImm) :
      match(x) :
        (x:EVar) :
          if mutable?(vt, n(x)) or global?(vt, n(x)) :
            emit(ECheckSet(x))
        (x) : false

    ;Emit instructions for checks
    for i in ins(body) do :
      do*(check-vars, i)
      match(i) :
        (i:ECheckedDo) :
          for (y in ys(i), t in ytypes(i)) do :
            emit(ECheck(y,t))
          emit(EDo(x(i), xtype(i), f(i), ys(i)))
          emit(ECheck(EVar(n(x(i))), xtype(i)))
        (i:ESet|EInit) :
          match(y(i):EImm) :
            emit(ECheck(y(i) as EImm, type(vt, n(x(i)))))
          emit(i)
        (i:ELabel) :
          emit(i)
          do(emit, entry(n(i)))
        (i:EMatch|EDispatch) :
          for b in branches(i) do :
            for (t in types(b), y in ys(i)) do :
              add-entry(n(b), ECheck(y,t)) when has-tvar?(t)
          emit(remove-tvars(i))
        (i:ECheckLength) : 
          emit(ECheck(y(i), EOf(VM-TUPLE-TYPE-ID)))
          emit(i)
        (i) :
          emit(i)

    ;Return new body
    to-body(buffer)

  ;Transform instructions for LoStanza body
  defn analyze-lostanza-body (body:EBody) :
    val ins* = for i in ins(body) map :
      match(i) :
        (i:EMatch|EDispatch) : remove-tvars(i)
        (i) : i
    sub-ins(body, ins*)

  ;Analysis for Methods
  defn guard-method (f:EFn, histanza?:True|False) -> EFn :
    val a1* = map(remove-tvars,a1(f))
    val body* = 
      if histanza? :
        val prelude = Vector<EIns>()
        for (x in args(f), t in a1(f)) do :
          add(prelude, ECheck(EVar(x),t)) when has-tvar?(t)
        guard-histanza-body(body(f), prelude)        
      else :
        analyze-lostanza-body(body(f))
    EFn(targs(f), args(f), a1*, a2(f), body*)

  ;Analysis for Functions
  defn guard-func (f:EFunction, histanza?:True|False) -> EFunction :
    defn loop (e:ELItem) -> ELItem :
      match(e) :
        (e:EBody) :
          if histanza? : guard-histanza-body(e, [])
          else : analyze-lostanza-body(e)
        (e) : map(loop, e)
    loop(f) as EFunction

  ;Overall driver
  defn analyze (e:ELBigItem) -> ELBigItem :
    match(map(analyze,e)) :
      (e:EDefmethod) : sub-func(e, guard-method(func(e), not lostanza?(e)))
      (e:EMethod) : sub-func(e, guard-method(func(e), true))
      (e:EDefn) : sub-func(e, guard-func(func(e), not lostanza?(e)))
      (e:EExternFn) : sub-func(e, guard-func(func(e), false) as EFn)
      (e:ELocalFn) : sub-func(e, guard-func(func(e), true))
      (e) : e
  map(analyze,epackage)


;============================================================
;=================== Freevar Analysis =======================
;============================================================

defn analyze-freevars<?T> (el:ELBigItem&?T) -> T :
  defn analyze-usages (e:EFn) -> EFn :
    ;Gather all uses in the function
    val var-uses = IntSet()
    val tvar-uses = IntSet()
        
    defn loop (e:ELItem) :
      match(e) :
        (e:EVar|EVarLoc) :
          add(var-uses, n(e))
        (e:ETVar|ETVarLoc) :
          add(tvar-uses, n(e))
        (e:EFn) :
          val free = free(e)
          add-all(var-uses, vars(free))
          add-all(tvar-uses, tvars(free))
        (e) :
          do(loop, e)
    do(loop,e)
    
    ;Remove all locally defined quantities
    defn remove-all (xs:IntSet, ys:Seqable<Int>) : do(remove{xs, _}, ys)
    remove-all(tvar-uses, targs(e))
    remove-all(tvar-uses, seq(n, localtypes(body(e))))
    remove-all(var-uses, args(e))
    remove-all(var-uses, seq(n, locals(body(e))))
    remove-all(var-uses, seq(n, localfns(body(e))))
    
    ;Record free
    sub-free(e, Free(to-tuple(var-uses), to-tuple(tvar-uses)))

  ;Recursively analyze usages
  defn analyze (e:ELBigItem) :
    match(map(analyze, e)) :
      (e:EFn) : analyze-usages(e)
      (e) : e
  analyze(el) as ELBigItem&T

;============================================================
;===================== Mutable Boxing =======================
;============================================================

defn box-mutables (vt:VarTable, epackage:EPackage) -> EPackage :
  val boxed = IntSet()
  defn box (e:ELBigItem) -> ELBigItem :
    match(e) :
      (e0:EBody) :
        ;Find all closed-over variables
        val closed-over = IntSet()
        defn add-to-closed (e:ELBigItem) :
          match(e:EFn) : add-all(closed-over, vars(free(e)))
          else : do*(add-to-closed, e)
        do*(add-to-closed, e0)

        ;Add all locally closed-over mutable items to boxed set
        for l in locals(e0) do :
          if mutable?(l) and closed-over[n(l)] :
            add(boxed, n(l))
            
        ;Recursively analyze sub-bodies
        val e = map(box, e0)

        ;Register local variables
        do(register{vt, _}, locals(e))

        ;Perform boxing
        val buffer = BodyBuffer(e)

        ;Convert a boxed var retrieval into a BoxGet instruction
        defn retrieve-var (e:EImm) :
          match(e:EVar) :
            if boxed[n(e)] :
              val x = fresh-id()
              emit(buffer, ELocal(x, type(vt, n(e)), false))
              emit(buffer, EBoxGet(EVarLoc(x), e))
              EVar(x)
            else : e
          else : e
        
        ;Convert instructions for operating with boxed variables
        for i in ins(e) do :
          match(map(retrieve-var, i)) :
            (i:EInit) :
              if boxed[n(x(i))] : emit(buffer,EBox(x(i), y(i)))
              else : emit(buffer,i)
            (i:ESet) :
              if boxed[n(x(i))] : emit(buffer,EBoxSet(EVar(n(x(i))), y(i)))
              else : emit(buffer,i)
            (i) :
              emit(buffer,i)

        ;Return new body
        to-body(buffer)
      (e) :
        map(box, e)

  ;Perform freevar analysis and then boxing
  map(box, analyze-freevars(epackage))

;============================================================
;=================== Object Lifting =========================
;============================================================

defn lift-objects (vt:VarTable, ft:FunctionTable, epackage:EPackage) -> EPackage :
  ;Buffer for new top level expressions
  val new-texps = Vector<ETExp>()

  ;Lift an instance method to the top level
  ;objfree contains the freevars stored in the object
  ;obj-n is the identifier of the EDefObject of the object declaration
  defn lift-method (obj-n:Int, m:EMethod, objfree:Free) :
    val fbody = body(func(m))
    val buffer = BodyBuffer(fbody)

    ;Track necessary renames
    val rename-table = IntTable<Int>()
    defn rename-var (v:Int) :
      val v* = fresh-id()
      rename-table[v] = v*
      v*
  
    ;Emit freevars for variables
    for v in vars(free(func(m))) do :
      val i = index-of(vars(objfree), v)
      match(i:Int) :
        val v* = rename-var(v)
        emit(buffer, EObjectGet(EVarLoc(v*), EVar(thisn(m)), i))
    ;Emit freetypes
    for v in tvars(free(func(m))) do :
      val i = index-of!(tvars(objfree), v)
      val v* = rename-var(v)
      emit(buffer, EObjectTGet(ETVarLoc(v*), EVar(thisn(m)), i))
    
    ;Emit renamed body
    defn rename (e:ELItem) :
      defn f (x:Int) : get?(rename-table, x, x)
      match(map(rename,e)) :
        (e:EVar) : EVar(f(n(e)))
        (e:EVarLoc) : EVarLoc(f(n(e)))
        (e:ETVar) : ETVar(f(n(e)))
        (e:ETVarLoc) : ETVarLoc(f(n(e)))
        (e) : e
    for i in ins(fbody) do :
      emit(buffer, rename(i) as EIns)
    
    ;Push new method to top level
    val f = func(m)
    val a1* = to-tuple $
      for (x in args(f), t in a1(f)) seq :
        EOf(obj-n) when x == thisn(m) else remove-tvars(t)
    val a2* = remove-tvars(a2(f))
    val f* = EFn(targs(f), args(f), a1*, a2*, to-body(buffer))
    add(new-texps, EDefmethod(fresh-id(), multi(m), [], f*, false))

  ;Given the sequence of freevars, combine them and
  ;return the locally free variables (excluding globals).
  defn locally-free (fs:Seqable<Free>) :
    val var-free = IntSet()
    val tvar-free = IntSet()
    for f in fs do :
      add-all(var-free, vars(f))
      add-all(tvar-free, tvars(f))
    defn local? (v:Int) : not global?(vt, v)
    Free(
      to-tuple(filter(local?, var-free))
      to-tuple(tvar-free))

  ;Sweep through the body and lift out declarations of local objects.
  defn lift-body (e:EBody) :
    ;For each object, which we will lift to obj-n:
    ;- calculate the freevars stored in the object
    ;- then generate the object declaration
    ;- then lift each instance method to the top level
    ;- then sweep through instructions and replace ENew with ENewObject
    
    ;Keep track of computed object freevars
    val objfree-table = IntTable<Free>()

    ;Lift each object
    for obj in localobjs(e) do :
      ;Compute object freevars
      val objfree = locally-free(seq(free{func(_)}, methods(obj)))
      objfree-table[n(obj)] = objfree
      
      ;Generate object declaration
      add(new-texps, EDefObject(n(obj), type(obj), ntargs, nargs)) where :
        val ntargs = length(tvars(objfree))
        val nargs = length(vars(objfree))
        
      ;Lift instance methods
      do(lift-method{n(obj), _, objfree}, methods(obj))

    ;Generate new instructions
    val ins* = for i in ins(e) map :
      match(i:ENew) :
        val objfree = objfree-table[n(i)]
        val ys = map(EVar, vars(objfree))
        val targs = map(ETVar, tvars(objfree))
        ENewObject(x(i), n(i), targs, ys)
      else : i
      
    ;Return new body
    sub-localobjs{_, []} $
    sub-ins(e, ins*)

  ;Recursively analyze each body
  defn analyze (e:ELBigItem) -> ELBigItem :
    match(map(analyze, e)) :
      (e:EBody) : lift-body(e)
      (e) : e
  map(analyze, epackage)

;============================================================
;====================== Utilities ===========================
;============================================================

;Type variable removal
defn remove-tvars<?T> (e:ELItem&?T) :
  defn loop (e:ELItem) -> ELItem :
    match(e) :
      (e:ETVar) : ETop()
      (e:ELItem) : map(loop, e)
  loop(e) as ELItem&T

;Check whether type has type variable
defn has-tvar? (t:EType) :
  var tvar? = false
  let loop (t:EType = t) :
    match(t:ETVar) : tvar? = true
    else : do*(loop, t)
  tvar?

public defn group-by<?T,?K,?V> (xkey:T -> ?K&Hashable&Equalable, xval:T -> ?V, xs:Seqable<?T>) :
  val table = HashTable<K,List<V>>(List())
  for x in xs do :
    update(table, cons{xval(x), _}, xkey(x))
  table

public defn group-by<?T,?K> (xkey:T -> ?K&Hashable&Equalable, xs:Seqable<?T>) :
  group-by(xkey, {_}, xs)

public defn select<?T> (xs:Tuple<?T>, mask:Tuple<True|False>) -> Tuple<T> :
  to-tuple(filter(xs, mask))