defpackage stz/proj :
  import core
  import collections
  import reader

;============================================================
;================== Stanza Project File =====================
;============================================================

public defstruct ProjFile :
  stmts: Tuple<ProjStmt>
with: (printer => true)

public deftype ProjStmt
public defmulti info (s:ProjStmt) -> FileInfo|False

public defstruct IncludeStmt <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  path: String
with: (printer => true)

public defstruct DefinedInStmt <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  package: Symbol
  filename: String
with: (printer => true)

public defstruct RequiresStmt <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  package: Symbol
  ccfiles: Maybe<ProjValue>
  ccflags: Maybe<ProjValue>
with: (printer => true)

public defstruct ImportWhenStmt <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  package: Symbol
  dependencies: Tuple<Symbol>
with: (printer => true)

public defstruct VMBindingsStmt <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  filename: String
  inputs: Tuple<String|Symbol>
with: (printer => true)

public defstruct BuildStmt <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  name: Symbol
  inputs: ProjValue
  pkg: Maybe<ProjValue>
  output: Maybe<ProjValue>
  assembly: Maybe<ProjValue>
  platform: Maybe<ProjValue>
  ccfiles: Maybe<ProjValue>
  ccflags: Maybe<ProjValue>
  flags: Maybe<ProjValue>
  extend: True|False
  optimize: True|False
with: (printer => true)

public deftype ProjValue
public defmulti info (s:ProjValue) -> FileInfo|False

public defstruct AtomValue <: ProjValue :
  info: FileInfo|False with: (as-method => true)
  value: String|Symbol
with: (printer => true)
public defstruct ProjValues <: ProjValue :
  info: FileInfo|False with: (as-method => true)
  values: Tuple<ProjValue>
with: (printer => true)
public defstruct CondPlatform <: ProjValue :
  info: FileInfo|False with: (as-method => true)
  values: Tuple<KeyValue<Symbol,ProjValue>>
with: (printer => true)

;============================================================
;======================= Reader =============================
;============================================================
public defn read-proj-file (filename:String) :
  parse-syntax[stanza-projfile / #projfile](read-file(filename))

;============================================================
;================= Project File Syntax ======================
;============================================================

defsyntax stanza-projfile :

  ;----------------------------------------------------------
  ;------------------- Main Productions ---------------------
  ;----------------------------------------------------------
  public defproduction projfile : ProjFile
  defproduction projstmt : ProjStmt
  defproduction projvalue: ProjValue

  defrule projfile = (?ss:#projstmt! ...) :
    ProjFile(to-tuple(ss))

  defrule projstmt = (include ?path:#string!) :
    IncludeStmt(closest-info(), path)

  defrule projstmt = (package ?package:#symbol! defined-in ?filename:#string!) :
    DefinedInStmt(closest-info(), package, filename)

  defrule projstmt = (package ?package:#symbol! requires #:! (?rs:#require! ...)) :
    RequiresStmt(closest-info(), package, entry?(rs, `ccfiles), entry?(rs, `ccflags))

  defrule projstmt = (import ?package:#symbol! when-imported (?deps:#symbol! ...)) :
    ImportWhenStmt(closest-info(), package, to-tuple(deps))

  defrule projstmt = (vmbindings ?filename:#string! generated-from #:! (?inputs:#symbol-or-string! ...)) :
    VMBindingsStmt(closest-info(), filename, to-tuple(inputs))

  defrule projstmt = (?extend?:#build-tag ?name:#symbol! #:! (?bs:#build-option! ...)) :
    within add-proj-file-info(closest-info()) :
      BuildStmt(closest-info(),
                name,
                entry!(bs, `inputs),
                entry?(bs, `pkg),
                entry?(bs, `o)
                entry?(bs, `s)
                entry?(bs, `platform)
                entry?(bs, `ccfiles)
                entry?(bs, `ccflags)
                entry?(bs, `flags)
                extend?
                entry?(bs, `optimize, false))

  defproduction build-tag: True|False
  defrule build-tag = (build) : false
  defrule build-tag = (extend) : true

  defrule projvalue = (on-platform #:! (?es:#platform-entry! ...)) :
    CondPlatform(closest-info(), to-tuple(es))
  defproduction platform-entry! : KeyValue<Symbol,ProjValue>
  defrule platform-entry! = (?platform:#symbol! #:! ?v:#projvalue!) : platform => v
  
  defrule projvalue = ((?v0:#projvalue ?vs:#projvalue! ...)) :
    if empty?(vs) : v0
    else : ProjValues(closest-info(), to-tuple(cons(v0,vs)))

  defrule projvalue = (?v:#symbol-or-string) :
    AtomValue(closest-info(), v)

  ;----------------------------------------------------------
  ;----------------- Require Statement Entries --------------
  ;----------------------------------------------------------
  defproduction require! : KeyValue<Symbol,ProjValue>
  defrule require! = (ccfiles #:! ?v:#projvalue!) : `ccfiles => v
  defrule require! = (ccflags #:! ?v:#projvalue!) : `ccflags => v
  fail-if require! = () : ProjFileError(closest-info(), "Expected a requirement entry here.")

  ;----------------------------------------------------------
  ;----------------- Build Option Entries -------------------
  ;----------------------------------------------------------
  defproduction build-option! : KeyValue<Symbol,?>
  defrule build-option! = (inputs #:! ?v:#projvalue!) : `inputs => v
  defrule build-option! = (pkg #:! ?v:#projvalue!) : `pkg => v
  defrule build-option! = (o #:! ?v:#projvalue!) : `o => v
  defrule build-option! = (s #:! ?v:#projvalue!) : `s => v
  defrule build-option! = (platform #:! ?v:#projvalue!) : `platform => v
  defrule build-option! = (ccfiles #:! ?v:#projvalue!) : `ccfiles => v
  defrule build-option! = (ccflags #:! ?v:#projvalue!) : `ccflags => v
  defrule build-option! = (flags #:! ?v:#projvalue!) : `flags => v
  defrule build-option! = (optimize) : `optimize => true

  ;----------------------------------------------------------
  ;--------------------- Error Productions ------------------
  ;----------------------------------------------------------
  defproduction projstmt! : ProjStmt  
  defproduction projvalue! : ProjValue

  defrule projstmt! = (?x:#projstmt) : x
  fail-if projstmt! = () : ProjFileError(closest-info(), "Expected a Stanza project statement here.")
  defrule projvalue! = (?x:#projvalue) : x
  fail-if projvalue! = () : ProjFileError(closest-info(), "Not a valid value.")

  defproduction :! : False
  defrule :! = (:) : false
  fail-if :! = () : ProjFileError(closest-info(), "Expected a colon here.")

  ;----------------------------------------------------------
  ;---------------------- Basics ----------------------------
  ;----------------------------------------------------------

  defn ut (x) : unwrap-token(x)
  
  public defproduction symbol: Symbol
  public defproduction string: String
  public defproduction char: Char
  public defproduction byte: Byte
  public defproduction int: Int
  public defproduction long: Long
  public defproduction float: Float
  public defproduction double: Double
  public defproduction symbol-or-string : Symbol|String

  public defproduction symbol!: Symbol
  public defproduction string!: String
  public defproduction char!: Char
  public defproduction byte!: Byte
  public defproduction int!: Int
  public defproduction long!: Long
  public defproduction float!: Float
  public defproduction double!: Double
  public defproduction symbol-or-string! : Symbol|String

  defrule symbol = (?x) when ut(x) is Symbol : ut(x)
  defrule string = (?x) when ut(x) is String : ut(x)
  defrule char = (?x) when ut(x) is Char : ut(x)
  defrule byte = (?x) when ut(x) is Byte : ut(x)
  defrule int = (?x) when ut(x) is Int : ut(x)
  defrule long = (?x) when ut(x) is Long : ut(x)
  defrule float = (?x) when ut(x) is Float : ut(x)
  defrule double = (?x) when ut(x) is Double : ut(x)
  defrule symbol-or-string = (?x) when ut(x) is Symbol|String : ut(x)

  defrule symbol! = (?x:#symbol) : x
  fail-if symbol! = () : ProjFileError(closest-info(), "Expected a symbol here.")
  defrule string! = (?x:#string) : x
  fail-if string! = () : ProjFileError(closest-info(), "Expected a string here.")
  defrule char! = (?x:#char) : x
  fail-if char! = () : ProjFileError(closest-info(), "Expected a char here.")
  defrule byte! = (?x:#byte) : x
  fail-if byte! = () : ProjFileError(closest-info(), "Expected a byte here.")
  defrule int! = (?x:#int) : x
  fail-if int! = () : ProjFileError(closest-info(), "Expected a int here.")
  defrule long! = (?x:#long) : x
  fail-if long! = () : ProjFileError(closest-info(), "Expected a long here.")
  defrule float! = (?x:#float) : x
  fail-if float! = () : ProjFileError(closest-info(), "Expected a float here.")
  defrule double! = (?x:#double) : x
  fail-if double! = () : ProjFileError(closest-info(), "Expected a double here.")
  defrule symbol-or-string! = (?x:#symbol-or-string) : x
  fail-if symbol-or-string! = () : ProjFileError(closest-info(), "Expected a symbol or string here.")

;============================================================
;===================== KeyValue Utilities ===================
;============================================================

defn entry?<?T> (es:Seqable<KeyValue<Symbol,?T>>, name:Symbol) :
  for e in es first :  
    One(value(e)) when key(e) == name else None()

defn entry?<?T> (es:Seqable<KeyValue<Symbol,?T>>, name:Symbol, default:?T) :
  val v = entry?(es, name)
  value?(v, default)  

defn entry!<?T> (es:Seqable<KeyValue<Symbol,?T>>, name:Symbol) :
  val v = entry?(es, name)
  if empty?(v) :
    throw(ProjFileError(false, to-string("No %_ entry given." % [name])))
  value!(v)

;============================================================
;======================= Errors =============================
;============================================================

public defstruct ProjFileError <: Exception :
  info: FileInfo|False
  msg: String
defmethod print (o:OutputStream, e:ProjFileError) :
  val info-str = "" when info(e) is False
            else "%_: " % [info(e)]
  print(o, "%_%_" % [info-str, msg(e)])

defn add-proj-file-info<?T> (f:() -> ?T, info:FileInfo|False) :
  try :
    f()
  catch (e:ProjFileError) :
    throw(ProjFileError(info, msg(e)))

;============================================================
;======================= Scratch ============================
;============================================================

defn main () :
  println $ read-proj-file("scratch/stanza.proj")

main()



