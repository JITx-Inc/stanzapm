defpackage stz/proj :
  import core
  import collections
  import reader
  import stz/params
  import stz/utils

;============================================================
;======================== Driver ============================
;============================================================

public defn read-proj-files (filenames:Seqable<String>, platform:Symbol) :
  combine $ for filename in filenames seq :
    flatten-relative-paths $
    normalize{_, platform} $
    traverse-includes{_, platform} $
    ensure-wellformed{_, platform} $
    read-raw-proj-file(filename)

;============================================================
;===== All Project Files by Default During Compilation ======
;============================================================

public defn default-proj-files () -> Vector<String> :
  val files = Vector<String>()
  add(files, string-join $ [STANZA-INSTALL-DIR, "/stanza.proj"])
  add-all(files, STANZA-PROJ-FILES)
  add(files, "stanza.proj") when file-exists?("stanza.proj")
  files

;============================================================
;================ Retrieve a Build Target ===================
;============================================================

public defn build-target (proj:ProjFile, target:Symbol) -> BuildStmt|False :
  for s in filter-by<BuildStmt>(stmts(proj)) find :
    name(s) == target

public defn build-target! (proj:ProjFile, target:Symbol) -> BuildStmt :
  val s = build-target(proj, target)
  match(s:BuildStmt) : s
  else : throw(ProjFileError(false, to-string("No build target named %~." % [target])))

;============================================================
;================== Stanza Project File =====================
;============================================================

public defstruct ProjFile :
  stmts: Tuple<ProjStmt>
with: (printer => true)

public deftype ProjStmt

public defstruct DefinedInStmt <: ProjStmt :
  package: Symbol
  filename: String
with: (printer => true)

public defstruct RequiresStmt <: ProjStmt :
  package: Symbol
  ccfiles: Tuple<String>
  ccflags: Tuple<String>
with: (printer => true)

public defstruct ImportWhenStmt <: ProjStmt :
  package: Symbol
  dependencies: Tuple<Symbol>
with: (printer => true)

public defstruct CompileStmt <: ProjStmt :
  file?: True|False
  name: String
  dependencies: Tuple<String>
  commands: Tuple<String>

public defstruct BuildStmt <: ProjStmt :
  name: Symbol
  inputs: Tuple<String|Symbol>
  supported-vm-packages: Tuple<String|Symbol>
  pkg: Maybe<String>
  output: Maybe<String>
  assembly: Maybe<String>
  ccfiles: Tuple<String>
  ccflags: Tuple<String>
  flags: Tuple<Symbol>
  optimize: True|False
with: (printer => true)

;============================================================
;==================== Staged AST ============================
;============================================================
defstruct ProjFileS0 :
  path: String
  full-path: String
  stmts: Tuple<ProjStmt>
with:
  printer => true

defmulti info (s:ProjStmt) -> FileInfo|False

defstruct IncludeStmtS0 <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  path: String
with: (printer => true)

defstruct IncludedStmtsS0 <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  path: String
  full-path: String
  stmts: Tuple<ProjStmt>
with: (printer => true)

defstruct DefinedInStmtS0 <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  package: Symbol
  filename: String
with: (printer => true)

defstruct RequiresStmtS0 <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  package: Symbol
  ccfiles: Maybe<ProjValue>
  ccflags: Maybe<ProjValue>
with: (printer => true)

defstruct ImportWhenStmtS0 <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  package: Symbol
  dependencies: Tuple<Symbol>
with: (printer => true)

defstruct CompileStmtS0 <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  file?: True|False
  name: String
  dependencies: Maybe<ProjValue>
  commands: ProjValue
with: (printer => true)

defstruct BuildStmtS0 <: ProjStmt :
  info: FileInfo|False with: (as-method => true)
  name: Symbol
  inputs: ProjValue
  supported-vm-packages: Maybe<ProjValue>
  pkg: Maybe<ProjValue>
  output: Maybe<ProjValue>
  assembly: Maybe<ProjValue>
  ccfiles: Maybe<ProjValue>
  ccflags: Maybe<ProjValue>
  flags: Maybe<ProjValue>
  optimize: True|False
with: (printer => true)

;------------------------------------------------------------
;--------------------- Values -------------------------------
;------------------------------------------------------------

deftype ProjValue
defmulti info (s:ProjValue) -> FileInfo|False

defstruct AtomValue <: ProjValue :
  info: FileInfo|False with: (as-method => true)
  value: String|Symbol
with: (printer => true)
defstruct ProjValues <: ProjValue :
  info: FileInfo|False with: (as-method => true)
  values: Tuple<ProjValue>
with: (printer => true)
defstruct CondPlatform <: ProjValue :
  info: FileInfo|False with: (as-method => true)
  values: Tuple<KeyValue<Symbol,ProjValue>>
with: (printer => true)

;============================================================
;======================= Reader =============================
;============================================================
defn read-raw-proj-file (filename:String) :
  val forms = read-file(filename)
  val stmts = parse-syntax[stanza-projfile / #projstmt! ...](forms)
  val full-path = resolve-path(filename) as String
  ProjFileS0(filename, full-path, to-tuple(stmts))

;============================================================
;================= Project File Syntax ======================
;============================================================

defsyntax stanza-projfile :

  ;----------------------------------------------------------
  ;------------------- Main Productions ---------------------
  ;----------------------------------------------------------
  defproduction projstmt : ProjStmt
  defproduction projvalue: ProjValue

  defrule projstmt = (include ?path:#string!) :
    IncludeStmtS0(closest-info(), path)

  defrule projstmt = (package ?package:#symbol! defined-in ?filename:#string!) :
    DefinedInStmtS0(closest-info(), package, filename)

  defrule projstmt = (package ?package:#symbol! requires #:! (?rs:#require! ...)) :
    RequiresStmtS0(closest-info(), package, entry?(rs, `ccfiles), entry?(rs, `ccflags))

  defrule projstmt = (import ?package:#symbol! when-imported (?deps:#symbol! ...)) :
    ImportWhenStmtS0(closest-info(), package, to-tuple(deps))

  defrule projstmt = (compile ?file?:#file? ?name:#string! ?dependencies:#dependencies #:! ?v:#projvalue!) :
    CompileStmtS0(closest-info(), file?, name, dependencies, v)
  defproduction file? : True|False
  defrule file? = (file) : true
  defrule file? = (flag) : false
  defproduction dependencies : Maybe<ProjValue>
  defrule dependencies = (from ?v:#projvalue!) : One(v)
  defrule dependencies = () : None()

  defrule projstmt = (build ?name:#symbol! #:! (?bs:#build-option! ...)) :
    within add-proj-file-info(closest-info()) :
      BuildStmtS0(closest-info(),
                  name,
                  entry!(bs, `inputs),
                  entry?(bs, `supported-vm-packages),
                  entry?(bs, `pkg),
                  entry?(bs, `o)
                  entry?(bs, `s)
                  entry?(bs, `ccfiles)
                  entry?(bs, `ccflags)
                  entry?(bs, `flags)
                  entry?(bs, `optimize, false))

  defrule projvalue = (on-platform #:! (?es:#platform-entry! ...)) :
    CondPlatform(closest-info(), to-tuple(es))
  defproduction platform-entry! : KeyValue<Symbol,ProjValue>
  defrule platform-entry! = (?platform:#symbol! #:! ?v:#projvalue!) : platform => v

  defrule projvalue = ((?v0:#projvalue ?vs:#projvalue! ...)) :
    if empty?(vs) : v0
    else : ProjValues(closest-info(), to-tuple(cons(v0,vs)))

  defrule projvalue = (?v:#symbol-or-string) :
    AtomValue(closest-info(), v)

  ;----------------------------------------------------------
  ;----------------- Require Statement Entries --------------
  ;----------------------------------------------------------
  defproduction require! : KeyValue<Symbol,ProjValue>
  defrule require! = (ccfiles #:! ?v:#projvalue!) : `ccfiles => v
  defrule require! = (ccflags #:! ?v:#projvalue!) : `ccflags => v
  fail-if require! = () : ProjFileError(closest-info(), "Expected a requirement entry here.")

  ;----------------------------------------------------------
  ;----------------- Build Option Entries -------------------
  ;----------------------------------------------------------
  defproduction build-option! : KeyValue<Symbol,?>
  defrule build-option! = (inputs #:! ?v:#projvalue!) : `inputs => v
  defrule build-option! = (supported-vm-packages #:! ?v:#projvalue!) : `supported-vm-packages => v
  defrule build-option! = (pkg #:! ?v:#projvalue!) : `pkg => v
  defrule build-option! = (o #:! ?v:#projvalue!) : `o => v
  defrule build-option! = (s #:! ?v:#projvalue!) : `s => v
  defrule build-option! = (ccfiles #:! ?v:#projvalue!) : `ccfiles => v
  defrule build-option! = (ccflags #:! ?v:#projvalue!) : `ccflags => v
  defrule build-option! = (flags #:! ?v:#projvalue!) : `flags => v
  defrule build-option! = (optimize) : `optimize => true

  ;----------------------------------------------------------
  ;--------------------- Error Productions ------------------
  ;----------------------------------------------------------
  public defproduction projstmt! : ProjStmt
  defproduction projvalue! : ProjValue

  defrule projstmt! = (?x:#projstmt) : x
  fail-if projstmt! = () : ProjFileError(closest-info(), "Expected a Stanza project statement here.")
  defrule projvalue! = (?x:#projvalue) : x
  fail-if projvalue! = () : ProjFileError(closest-info(), "Not a valid value.")

  defproduction :! : False
  defrule :! = (:) : false
  fail-if :! = () : ProjFileError(closest-info(), "Expected a colon here.")

  ;----------------------------------------------------------
  ;---------------------- Basics ----------------------------
  ;----------------------------------------------------------

  defn ut (x) : unwrap-token(x)

  public defproduction symbol: Symbol
  public defproduction string: String
  public defproduction char: Char
  public defproduction byte: Byte
  public defproduction int: Int
  public defproduction long: Long
  public defproduction float: Float
  public defproduction double: Double
  public defproduction symbol-or-string : Symbol|String

  public defproduction symbol!: Symbol
  public defproduction string!: String
  public defproduction char!: Char
  public defproduction byte!: Byte
  public defproduction int!: Int
  public defproduction long!: Long
  public defproduction float!: Float
  public defproduction double!: Double
  public defproduction symbol-or-string! : Symbol|String

  defrule symbol = (?x) when ut(x) is Symbol : ut(x)
  defrule string = (?x) when ut(x) is String : ut(x)
  defrule char = (?x) when ut(x) is Char : ut(x)
  defrule byte = (?x) when ut(x) is Byte : ut(x)
  defrule int = (?x) when ut(x) is Int : ut(x)
  defrule long = (?x) when ut(x) is Long : ut(x)
  defrule float = (?x) when ut(x) is Float : ut(x)
  defrule double = (?x) when ut(x) is Double : ut(x)
  defrule symbol-or-string = (?x) when ut(x) is Symbol|String : ut(x)

  defrule symbol! = (?x:#symbol) : x
  fail-if symbol! = () : ProjFileError(closest-info(), "Expected a symbol here.")
  defrule string! = (?x:#string) : x
  fail-if string! = () : ProjFileError(closest-info(), "Expected a string here.")
  defrule char! = (?x:#char) : x
  fail-if char! = () : ProjFileError(closest-info(), "Expected a char here.")
  defrule byte! = (?x:#byte) : x
  fail-if byte! = () : ProjFileError(closest-info(), "Expected a byte here.")
  defrule int! = (?x:#int) : x
  fail-if int! = () : ProjFileError(closest-info(), "Expected a int here.")
  defrule long! = (?x:#long) : x
  fail-if long! = () : ProjFileError(closest-info(), "Expected a long here.")
  defrule float! = (?x:#float) : x
  fail-if float! = () : ProjFileError(closest-info(), "Expected a float here.")
  defrule double! = (?x:#double) : x
  fail-if double! = () : ProjFileError(closest-info(), "Expected a double here.")
  defrule symbol-or-string! = (?x:#symbol-or-string) : x
  fail-if symbol-or-string! = () : ProjFileError(closest-info(), "Expected a symbol or string here.")

;============================================================
;===================== KeyValue Utilities ===================
;============================================================

defn entry?<?T> (es:Seqable<KeyValue<Symbol,?T>>, name:Symbol) :
  for e in es first :
    One(value(e)) when key(e) == name else None()

defn entry?<?T> (es:Seqable<KeyValue<Symbol,?T>>, name:Symbol, default:?T) :
  val v = entry?(es, name)
  value?(v, default)

defn entry!<?T> (es:Seqable<KeyValue<Symbol,?T>>, name:Symbol) :
  val v = entry?(es, name)
  if empty?(v) :
    throw(ProjFileError(false, to-string("No %_ entry given." % [name])))
  value!(v)

;============================================================
;============ Check Statements Under Platform ===============
;============================================================

defn ensure-wellformed (f:ProjFileS0, platform:Symbol) :
  val errors = Vector<ProjFileError>()
  defn emit-error (e:ProjFileError) : add(errors, e)

  defn check-for-errors (body:() -> ?) :
    val num-errors = length(errors)
    body()
    length(errors) > num-errors

  defn ensure-suffix! (info:FileInfo|False, path:String, suffix:String) :
    if not suffix?(path, suffix) :
      val msg = "Expected a %_ file here, but found %~." % [suffix path]
      emit-error $ ProjFileError(info, to-string(msg))

  defn ensure-stanza-file! (info:FileInfo|False, path:String) :
    val has-suffix? = any?(suffix?{path, _}, [".stanza" ".pkg" ".fpkg"])
    if not has-suffix? :
      val msg = "Expected a stanza input file here, but found %~." % [path]
      emit-error $ ProjFileError(info, to-string(msg))

  defn ensure-wellformed (type:Symbol, v:Maybe<ProjValue>) :
    ensure-wellformed(type,value!(v)) when not empty?(v)

  defn ensure-wellformed (type:Symbol, v:ProjValue) :
    ;Check whether platforms are supported in value
    defn check-platforms (v:ProjValue) :
      match(v) :
        (v:AtomValue) :
          false
        (v:ProjValues) :
          do(check-platforms, values(v))
        (v:CondPlatform) :
          ;First check keys are supported platforms or 'else'.
          val n = length(values(v))
          for (entry in values(v), i in 0 to false) do :
            if key(entry) == `else :
              if i != n - 1 :
                emit-error $ ProjFileError(info(v), "The 'else' keyword can only be used as last entry in list.")
            else :
              if not supported-platform?(key(entry)) :
                emit-error $ ProjFileError(info(v), to-string("'%~' does not refer to a supported platform." % [key(entry)]))
          ;Check whether given platform is supported.
          val platform-supported? =
            for entry in values(v) any? :
              key(entry) == `else or key(entry) == platform
          if not platform-supported? :
            emit-error $ ProjFileError(info(v), to-string("There is no available option for the current platform %~." % [platform]))
          ;Then recurse
          do(check-platforms{value(_)}, values(v))

    ;Flatten values into a single vector of atoms
    defn flatten (v:ProjValue) :
      val buffer = Vector<AtomValue>()
      let loop (v:ProjValue = v) :
        match(v) :
          (v:AtomValue) :
            add(buffer, v)
          (v:ProjValues) :
            do(loop, values(v))
          (v:CondPlatform) :
            val v0 = for entry in values(v) first! :
              if key(entry) == `else or key(entry) == platform : One(value(entry))
              else : None()
            loop(v0)
      buffer

    ;Launch!
    val platform-errors? = check-for-errors(check-platforms{v})
    if not platform-errors? :
      val atoms = flatten(v)
      switch(type) :
        `strings :
          for v in atoms do :
            if value(v) is-not String :
              emit-error $ ProjFileError(info(v), to-string("Expected a string here, but received symbol %~." % [value(v)]))
        `symbols :
          for v in atoms do :
            if value(v) is-not Symbol :
              emit-error $ ProjFileError(info(v), to-string("Expected a symbol here, but received string %~." % [value(v)]))
        `stanza-inputs :
          for v in atoms do :
            match(value(v)) :
              (value:String) : ensure-stanza-file!(info(v), value)
              (value:Symbol) : false
        `string :
          if length(atoms) != 1 :
            emit-error $ ProjFileError(info(v), to-string("Expected a single string here, but received %_ values." % [length(atoms)]))
          else :
            val v = atoms[0]
            if value(v) is-not String :
              emit-error $ ProjFileError(info(v), to-string("Expected a string here, but received symbol %~." % [value(v)]))

  defn ensure-no-duplicates<?T> (error:(T, T) -> ProjFileError, key:T -> ?, stmts:Seqable<?T>) :
    for group in group-by(key, stmts) do :
      if length(value(group)) > 1 :
        val vs = reverse(value(group))
        val v0 = head(vs)
        for v in tail(vs) do :
          emit-error(error(v0, v))

  ;Scan through all statements
  for s in stmts(f) do :
    match(s) :
      (s:IncludeStmtS0) :
        ensure-suffix!(info(s), path(s), ".proj")
      (s:DefinedInStmtS0) :
        ensure-suffix!(info(s), filename(s) ".stanza")
      (s:RequiresStmtS0) :
        ensure-wellformed(`strings, ccfiles(s))
        ensure-wellformed(`strings, ccflags(s))
      (s:ImportWhenStmtS0) :
        false
      (s:CompileStmtS0) :
        ensure-wellformed(`strings, dependencies(s))
        ensure-wellformed(`strings, commands(s))
      (s:BuildStmtS0) :
        ensure-wellformed(`stanza-inputs, inputs(s))
        ensure-wellformed(`stanza-inputs, supported-vm-packages(s))
        ensure-wellformed(`string, pkg(s))
        ensure-wellformed(`string, output(s))
        ensure-wellformed(`string, assembly(s))
        ensure-wellformed(`strings, ccfiles(s))
        ensure-wellformed(`strings, ccflags(s))
        ensure-wellformed(`symbols, flags(s))

  ;Check for duplicate statements
  within (s0,s1) = ensure-no-duplicates(path, filter-by<IncludeStmtS0>(stmts(f))) :
    ProjFileError(info(s1), to-string $ "Duplicate include statement for file %~. Earlier statement at %_." % [
      path(s1), info(s0)])
  within (s0,s1) = ensure-no-duplicates(package, filter-by<DefinedInStmtS0>(stmts(f))) :
    ProjFileError(info(s1), to-string $ "Duplicate defined-in statement for package %_. Earlier statement at %_." % [
      package(s1), info(s0)])
  within (s0,s1) = ensure-no-duplicates(package, filter-by<RequiresStmtS0>(stmts(f))) :
    ProjFileError(info(s1), to-string $ "Duplicate requires statement for package %_. Earlier statement at %_." % [
      package(s1), info(s0)])
  within (s0,s1) = ensure-no-duplicates(name, filter-by<CompileStmtS0>(stmts(f))) :
    ProjFileError(info(s1), to-string $ "Duplicate compile statement for file %~. Earlier statement at %_." % [
      name(s1), info(s0)])
  within (s0,s1) = ensure-no-duplicates(name, filter-by<BuildStmtS0>(stmts(f))) :
    ProjFileError(info(s1), to-string $ "Duplicate build definition for target %~. Earlier definition at %_." % [
      name(s1), info(s0)])

  ;Throw exception if any errors
  throw(ProjFileErrors(errors)) when not empty?(errors)
  ;Return file unchanged
  f

;============================================================
;================== Traverse Includes =======================
;============================================================

defn traverse-includes (f:ProjFileS0, platform:Symbol) :
  defn process (s:ProjStmt, parent-paths:List<IncludePath>) :
    match(s:IncludeStmtS0) :
      val parent-path = head(parent-paths)
      val full-path = include-path $
        if relative-path?(path(s)) : replace-path-head(path(parent-path), path(s))
        else : path(s)
      if not exists?(full-path) :
        throw(CannotFindIncludeProj(info(s), path(parent-path), path(full-path)))
      else if included?(parent-paths, full-path) :
        throw(IncludeCycle(info(s), path(full-path), map(path,parent-paths)))
      else :
        included-stmts(cons(full-path, parent-paths), info(s))
    else :
      s
  defn included-stmts (parent-paths:List<IncludePath>, info:FileInfo|False) :
    val ipath = head(parent-paths)
    val file = ensure-wellformed(read-raw-proj-file(path(ipath)), platform)
    val stmts* = map(process{_, parent-paths}, stmts(file))
    IncludedStmtsS0(info, path(ipath), full-path(ipath) as String, stmts*)

  ;Launch!
  val path* = include-path(path(f))
  fatal("Project file no longer resolvable.") when not exists?(path*)
  val stmts* = map(process{_, List(path*)}, stmts(f))
  ProjFileS0(path(f), full-path(f), stmts*)

defstruct IncludePath :
  path: String
  full-path: String|False

defn include-path (path:String) :
  IncludePath(path, resolve-path(path))

defn exists? (p:IncludePath) :
  full-path(p) is String

defn included? (paths:List<IncludePath>, p:IncludePath) :
  for p1 in paths any? :
    full-path(p1) == full-path(p)

defn absolute-path? (path:String) :
  prefix?(path, "/")

defn relative-path? (path:String) :
  not absolute-path?(path)

defn replace-path-head (path:String, head:String) :
  val i = last-index-of-char(path, '/')
  match(i:Int) : string-join $ [path[0 through i], head]
  else : head

defn remove-path-head (path:String) :
  val i = last-index-of-char(path, '/')
  match(i:Int) : path[0 to i]
  else : "."

;============================================================
;============ Normalize Statements Under Platform ===========
;============================================================

defn normalize (f:ProjFileS0, current-platform:Symbol) :
  defn norm (s:ProjStmt) :
    match(s) :
      (s:IncludedStmtsS0) :
        val stmts* = map(norm, stmts(s))
        IncludedStmtsS0(info(s), path(s), full-path(s), stmts*)
      (s:DefinedInStmtS0) :
        DefinedInStmt(package(s), filename(s))
      (s:RequiresStmtS0) :
        RequiresStmt(package(s),
                     tuple?(strings{norm(_)}, ccfiles(s)),
                     tuple?(strings{norm(_)}, ccflags(s)))
      (s:ImportWhenStmtS0) :
        ImportWhenStmt(package(s), dependencies(s))
      (s:CompileStmtS0) :
        CompileStmt(file?(s),
                    name(s),
                    tuple?(strings{norm(_)}, dependencies(s)),
                    strings(norm(commands(s))))
      (s:BuildStmtS0) :
        BuildStmt(name(s),
                  strings-or-symbols(norm(inputs(s))),
                  tuple?(strings-or-symbols{norm(_)}, supported-vm-packages(s)),
                  maybe?(string{norm(_)}, pkg(s)),
                  maybe?(string{norm(_)}, output(s)),
                  maybe?(string{norm(_)}, assembly(s)),
                  tuple?(strings{norm(_)}, ccfiles(s)),
                  tuple?(strings{norm(_)}, ccflags(s)),
                  tuple?(symbols{norm(_)}, flags(s)),
                  optimize(s))
  defn norm (v:ProjValue) :
    match(v) :
      (v:AtomValue) :
        v
      (v:ProjValues) :
        ProjValues(info(v), map(norm, values(v)))
      (v:CondPlatform) :
        val v* = for e in values(v) first :
          if key(e) == current-platform or key(e) == `else :
            One(norm(value(e)))
          else : None()
        value!(v*)

  ;Remove ProjValues nested within ProjValues
  defn flatten (v:ProjValue) -> ProjValue :
    match(v) :
      (v:AtomValue) :
        v
      (v:ProjValues) :
        val accum = Vector<AtomValue>()
        let loop (v:ProjValue = v) :
          match(v) :
            (v:AtomValue) : add(accum,v)
            (v:ProjValues) : do(loop, values(v))
        ProjValues(info(v), to-tuple(accum))

  ;Convert to primitive types
  defn strings (v:ProjValue) -> Tuple<String> :
    match(flatten(v)) :
      (v:AtomValue) : [string(v)]
      (v:ProjValues) : map(string, values(v))
  defn symbols (v:ProjValue) -> Tuple<Symbol> :
    match(flatten(v)) :
      (v:AtomValue) : [symbol(v)]
      (v:ProjValues) : map(symbol, values(v))
  defn strings-or-symbols (v:ProjValue) -> Tuple<String|Symbol> :
    match(flatten(v)) :
      (v:AtomValue) : [value(v)]
      (v:ProjValues) : map(value{_ as AtomValue}, values(v))
  defn string (v:ProjValue) -> String :
    value(v as AtomValue) as String
  defn symbol (v:ProjValue) -> Symbol :
    value(v as AtomValue) as Symbol

  ;Launch!
  ProjFileS0(path(f), full-path(f), map(norm,stmts(f)))

;============================================================
;=============== Flatten Relative Paths =====================
;============================================================
defn flatten-relative-paths (f:ProjFileS0) :
  ;Compute working directory
  val workdir = resolve-path(".") as String

  ;Accumulate flattened statements
  val accum = Vector<ProjStmt>()
  defn emit (s:ProjStmt) : add(accum,s)

  ;Accumulate errors
  val errors = Vector<Exception>()

  ;Replace environment variables in string
  defn no-var! (proj-file:String) :
    fn (name:String) :
      val msg = "Could not resolve environment variable %_ in %~." % [name, proj-file]
      add(errors, ProjFileError(false, to-string(msg)))
      fail()
  defn sub-env-vars (s:String, proj-file:String, proj-dir:String) -> String :
    attempt : substitute-environment-vars(s, workdir, proj-dir, no-var!(proj-file))
    else : s
  defn sub-env-lists (s:String, proj-file:String, proj-dir:String) -> Tuple<String> :
    attempt : substitute-environment-lists(s, workdir, proj-dir, no-var!(proj-file))
    else : [s]

  ;Process statement and sub-statements and push into accumulator.
  defn process (s:ProjStmt, parent-path:String, parent-full-path:String) :
    val parent-dir = remove-path-head(parent-full-path)

    ;Substitute variables in given string
    defn sub-vars (s:String) -> String :
      sub-env-vars(s, parent-path, parent-dir)
    ;Substitute lists in given strings
    defn sub-lists (ss:Tuple<String>) -> Tuple<String> :
      to-tuple $ for s in ss seq-cat :
        sub-env-lists(s, parent-path, parent-dir)

    ;Given that s is a filename, add a prefix so it
    ;such that it is relative to the correct directory.
    defn add-prefix-to-path (s:String) :
      if absolute-path?(s) : s
      else : replace-path-head(parent-path, s)

    ;Substitute all variables and add prefix.
    defn flatten-path (s:String) -> String :
      add-prefix-to-path(sub-vars(s))

    ;Substitute all variables and add prefix.
    defn flatten-paths (ss:Tuple<String>) -> Tuple<String> :
      map(add-prefix-to-path, sub-lists(ss))

    ;Substitute all variables and add prefix
    defn flatten-inputs (ss:Tuple<String|Symbol>) -> Tuple<String|Symbol> :
      to-tuple $ for s in ss seq-cat :
        match(s:String) : sub-env-lists(s, parent-path, parent-dir)
        else : [s]      

    match(s) :
      (s:IncludedStmtsS0) :
        do(process{_, path(s), full-path(s)}, stmts(s))
      (s:DefinedInStmt) :
        emit $ DefinedInStmt(package(s), flatten-path(filename(s)))
      (s:RequiresStmt) :
        emit $ RequiresStmt(package(s),
                            flatten-paths(ccfiles(s)),
                            sub-lists(ccflags(s)))
      (s:ImportWhenStmt) :
        emit $ s
      (s:CompileStmt) :
        val name* = flatten-path(name(s)) when file?(s)
               else sub-vars(name(s))
        emit $ CompileStmt(file?(s),
                           name*,
                           flatten-paths(dependencies(s))
                           map(sub-vars,commands(s)))
      (s:BuildStmt) :
        emit $ BuildStmt(
          name(s)
          flatten-inputs(inputs(s))
          flatten-inputs(supported-vm-packages(s))
          maybe?(flatten-path,pkg(s))
          maybe?(flatten-path,output(s))
          maybe?(flatten-path,assembly(s))
          flatten-paths(ccfiles(s))
          sub-lists(ccflags(s))
          flags(s)
          optimize(s))

  ;Launch!
  do(process{_, path(f), full-path(f)}, stmts(f))

  ;Throw errors
  throw(ProjFileErrors(errors)) when not empty?(errors)

  ;Return new project file
  ProjFile(to-tuple(accum))

;============================================================
;================= Substitution Utilities ===================
;============================================================

defstruct Separator
defn replace-curly (f:String -> Collection<String>, s:String) -> Tuple<String> :
  if index-of-char(s, '{') is False :
    [s]
  else :
    ;Add strings to buffer
    val char-buffer = StringBuffer()
    val buffer = Vector<String>()
    defn flush-char-buffer () :
      add(buffer, to-string(char-buffer))
      clear(char-buffer)
    defn add-item (s:String|Separator) :
      match(s) :
        (s:String) : add-all(char-buffer, s)
        (s:Separator) : flush-char-buffer()

    ;Iterate through the curlies
    let loop (start:Int = 0) :
      val [i, j] = let :
        val i = index-of-char(s, start to false, '{')
        match(i:Int) :
          [i, index-of-char(s, (i + 1) to false, '}')]
        else : [i, false]
      match(i:Int, j:Int) :
        add-item(s[start to i])
        val replacements = f(s[(i + 1) through (j - 1)])
        do(add-item, join(replacements, Separator()))
        loop(j + 1)
      else :
        add-item(s[start to false])
        
    ;Return buffer
    flush-char-buffer()
    to-tuple(buffer)

defn replace-curly (f:String -> String, s:String) -> String :
  val replaced = replace-curly({[f(_)]}, s)
  fatal("Unexpected length.") when length(replaced) != 1
  replaced[0]

defn substitute-environment-lists (s:String,
                                   work-dir:String,
                                   proj-dir:String,
                                   no-var:String -> Void) -> Tuple<String> :
  within name = replace-curly(s) :
    switch(name) :
      "WORKDIR" :
        [work-dir]
      "." :
        [proj-dir]
      else :
        val v = get-env(name)
        match(v:String) : tokenize-shell-command(v)
        else : no-var(name)

defn substitute-environment-vars (s:String,
                                  work-dir:String,
                                  proj-dir:String,
                                  no-var:String -> Void) -> String :
  within name = replace-curly(s) :
    switch(name) :
      "WORKDIR" :
        work-dir
      "." :
        proj-dir
      else :
        val v = get-env(name)
        match(v:String) : v
        else : no-var(name)

;============================================================
;=================== Combine Files ==========================
;============================================================
defn combine (fs:Seqable<ProjFile>) :
  defn strip-by-key<?T> (key:T -> ?, stmts:Seqable<?T>) :
    val table = HashTable<?,T>()
    for s in stmts do : table[key(s)] = s
    values(table)

  val all-stmts = to-tuple $ seq-cat(stmts, fs)
  val new-stmts = to-tuple $ cat-all $ [
    strip-by-key(package, filter-by<DefinedInStmt>(all-stmts))
    strip-by-key(package, filter-by<RequiresStmt>(all-stmts))
    strip-by-key(package, filter-by<ImportWhenStmt>(all-stmts))
    strip-by-key(name, filter-by<CompileStmt>(all-stmts))
    strip-by-key(name, filter-by<BuildStmt>(all-stmts))]
  ProjFile(new-stmts)

;============================================================
;======================= Errors =============================
;============================================================

public defstruct ProjFileError <: Exception :
  info: FileInfo|False
  msg: String
defmethod print (o:OutputStream, e:ProjFileError) :
  val info-str = "" when info(e) is False
            else "%_: " % [info(e)]
  print(o, "%_%_" % [info-str, msg(e)])

public defstruct ProjFileErrors <: Exception :
  exceptions: Collection<Exception>
defmethod print (o:OutputStream, e:ProjFileErrors) :
  print(o, "%n" % [exceptions(e)])

public defn CannotFindIncludeProj (info:FileInfo|False, src-proj:String, load-proj:String) :
  val msg = to-string("The project file %~ cannot load non-existent project file %~." % [src-proj, load-proj])
  ProjFileError(info, msg)

public defn IncludeCycle (info:FileInfo|False, path:String, parent-paths:List<String>) :
  val msg = to-string("Cyclic include error when attempting to re-include project file %~. Already included through paths: %@." % [
    path, parent-paths])
  ProjFileError(info, msg)

defn add-proj-file-info<?T> (f:() -> ?T, info:FileInfo|False) :
  try :
    f()
  catch (e:ProjFileError) :
    throw(ProjFileError(info, msg(e)))

;============================================================
;======================== Utilities =========================
;============================================================

defn maybe?<?T,?S> (f:T -> ?S, x:Maybe<?T>) -> Maybe<S> :
  if empty?(x) : None()
  else : One(f(value!(x)))

defn tuple?<?T,?S> (f:T -> Tuple<?S>, x:Maybe<?T>) -> Tuple<S> :
  if empty?(x) : []
  else : f(value!(x))