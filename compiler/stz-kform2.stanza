defpackage stz/kform2 :
  import core
  import collections
  import stz/pl-ir
  import stz/kl2-ir
  import stz/ids
  import stz/dec-table2
  import stz/tgt-ir
  import stz/utils

;============================================================
;======================= Driver =============================
;============================================================

public defn compile (pkgs:List<KPkgComm>) -> List<TGPackage> :
  val dec-table = compute-declaration-table(pkgs)
  println(dec-table)
  for pkg in pkgs map :
    match(pkg) :
      (pkg:TGPackage) :
        pkg
      (#pkg:KPackage) :
        var pkg:KPackage = #pkg
        vheader("Package %_" % [name(pkg)])
        vprintln(pkg)
        pkg = map-method-targs(dec-table, pkg)
        vheader("Package %_ : After Mapping Method Targs" % [name(pkg)])
        vprintln(pkg)
        pkg = create-closures(dec-table, pkg)
        vheader("Package %_ : After Creating Closures" % [name(pkg)])
        vprintln(pkg)
        pkg = convert-mixes(dec-table, pkg)
        vheader("Package %_ : After Converting Mixes" % [name(pkg)])
        vprintln(pkg)
        pkg = guard-boundary(dec-table, pkg)
        vheader("Package %_ : After Guarding Boundary" % [name(pkg)])
        vprintln(pkg)
        pkg = box-mutables(dec-table, pkg)
        vheader("Package %_ : After Boxing Mutables" % [name(pkg)])
        vprintln(pkg)
        pkg = lift-objects(dec-table, pkg)
        vheader("Package %_ : After Lifting Objects" % [name(pkg)])
        vprintln(pkg)
        pkg = lift-closures(dec-table, pkg)
        vheader("Package %_ : After Lifting Closures" % [name(pkg)])
        vprintln(pkg)
  exit(0)

;============================================================
;============== Compute Declaration Table ===================
;============================================================

defn compute-declaration-table (pkgs:List<KPkgComm>) :
  val table = DecTable()
  defn scan (e:KTExp) :
    defn scan-e (e:KExp) :
      do(scan-e, e)
      register(table, e)
    register(table, e)
    do(scan-e, e)
  for pkg in pkgs do :
    match(pkg) :
      (pkg:KPackage) : do(scan, exps(pkg))
      (pkg:TGPackage) : false ;do(register{table, _}, declarations(ids(pkg)))
  table

;============================================================
;================== Method TArg Mapping =====================
;============================================================

defn inverse-solve (input-xs:List<Int>, input-targs:List<KType>) -> [List<Int>, List<KType>] :
  ;Created targs
  val ys = map(fresh-id{}, input-targs)
  ;Simplify
  val targs = map(trivial-simplify, input-targs)
  ;Initialize solved table
  val solved = IntTable<Int>()
  defn update (x:Int, y:Int) :
    set?(solved, x, {y})
  ;Precise Solutions
  for (t in targs, y in ys) do :
    match(t:KTVar) : update(n(t), y)
  ;Approximate Solutions
  for (t in targs, y in ys) do :
    let loop (t:KType = t) :
      match(t) :
        (t:KTVar) : update(n(t), y)
        (t:KOr) : do(loop, t)
        (t) : false
  ;Invert solutions
  val solns = for x in input-xs map :
    match(get?(solved,x)) :
      (y:Int) : KTVar(y)
      (y:False) : KTop()
  ;Return solutions
  [ys, solns]

defn map-methods (pkg:KPackage, dec-table:DecTable, f:(KFn|KFn*, Int, List<KType>) -> KFn|KFn*) :
  defn registered (e:KTExp) : (register(dec-table,e), e)
  defn fe (e:KExp) :
    match(map(fe,e)) :
      (e:KMethod*) :
        val value* = f(value(e) as KFn|KFn*, multi(e), targs(e))
        KMethod(multi(e), thisn(e), value*)
      (e) : e
  defn fte (e:KTExp) :
    match(map(fe,e)) :
      (e:KDefmethod*) :
        val value* = f(value(e) as KFn|KFn*, multi(e), targs(e))
        registered(KDefmethod(fresh-id(), multi(e), value*))
      (e) : e
  map(fte, pkg)

defn replace-tvars (e:KExp, xs:List<Int>, ts:List<KType>) :
  val table = to-hashtable<Int,KType>(xs,ts)
  defn fe (e:KExp) :
    val e* = map(fe, e)
    map(replace-tvars{_:KType, table}, e*)
  fe(e)

defn attach (f:KFn|KFn*, targs:List<Int>, a1:List<KType>, a2:KType) :
  match(f) :
    (f:KFn) : KFn(tail?(f), targs, a1, a2, args(f), body(f), info(f))
    (f:KFn*) : KFn*(tail?(f), targs, a1, a2, args(f), body(f), info(f))

defn map-method-targs (dec-table:DecTable, pkg:KPackage) :
  map-methods(pkg, dec-table
    fn (f:KFn|KFn*, m:Int, targ-types:List<KType>) :
      val [targs*, targ-types*] = inverse-solve(targs(f), targ-types)
      val [multi-a1, multi-a2] = fn-types(dec-table, m, map(KTVar,targs*))
      val f* = replace-tvars(f, targs(f), targ-types*) as KFn|KFn*
      val a1* = map(KAnd, multi-a1, a1(f*))
      val a2* = KAnd(multi-a2, a2(f*))
      attach(f*, targs*, a1*, a2*))

;============================================================
;===================== Closure Creation =====================
;============================================================

defn map-closures (pkg: KPackage, dec-table: DecTable
                   f: KMix|KCurry|KVar -> KFn|KMultifn) -> KPackage :
  ;Track newly introduced global functions
  val global-functions = HashTable-init<Int,KDefConst> $
    KDefConst{fresh-id(), f(KVar(_))}
  defn lift-function (func:Int) :
    n(global-functions[func])
  defn prepend-defs (pkg:KPackage) :
    do(register{dec-table, _}, values(global-functions))
    attach-exps(pkg, append(values(global-functions), exps(pkg)))

  ;Map over expressions
  defn fe (e:KExp) :
    match(map-without-functions(fe, e)) :
      (e:KMix|KCurry) :
        f(e)
      (e:KVar|KVar*) :
        if global?(dec-table,n(e)) and function?(dec-table, n(e)) :
          KVar(lift-function(n(e)))
        else : e
      (e) :
        e
  defn fte (e:KTExp) : map(fe, e)
  prepend-defs(map(fte,pkg))

defn create-closures (dec-table:DecTable, pkg:KPackage) -> KPackage :
  defn mix-fn (dec-table:DecTable, f:KMix|KCurry|KVar) :
    defn make-fn (f:KExp, arity:Int) :
      val args* = map(fresh-id{}, 0 to arity)
      val body = KDo(f, KVars(args*), KTop(), false)
      val info = let loop (f:KExp = f) :
        match(f) :
          (f:KVar|KCurry) : info(dec-table, n(f))
          (f:KMix) : loop(head(exps(f)))
      KFn(true, List(), KTops(args*), KTop(), args*, body, info)

    match(f) :
      (f:KCurry|KVar) :
        make-fn(f, arity(dec-table, n(f)))
      (f:KMix) :
        val groups = IntTable<List<KCurry|KVar|KVar*>>(List())
        for exp in exps(f) as List<KCurry|KVar|KVar*> do :
          val n = arity(dec-table, n(exp))
          update(groups, cons{exp, _}, n)
        KMultifn{to-list(_)} $ for entry in groups seq :
          val [n, fs] = [key(entry), value(entry)]
          if length(fs) == 1 : make-fn(head(fs), n)
          else : make-fn(KMix(fs), n)

  map-closures(pkg, dec-table, mix-fn{dec-table, _})

;============================================================
;===================== Mix Conversion =======================
;============================================================

defn map-mixes (pkg:KPackage, f: KDo|KDo* -> KExp) :
  defn fe (e:KExp) :
    match(map(fe,e)) :
      (e:KDo|KDo*) :
        match(func(e):KMix) : f(e)
        else : e
      (e) : e
  defn fte (e:KTExp) :
    map(fe, e)
  map(fte, pkg)

defn convert (dec-table:DecTable, e:KDo|KDo*) :
  ;===== Utilities =====
  ;Construct a call to f with given arguments and return type
  defn Do (f:KExp, args:List<KExp>, a2:KType) :
    match(e) :
      (e:KDo) : KDo(f, args, a2, info(e))
      (e:KDo*) : KDo*(f, args, a1(e), a2, info(e))

  ;Retrieve argument types for function
  defn arg-types (e:KExp) :
    val n = n(e as KVar|KVar*|KCurry)
    fst(/fn-types(dec-table, n))

  ;Retrieve argument types for given function
  defn fn-types (f:KCurry|KVar|KVar*) :
    match(f) :
      (f:KVar|KVar*) : /fn-types(dec-table, n(f), List())
      (f:KCurry) : /fn-types(dec-table, n(f), targs(f))

  ;===== Stages =====
  ;Pull out definitions to before call
  defn pull-out-defs (e:KDo|KDo*) :
    val defs = Vector<KeyValue<Int,KExp>>()
    val args* = Vector<KVar>()
    for x in args(e) do :
      match(x) :
        (x:KVar) :
          add(args*, x)
        (x) :
          val id = fresh-id()
          add(defs, id => x)
          add(args*, KVar(id))
    KLet(defs, make-dispatch(func(e) as KMix, to-list(args*)))

  ;Make a call to func with given args
  defn make-dispatch (func:KMix, args:List<KExp>) :
    if all?(histanza?, arg-types(head(exps(func)))) :
      val bs = for f in exps(func) as List<KCurry|KVar|KVar*> map :
        val args* = map(fresh-id{}, args)
        val [a1, a2] = fn-types(f)
        KBranch(args*, a1, Do(f, KVars(args*), a2))
      KDispatch(args, bs, info(e))
    else :
      ;Compute mask
      val refmask = map(histanza?, arg-types(head(exps(func))))
      val refargs = select(args, refmask)
      ;Create branches
      val bs = for f in exps(func) as List<KCurry|KVar|KVar*> map :
        val refargs* = map(fresh-id{}, refargs)
        val args* = replace(args, refmask, KVars(refargs*))
        val [a1, a2] = fn-types(f)
        KBranch(refargs*, select(a1,refmask), Do(f,args*,a2))
      ;Create dispatch
      KDispatch(refargs, bs, info(e))

  ;Driver
  pull-out-defs(e)

defn convert-mixes (dec-table:DecTable, pkg:KPackage) -> KPackage :
  map-mixes(pkg, convert{dec-table, _})

;============================================================
;=================== Boundary Guards ========================
;============================================================

defn guard-boundary (dec-table:DecTable, pkg:KPackage) :
  ;Guard a call to a known function
  defn guard-call-to-known (e:KDo*, tail-pos?:True|False) :
    val [n, targs] = n+targs(func(e))
    val [a1, a2] = fn-types(dec-table, n, targs)
    ;Guard arguments when necessary
    val args* =
      if guarded?(dec-table, n) :
        args(e)
      else :
        map(KCheck{_, _, ARG-ERROR-TYPE, info(e)}, args(e), a1)
    ;Make call
    val call = KDo(func(e), args*, a2, info(e))
    ;Determine whether return should be guarded
    val guard-return? =
      if tail-pos? : false
      else if not guarded?(dec-table, n) : true
      else if tail?(dec-table, n) : true
      else : false
    ;Guard return when necessary
    if guard-return? : KCheck(call, a2, RETURN-ERROR-TYPE, info(e))
    else : call

  ;Guard a call to an unknown function
  defn guard-call-to-unknown (e:KDo*, tail-pos?:True|False) :
    val args* = map(KCheck{_, _, ARG-ERROR-TYPE, info(e)}, args(e), a1(e))
    val func* = KCheck(func(e), KOf(FN-TYPE-ID), CALL-ERROR-TYPE, info(e))
    val call = KDo(func*, args*, a2(e), info(e))
    if tail-pos? : call
    else : KCheck(call, a2(e), RETURN-ERROR-TYPE, info(e))

  ;Cast expression to just the variables tvars in the type
  defn KCheckTVar (e:KExp, t:KType, i:False|FileInfo) :
    defn strip (t:KType) :
      if has-var?(t) :
        match(t:KOr) : t
        else : map(strip, t)
      else : KTop()
    KCheck(e, trivial-simplify(strip(t)), ARG-ERROR-TYPE, i)

  ;Add boundary guards
  defn guard (e:KExp, tail-pos?:True|False, method-pos?:True|False, loc-pos?:True|False) :
    defn recur (e:KExp) :
      map-tail(guard{_, _, e is KMethod, false}, e, tail-pos?)
    match(e) :
      (e0:KFn*) :
        val e = recur(e0) as KFn*
        ;Check arguments
        val args* = map(fresh-id{}, args(e))
        val defs = for (a in args(e), a* in args*, t in a1(e)) map :
          if method-pos? : a => KCheckTVar(KVar(a*), t, info(e))
          else : a => KCheck(KVar(a*), t, ARG-ERROR-TYPE, info(e))
        ;Check return
        val body* =
          if tail?(e) : body(e)
          else : map-return(KCheck{_, a2(e), RETURN-ERROR-TYPE, info(e)}, body(e))
        ;Create function
        KFn(tail?(e), targs(e), a1(e), a2(e),
            args*, KLet(defs, body*), info(e))
      (e:KDo*) :
        recur $ match(func(e)) :
          (f:KVar|KVar*) :
            if function?(dec-table, n(f)) : guard-call-to-known(e, tail-pos?)
            else : guard-call-to-unknown(e, tail-pos?)
          (f:KCurry) : guard-call-to-known(e, tail-pos?)
          (f) : guard-call-to-unknown(e, tail-pos?)
      (e:KVar*) :
        val check? =
          (not loc-pos?) and                    ;Not in location position and
          (not function?(dec-table, n(e))) and  ;Not a function and
          guarded?(dec-table, n(e)) and (       ;Guarded and
            global?(dec-table, n(e)) or           ;Global or
            mutable?(dec-table, n(e)) and         ;Mutable and
            not initialized?(dec-table, n(e)))    ;not initialized
        if check? : KEnsureSet(KVar(n(e)), info(e))
        else : KVar(n(e))
      (e:KLet*) :
        val v* = KCheck(value(e), type(e), DEF-ERROR-TYPE, info(e))
        recur(KLet(n(e), v*, body(e)))
      (e:KLetVar*) :
        val v* = attempt: KCheck(value(e) as? KExp, type(e), DEF-ERROR-TYPE, info(e))
        recur(KLetVar(n(e), type(e), v*, body(e)))
      (e:KSet*) :
        val loc = guard(exp(e), false, false, true)
        val v = guard(value(e), false, false, false)
        val v* = match(loc) :
          (loc:KVar) :
            if guarded?(dec-table, n(loc)) :
              KCheck(v, type(e), SET-ERROR-TYPE, info(e))
            else : v
          (loc) : v
        KSet(loc, type(e), v*)
      (e0:KBranch*) :
        val e = recur(e0) as KBranch*
        val guards = for (a in args(e), t in types(e)) map :
          KCheckTVar(KVar(a), t, info(e))
        val body* = KSeq(guards, body(e))
        KBranch(args(e), types(e), body*)
      (e0:KEnsureLength) :
        val e = recur(e0) as KEnsureLength
        val v = KCheck(exp(e), KOf(TUPLE-TYPE-ID), TUPLE-ERROR-TYPE, info(e))
        KEnsureLength(v, length(e), info(e))
      (e:KField) :
        KField(guard(exp(e), false, false, loc-pos?), n(e))
      (e:KPtr) :
        KPtr(guard(loc(e), false, false, true))
      (e) :
        recur(e)

  ;Add guards
  defn guard (e:KTExp) :    
    defn recur (e:KTExp) :
      map(guard{_, false, e is KDefmethod, false}, e)
    match(recur(e)) :
      (e:KDef*) :
        val v* = KCheck(value(e), type(e), DEF-ERROR-TYPE, info(e))
        KDef(n(e), type(e), v*)
      (e:KDefVar*) :
        val v* = attempt: KCheck(value(e) as? KExp, type(e), DEF-ERROR-TYPE, info(e))
        KDefVar(n(e), type(e), v*)
      (e) : e

  map(guard, pkg)

;============================================================
;================== Free Variable Analysis ==================
;============================================================
defn compute-freevars (dec-table:DecTable, pkg:KPackage) :
  ;Variable tracking
  var vars = IntSet()
  var tvars = IntSet()
  defn use-var (v:Int) : add(vars, v)
  defn def-var (v:Int) : remove(vars, v)
  defn use-tvar (v:Int) : add(tvars, v)
  defn def-tvar (v:Int) : remove(tvars, v)
  defn all-vars () : to-list(vars)
  defn all-tvars () : to-list(tvars)

  ;Mapping function
  defn scan (e:KExp) -> KExp :
    match(e) :
      (e:KFn) :
        val e* =
          let-var vars = IntSet() :
            let-var tvars = IntSet() :
              val e* = map-bound-rev(scan, def-var, def-tvar, scan, e) as KFn
              attach(e*, KFnStat(all-vars(), all-tvars()))
        do(use-var, freevars(e*))
        do(use-tvar, freetypes(e*))
        e*
      (e) :
        for v in e do-used-vars :
          use-var(v) when not global?(dec-table, v)
        do-used-tvars(use-tvar, e)
        map-bound-rev(scan, def-var, def-tvar, scan, e)
        
  ;Scanning a top level expression
  defn scan (e:KTExp) : map(scan, e)
  map(scan, pkg)        

;============================================================
;================ Mutable Variable Lifting ==================
;============================================================
defn box-mutables (dec-table:DecTable, pkg:KPackage) :
  ;Compute closed over set
  val [closed-over, local-vars] = let :
    val cset = IntSet()
    val vset = IntSet()
    defn scan (e:KExp) :
      do(scan, e)
      match(e) :
        (e:KFn) : add-all(cset, freevars(e))
        (e:KLetVar) : add(vset, n(e))
        (e) : false
    defn scan (e:KTExp) : do(scan, e)
    do(scan, compute-freevars(dec-table, pkg))
    [cset, vset]

  ;Box a variable
  defn box? (n:Int) :
    local-vars[n] and closed-over[n]
  defn box? (e:KExp) :
    match(e:KVar) : box?(n(e))    

  ;Algorithm
  defn lift (e:KExp) :
    defn recur (e:KExp) : map(lift, e)
    match(e) :
      (e:KLetVar) :
        recur $
          if box?(n(e)) : KLet(n(e), KBox(value(e)), body(e))
          else : e
      (e:KVar) :
        if box?(n(e)) : KBoxGet(e)
        else : e
      (e:KSet) :
        if box?(exp(e)) : KBoxSet(exp(e), lift(value(e)))
        else : recur(e)
      (e) :
        recur(e)
        
  defn lift (e:KTExp) : map(lift, e)
  map(lift, pkg)  

;============================================================
;======================= Renaming ===========================
;============================================================

defn rename (e:KExp, vs:Seqable<Int>) :
  rename(e, seq({_ => fresh-id()}, vs))
  
defn rename (e:KExp, vs:Seqable<KeyValue<Int,Int>>) :
  ;Rename table
  val table = to-hashtable<Int,Int>(vs)

  defn fi (i:Int) :
    get?(table, i, i)
  defn ft (t:KType) :
    match(t) :
      (t:KTVar) : KTVar(fi(n(t)))
      (t) : map(ft, t)
  defn fe (e:KExp) :
    map-ids(fi,map(fe,map(ft,e)))
  fe(e)  
    
;============================================================
;=================== Object Lifting =========================
;============================================================

defn lift-objects (dec-table:DecTable, pkg:KPackage) :
  ;Track lifts
  val defs = Vector<KTExp>()
  defn prepend-defs (pkg:KPackage) :
    attach-exps(pkg, append(defs, exps(pkg)))

  defn free (e:KNew) -> [List<Int>, List<Int>] :
    val vs = Vector<Int>()
    val ts = Vector<Int>()
    for m in methods(e) as List<KMethod> do :
      val f = value(m) as KFn
      add-all(vs, freevars(f))
      add-all(ts, freetypes(f))
    [unique(vs), unique(ts)]
  
  defn create-object (e:KNew) :
    val id = fresh-id()    
    val [vs,ts] = free(e)
    ;Define object
    add(defs, KDefObject(id, name(e), type(e), length(ts), length(vs)))
    ;Pull out methods
    for m in methods(e) as List<KMethod> do :
      val f = value(m) as KFn
      val def-vars = for v in freevars(f) seq :
        val i = index-of!(vs,v)
        v => KObjectGet(KVar(thisn(m)), i)
      val def-tvars = for v in freetypes(f) seq :
        val i = index-of!(ts,v)
        v => KObjectTGet(KVar(thisn(m)), i)
      val body* = KLet(cat(def-vars, def-tvars),body(f))
      val a1* = for (a in args(f), t in a1(f)) map :
        if a == thisn(m) : KOf(id)
        else : erase-tvars(t,ts)
      val a2* = erase-tvars(a2(f),ts)
      val f* = attach-a1-a2-body(f, a1*, a2*,
                 rename(body*,append(vs,ts)))
      add(defs, KDefmethod(fresh-id(), multi(m), f*))
    ;Create object
    KNewObject(id, KTVars(ts), KVars(vs), info(e))

  defn fe (e:KExp) :
    match(map(fe,e)) :
      (e:KNew) : create-object(e)
      (e) : e
  defn fte (e:KTExp) : map(fe,e)
  prepend-defs(map(fte, compute-freevars(dec-table,pkg)))

;============================================================
;==================== Closure Lifting =======================
;============================================================

defn lift-closures (dec-table:DecTable, pkg:KPackage) :
  ;Track lifts
  val defs = Vector<KTExp>()
  defn prepend-defs (pkg:KPackage) :
    attach-exps(pkg, append(defs, exps(pkg)))

  ;Removing an int
  defn minus (xs:List<Int>, y:Int) :
    to-list(filter({_ != y}, xs))

  defn free (closure:Int, e:KFn|KMultifn) -> [List<Int>, List<Int>] :
    match(e) :
      (e:KFn) :
        [freevars(e) - closure, freetypes(e)]
      (e:KMultifn) :
        val vs = Vector<Int>()
        val ts = Vector<Int>()
        for f in funcs(e) as List<KFn> do :
          add-all(vs, freevars(f))
          add-all(ts, freetypes(f))
        [unique(vs) - closure, unique(ts)]

  defn create-closure (closure:Int, e:KFn|KMultifn) :
    val id = fresh-id()
    val [vs,ts] = free(closure, e)
    val closure* = fresh-id()
    val vs* = map(fresh-id{}, vs)
    val ts* = map(fresh-id{}, ts)
    val subs = cat-all $ [
                [closure => closure*]
                 seq(KeyValue,vs,vs*)
                 seq(KeyValue,ts,ts*)]
    val e* = rename(e, subs)
    ;Define closure
    add(defs, KDefClosure(id, closure*, ts*, vs*, e*))
    ;Make closure object
    val info = match(e) :
      (e:KFn) : info(e)
      (e:KMultifn) : info(head(funcs(e)) as KFn)
    KClosure(id, KTVars(ts), KVars(vs), info)

  defn fe (e:KExp) :
    defn recur (e:KExp) :
      match(e) :
        (e:KLetRec) : KLetRec(ns(e), map(recur,values(e)), fe(body(e)))
        (e:KMultifn) : map(recur,e)
        (e) : map(fe, e)
    match(recur(e)) :
      (e:KLetRec) :
        val vs* = for (n in ns(e), v in values(e)) map :
          create-closure(n, v as KFn|KMultifn)
        KLetRec(ns(e), vs*, body(e))
      (e:KMultifn|KFn) : create-closure(fresh-id(), e)
      (e) : e

  defn fte (e:KTExp) :
    match(e) :
      (e:KDefn|KExternFn|KDefmethod) : map(map{fe, _:KExp}, e)
      (e) : map(fe, e)
  prepend-defs(map(fte,compute-freevars(dec-table,pkg)))

;============================================================
;===================== Fancy Mappers ========================
;============================================================

defn map-without-functions (f:KExp -> KExp, e:KExp) :
  defn ff (e:KExp) :
    match(e:KVar|KCurry|KMix|KVar*) : e
    else : f(e)
  defn fs (es:List<KExp>) :
    map(f, es)
  match(e) :
    (e:KDo*) : KDo*(ff(func(e)), fs(args(e)), a1(e), a2(e), info(e))
    (e:KDo) : KDo(ff(func(e)), fs(args(e)), type(e), info(e))
    (e:KDoC) : KDoC(ff(func(e)), fs(args(e)), fs(varargs(e)), type(e))
    (e) : map(f,e)

defn map-tail (f:(KExp, True|False) -> KExp, e:KExp, tail-pos?:True|False) :
  defn ftail (e:KExp) : f(e, true)
  defn farg (e:KExp) : f(e, false)
  defn fcont (e:KExp) : f(e, tail-pos?)
  defn fargs (e:List<KExp>) : map(farg, e)
  defn fconts (e:List<KExp>) : map(fcont, e)
  defn farg? (e:KExp|False) : match(e:KExp) : farg(e)

  match(e) :
    ;Input Expressions
    (e:KFn*) :
      val body* = f(body(e), tail?(e))
      KFn*(tail?(e), targs(e), a1(e), a2(e), args(e), body*, info(e))
    (e:KLet*) :
      val value* = farg(value(e))
      val body* = fcont(body(e))
      KLet*(n(e), type(e), value*, body*, info(e))
    (e:KLetVar*) :
      val value* = farg?(value(e))
      val body* = fcont(body(e))
      KLetVar*(n(e), type(e), value*, body*, info(e))
    (e:KBranch*) :
      val body* = fcont(body(e))
      KBranch*(args(e), types(e), body*, info(e))
    ;Standard Expressions
    (e:KLet) :
      val value* = farg(value(e))
      val body* = fcont(body(e))
      KLet(n(e), value*, body*)
    (e:KLetVar) :
      val value* = farg?(value(e))
      val body* = fcont(body(e))
      KLetVar(n(e), type(e), value*, body*)
    (e:KLetRec) :
      val values* = fargs(values(e))
      val body* = fcont(body(e))
      KLetRec(ns(e), values*, body*)
    (e:KMatch) :
      val args* = fargs(args(e))
      val branches* = fconts(branches(e))
      KMatch(args*, branches*, info(e))
    (e:KBranch) :
      val body* = fcont(body(e))
      KBranch(args(e), types(e), body*)
    (e:KLabels) :
      KLabels(fconts(blocks(e)))
    (e:KBlock) :
      KBlock(n(e), args(e), types(e), fcont(body(e)))
    (e:KIf) :
      KIf(farg(pred(e)), fcont(conseq(e)), fcont(alt(e)))
    (e:KSeq) :
      KSeq(farg(a(e)), fcont(b(e)))
    (e:KReturn) :
      KReturn(ftail(exp(e)))
    (e:KFn) :
      val body* = f(body(e), tail?(e))
      KFn(tail?(e), targs(e), a1(e), a2(e), args(e), body*, info(e))
    ;Working Expressions
    (e:KDispatch) :
      val args* = fargs(args(e))
      val branches* = fconts(branches(e))
      KDispatch(args*, branches*, info(e))
    ;Otherwise
    (e) :
      map(farg, e)

defn map-return (f:KExp -> KExp, e:KExp) :
  defn scan (e:KExp, ret-pos?:True|False) :
    match(e:KReturn) :
      map(scan{_, true}, e)
    else: if has-body?(e) :
      map-tail(scan, e, ret-pos?)
    else if ret-pos? :
      f(map(scan{_, false}, e))
    else :
      map(scan{_, false}, e)
  scan(e, true)

defn map-ids (f:Int -> Int, e:KExp) :
  defn fs (xs:List<Int>) : map(f,xs)
  match(e) :
    (e:KLet) : KLet(f(n(e)), value(e), body(e))
    (e:KLetVar) : KLetVar(f(n(e)), type(e), value(e), body(e))
    (e:KLetRec) : KLetRec(fs(ns(e)), values(e), body(e))
    (e:KVar) : KVar(f(n(e)))
    (e:KObject) : KObject(f(n(e)), args(e), info(e))
    (e:KArray) : KArray(f(n(e)), length(e), args(e), info(e))
    (e:KStruct) : KStruct(f(n(e)), args(e))
    (e:KCurry) : KCurry(f(n(e)), targs(e))
    (e:KTagof) : KTagof(f(n(e)))
    (e:KBranch) : KBranch(fs(args(e)), types(e), body(e))
    (e:KBlock) : KBlock(f(n(e)), fs(args(e)), types(e), body(e))
    (e:KGoto) : KGoto(f(n(e)), args(e))
    (e:KField) : KField(exp(e), f(n(e)))
    (e:KFn) : KFn(tail?(e), fs(targs(e)), a1(e), a2(e), fs(args(e)), body(e), info(e), stats(e))
    (e:KMethod) : KMethod(f(multi(e)), f(thisn(e)), value(e))
    (e:KNewObject) : KNewObject(f(n(e)), targs(e), args(e), info(e))
    (e:KLetType) : KLetType(f(n(e)), value(e), body(e))
    (e) : e

defn map-bound (before:KExp -> KExp, bindvar:Int -> ?, bindtvar:Int -> ?, after:KExp -> KExp, e:KExp) :
  match(e) :
    (e:KLet) :
      val v* = before(value(e))
      bindvar(n(e))
      KLet(n(e), v*, after(body(e)))
    (e:KLetVar) :
      val v* = attempt: before(value(e) as? KExp)
      bindvar(n(e))
      KLetVar(n(e), type(e), v*, after(body(e)))
    (e:KLetRec) :
      do(bindvar,ns(e))
      map(after,e)
    (e:KBranch) :
      do(bindvar,args(e))
      map(after,e)
    (e:KBlock) :
      do(bindvar,args(e))
      map(after,e)
    (e:KFn) :
      do(bindtvar, targs(e))
      do(bindvar, args(e))
      map(after,e)
    (e:KLetType) :
      val value* = before(value(e))
      bindtvar(n(e))
      val body* = after(body(e))
      KLetType(n(e), value*, body*)
    (e) :
      map(after, e)

defn map-bound-rev (before:KExp -> KExp, bindvar:Int -> ?, bindtvar:Int -> ?, after:KExp -> KExp, e:KExp) :
  match(e) :
    (e:KLet) :
      val body* = after(body(e))
      bindvar(n(e))
      val v* = before(value(e))      
      KLet(n(e), v*, body*)      
    (e:KLetVar) :
      val body* = after(body(e))
      bindvar(n(e))
      val v* = attempt: before(value(e) as? KExp)
      KLetVar(n(e), type(e), v*, body*)
    (e:KLetRec) :
      val e* = map(after,e)
      do(bindvar,ns(e))
      e*    
    (e:KBranch) :
      val e* = map(after,e)
      do(bindvar,args(e))
      e*
    (e:KBlock) :
      val e* = map(after,e)
      do(bindvar,args(e))
      e*
    (e:KFn) :
      val e* = map(after,e)
      do(bindtvar, targs(e))
      do(bindvar, args(e))
      e*
    (e:KLetType) :
      val body* = after(body(e))
      bindtvar(n(e))
      val value* = before(value(e))
      KLetType(n(e), value*, body*)
    (e) :
      map(after, e)

defn do-used-vars (use:Int -> ?, e:KExp) :
  match(e) :
    (e:KVar) : use(n(e))
    (e:KCurry) : use(n(e))
    (e) : false

defn do-used-tvars (use:Int -> ?, e:KExp) :
  defn do-tvars (f:Int -> ?, t:KType) :
    match(t) :
      (t:KTVar) : f(n(t))
      (t) : do(do-tvars{f, _}, t)
  defn do-tvars (f:Int -> ?, ts:List<KType>) :
    for t in ts do :
      do-tvars(f, t)
  match(e) :
    (e:KCurry) : do-tvars(use, targs(e))
    (e:KCheck) : do-tvars(use, type(e))
    (e:KNewObject) : do-tvars(use, targs(e))
    (e) : false


















