defpackage stz/tl-to-el :
  import core
  import collections
  import stz/namemap
  import stz/tl-ir
  import stz/el-ir
  import stz/dl-ir
  import stz/ids

public defn to-el (p:TProg, nm:NameMap) -> EPackage :
  for package in packages(p) as Seqable<TPackage> do :
    compile(package, nm)    
  fatal("Not yet implemented")

defn compile (p:TPackage, namemap:NameMap) :
  val texps = Vector<ETExp>()
  defn emit (e:ETExp) : add(texps, e)

  let-var CURRENT-DTABLE = DTable() :
    for c in comms(p) do :
      match(c) :
        (c:TDefType) :
          println("Not yet implemented: %_" % [c])
           ;n: Int
           ;args: List<Int>
           ;parent: False|Type
           ;children: List<Child>

  ;public defstruct EDefType <: ETExp :
  ;  n: Int
  ;  parent: False|EType
  ;  children: Tuple<Int>

        (c:TLDefType) :
          println("Not yet implemented: %_" % [c])
           ;n: Int
           ;args: List<Int>
           ;parent: False|Type
           ;fields: List<Field>

  ;public defstruct EDefType <: ETExp :
  ;  n: Int
  ;  parent: False|EType
  ;  children: Tuple<Int>


        (c:TDef) :
          println("Not yet implemented: %_" % [c])
           ;n: Int
           ;type: False|Type
           ;value: TExp

  ;public defstruct EDefGlobal <: ETExp :
  ;  n: Int
  ;  type: EType
  ;  mutable?: True|False
  ;  lostanza?: True|False


        (c:TDefTuple) :
          println("Not yet implemented: %_" % [c])
           ;ns: List<Int>
           ;types: List<False|Type>
           ;value: TExp

  ;public defstruct EDefGlobal <: ETExp :
  ;  n: Int
  ;  type: EType
  ;  mutable?: True|False
  ;  lostanza?: True|False


        (c:TDefVar) :
          println("Not yet implemented: %_" % [c])
           ;n: Int
           ;type: False|Type
           ;value: False|TExp

  ;public defstruct EDefGlobal <: ETExp :
  ;  n: Int
  ;  type: EType
  ;  mutable?: True|False
  ;  lostanza?: True|False

        (c:TDefn) :
          println("Not yet implemented: %_" % [c])
           ;props: FnProperties
           ;tail?: True|False
           ;n: Int
           ;targs: List<Int>
           ;cargs: List<Int>
           ;a1: List<False|Type>
           ;a2: False|Type
           ;args: List<Int>
           ;body: TExp

  ;public defstruct EDefn <: ETExp :
  ;  n: Int
  ;  func: EFunction with: (updater => sub-func)
  ;  lostanza?: True|False


        (c:TDefmulti) :
          println("Not yet implemented: %_" % [c])
           ;n: Int
           ;targs: List<Int>
           ;cargs: List<Int>
           ;a1: List<False|Type>
           ;a2: False|Type

  ;public defstruct EDefmulti <: ETExp :
  ;  n: Int
  ;  targs: Tuple<Int>
  ;  a1: Tuple<EType>
  ;  a2: EType


        (c:TDefmethod) :
          println("Not yet implemented: %_" % [c])
           ;props: FnProperties
           ;tail?: True|False
           ;n: Int
           ;multi: TExp
           ;thisn: False|Int
           ;targs: List<Int>
           ;cargs: List<Int>
           ;a1: List<False|Type>
           ;a2: False|Type
           ;args: List<Int>
           ;body: TExp

  ;public defstruct EDefmethod <: ETExp :
  ;  n: Int
  ;  multi: Int
  ;  targs: Tuple<EType>
  ;  func: EFn with: (updater => sub-func)
  ;  lostanza?: True|False


        (c:TInit) :
          println("Not yet implemented: %_" % [c])
           ;exp: TExp

  ;public defstruct EInit <: ETExp :
  ;  body: EBody with: (updater => sub-body)
  ;  lostanza?: True|False

        (c:TLDef) :
          println("Not yet implemented: %_" % [c])
           ;n: Int
           ;type: LSType
           ;value: LSExp

  ;public defstruct EDefGlobal <: ETExp :
  ;  n: Int
  ;  type: EType
  ;  mutable?: True|False
  ;  lostanza?: True|False


        (c:TLDefVar) :
          println("Not yet implemented: %_" % [c])
           ;n: Int
           ;type: LSType
           ;value: False|LSExp

  ;public defstruct EDefGlobal <: ETExp :
  ;  n: Int
  ;  type: EType
  ;  mutable?: True|False
  ;  lostanza?: True|False


        (c:TLDefn) :
          println("Not yet implemented: %_" % [c])
           ;props: FnProperties
           ;tail?: True|False
           ;n: Int
           ;targs: List<Int>
           ;cargs: List<Int>
           ;a1: List<LSType>
           ;a2: LSType
           ;args: List<Int>
           ;body: LSComm

  ;public defstruct EDefn <: ETExp :
  ;  n: Int
  ;  func: EFunction with: (updater => sub-func)
  ;  lostanza?: True|False

        (c:TLExternFn) :
          println("Not yet implemented: %_" % [c])
           ;props: FnProperties
           ;n: Int
           ;a1: List<LSType>
           ;a2: LSType
           ;args: List<Int>
           ;body: LSComm

  ;public defstruct EExternFn <: ETExp :
  ;  n: Int
  ;  lbl: Symbol
  ;  func: EFn with: (updater => sub-func)

        (c:TLDefmethod) :
          println("Not yet implemented: %_" % [c])
           ;props: FnProperties
           ;tail?: True|False
           ;n: Int
           ;multi: TExp
           ;targs: List<Int>
           ;cargs: List<Int>
           ;a1: List<LSType>
           ;a2: LSType
           ;args: List<Int>
           ;body: LSComm

  ;public defstruct EDefmethod <: ETExp :
  ;  n: Int
  ;  multi: Int
  ;  targs: Tuple<EType>
  ;  func: EFn with: (updater => sub-func)
  ;  lostanza?: True|False

        (c:TExtern) :
          val lbl = name(namemap[n(c)])
          emit(EExtern(n(c), lbl, to-etype(type(c))))

  ;public defstruct EExtern <: ETExp :
  ;  n: Int
  ;  lbl: Symbol
  ;  type: EType

        (c:TLInit) :
          println("Not yet implemented: %_" % [c])
           ;comm: LSComm

  ;public defstruct EInit <: ETExp :
  ;  body: EBody with: (updater => sub-body)
  ;  lostanza?: True|False

    println("===== Compiled =====")
    do(println, texps)

defn to-etype (t:LSType) :
  match(t) :
    (t:ByteT) : EByte()
    (t:IntT) : EInt()
    (t:LongT) : ELong()
    (t:FloatT) : EFloat()
    (t:DoubleT) : EDouble()
    (t:UnknownT) : EUnknown()
    (t:PtrT) : EPtrT()
    (t:RefT) : to-etype(type(t))
    (t:FnT) : EFnT(to-tuple(seq(to-etype,a(t))), to-etype?(r(t)), to-etype(b(t)))
    (t:StructT) : EStructT(n(t))

defn to-etype (t:Type) :
  match(t) :
    (t:TCap) : ETVar(n(t))
    (t:TOf) : EOf(n(t))
    (t:TTuple) : EOf(core-type(`Tuple))
    (t:TOr) : EOr(to-etype(a(t)), to-etype(b(t)))
    (t:TAnd) : EAnd(to-etype(a(t)), to-etype(b(t)))
    (t:TVar) : ETVar(n(t))
    (t:TArrow) : EOf(core-type(`Fn))
    (t:TGradual) : ETop()
    (t:TBot) : EBot()

defn to-etype? (t:False) : false
defn to-etype? (t:LSType) : to-etype(t)
defn to-etype? (t:Type) : to-etype(t)

var CURRENT-DTABLE:DTable|False = false
defn core-type (name:Symbol) :
  val t = CURRENT-DTABLE as DTable
  t[TypeId(`core, name)]

;   defnodes Type :
;      TMixed: (types:List<TArrow>) with: (constructor => #TMixed)
;      TPoly : (targs:List<Int>, cargs:List<Int>, func:TArrow)
;      TCap : (n:Int, name:Symbol|False)
;      TOf : (n:Int, type:Type)
;      TTuple : (types:List<Type>)
;      TOr : (a:Type, b:Type) with: (constructor => #TOr)
;      TAnd : (a:Type, b:Type) with: (constructor => #TAnd)
;      TVar : (n:Int, name:Symbol|False)
;      TArrow : (a:Type, b:Type)
;      TGradual : ()
;      TBot : ()
;      TUVar : (n:Int)

  
;   defnodes LSType :
;      ByteT
;      IntT
;      LongT
;      FloatT
;      DoubleT
;      UnknownT
;      PolyT : (targs:List<Int>, cargs:List<Int>, func:FnT)
;      RestT: (type:LSType)
;      PtrT: (type:LSType)
;      RefT: (type:Type)
;      FnT: (a:List<LSType>, r:False|LSType, b:LSType)
;      StructT: (n:Int, type:Type)
;      UVarT: (n:Int)

;LoStanza Types
;public defstruct EByte <: EType
;public defstruct EInt <: EType
;public defstruct ELong <: EType
;public defstruct EFloat <: EType
;public defstruct EDouble <: EType
;public defstruct EUnknown <: EType
;public defstruct EPtrT <: EType : (type:EType)
;public defstruct EFnT <: EType : (a:Tuple<EType>, r:False|EType, b:EType)
;public defstruct EStructT <: EType : (n:Int)
;
;;HiStanza Types
;public defstruct EOf <: EType: (n:Int)
;public defstruct ETVar <: EType: (n:Int)
;public defstruct EAnd <: EType: (a:EType, b:EType)
;public defstruct EOr <: EType: (a:EType, b:EType)
;public defstruct ETop <: EType
;public defstruct EBot <: EType

;============================================================
;====================== DTable ==============================
;============================================================

deftype DTable
defmulti get (this, id:RecId) -> Int

defn DTable () :
  val table = HashTable<RecId,Int>()
  new DTable :
    defmethod get (this, id:RecId) :
      match(get?(table,id)) :
        (n:Int) :
          n
        (_:False) :
          val n = fresh-id()
          table[id] = n
          n