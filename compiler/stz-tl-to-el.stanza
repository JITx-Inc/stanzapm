defpackage stz/tl-to-el :
  import core
  import collections
  import stz/namemap
  import stz/tl-ir
  import stz/el-ir
  import stz/dl-ir
  import stz/ids

public defn to-el (p:TProg, nm:NameMap) -> EPackage :
  for package in packages(p) as Seqable<TPackage> do :
    compile(package, nm)    
  fatal("Not yet implemented")

defn compile (p:TPackage, namemap:NameMap) :
  val texps = Vector<ETExp>()
  defn emit (e:ETExp) : add(texps, e)

  let-var CURRENT-DTABLE = DTable() :
    for c in comms(p) do :
      match(c) :
        (c:TDefType) :
          val parent = to-etype?(parent(c))
          val children = to-tuple(seq(n,children(c)))
          emit(EDefType(n(c), parent, children))
        (c:TLDefType) :
          println("Not yet implemented: %_" % [c])
           ;n: Int
           ;args: List<Int>
           ;parent: False|Type
           ;fields: List<Field>

  ;public defstruct EDefType <: ETExp :
  ;  n: Int
  ;  parent: False|EType
  ;  children: Tuple<Int>


        (c:TDef) :
          println("Not yet implemented: %_" % [c])
           ;n: Int
           ;type: False|Type
           ;value: TExp

  ;public defstruct EDefGlobal <: ETExp :
  ;  n: Int
  ;  type: EType
  ;  mutable?: True|False
  ;  lostanza?: True|False


        (c:TDefTuple) :
          println("Not yet implemented: %_" % [c])
           ;ns: List<Int>
           ;types: List<False|Type>
           ;value: TExp

  ;public defstruct EDefGlobal <: ETExp :
  ;  n: Int
  ;  type: EType
  ;  mutable?: True|False
  ;  lostanza?: True|False


        (c:TDefVar) :
          println("Not yet implemented: %_" % [c])
           ;n: Int
           ;type: False|Type
           ;value: False|TExp

  ;public defstruct EDefGlobal <: ETExp :
  ;  n: Int
  ;  type: EType
  ;  mutable?: True|False
  ;  lostanza?: True|False

        (c:TDefn) :
          emit(EDefn(n(c), compile-function(c), false))
        (c:TDefmulti) :
          println("Not yet implemented: %_" % [c])
           ;n: Int
           ;targs: List<Int>
           ;cargs: List<Int>
           ;a1: List<False|Type>
           ;a2: False|Type

  ;public defstruct EDefmulti <: ETExp :
  ;  n: Int
  ;  targs: Tuple<Int>
  ;  a1: Tuple<EType>
  ;  a2: EType


        (c:TDefmethod) :
          println("Not yet implemented: %_" % [c])
           ;props: FnProperties
           ;tail?: True|False
           ;n: Int
           ;multi: TExp
           ;thisn: False|Int
           ;targs: List<Int>
           ;cargs: List<Int>
           ;a1: List<False|Type>
           ;a2: False|Type
           ;args: List<Int>
           ;body: TExp

  ;public defstruct EDefmethod <: ETExp :
  ;  n: Int
  ;  multi: Int
  ;  targs: Tuple<EType>
  ;  func: EFn with: (updater => sub-func)
  ;  lostanza?: True|False


        (c:TInit) :
          println("Not yet implemented: %_" % [c])
           ;exp: TExp

  ;public defstruct EInit <: ETExp :
  ;  body: EBody with: (updater => sub-body)
  ;  lostanza?: True|False

        (c:TLDef) :
          println("Not yet implemented: %_" % [c])
           ;n: Int
           ;type: LSType
           ;value: LSExp

  ;public defstruct EDefGlobal <: ETExp :
  ;  n: Int
  ;  type: EType
  ;  mutable?: True|False
  ;  lostanza?: True|False


        (c:TLDefVar) :
          println("Not yet implemented: %_" % [c])
           ;n: Int
           ;type: LSType
           ;value: False|LSExp

  ;public defstruct EDefGlobal <: ETExp :
  ;  n: Int
  ;  type: EType
  ;  mutable?: True|False
  ;  lostanza?: True|False


        (c:TLDefn) :
          println("Not yet implemented: %_" % [c])
           ;props: FnProperties
           ;tail?: True|False
           ;n: Int
           ;targs: List<Int>
           ;cargs: List<Int>
           ;a1: List<LSType>
           ;a2: LSType
           ;args: List<Int>
           ;body: LSComm

  ;public defstruct EDefn <: ETExp :
  ;  n: Int
  ;  func: EFunction with: (updater => sub-func)
  ;  lostanza?: True|False

        (c:TLExternFn) :
          println("Not yet implemented: %_" % [c])
           ;props: FnProperties
           ;n: Int
           ;a1: List<LSType>
           ;a2: LSType
           ;args: List<Int>
           ;body: LSComm

  ;public defstruct EExternFn <: ETExp :
  ;  n: Int
  ;  lbl: Symbol
  ;  func: EFn with: (updater => sub-func)

        (c:TLDefmethod) :
          println("Not yet implemented: %_" % [c])
           ;props: FnProperties
           ;tail?: True|False
           ;n: Int
           ;multi: TExp
           ;targs: List<Int>
           ;cargs: List<Int>
           ;a1: List<LSType>
           ;a2: LSType
           ;args: List<Int>
           ;body: LSComm

  ;public defstruct EDefmethod <: ETExp :
  ;  n: Int
  ;  multi: Int
  ;  targs: Tuple<EType>
  ;  func: EFn with: (updater => sub-func)
  ;  lostanza?: True|False

        (c:TExtern) :
          val lbl = name(namemap[n(c)])
          emit(EExtern(n(c), lbl, to-etype(type(c))))

  ;public defstruct EExtern <: ETExp :
  ;  n: Int
  ;  lbl: Symbol
  ;  type: EType

        (c:TLInit) :
          println("Not yet implemented: %_" % [c])
           ;comm: LSComm

  ;public defstruct EInit <: ETExp :
  ;  body: EBody with: (updater => sub-body)
  ;  lostanza?: True|False

    println("===== Compiled =====")
    do(println, texps)

;============================================================
;=================== Function Compilation ===================
;============================================================
defn compile-function (e:TDefn) :
  val targs* = to-tuple(cat(targs(e), cargs(e)))
  val args* = to-tuple(args(e))
  val a1* = to-tuple(seq(to-etype{_ as Type}, a1(e)))
  val a2* = to-etype(a2(e) as Type)
  
  val c = Compiler()
  for t in targs* do :
    emit(c, ELocalType(t))
  for (a in args*, t in a1*) do :
    emit(c, ELocal(a, t, false))
  compile(c, body(e))
  EFn(targs*, args*, a1*, a2*, body(c))

;============================================================
;=============== Expression Compilation =====================
;============================================================

deftype Compiler
defmulti compile (c:Compiler, e:TExp) -> False
defmulti body (c:Compiler) -> EBody
defmulti emit (c:Compiler, l:ELocal) -> False
defmulti emit (c:Compiler, l:ELocalType) -> False

defn Compiler () :
  ;Buffers
  val locals = Vector<ELocal>()
  val localtypes = Vector<ELocalType>()
  val localfns = Vector<ELocalFn>()
  val localobjs = Vector<ELocalObj>()
  val ins = Vector<EIns>()
  defn emit (l:ELocal) : add(locals, l)
  defn emit (l:ELocalType) : add(localtypes, l)
  defn emit (l:ELocalFn) : add(localfns, l)
  defn emit (l:ELocalObj) : add(localobjs, l)
  defn emit (l:EIns) : add(ins, l)

  defn compile (e:TExp) -> EImm :
    match(e) :
      (e:TLet) :
        emit(ELocal(n(e), to-etype(ntype(e) as Type), false))
        emit(EDef(EVarLoc(n(e)), compile(value(e))))
        compile(body(e))
      (e:TLetVar) :
        emit(ELocal(n(e), to-etype(ntype(e) as Type), true))
        emit(EDef(EVarLoc(n(e)), compile?(value(e))))
        compile(body(e))
      (e:TLetTuple) :
        val tmp = fresh-id()
        emit(ELocal(tmp, ETop(), false))
        emit(EDef(EVarLoc(tmp), compile(value(e))))
        emit(ECheckLength(EVar(tmp), length(ns(e))))
        for (n in ns(e), t in ntypes(e), i in 0 to false) do :
          emit(ELocal(n, to-etype(t as Type), false))
          emit(ETupleGet(EVarLoc(n), EVar(tmp), i))
        compile(body(e))
      (e:TLetRec) :
        for d in defns(e) do :
          emit(ELocalFn(n(d), compile-function(d)))
        val closures = to-tuple(seq(EVarLoc{n(_)}, defns(e)))
        emit(EInitClosures(closures))
        compile(body(e))
      (e:TFn) :
        ;(tail?:True|False, a1:List<False|Type>, a2:False|Type, args:List<Int>, body:TExp)
        println("Not yet implemented: %_" % [e])
        ELiteral(false)
      (e:TMulti) :
        ;(funcs:List<TFn>)
        println("Not yet implemented: %_" % [e])
        ELiteral(false)
      (e:TSeq) :
        ;(a:TExp, b:TExp)
        println("Not yet implemented: %_" % [e])
        ELiteral(false)
      (e:TMatch) :
        ;(args:List<TExp>, branches:List<TBranch>)
        println("Not yet implemented: %_" % [e])
        ELiteral(false)
      (e:TBranch) :
        ;(args:List<Int>, atypes:List<False|Type>, body:TExp)
        println("Not yet implemented: %_" % [e])
        ELiteral(false)
      (e:TNew) :
        ;(class:Type, methods:List<TDefmethod>)
        println("Not yet implemented: %_" % [e])
        ELiteral(false)
      (e:TRef) :
        ;(n:Int)
        println("Not yet implemented: %_" % [e])
        ELiteral(false)
      (e:TCast) :
        ;(exp:TExp, targ:Type)
        println("Not yet implemented: %_" % [e])
        ELiteral(false)
      (e:TUpCast) :
        ;(exp:TExp, targ:Type)
        println("Not yet implemented: %_" % [e])
        ELiteral(false)
      (e:TSet) :
        ;(ref:TRef, value:TExp)
        println("Not yet implemented: %_" % [e])
        ELiteral(false)
      (e:TDo) :
        ;(func:TExp, args:List<TExp>)
        println("Not yet implemented: %_" % [e])
        ELiteral(false)
      (e:TPrim) :
        ;(op:Primitive, args:List<TExp>)
        println("Not yet implemented: %_" % [e])
        ELiteral(false)
      (e:TLiteral) :
        ;(value:?)
        println("Not yet implemented: %_" % [e])
        ELiteral(false)
      (e:TTupleExp) :
        ;(exps:List<TExp>)
        println("Not yet implemented: %_" % [e])
        ELiteral(false)
      (e:TMix) :
        ;(sel:False|Selection, exps:List<TExp>)
        println("Not yet implemented: %_" % [e])
        ELiteral(false)
      (e:TCurry) :
        ;(ref:TRef, targs:List<Type>, cargs:List<False|Type>)
        println("Not yet implemented: %_" % [e])
        ELiteral(false)

  defn compile? (e:TExp) : compile(e)
  defn compile? (e:False) : false

  new Compiler :
    defmethod compile (this, e:TExp) :
      compile(e)
      false
    defmethod body (this) :
      EBody(to-tuple(locals),
            to-tuple(localtypes),
            to-tuple(localfns),
            to-tuple(localobjs),
            to-tuple(ins))
    defmethod emit (this, l:ELocal) :
      emit(l)
    defmethod emit (this, l:ELocalType) :
      emit(l)

;============================================================
;================== Type Compilation ========================
;============================================================

defn to-etype (t:LSType) :
  match(t) :
    (t:ByteT) : EByte()
    (t:IntT) : EInt()
    (t:LongT) : ELong()
    (t:FloatT) : EFloat()
    (t:DoubleT) : EDouble()
    (t:UnknownT) : EUnknown()
    (t:PtrT) : EPtrT()
    (t:RefT) : to-etype(type(t))
    (t:FnT) : EFnT(to-tuple(seq(to-etype,a(t))), to-etype?(r(t)), to-etype(b(t)))
    (t:StructT) : EStructT(n(t))

defn to-etype (t:Type) :
  match(t) :
    (t:TCap) : ETVar(n(t))
    (t:TOf) : EOf(n(t))
    (t:TTuple) : EOf(core-type(`Tuple))
    (t:TOr) : EOr(to-etype(a(t)), to-etype(b(t)))
    (t:TAnd) : EAnd(to-etype(a(t)), to-etype(b(t)))
    (t:TVar) : ETVar(n(t))
    (t:TArrow) : EOf(core-type(`Fn))
    (t:TGradual) : ETop()
    (t:TBot) : EBot()

defn to-etype? (t:False) : false
defn to-etype? (t:LSType) : to-etype(t)
defn to-etype? (t:Type) : to-etype(t)


;============================================================
;====================== DTable ==============================
;============================================================

deftype DTable
defmulti get (this, id:RecId) -> Int

defn DTable () :
  val table = HashTable<RecId,Int>()
  new DTable :
    defmethod get (this, id:RecId) :
      match(get?(table,id)) :
        (n:Int) :
          n
        (_:False) :
          val n = fresh-id()
          table[id] = n
          n

var CURRENT-DTABLE:DTable|False = false
defn core-type (name:Symbol) :
  val t = CURRENT-DTABLE as DTable
  t[TypeId(`core, name)]