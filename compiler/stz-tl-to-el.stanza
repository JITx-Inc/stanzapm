defpackage stz/tl-to-el :
  import core
  import collections
  import stz/namemap
  import stz/tl-ir
  import stz/el-ir

public defn to-el (p:TProg, nm:NameMap) -> EPackage :
  for package in packages(p) as Seqable<TPackage> do :
    compile(package)    
  fatal("Not yet implemented")

defn compile (p:TPackage) :
  for c in comms(p) do :
    match(c) :
      (c:TDefType) :
        println("Not yet implemented: %_" % [c])
         ;n: Int
         ;args: List<Int>
         ;parent: False|Type
         ;children: List<Child>

;public defstruct EDefType <: ETExp :
;  n: Int
;  parent: False|EType
;  children: Tuple<Int>

      (c:TLDefType) :
        println("Not yet implemented: %_" % [c])
         ;n: Int
         ;args: List<Int>
         ;parent: False|Type
         ;fields: List<Field>

;public defstruct EDefType <: ETExp :
;  n: Int
;  parent: False|EType
;  children: Tuple<Int>


      (c:TDef) :
        println("Not yet implemented: %_" % [c])
         ;n: Int
         ;type: False|Type
         ;value: TExp

;public defstruct EDefGlobal <: ETExp :
;  n: Int
;  type: EType
;  mutable?: True|False
;  lostanza?: True|False


      (c:TDefTuple) :
        println("Not yet implemented: %_" % [c])
         ;ns: List<Int>
         ;types: List<False|Type>
         ;value: TExp

;public defstruct EDefGlobal <: ETExp :
;  n: Int
;  type: EType
;  mutable?: True|False
;  lostanza?: True|False


      (c:TDefVar) :
        println("Not yet implemented: %_" % [c])
         ;n: Int
         ;type: False|Type
         ;value: False|TExp

;public defstruct EDefGlobal <: ETExp :
;  n: Int
;  type: EType
;  mutable?: True|False
;  lostanza?: True|False

      (c:TDefn) :
        println("Not yet implemented: %_" % [c])
         ;props: FnProperties
         ;tail?: True|False
         ;n: Int
         ;targs: List<Int>
         ;cargs: List<Int>
         ;a1: List<False|Type>
         ;a2: False|Type
         ;args: List<Int>
         ;body: TExp

;public defstruct EDefn <: ETExp :
;  n: Int
;  func: EFunction with: (updater => sub-func)
;  lostanza?: True|False


      (c:TDefmulti) :
        println("Not yet implemented: %_" % [c])
         ;n: Int
         ;targs: List<Int>
         ;cargs: List<Int>
         ;a1: List<False|Type>
         ;a2: False|Type

;public defstruct EDefmulti <: ETExp :
;  n: Int
;  targs: Tuple<Int>
;  a1: Tuple<EType>
;  a2: EType


      (c:TDefmethod) :
        println("Not yet implemented: %_" % [c])
         ;props: FnProperties
         ;tail?: True|False
         ;n: Int
         ;multi: TExp
         ;thisn: False|Int
         ;targs: List<Int>
         ;cargs: List<Int>
         ;a1: List<False|Type>
         ;a2: False|Type
         ;args: List<Int>
         ;body: TExp

;public defstruct EDefmethod <: ETExp :
;  n: Int
;  multi: Int
;  targs: Tuple<EType>
;  func: EFn with: (updater => sub-func)
;  lostanza?: True|False


      (c:TInit) :
        println("Not yet implemented: %_" % [c])
         ;exp: TExp

;public defstruct EInit <: ETExp :
;  body: EBody with: (updater => sub-body)
;  lostanza?: True|False

      (c:TLDef) :
        println("Not yet implemented: %_" % [c])
         ;n: Int
         ;type: LSType
         ;value: LSExp

;public defstruct EDefGlobal <: ETExp :
;  n: Int
;  type: EType
;  mutable?: True|False
;  lostanza?: True|False


      (c:TLDefVar) :
        println("Not yet implemented: %_" % [c])
         ;n: Int
         ;type: LSType
         ;value: False|LSExp

;public defstruct EDefGlobal <: ETExp :
;  n: Int
;  type: EType
;  mutable?: True|False
;  lostanza?: True|False


      (c:TLDefn) :
        println("Not yet implemented: %_" % [c])
         ;props: FnProperties
         ;tail?: True|False
         ;n: Int
         ;targs: List<Int>
         ;cargs: List<Int>
         ;a1: List<LSType>
         ;a2: LSType
         ;args: List<Int>
         ;body: LSComm

;public defstruct EDefn <: ETExp :
;  n: Int
;  func: EFunction with: (updater => sub-func)
;  lostanza?: True|False

      (c:TLExternFn) :
        println("Not yet implemented: %_" % [c])
         ;props: FnProperties
         ;n: Int
         ;a1: List<LSType>
         ;a2: LSType
         ;args: List<Int>
         ;body: LSComm

;public defstruct EExternFn <: ETExp :
;  n: Int
;  lbl: Symbol
;  func: EFn with: (updater => sub-func)

      (c:TLDefmethod) :
        println("Not yet implemented: %_" % [c])
         ;props: FnProperties
         ;tail?: True|False
         ;n: Int
         ;multi: TExp
         ;targs: List<Int>
         ;cargs: List<Int>
         ;a1: List<LSType>
         ;a2: LSType
         ;args: List<Int>
         ;body: LSComm

;public defstruct EDefmethod <: ETExp :
;  n: Int
;  multi: Int
;  targs: Tuple<EType>
;  func: EFn with: (updater => sub-func)
;  lostanza?: True|False

      (c:TExtern) :
        println("Not yet implemented: %_" % [c])
         ;n: Int
         ;type: LSType

;public defstruct EExtern <: ETExp :
;  n: Int
;  lbl: Symbol
;  type: EType

      (c:TLInit) :
        println("Not yet implemented: %_" % [c])
         ;comm: LSComm

;public defstruct EInit <: ETExp :
;  body: EBody with: (updater => sub-body)
;  lostanza?: True|False

defn to-etype (t:LSType) :
  match(t) :
    (t:ByteT) : EByte()
    (t:IntT) : EInt()
    (t:LongT) : ELong()
    (t:FloatT) : EFloat()
    (t:DoubleT) : EDouble()
    (t:UnknownT) : EUnknown()
    (t:PtrT) : EPtrT(to-etype(type(t)))
    (t:RefT) : to-etype(type(t))
    (t:FnT) : EFnT(map(to-etype(a(t))), to-etype?(r(t)), to-etype(b(t)))
    (t:StructT) : EStructT(n(t))

defn to-etype (t:Type) :
  match(t) :
    (t:TCap) : ETVar(n(t))
    (t:TOf) : EOf(n(t))
    (t:TTuple) : EOf(TUPLE-TYPE) <-- Where does this come from?
    (t:TOr) : EOr(to-etype(a(t)), to-etype(b(t)))
    (t:TAnd) : EAnd(to-etype(a(t)), to-etype(b(t)))
    (t:TVar) : ETVar(n(t))
    (t:TArrow) : EOf(FN-TYPE) <-- Where does this come from?
    (t:TGradual) : ETop()
    (t:TBot) : EBot()

defn to-etype? (t:False) : false
defn to-etype? (t:LSType) : to-etype(t)
defn to-etype? (t:Type) : to-etype(t)

;   defnodes Type :
;      TMixed: (types:List<TArrow>) with: (constructor => #TMixed)
;      TPoly : (targs:List<Int>, cargs:List<Int>, func:TArrow)
;      TCap : (n:Int, name:Symbol|False)
;      TOf : (n:Int, type:Type)
;      TTuple : (types:List<Type>)
;      TOr : (a:Type, b:Type) with: (constructor => #TOr)
;      TAnd : (a:Type, b:Type) with: (constructor => #TAnd)
;      TVar : (n:Int, name:Symbol|False)
;      TArrow : (a:Type, b:Type)
;      TGradual : ()
;      TBot : ()
;      TUVar : (n:Int)

  
;   defnodes LSType :
;      ByteT
;      IntT
;      LongT
;      FloatT
;      DoubleT
;      UnknownT
;      PolyT : (targs:List<Int>, cargs:List<Int>, func:FnT)
;      RestT: (type:LSType)
;      PtrT: (type:LSType)
;      RefT: (type:Type)
;      FnT: (a:List<LSType>, r:False|LSType, b:LSType)
;      StructT: (n:Int, type:Type)
;      UVarT: (n:Int)

;LoStanza Types
;public defstruct EByte <: EType
;public defstruct EInt <: EType
;public defstruct ELong <: EType
;public defstruct EFloat <: EType
;public defstruct EDouble <: EType
;public defstruct EUnknown <: EType
;public defstruct EPtrT <: EType : (type:EType)
;public defstruct EFnT <: EType : (a:Tuple<EType>, r:False|EType, b:EType)
;public defstruct EStructT <: EType : (n:Int)
;
;;HiStanza Types
;public defstruct EOf <: EType: (n:Int)
;public defstruct ETVar <: EType: (n:Int)
;public defstruct EAnd <: EType: (a:EType, b:EType)
;public defstruct EOr <: EType: (a:EType, b:EType)
;public defstruct ETop <: EType
;public defstruct EBot <: EType