defpackage stz/tl-to-el :
  import core
  import collections
  import stz/namemap with:
    prefix(EType) => NM
  import stz/tl-ir
  import stz/el-ir
  import stz/dl-ir
  import stz/ids
  import stz/primitives

public defn to-el (p:TProg, nm:NameMap) -> EPackage :
  for package in packages(p) as Seqable<TPackage> do :
    compile(package, nm)    
  fatal("Not yet implemented")

defn compile (p:TPackage, namemap:NameMap) :
  val texps = Vector<ETExp>()
  defn emit (e:ETExp) : add(texps, e)

  let-var CURRENT-DTABLE = DTable() :
    for c in comms(p) do :
      match(c) :
        (c:TDefType) :
          val parent = to-etype?(parent(c))
          val children = to-tuple(seq(n,children(c)))
          emit(EDefType(n(c), parent, children))
        (c:TLDefType) :
          println("Not yet implemented: %_" % [c])
           ;n: Int
           ;args: List<Int>
           ;parent: False|Type
           ;fields: List<Field>

  ;public defstruct EDefType <: ETExp :
  ;  n: Int
  ;  parent: False|EType
  ;  children: Tuple<Int>


        (c:TDef) :
          println("Not yet implemented: %_" % [c])
           ;n: Int
           ;type: False|Type
           ;value: TExp

  ;public defstruct EDefGlobal <: ETExp :
  ;  n: Int
  ;  type: EType
  ;  mutable?: True|False
  ;  lostanza?: True|False


        (c:TDefTuple) :
          println("Not yet implemented: %_" % [c])
           ;ns: List<Int>
           ;types: List<False|Type>
           ;value: TExp

  ;public defstruct EDefGlobal <: ETExp :
  ;  n: Int
  ;  type: EType
  ;  mutable?: True|False
  ;  lostanza?: True|False


        (c:TDefVar) :
          println("Not yet implemented: %_" % [c])
           ;n: Int
           ;type: False|Type
           ;value: False|TExp

  ;public defstruct EDefGlobal <: ETExp :
  ;  n: Int
  ;  type: EType
  ;  mutable?: True|False
  ;  lostanza?: True|False

        (c:TDefn) :
          emit(EDefn(n(c), compile-function(c), false))
        (c:TDefmulti) :
          println("Not yet implemented: %_" % [c])
           ;n: Int
           ;targs: List<Int>
           ;cargs: List<Int>
           ;a1: List<False|Type>
           ;a2: False|Type

  ;public defstruct EDefmulti <: ETExp :
  ;  n: Int
  ;  targs: Tuple<Int>
  ;  a1: Tuple<EType>
  ;  a2: EType


        (c:TDefmethod) :
          println("Not yet implemented: %_" % [c])
           ;props: FnProperties
           ;tail?: True|False
           ;n: Int
           ;multi: TExp
           ;thisn: False|Int
           ;targs: List<Int>
           ;cargs: List<Int>
           ;a1: List<False|Type>
           ;a2: False|Type
           ;args: List<Int>
           ;body: TExp

  ;public defstruct EDefmethod <: ETExp :
  ;  n: Int
  ;  multi: Int
  ;  targs: Tuple<EType>
  ;  func: EFn with: (updater => sub-func)
  ;  lostanza?: True|False


        (c:TInit) :
          println("Not yet implemented: %_" % [c])
           ;exp: TExp

  ;public defstruct EInit <: ETExp :
  ;  body: EBody with: (updater => sub-body)
  ;  lostanza?: True|False

        (c:TLDef) :
          println("Not yet implemented: %_" % [c])
           ;n: Int
           ;type: LSType
           ;value: LSExp

  ;public defstruct EDefGlobal <: ETExp :
  ;  n: Int
  ;  type: EType
  ;  mutable?: True|False
  ;  lostanza?: True|False


        (c:TLDefVar) :
          println("Not yet implemented: %_" % [c])
           ;n: Int
           ;type: LSType
           ;value: False|LSExp

  ;public defstruct EDefGlobal <: ETExp :
  ;  n: Int
  ;  type: EType
  ;  mutable?: True|False
  ;  lostanza?: True|False


        (c:TLDefn) :
          println("Not yet implemented: %_" % [c])
           ;props: FnProperties
           ;tail?: True|False
           ;n: Int
           ;targs: List<Int>
           ;cargs: List<Int>
           ;a1: List<LSType>
           ;a2: LSType
           ;args: List<Int>
           ;body: LSComm

  ;public defstruct EDefn <: ETExp :
  ;  n: Int
  ;  func: EFunction with: (updater => sub-func)
  ;  lostanza?: True|False

        (c:TLExternFn) :
          println("Not yet implemented: %_" % [c])
           ;props: FnProperties
           ;n: Int
           ;a1: List<LSType>
           ;a2: LSType
           ;args: List<Int>
           ;body: LSComm

  ;public defstruct EExternFn <: ETExp :
  ;  n: Int
  ;  lbl: Symbol
  ;  func: EFn with: (updater => sub-func)

        (c:TLDefmethod) :
          println("Not yet implemented: %_" % [c])
           ;props: FnProperties
           ;tail?: True|False
           ;n: Int
           ;multi: TExp
           ;targs: List<Int>
           ;cargs: List<Int>
           ;a1: List<LSType>
           ;a2: LSType
           ;args: List<Int>
           ;body: LSComm

  ;public defstruct EDefmethod <: ETExp :
  ;  n: Int
  ;  multi: Int
  ;  targs: Tuple<EType>
  ;  func: EFn with: (updater => sub-func)
  ;  lostanza?: True|False

        (c:TExtern) :
          val lbl = name(namemap[n(c)])
          emit(EExtern(n(c), lbl, to-etype(type(c))))

  ;public defstruct EExtern <: ETExp :
  ;  n: Int
  ;  lbl: Symbol
  ;  type: EType

        (c:TLInit) :
          println("Not yet implemented: %_" % [c])
           ;comm: LSComm

  ;public defstruct EInit <: ETExp :
  ;  body: EBody with: (updater => sub-body)
  ;  lostanza?: True|False

    println("===== Compiled =====")
    do(println, texps)

;============================================================
;=================== Function Compilation ===================
;============================================================
defn compile-function (e:TDefn) :
  val targs* = to-tuple(cat(targs(e), cargs(e)))
  val args* = to-tuple(args(e))
  val a1* = to-tuple(seq(to-etype{_ as Type}, a1(e)))
  val a2* = to-etype(a2(e) as Type)
  
  val c = Compiler()
  for t in targs* do :
    emit(c, ELocalType(t))
  for (a in args*, t in a1*) do :
    emit(c, ELocal(a, t, false))
  compile(c, body(e))
  EFn(targs*, args*, a1*, a2*, body(c))

defn compile-function (e:TDefmethod) :
  val targs* = to-tuple(cat(targs(e), cargs(e)))
  val args* = to-tuple(args(e))
  val a1* = to-tuple(seq(to-etype{_ as Type}, a1(e)))
  val a2* = to-etype(a2(e) as Type)
  
  val c = Compiler()
  for t in targs* do :
    emit(c, ELocalType(t))
  for (a in args*, t in a1*) do :
    emit(c, ELocal(a, t, false))
  compile(c, body(e))
  EFn(targs*, args*, a1*, a2*, body(c))

defn compile-function (e:TFn) :
  val args* = to-tuple(args(e))
  val a1* = to-tuple(seq(to-etype{_ as Type}, a1(e)))
  val a2* = to-etype(a2(e) as Type)
  
  val c = Compiler()
  for (a in args*, t in a1*) do :
    emit(c, ELocal(a, t, false))
  compile(c, body(e))
  EFn([], args*, a1*, a2*, body(c))

defn compile-function (e:TMulti) :
  EMultifn(to-tuple(seq(compile-function, funcs(e))))

;============================================================
;=============== Expression Compilation =====================
;============================================================

deftype Compiler
defmulti compile (c:Compiler, e:TExp) -> False
defmulti body (c:Compiler) -> EBody
defmulti emit (c:Compiler, l:ELocal) -> False
defmulti emit (c:Compiler, l:ELocalType) -> False

defn Compiler () :
  ;Buffers
  val locals = Vector<ELocal>()
  val localtypes = Vector<ELocalType>()
  val localfns = Vector<ELocalFn>()
  val localobjs = Vector<ELocalObj>()
  val ins = Vector<EIns>()
  defn emit (l:ELocal) : add(locals, l)
  defn emit (l:ELocalType) : add(localtypes, l)
  defn emit (l:ELocalFn) : add(localfns, l)
  defn emit (l:ELocalObj) : add(localobjs, l)
  defn emit (l:EIns) : add(ins, l)

  defn compile (e:TExp) -> EImm :
    match(e) :
      (e:TLet) :
        emit(ELocal(n(e), to-etype(ntype(e) as Type), false))
        emit(EDef(EVarLoc(n(e)), compile(value(e))))
        compile(body(e))
      (e:TLetVar) :
        emit(ELocal(n(e), to-etype(ntype(e) as Type), true))
        emit(EDef(EVarLoc(n(e)), compile?(value(e))))
        compile(body(e))
      (e:TLetTuple) :
        val tmp = fresh-id()
        emit(ELocal(tmp, ETop(), false))
        emit(EDef(EVarLoc(tmp), compile(value(e))))
        emit(ECheckLength(EVar(tmp), length(ns(e))))
        for (n in ns(e), t in ntypes(e), i in 0 to false) do :
          emit(ELocal(n, to-etype(t as Type), false))
          emit(ETupleGet(EVarLoc(n), EVar(tmp), i))
        compile(body(e))
      (e:TLetRec) :
        for d in defns(e) do :
          emit(ELocalFn(n(d), compile-function(d)))
        val closures = to-tuple(seq(EVarLoc{n(_)}, defns(e)))
        emit(EInitClosures(closures))
        compile(body(e))
      (e:TFn|TMulti) :
        val tmp = fresh-id()
        emit(ELocalFn(tmp, compile-function(e)))
        emit(EInitClosures([EVarLoc(tmp)]))
        EVar(tmp)
      (e:TSeq) :
        compile(a(e))
        compile(b(e))
      (e:TMatch) :
        val ebranches = to-tuple $
          for b in branches(e) seq :
            val types* = to-tuple $
              for t in atypes(b) seq :
                to-etype(t as Type)
            EBranch(types*, fresh-id())
        val ys = to-tuple(seq(compile, args(e)))
        emit(EMatch(ys, ebranches))
        val end = fresh-id()
        val tmp = fresh-id()
        emit(ELocal(tmp, ETop(), false))
        for (b in branches(e), eb in ebranches) do :
          emit(ELabel(n(eb)))
          for (a in args(b), t in types(eb), y in ys) do :            
            emit(ELocal(a, t, false))
            emit(EDef(EVarLoc(a), y))
          val result = compile(body(b))
          emit(EDef(EVarLoc(tmp), result))
          emit(EGoto(end))
        emit(ELabel(end))
        EVar(tmp)
      (e:TNew) :
        val methods = to-tuple $ for m in methods(e) seq :
          val func = compile-function(m)
          val [multi, targs] = multi-args(multi(m))
          EMethod(multi, to-tuple(seq(to-etype, targs)), thisn(m) as Int, func)
        val obj = fresh-id()
        emit(ELocalObj(obj, to-etype(class(e)), methods))
        val tmp = fresh-id()
        emit(ELocal(tmp, to-etype(class(e)), false))
        emit(ENew(EVarLoc(tmp), obj))
        EVar(tmp)
      (e:TRef) :
        EVar(n(e))
      (e:TCast) :
        val etype = to-etype(targ(e))
        val tmp = fresh-id()
        val x = compile(exp(e))
        emit(ECheck(x, etype))
        emit(ELocal(tmp, etype, false))
        emit(EDef(EVarLoc(tmp), x))
        EVar(tmp)
      (e:TUpCast) :
        compile(exp(e))
      (e:TSet) :
        emit(EStore(EVarLoc(n(ref(e))), compile(value(e))))
        ELiteral(false)
      (e:TDo) :
        ;Get types
        val a1 = seq({type(ctxt(_) as CExp) as Type}, args(e))
        val a2 = type(e) as Type
        val ytypes = to-tuple(seq(to-etype, a1))
        val xtype = to-etype(a2)
        ;Make instruction
        val func* = compile(func(e))
        val args* = to-tuple(seq(compile,args(e)))
        val ret = fresh-id()
        emit(ELocal(ret, xtype, false))
        emit(ECheckedDo(EVarLoc(ret), func*, args*, ytypes))
        EVar(ret)
      (e:TPrim) :
        val ys = to-tuple(seq(compile, args(e)))
        val [op, type] = to-eop(op(e))
        val ret = fresh-id()
        emit(ELocal(ret, type, false))
        emit(EPrim(EVarLoc(ret), op, ys))
        EVar(ret)
      (e:TLiteral) :
        ELiteral(value(e))
      (e:TTupleExp) :
        val ys = to-tuple(seq(compile, exps(e)))
        val ret = fresh-id()
        emit(ELocal(ret, EOf(core-type(`Tuple)), false))
        emit(ETuple(EVarLoc(ret), ys))
        EVar(ret)
      (e:TMix) :
        val exps* = select-all(sel(e) as SSel, exps(e))
        if length(exps*) == 1 :
          compile(head(exps*))
        else :
          val ys = seq({compile(_) as EVar|ECurry}, exps*)
          EMix(to-tuple(ys))
      (e:TCurry) :
        val types = cat(targs(e), cargs(e) as List<Type>)
        val targs = to-tuple(seq(to-etype, types))
        ECurry(EVar(n(ref(e))), targs)

  ;Compile an expression if it is not false
  defn compile? (e:TExp) : compile(e)
  defn compile? (e:False) : false

  new Compiler :
    defmethod compile (this, e:TExp) :
      compile(e)
      false
    defmethod body (this) :
      EBody(to-tuple(locals),
            to-tuple(localtypes),
            to-tuple(localfns),
            to-tuple(localobjs),
            to-tuple(ins))
    defmethod emit (this, l:ELocal) :
      emit(l)
    defmethod emit (this, l:ELocalType) :
      emit(l)

;============================================================
;==================== Primitives ============================
;============================================================

defn to-eop (op:Primitive) -> [EOp, EType] :
  val int = EOf(core-type(`Int))
  val bool = EOr(EOf(core-type(`True)), EOf(core-type(`False)))
  switch(op) :
    ADD-OP : [IntAddOp(), int]
    SUB-OP : [IntSubOp(), int]
    MUL-OP : [IntMulOp(), int]
    DIV-OP : [IntDivOp(), int]
    MOD-OP : [IntModOp(), int]
    AND-OP : [IntAndOp(), int]
    OR-OP :  [IntOrOp(), int]
    XOR-OP : [IntXorOp(), int]
    SHL-OP : [IntShlOp(), int]
    SHR-OP : [IntShrOp(), int]
    ASHR-OP : [IntAshrOp(), int]
    NOT-OP : [IntNotOp(), int]
    NEG-OP : [IntNegOp(), int]
    EQ-OP : [RefEqOp(), bool]
    NE-OP : [RefNeOp(), bool]
    LT-OP : [IntLtOp(), bool]
    GT-OP : [IntGtOp(), bool]
    LE-OP : [IntLeOp(), bool]
    GE-OP : [IntGeOp(), bool]
    IDENTICAL-OP : [RefEqOp(), bool]

;============================================================
;================== Type Compilation ========================
;============================================================

defn to-etype (t:LSType) :
  match(t) :
    (t:ByteT) : EByte()
    (t:IntT) : EInt()
    (t:LongT) : ELong()
    (t:FloatT) : EFloat()
    (t:DoubleT) : EDouble()
    (t:UnknownT) : EUnknown()
    (t:PtrT) : EPtrT()
    (t:RefT) : to-etype(type(t))
    (t:FnT) : EFnT(to-tuple(seq(to-etype,a(t))), to-etype?(r(t)), to-etype(b(t)))
    (t:StructT) : EStructT(n(t))

defn to-etype (t:Type) :
  match(t) :
    (t:TCap) : ETVar(n(t))
    (t:TOf) : EOf(n(t))
    (t:TTuple) : EOf(core-type(`Tuple))
    (t:TOr) : EOr(to-etype(a(t)), to-etype(b(t)))
    (t:TAnd) : EAnd(to-etype(a(t)), to-etype(b(t)))
    (t:TVar) : ETVar(n(t))
    (t:TArrow) : EOf(core-type(`Fn))
    (t:TGradual) : ETop()
    (t:TBot) : EBot()

defn to-etype? (t:False) : false
defn to-etype? (t:LSType) : to-etype(t)
defn to-etype? (t:Type) : to-etype(t)

;============================================================
;====================== DTable ==============================
;============================================================

deftype DTable
defmulti get (this, id:RecId) -> Int

defn DTable () :
  val table = HashTable<RecId,Int>()
  new DTable :
    defmethod get (this, id:RecId) :
      match(get?(table,id)) :
        (n:Int) :
          n
        (_:False) :
          val n = fresh-id()
          table[id] = n
          n

var CURRENT-DTABLE:DTable|False = false
defn core-type (name:Symbol) :
  val t = CURRENT-DTABLE as DTable
  t[TypeId(`core, name)]

;============================================================
;===================== Utilities ============================
;============================================================

defn multi-args (e:TExp) -> [Int, List<Type>] :
  match(e) :
    (e:TRef) : [n(e), List()]
    (e:TCurry) : [n(ref(e)), append(targs(e), cargs(e)) as List<Type>]
    (e:TMix) : multi-args(select-1(sel(e) as SSel, exps(e)))

defn select-1<?T> (ss:SSel, xs:List<?T>) -> T :
  for (x in xs, s in sels(ss)) find! :
    s is-not False

defn select-all<?T> (ss:SSel, xs:List<?T>) -> List<T> :
  to-list $
  for (x in xs, s in sels(ss)) filter :
    s is-not False