defpackage stz/fuse :
  import core
  import collections
  import stz/pl-ir
  import stz/tgt-ir
  import stz/tl-ir
  import stz/type-calculus
  import stz/namemap
  import stz/asm-ir
  import stz/kl-ir
  import stz/ids

;============================================================
;==================== Stage0 Fusing =========================
;============================================================

public defn resolve (nm:NameMap, pkg:TGPackage) :
  val ids* = resolve-ids(nm, ids(pkg))
  TGPackage(name(pkg), ids*, entry(pkg), decls(pkg))

defn resolve-ids (nm:NameMap, ids:PkgIds) -> PkgIds :
  ;==============================
  ;==== Compute Rename Table ====
  ;==============================
  val table = HashTable<Int,Int>()
  for d in declarations(ids) do :
    table[old-n(nm,d)] = n(d)
  for ip in imports(ids) do :
    for i in imports(ip) do :
      match(id(i)) :
        (id:TypeId|LSTypeId) :
          match(type-id(nm, package(ip), name(id))) :
            (g:Int) : table[n(i)] = g
            (g:False) : fatal("Could not import type %_/%_." % [
              package(ip), name(id)])
        (id) : false

  ;=====================
  ;==== Resolve Ids ====
  ;=====================
  val r = Renamer(fn (i) : get?(table, i, i), true)
  defn rename (d:Declare) : Declare(n(d), /rename(r, id(d)), info(d))
  defn rename (i:Import) : Import(n(i), /rename(r, id(i)))
  defn rename (i:ImportPackage) : ImportPackage(package(i), map(rename, imports(i)))

  PkgIds(map(rename, declarations(ids)),
         map(rename, imports(ids)))

;============================================================
;==================== Stage1 Fusing =========================
;============================================================

public defn fuse-pkgs (nm:NameMap, pkgs:List<KPkgComm>) -> List<KPkgComm> :
  ;Construct id tables
  val id-tables = IdTables()
  for pkg in pkgs do :
    match(pkg) :
      (pkg:KPackage) :
        val table = id-tables[name(pkg)]
        for d in declarations(ids(pkg)) do :
          table[id(d)] = n(d)
      (pkg:TGPackage) :
        val table = id-tables[name(pkg)]
        for d in declarations(ids(pkg)) do :
          table[id(d)] = n(d)
          
  ;Rename all tgpackages
  for pkg in pkgs map :
    match(pkg:TGPackage) :
      rename-pkg(nm, id-tables, pkg)
    else : pkg
  
defn rename-pkg (nm:NameMap,
                 id-tables:IdTables,
                 pkg:TGPackage) :
  ;=======================
  ;==== Rename Tables ====
  ;=======================
  val table = HashTable<Int,Int>()
  
  ;====================
  ;==== ID Mapping ====
  ;====================
  defn map-over (src:Int, dst:Int) :
    table[dst] = src
  defn map-over (src:List<Int>, dst:List<Int>) :
    do(map-over, src, dst)
  defn map-over (src:Id, dst:Id) :
    match(src, dst) :
      (src:FnId, dst:FnId) :
        map-over(append(targs(src), cargs(src)),
                 append(targs(dst), cargs(dst)))        
      (src:MultiId, dst:MultiId) :
        map-over(append(targs(src), cargs(src)),
                 append(targs(dst), cargs(dst)))        
      (src:TypeId, dst:TypeId) :
        map-over(args(src), args(dst))                 
        map-over(seq-append(args, children(src))
                 seq-append(args, children(dst)))        
      (src:LSFnId, dst:LSFnId) :
        map-over(append(targs(src), cargs(src)),
                 append(targs(dst), cargs(dst)))        
      (src:LSTypeId, dst:LSTypeId) :
        map-over(args(src), args(dst))
        map-over(map(n, fields(src))
                 map(n, fields(dst)))

  ;===================================
  ;==== Constructing Rename Table ====
  ;===================================
  for d in declarations(ids(pkg)) do :
    table[old-n(nm,d)] = n(d)
  for ip in imports(ids(pkg)) do :
    val id-table = id-tables[package(ip)]
    for i in imports(ip) do :
      val g = id-table[id(i)]
      table[n(i)] = g
      match(id(i):FnId|MultiId|TypeId|LSFnId|LSTypeId) :
        map-over(id-tables[g], id(i))


  ;==============================================
  ;==== Rename Imports and Check Consistency ====
  ;==============================================
  val r = Renamer({table[_]}, false)
  defn rename (i:Import) : Import(table[n(i)], /rename(r,id(i)))
  defn rename (i:ImportPackage) : ImportPackage(package(i), map(rename, imports(i)))
  val imports* = map(rename, imports(ids(pkg)))

  for i in seq-cat(imports, imports*) do :
    if id(i) != id-tables[n(i)] :
      fatal("Import mismatch: Expected %_ but imported %_." % [
        id(i), id-tables[n(i)]])

  ;========================
  ;==== Rename Package ====
  ;========================
  defn rename? (x:Int) :
    if stable-id?(x) :
      x
    else :
      match(get?(table, x)) :
        (y:Int) :
          y
        (_:False) :
          val y = fresh-id()
          table[x] = y
          y    
  val decls* = /rename(Renamer(rename?, false), decls(pkg))
  val ids* = PkgIds(declarations(ids(pkg)), imports*)
  TGPackage(name(pkg), ids*, rename?(entry(pkg)), decls*)

;============================================================
;==================== Renamer ===============================
;============================================================

deftype Renamer
defmulti rename (r:Renamer, id:Id) -> Id
defmulti rename (r:Renamer, e:Vector<TGDecl>) -> Vector<TGDecl>

defn Renamer (rename-int: Int -> Int,
              rename-types?: True|False) :
  defn rename (i:Int) : rename-int(i)
  defn rename (x:Symbol) : x
  defn rename (x:False) : false
  
  defn rename (c:ChildDec) :
    val n* = rename(n(c)) when rename-types? else n(c)
    ChildDec(n*, rename(args(c)), rename(parent(c)))
    
  defn rename (f:FieldDec) :
    FieldDec(rename(n(f)), rename(type(f)))

  defn rename (t:Type) :
    match(map(rename,t)) :
      (t:TOf) :
        if rename-types? : TOf(rename(n(t)), type(t))
        else : t
      (t:TVar) : TVar(rename(n(t)))
      (t:TCap) : TCap(rename(n(t)))
      (t) : t

  defn rename (t:LSType) :
    match(map(rename{_:Type}, map(rename{_:LSType}, t))) :
      (t:StructT) :
        if rename-types? : StructT(rename(n(t)), type(t))
        else : t
      (t) : t
  
  defn rename (id:Id) :
    match(id) :
      (id:ValId) :
        ValId(name(id), rename(type(id)), visibility(id))
      (id:VarId) :
        VarId(name(id), rename(type(id)), visibility(id))
      (id:FnId) :
        FnId(name(id), tail?(id), rename(targs(id)), rename(cargs(id)),
          rename(a1(id)), rename(a2(id)), visibility(id))
      (id:MultiId) :
        MultiId(name(id), tail?(id), rename(targs(id)), rename(cargs(id)),
          rename(a1(id)), rename(a2(id)), visibility(id)), 
      (id:TypeId) :
        TypeId(name(id), rename(args(id)), rename(parent(id)),
          rename(children(id)), visibility(id)), 
      (id:TArgId) :
        id
      (id:LSValId) :
        LSValId(name(id), rename(type(id)), visibility(id))
      (id:LSVarId) :
        LSVarId(name(id), rename(type(id)), visibility(id))
      (id:LSFnId) :
        LSFnId(name(id), tail?(id), rename(targs(id)), rename(cargs(id)),
          rename(a1(id)), rename(a2(id)), visibility(id))
      (id:LSTypeId) :
        LSTypeId(name(id), rename(args(id)), rename(parent(id)),
          rename(fields(id)), visibility(id))
      (id:FieldId) :
        id
      (id:LSExternFnId) :
        LSExternFnId(name(id), lbl(id), rename(a1(id)),
          rename(a2(id)), visibility(id))
      (id:LSExternId) :
        LSExternId(name(id), lbl(id), rename(type(id)), visibility(id))  

  defn rename (x:Imm) :
    match(x) :
      (x:Mem) : Mem(rename(n(x)), offset(x))
      (x:TagImm) : TagImm(rename(n(x)), marker?(x))
      (x) : x
      
  defn rename (t:KTag) :
    match(t:KOf) : KOf(rename(n(t)))
    else : map(rename, t)
    
  defn rename (b:Branch) :
    Branch(map(rename, tags(b)), rename(n(b)))
    
  defn rename (x:Ins) :
    match(map(rename, x)) :
      (x:Label) : Label(rename(n(x)), info(x))
      (x:DefLabel) : DefLabel(rename(n(x)))
      (x:Match) : Match(xs(x), rename(branches(x)), info(x))
      (x:Dispatch) : Dispatch(xs(x), rename(branches(x)), info(x))
      (x) : x

  defn rename-const (c:TGConst) :
    match(c:TGTypeObject) : TGTypeObject(rename(n(c)))
    else : c

  defn rename (e:TGDecl) :      
    match(e) :
      (e:TGDefASM) :
        TGDefASM(rename(n(e)), rename(ins(e)))
      (e:TGDefmulti) :
        TGDefmulti(rename(n(e)), tarity(e), arity(e), info(e))
      (e:TGDefmethod) :
        TGDefmethod(rename(multi(e)), rename(tags(e)), rename(code(e)))
      (e:TGDefConst) :
        TGDefConst(rename(n(e)), rename-const(value(e)))
      (e:TGDefObject) :
        TGDefObject(rename(n(e)), rename(parent(e)), size(e),
          types(e), offsets(e), rsize(e), rtypes(e), roffsets(e))
      (e:TGDefGlobal) :
        TGDefGlobal(rename(n(e)), size(e), alignment(e),
          types(e), offsets(e))

  ;Plurals
  defn rename (xs:List<Int>) : map(rename, xs)
  defn rename (ts:List<LSType>) : map(rename, ts)
  defn rename (ts:List<Type>) : map(rename, ts)
  defn rename (xs:List<ChildDec>) : map(rename, xs)
  defn rename (xs:List<FieldDec>) : map(rename, xs)
  defn rename (xs:List<Branch>) : map(rename, xs)
  defn rename (xs:List<KTag>) : map(rename, xs)
  defn rename (xs:Vector<Ins>) : map<Ins>(rename, xs)
  defn rename (xs:Vector<TGDecl>) : map<TGDecl>(rename, xs)

  ;Return renamer
  new Renamer :
    defmethod rename (this, id:Id) : rename(id)
    defmethod rename (this, e:Vector<TGDecl>) : rename(e)

;============================================================
;==================== IdTable ===============================
;============================================================

;=================
;==== Id Keys ====
;=================
deftype IdKey <: Hashable & Equalable
defmulti id (k:IdKey) -> Id

defn IdKey (id:Id) :
  val id* = normalize(id)
  new IdKey :
    defmethod id (this) : id*
  
defn normalize (id:Id) :
  defn env (targs:List<Int>, cargs:List<Int>) ->
           [List<Int>, List<Int>, List<KeyValue<Int,Int>>] :
    val counter = to-seq(0 to false)
    val targs* = map(next{counter}, targs)
    val cargs* = map(next{counter}, cargs)
    val env = map(KeyValue,
                  append(targs, cargs),
                  append(targs*, cargs*))
    [targs*, cargs*, env]              
    
  defn norm (targs:List<Int>, cargs:List<Int>, a1:List<Type>) ->
             [List<Int>, List<Int>, List<Type>] :
    val [targs*, cargs*, env] = env(targs, cargs)
    val a1* = map(sub{_, env}, a1)
    [targs*, cargs*, a1*]
    
  defn norm (targs:List<Int>, cargs:List<Int>, a1:List<LSType>) ->
             [List<Int>, List<Int>, List<LSType>] :
    val [targs*, cargs*, env] = env(targs, cargs)
    val a1* = map(sub{_, env}, a1)
    [targs*, cargs*, a1*]

  match(id) :
    (id:FnId) :
      val [targs*, cargs*, a1*] = norm(targs(id), cargs(id), a1(id))
      FnId(name(id), tail?(id), targs*, cargs*, a1*, a2(id), visibility(id))      
    (id:MultiId) :
      val [targs*, cargs*, a1*] = norm(targs(id), cargs(id), a1(id))
      MultiId(name(id), tail?(id), targs*, cargs*, a1*, a2(id), visibility(id))
    (id:LSFnId) :
      val [targs*, cargs*, a1*] = norm(targs(id), cargs(id), a1(id))
      LSFnId(name(id), tail?(id), targs*, cargs*, a1*, a2(id), visibility(id))
    (id) : id

defmethod hash (x:IdKey) :
  match(id(x)) :
    (id:ValId) : hash(name(id))
    (id:VarId) : hash(name(id))
    (id:TypeId) : hash(name(id))
    (id:LSValId) : hash(name(id))
    (id:LSVarId) : hash(name(id))
    (id:LSTypeId) : hash(name(id))
    (id:LSExternId) : hash(name(id))
    (id:FnId) : hash([name(id), targs(id), cargs(id), a1(id)])
    (id:MultiId) : hash([name(id), targs(id), cargs(id), a1(id)])
    (id:LSFnId) : hash([name(id), targs(id), cargs(id), a1(id)])
    (id:LSExternFnId) : hash([name(id), a1(id)])
    (id:TArgId) : hash([name(id)])
    (id:FieldId) : hash([name(id)])
  
defmethod equal? (a:IdKey, b:IdKey) :
  match(id(a), id(b)) :
    (a:ValId, b:ValId) : name(a) == name(b)
    (a:VarId, b:VarId) : name(a) == name(b)
    (a:TypeId, b:TypeId) : name(a) == name(b)
    (a:LSValId, b:LSValId) : name(a) == name(b)
    (a:LSVarId, b:LSVarId) : name(a) == name(b)
    (a:LSTypeId, b:LSTypeId) : name(a) == name(b)
    (a:LSExternId, b:LSExternId) : name(a) == name(b)
    (a:TArgId, b:TArgId) : name(a) == name(b)
    (a:FieldId, b:FieldId) : name(a) == name(b)
    (a:FnId, b:FnId) :
      name(a) == name(b) and
      targs(a) == targs(b) and
      cargs(a) == cargs(b) and
      a1(a) == a1(b)
    (a:MultiId, b:MultiId) : 
      name(a) == name(b) and
      targs(a) == targs(b) and
      cargs(a) == cargs(b) and
      a1(a) == a1(b)
    (a:LSFnId, b:LSFnId) :
      name(a) == name(b) and
      targs(a) == targs(b) and
      cargs(a) == cargs(b) and
      a1(a) == a1(b)
    (a:LSExternFnId, b:LSExternFnId) :
      name(a) == name(b) and
      a1(a) == a1(b)
    (a, b) : false

;==================
;==== Id Table ====
;==================

deftype IdTable
defmulti set (t:IdTable, id:Id, n:Int) -> False
defmulti get (t:IdTable, id:Id) -> Int
defmulti key? (t:IdTable, id:Id) -> True|False

defn IdTable (ts:IdTables) :
  val table = HashTable<IdKey, Int>()
  new IdTable :
    defmethod get (this, id:Id) : table[IdKey(id)]
    defmethod key? (this, id:Id) : key?(table, IdKey(id))
    defmethod set (this, id:Id, n:Int) :
      table[IdKey(id)] = n
      ts[id] = n

;===================
;==== Id Tables ====
;===================

deftype IdTables
defmulti set (t:IdTables, id:Id, n:Int) -> False
defmulti get (t:IdTables, n:Int)  -> Id
defmulti get (t:IdTables, pkg:Symbol) -> IdTable

defn IdTables () :
  val tables = HashTable<Symbol,IdTable>()
  val ids = HashTable<Int,Id>()
  new IdTables :
    defmethod set (this, id:Id, n:Int) : ids[n] = id
    defmethod get (this, n:Int) : ids[n]
    defmethod get (this, pkg:Symbol) :
      if not key?(tables, pkg) :
        tables[pkg] = IdTable(this)
      tables[pkg]



