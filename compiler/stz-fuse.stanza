defpackage stz/fuse :
  import core
  import collections
  import stz/pl-ir
  import stz/tgt-ir
  import stz/tl-ir
  import stz/type-calculus
  import stz/namemap
  import stz/asm-ir
  import stz/kl-ir
  import stz/ids

;============================================================
;==================== Stage0 Fusing =========================
;============================================================

public defn resolve (nm:NameMap, pkg:TGPackage) :
  attach-ids(pkg, resolve-ids(nm, ids(pkg)))

public defn resolve (nm:NameMap, pkg:KPackage) :
  attach-ids(pkg, resolve-ids(nm, ids(pkg)))

defn resolve-ids (nm:NameMap, ids:PkgIds) -> PkgIds :
  ;==============================
  ;==== Compute Rename Table ====
  ;==============================
  val table = HashTable<Int,Int>()
  for d in declarations(ids) do :
    table[old-n(nm,d)] = n(d)
  for ip in imports(ids) do :
    for i in imports(ip) do :
      match(id(i)) :
        (id:TypeId|LSTypeId) :
          match(type-id(nm, package(ip), name(id))) :
            (g:Int) : table[n(i)] = g
            (g:False) : fatal("Could not import type %_/%_." % [
              package(ip), name(id)])
        (id) : false

  ;=====================
  ;==== Resolve Ids ====
  ;=====================
  val r = Renamer(fn (i) : get?(table, i, i), true)
  defn rename (d:Declare) : Declare(n(d), /rename(r, id(d)), info(d))
  defn rename (i:Import) : Import(n(i), /rename(r, id(i)))
  defn rename (i:ImportPackage) : ImportPackage(package(i), map(rename, imports(i)))

  PkgIds(map(rename, declarations(ids)),
         map(rename, imports(ids)))

;============================================================
;==================== Stage1 Fusing =========================
;============================================================

public defn fuse-pkgs (nm:NameMap, pkgs:List<KPkgComm>) -> List<KPkgComm> :
  ;Construct id tables
  val id-tables = IdTables()
  for pkg in pkgs do :
    match(pkg) :
      (pkg:KPackage) :
        val table = id-tables[name(pkg)]
        for d in declarations(ids(pkg)) do :
          table[id(d)] = n(d)
      (pkg:TGPackage) :
        val table = id-tables[name(pkg)]
        for d in declarations(ids(pkg)) do :
          table[id(d)] = n(d)

  ;Rename all tgpackages
  for pkg in pkgs map :
    match(pkg) :
      (pkg:TGPackage) :
        rename-pkg(nm, id-tables, pkg)
      (pkg:KPackage) :
        if loaded?(pkg) : rename-pkg(nm, id-tables, pkg)
        else : pkg

defn rename-pkg (nm:NameMap,
                 id-tables:IdTables,
                 pkg:TGPackage|KPackage) :
  ;=======================
  ;==== Rename Tables ====
  ;=======================
  val table = HashTable<Int,Int>()

  ;====================
  ;==== ID Mapping ====
  ;====================
  defn map-over (src:Int, dst:Int) :
    table[dst] = src
  defn map-over (src:List<Int>, dst:List<Int>) :
    do(map-over, src, dst)
  defn map-over (src:Id, dst:Id) :
    match(src, dst) :
      (src:FnId, dst:FnId) :
        map-over(append(targs(src), cargs(src)),
                 append(targs(dst), cargs(dst)))
      (src:MultiId, dst:MultiId) :
        map-over(append(targs(src), cargs(src)),
                 append(targs(dst), cargs(dst)))
      (src:TypeId, dst:TypeId) :
        map-over(args(src), args(dst))
        map-over(seq-append(args, children(src))
                 seq-append(args, children(dst)))
      (src:LSFnId, dst:LSFnId) :
        map-over(append(targs(src), cargs(src)),
                 append(targs(dst), cargs(dst)))
      (src:LSTypeId, dst:LSTypeId) :
        map-over(args(src), args(dst))
        map-over(map(n, fields(src))
                 map(n, fields(dst)))

  ;===================================
  ;==== Constructing Rename Table ====
  ;===================================
  for d in declarations(ids(pkg)) do :
    table[old-n(nm,d)] = n(d)
  for ip in imports(ids(pkg)) do :
    val id-table = id-tables[package(ip)]
    for i in imports(ip) do :
      val g = id-table[id(i)]
      table[n(i)] = g
      match(id(i):FnId|MultiId|TypeId|LSFnId|LSTypeId) :
        map-over(id-tables[g], id(i))


  ;==============================================
  ;==== Rename Imports and Check Consistency ====
  ;==============================================
  val r = Renamer({table[_]}, false)
  defn rename (i:Import) : Import(table[n(i)], /rename(r,id(i)))
  defn rename (i:ImportPackage) : ImportPackage(package(i), map(rename, imports(i)))
  val imports* = map(rename, imports(ids(pkg)))
  val ids* = PkgIds(declarations(ids(pkg)), imports*)

  for i in seq-cat(imports, imports*) do :
    if id(i) != id-tables[n(i)] :
      fatal("Import mismatch: Expected %_ but imported %_." % [
        id(i), id-tables[n(i)]])

  ;========================
  ;==== Rename Package ====
  ;========================
  defn rename? (x:Int) :
    if stable-id?(x) :
      x
    else :
      match(get?(table, x)) :
        (y:Int) :
          y
        (_:False) :
          val y = fresh-id()
          table[x] = y
          y

  val renamer = Renamer(rename?, false)
  match(pkg) :
    (pkg:TGPackage) : 
      val decls* = /rename(renamer, decls(pkg))
      attach-ids{_, ids*} $
      attach-decls(pkg, decls*)
    (pkg:KPackage) :
      val comms* = map(/rename{renamer, _}, comms(pkg))
      attach-ids{_, ids*} $
      attach-comms(pkg, comms*)

;============================================================
;==================== Renamer ===============================
;============================================================

deftype Renamer
defmulti rename (r:Renamer, id:Id) -> Id
defmulti rename (r:Renamer, e:Vector<TGDecl>) -> Vector<TGDecl>
defmulti rename (r:Renamer, c:KComm) -> KComm

defn Renamer (rename-int: Int -> Int,
              rename-types?: True|False) :
  defn rename (i:Int) : rename-int(i)
  defn rename (x:Symbol) : x
  defn rename (x:False) : false

  defn rename (c:ChildDec) :
    val n* = rename(n(c)) when rename-types? else n(c)
    ChildDec(n*, rename(args(c)), rename(parent(c)))

  defn rename (f:FieldDec) :
    FieldDec(rename(n(f)), rename(type(f)))

  defn rename (t:Type) :
    match(map(rename,t)) :
      (t:TOf) :
        if rename-types? : TOf(rename(n(t)), type(t))
        else : t
      (t:TVar) : TVar(rename(n(t)))
      (t:TCap) : TCap(rename(n(t)))
      (t) : t

  defn rename (t:LSType) :
    match(map(rename{_:Type}, map(rename{_:LSType}, t))) :
      (t:StructT) :
        if rename-types? : StructT(rename(n(t)), type(t))
        else : t
      (t) : t

  defn rename (id:Id) :
    match(id) :
      (id:ValId) :
        ValId(name(id), rename(type(id)), visibility(id))
      (id:VarId) :
        VarId(name(id), rename(type(id)), visibility(id))
      (id:FnId) :
        FnId(name(id), tail?(id), rename(targs(id)), rename(cargs(id)),
          rename(a1(id)), rename(a2(id)), visibility(id))
      (id:MultiId) :
        MultiId(name(id), tail?(id), rename(targs(id)), rename(cargs(id)),
          rename(a1(id)), rename(a2(id)), visibility(id)),
      (id:TypeId) :
        TypeId(name(id), rename(args(id)), rename(parent(id)),
          rename(children(id)), visibility(id)),
      (id:TArgId) :
        id
      (id:LSValId) :
        LSValId(name(id), rename(type(id)), visibility(id))
      (id:LSVarId) :
        LSVarId(name(id), rename(type(id)), visibility(id))
      (id:LSFnId) :
        LSFnId(name(id), tail?(id), rename(targs(id)), rename(cargs(id)),
          rename(a1(id)), rename(a2(id)), visibility(id))
      (id:LSTypeId) :
        LSTypeId(name(id), rename(args(id)), rename(parent(id)),
          rename(fields(id)), visibility(id))
      (id:FieldId) :
        id
      (id:LSExternFnId) :
        LSExternFnId(name(id), lbl(id), rename(a1(id)),
          rename(a2(id)), visibility(id))
      (id:LSExternId) :
        LSExternId(name(id), lbl(id), rename(type(id)), visibility(id))

  defn rename (x:Imm) :
    match(x) :
      (x:Mem) : Mem(rename(n(x)), offset(x))
      (x:TagImm) : TagImm(rename(n(x)), marker?(x))
      (x) : x

  defn rename (t:KTag) :
    match(t:KOf) : KOf(rename(n(t)))
    else : map(rename{_:KTag}, t)

  defn rename (t:KLSType) :
    match(t) :
      (t:KRefT) : KRefT(rename(tag(t)))
      (t:KStructT) : KStructT(rename(n(t)))
      (t) : map(rename{_:KLSType}, t)

  defn rename (b:Branch) :
    Branch(map(rename, tags(b)), rename(n(b)))

  defn rename (x:Ins) :
    match(map(rename, x)) :
      (x:Label) : Label(rename(n(x)), info(x))
      (x:DefLabel) : DefLabel(rename(n(x)))
      (x:Match) : Match(xs(x), rename(branches(x)), rename(no-branch(x)))
      (x:Dispatch) : Dispatch(xs(x), rename(branches(x)), rename(no-branch(x)), rename(amb-branch(x)))
      (x) : x

  defn rename-node (x:KNode) :
    match(map-all(rename{_:KTag|KLSType}, map-all(rename-node, x))) :
      (x:KDef) : KDef(rename(n(x)), tag(x), value(x), info(x))
      (x:KDefVar) : KDefVar(rename(n(x)), tag(x), value(x), info(x))
      (x:KDefn) : KDefn(rename(n(x)), rename(value(x)))
      (x:KDefmulti) : KDefmulti(rename(n(x)), tail?(x), rename(targs(x)), a1(x), a2(x), info(x))
      (x:KDefmethod) : KDefmethod(rename(multi(x)), targs(x), rename(thisn(x)), rename(value(x)))
      (x:KDefTag) : KDefTag(rename(n(x)), parent(x), rename(children(x)))
      (x:KLSDef) : KLSDef(rename(n(x)), type(x), value(x))
      (x:KLSDefVar) : KLSDefVar(rename(n(x)), type(x), value(x))
      (x:KLSDefn) : KLSDefn(rename(n(x)), rename(value(x)))
      (x:KLSDefmethod) : KLSDefmethod(rename(multi(x)), targs(x), rename(value(x)))
      (x:KLSDefStruct) : KLSDefStruct(rename(n(x)), parent(x), rename(fields(x)), rename(rfield(x)))
      (x:KLSExternFn) : KLSExternFn(rename(n(x)), lbl(x), rename(value(x)))
      (x:KLSExtern) : KLSExtern(rename(n(x)), lbl(x), type(x))
      (x:KSet) : KSet(rename(n(x)), tag(x), value(x))
      (x:KMatch) : KMatch(args(x), rename(branches(x)), info(x))
      (x:KVar) : KVar(rename(n(x)), info(x))
      (x:KCurry) : KCurry(rename(n(x)), targs(x))
      (x:KAFn) : KAFn(rename(value(x)))
      (x:KLSLabels) : KLSLabels(rename(blocks(x)))
      (x:KLSGoto) : KLSGoto(rename(n(x)), args(x))
      (x:KLSDefLocal) : KLSDefLocal(rename(n(x)), type(x), value(x))
      (x:KLSDefLocalVar) : KLSDefLocalVar(rename(n(x)), type(x), value(x))
      (x:KLSMatch) : KLSMatch(args(x), rename(branches(x)), info(x))
      (x:KField) : KField(exp(x), rename(n(x)))
      (x:KVarLoc) : KVarLoc(rename(n(x)))
      (x:KLSVar) : KLSVar(rename(n(x)))
      (x:KLSRef) : KLSRef(rename(n(x)), args(x), info(x))
      (x:KLSArray) : KLSArray(rename(n(x)), args(x), info(x))
      (x:KLSStruct) : KLSStruct(rename(n(x)), args(x))
      (x:KLSCurry) : KLSCurry(rename(n(x)), targs(x))
      (x:KLSTagof) : KLSTagof(rename(n(x)))      
      (x) : x

  defn rename (c:KChild) :
    KChild(rename(n(c)), parent(c))

  defn rename (c:KStructField) :
    KStructField(rename(n(c)), type(c))

  defn rename (c:KFunc) :
    match(c) :
      (c:KFn) : KFn(tail?(c), rename(targs(c)), a1(c), a2(c), rename(args(c)), body(c), info(c))
      (c:KMultifn) : KMultifn(rename(funcs(c)))

  defn rename (c:KLSFunc) :
    match(c) :
      (c:KLSFn) : KLSFn(tail?(c), rename(targs(c)), a1(c), a2(c), rename(args(c)), body(c), info(c))

  defn rename (c:KBranch) :
    match(c) :
      (c:KBranch) : KBranch(rename(args(c)), tags(c), body(c), info(c))

  defn rename (c:KLSBranch) :
    match(c) :
      (c:KLSBranch) : KLSBranch(rename(args(c)), tags(c), body(c))

  defn rename (c:KLSLabeledBlock) :
    match(c) :
      (c:KLSLabeledBlock) : KLSLabeledBlock(rename(n(c)), rename(args(c)), types(c), body(c))

  defn rename-const (c:TGConst) :
    match(c) :
      (c:TGTypeObject) : TGTypeObject(rename(n(c)))
      (c:TGClosure) : TGClosure(rename(n(c)))
      (c) : c

  defn rename (e:TGDecl) :
    match(e) :
      (e:TGDefASM) :
        TGDefASM(rename(n(e)), rename(ins(e)))
      (e:TGDefmulti) :
        TGDefmulti(rename(n(e)), tarity(e), arity(e), info(e))
      (e:TGDefmethod) :
        TGDefmethod(rename(multi(e)), rename(tags(e)), rename(code(e)))
      (e:TGDefConst) :
        TGDefConst(rename(n(e)), rename-const(value(e)))
      (e:TGDefObject) :
        TGDefObject(rename(n(e)), rename(parent(e)), size(e),
          types(e), offsets(e), rsize(e), rtypes(e), roffsets(e))
      (e:TGDefGlobal) :
        TGDefGlobal(rename(n(e)), size(e), alignment(e),
          types(e), offsets(e))

  ;Plurals
  defn rename (xs:List<Int>) : map(rename, xs)
  defn rename (ts:List<LSType>) : map(rename, ts)
  defn rename (ts:List<Type>) : map(rename, ts)
  defn rename (xs:List<ChildDec>) : map(rename, xs)
  defn rename (xs:List<FieldDec>) : map(rename, xs)
  defn rename (xs:List<Branch>) : map(rename, xs)
  defn rename (xs:List<KTag>) : map(rename, xs)
  defn rename (xs:List<KChild>) : map(rename, xs)
  defn rename (xs:List<KStructField>) : map(rename, xs)
  defn rename (xs:List<KFunc>) : map(rename, xs)
  defn rename (xs:List<KBranch>) : map(rename, xs)
  defn rename (xs:List<KLSBranch>) : map(rename, xs)
  defn rename (xs:List<KLSLabeledBlock>) : map(rename, xs)
  defn rename (xs:Vector<Ins>) : map<Ins>(rename, xs)
  defn rename (xs:Vector<TGDecl>) : map<TGDecl>(rename, xs)  

  ;Return renamer
  new Renamer :
    defmethod rename (this, id:Id) : rename(id)
    defmethod rename (this, e:Vector<TGDecl>) : rename(e)
    defmethod rename (this, c:KComm) : rename-node(c) as KComm

;============================================================
;==================== IdTable ===============================
;============================================================

;=================
;==== Id Keys ====
;=================
deftype IdKey <: Hashable & Equalable
defmulti id (k:IdKey) -> Id

defn IdKey (id:Id) :
  val id* = normalize(id)
  new IdKey :
    defmethod id (this) : id*

defn normalize (id:Id) :
  defn env (targs:List<Int>, cargs:List<Int>) ->
           [List<Int>, List<Int>, List<KeyValue<Int,Int>>] :
    val counter = to-seq(0 to false)
    val targs* = map(next{counter}, targs)
    val cargs* = map(next{counter}, cargs)
    val env = map(KeyValue,
                  append(targs, cargs),
                  append(targs*, cargs*))
    [targs*, cargs*, env]

  defn norm (targs:List<Int>, cargs:List<Int>, a1:List<Type>) ->
             [List<Int>, List<Int>, List<Type>] :
    val [targs*, cargs*, env] = env(targs, cargs)
    val a1* = map(sub{_, env}, a1)
    [targs*, cargs*, a1*]

  defn norm (targs:List<Int>, cargs:List<Int>, a1:List<LSType>) ->
             [List<Int>, List<Int>, List<LSType>] :
    val [targs*, cargs*, env] = env(targs, cargs)
    val a1* = map(sub{_, env}, a1)
    [targs*, cargs*, a1*]

  match(id) :
    (id:FnId) :
      val [targs*, cargs*, a1*] = norm(targs(id), cargs(id), a1(id))
      FnId(name(id), tail?(id), targs*, cargs*, a1*, a2(id), visibility(id))
    (id:MultiId) :
      val [targs*, cargs*, a1*] = norm(targs(id), cargs(id), a1(id))
      MultiId(name(id), tail?(id), targs*, cargs*, a1*, a2(id), visibility(id))
    (id:LSFnId) :
      val [targs*, cargs*, a1*] = norm(targs(id), cargs(id), a1(id))
      LSFnId(name(id), tail?(id), targs*, cargs*, a1*, a2(id), visibility(id))
    (id) : id

defmethod hash (x:IdKey) :
  match(id(x)) :
    (id:ValId) : hash(name(id))
    (id:VarId) : hash(name(id))
    (id:TypeId) : hash(name(id))
    (id:LSValId) : hash(name(id))
    (id:LSVarId) : hash(name(id))
    (id:LSTypeId) : hash(name(id))
    (id:LSExternId) : hash(name(id))
    (id:FnId) : hash([name(id), targs(id), cargs(id), a1(id)])
    (id:MultiId) : hash([name(id), targs(id), cargs(id), a1(id)])
    (id:LSFnId) : hash([name(id), targs(id), cargs(id), a1(id)])
    (id:LSExternFnId) : hash([name(id), a1(id)])
    (id:TArgId) : hash([name(id)])
    (id:FieldId) : hash([name(id)])

defmethod equal? (a:IdKey, b:IdKey) :
  match(id(a), id(b)) :
    (a:ValId, b:ValId) : name(a) == name(b)
    (a:VarId, b:VarId) : name(a) == name(b)
    (a:TypeId, b:TypeId) : name(a) == name(b)
    (a:LSValId, b:LSValId) : name(a) == name(b)
    (a:LSVarId, b:LSVarId) : name(a) == name(b)
    (a:LSTypeId, b:LSTypeId) : name(a) == name(b)
    (a:LSExternId, b:LSExternId) : name(a) == name(b)
    (a:TArgId, b:TArgId) : name(a) == name(b)
    (a:FieldId, b:FieldId) : name(a) == name(b)
    (a:FnId, b:FnId) :
      name(a) == name(b) and
      targs(a) == targs(b) and
      cargs(a) == cargs(b) and
      a1(a) == a1(b)
    (a:MultiId, b:MultiId) :
      name(a) == name(b) and
      targs(a) == targs(b) and
      cargs(a) == cargs(b) and
      a1(a) == a1(b)
    (a:LSFnId, b:LSFnId) :
      name(a) == name(b) and
      targs(a) == targs(b) and
      cargs(a) == cargs(b) and
      a1(a) == a1(b)
    (a:LSExternFnId, b:LSExternFnId) :
      name(a) == name(b) and
      a1(a) == a1(b)
    (a, b) : false

;==================
;==== Id Table ====
;==================

deftype IdTable
defmulti set (t:IdTable, id:Id, n:Int) -> False
defmulti get (t:IdTable, id:Id) -> Int
defmulti key? (t:IdTable, id:Id) -> True|False

defn IdTable (ts:IdTables) :
  val table = HashTable<IdKey, Int>()
  new IdTable :
    defmethod get (this, id:Id) : table[IdKey(id)]
    defmethod key? (this, id:Id) : key?(table, IdKey(id))
    defmethod set (this, id:Id, n:Int) :
      table[IdKey(id)] = n
      ts[id] = n

;===================
;==== Id Tables ====
;===================

deftype IdTables
defmulti set (t:IdTables, id:Id, n:Int) -> False
defmulti get (t:IdTables, n:Int)  -> Id
defmulti get (t:IdTables, pkg:Symbol) -> IdTable

defn IdTables () :
  val tables = HashTable<Symbol,IdTable>()
  val ids = HashTable<Int,Id>()
  new IdTables :
    defmethod set (this, id:Id, n:Int) : ids[n] = id
    defmethod get (this, n:Int) : ids[n]
    defmethod get (this, pkg:Symbol) :
      if not key?(tables, pkg) :
        tables[pkg] = IdTable(this)
      tables[pkg]
