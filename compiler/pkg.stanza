;See License.txt for details about licensing

defpackage stz/pkg :
  import core
  import collections
  import stz/algorithms
  import stz/params
  import stz/utils
  import stz/typeset
  import stz/asm-ir with :
    prefix(AddOp, SubOp, MulOp, DivOp, ModOp, AndOp, OrOp, XorOp, ShlOp,
           ShrOp, AshrOp, EqOp, NeOp, LtOp, GtOp, LeOp, GeOp, UleOp,
           UltOp, UgtOp, UgeOp, NotOp, NegOp, DivModOp, BitSetOp, BitNotSetOp, LowestZeroBitCountOp,
           TestBitOp, TestAndSetBitOp, TestAndClearBitOp, SetBitOp, ClearBitOp,
           TypeofOp, XchgIns, SetIns, ConvertIns, InterpretIns, UnaOp, BinOp, VoidBinOp,
           DualOp, Load, Store, Call, Return, Goto, Break, Label, LinkLabel,
           ExLabel, Match, Dispatch, MethodDispatch, DefData, DefText, DefDirectives, DefExportLabel, DefByte,
           DefInt, DefLong, DefFloat, DefDouble, DefString, DefBytes, DefSpace, DefLabel, Comment) => asm-
  import stz/visibility
  import stz/dl-ir
  import stz/basic-ops
  import stz/vm-ir
  import stz/el-ir
  import core/parsed-path
  import core/stack-trace
  import stz/pkg-ir
  import stz/timing-log-api
  import stz/fastio-errors
  import stz/pkg-errors
  import stz/pkg-serializer
  import stz/dir-utils
  import core/sha256

;============================================================
;==================== Timers ================================
;============================================================

val READ-PACKAGE = TimerLabel("Read Package")

;============================================================
;=================== Package IO =============================
;============================================================

;Cache a package, computing suffix representing given vector of build params
public defn cache-repl-build (dir:String, p:Pkg) -> String :
  val cname = repl-cache-pkg-name(name(p))
  if verbose?(sys) :
    println("Caching REPL package %_" % [cname])
  save-package(dir, p, cname, false)

public defn cache-std-build (dir:String, p:Pkg) -> String :
  val cname = cache-pkg-name(name(p))
  if verbose?(sys) :
    println("Caching package %_" % [cname])
  save-package(dir, p, cname, true)

public defn save-package (dir:String, p:Pkg) -> String :
  save-package(dir, p, std-pkg-name(name(p)), true)

; Do not include suffix
defn std-pkg-name (pkg-name:Symbol) : mangle-as-filename(pkg-name)
; Include default parameter suffix
defn cache-pkg-name (pkg-name:Symbol) : mangle-as-filename(pkg-name, param-suffix())
; Include REPL symbol in parameter suffix -- a bit of a hack to prevent normal compilation
;  flows from attempting to decode partially compiled REPL pkgs 
defn repl-cache-pkg-name (pkg-name:Symbol) : mangle-as-filename(pkg-name, param-suffix(`REPL))

;Default: use flags
defn param-suffix () -> String : param-suffix(compiler-flags())

;Include an extra flag
defn param-suffix (extra:Symbol) -> String : param-suffix(cat([extra], compiler-flags()))

;Base implementation
defn param-suffix (flags:Seqable<Symbol>) -> String :
  to-hex(sha256-hash-str(string-join(seq(to-string,qsort(flags)))))

defn save-package (dir:String, p:Pkg, name, include-asm?:True|False) -> String :
  val pkg-file = string-join([name, extension(p)])
  val filename = to-string(relative-to-dir(parse-path(dir), pkg-file))
  ensure-directory-exists(dir)
  try :
    if include-asm?:
      serialize-pkg(filename, p)
    else:
      serialize-repl-pkg(filename, p)
  catch (e:IOException|FastIOError) : throw(PackageWriteException(filename))
  filename

public defn load-package (filename:String,
                          expected-name:Symbol|False,
                          optimized?:True|False,
                          include-asm?:True|False) :
  ;Sanity check
  if optimized? and not include-asm? :
    fatal("Invalid option: Optimized .pkg files always include asm instructions.")

  val event-name = to-string("Read Package: file = %_, expected-name = %_, optimized? = %_" % [
    filename, expected-name, optimized?])
  within log-time(READ-PACKAGE, event-name) :
    ;Load in the package
    ;val f = FileInputStream(filename)
    val pkg =
      try :
        if include-asm? :
          deserialize-pkg(filename)
        else :
          deserialize-repl-pkg(filename)
      catch (e:WrongPkgVersion) :
        throw(sub-filename(e, filename))
      catch (e:FastIOError|IOException) :
        throw(PackageReadException(filename))
    ;  finally : close(f)
    ;Ensure that name and optimization levels match expected.
    match(expected-name:Symbol) :
      ensure-expected-name!(pkg, filename, expected-name)
    ensure-expected-optimization!(pkg, filename, optimized?)
    ;Return the pkg
    pkg

defn ensure-expected-name! (pkg:Pkg, filename:String, name:Symbol) :
  if /name(pkg) != name :
    throw(WrongPackageNameException(filename, name, /name(pkg)))

defn ensure-expected-optimization! (pkg:Pkg, filename:String, optimized?:True|False) :
  val pkg-optimized? = pkg is FastPkg
  if pkg-optimized? != optimized? :
    throw(WrongPackageOptimization(name(pkg), filename, pkg-optimized?, optimized?))  

;============================================================
;===================== Pkg Search ===========================
;============================================================

public defn find-pkg (name:Symbol, optimized?:True|False, for-repl?:True|False) -> String|False :
  label<String|False> return :
    ;Check functions
    defn check-file (filename:String) :
      return(filename) when file-exists?(filename)
    defn check-dir (dir:String, mangled-name:String) :
      val extension = ".fpkg" when optimized? else ".pkg"
      val pkgfile = string-join([mangled-name, extension])
      val filename = to-string(relative-to-dir(parse-path(dir), parse-path(pkgfile)))
      check-file(filename)    
    if for-repl? : ;If pkg will be used in repl, try the repl-specific key
      match(STANZA-PKG-CACHE:String) :
        check-dir(STANZA-PKG-CACHE as String, repl-cache-pkg-name(name))
    ;Check cache for default .pkg name
    match(STANZA-PKG-CACHE:String) :
      check-dir(STANZA-PKG-CACHE as String, cache-pkg-name(name))
   ;Check normal folders
    for dir in STANZA-PKG-DIRS do :
      check-dir(dir, std-pkg-name(name))
    check-dir(system-filepath(StanzaPkgsDir), std-pkg-name(name))