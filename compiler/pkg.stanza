;See License.txt for details about licensing

defpackage stz/pkg :
  import core
  import collections
  import stz/algorithms
  import stz/params
  import stz/utils
  import stz/typeset
  import stz/asm-ir with :
    prefix(AddOp, SubOp, MulOp, DivOp, ModOp, AndOp, OrOp, XorOp, ShlOp,
           ShrOp, AshrOp, EqOp, NeOp, LtOp, GtOp, LeOp, GeOp, UleOp,
           UltOp, UgtOp, UgeOp, NotOp, NegOp, DivModOp, BitSetOp, BitNotSetOp, LowestZeroBitCountOp,
           TestBitOp, TestAndSetBitOp, TestAndClearBitOp, SetBitOp, ClearBitOp,
           TypeofOp, XchgIns, SetIns, ConvertIns, InterpretIns, UnaOp, BinOp, VoidBinOp,
           DualOp, Load, Store, Call, Return, Goto, Break, Label, LinkLabel,
           ExLabel, Match, Dispatch, MethodDispatch, DefData, DefText, DefDirectives, DefExportLabel, DefByte,
           DefInt, DefLong, DefFloat, DefDouble, DefString, DefBytes, DefSpace, DefLabel, Comment) => asm-
  import stz/visibility
  import stz/dl-ir
  import stz/basic-ops
  import stz/vm-ir
  import stz/el-ir
  import core/parsed-path
  import core/stack-trace
  import stz/pkg-ir
  import stz/timing-log-api
  import stz/fastio-errors
  import stz/pkg-errors
  import stz/pkg-serializer
  import stz/package-stamps
  import stz/dir-utils
  import core/sha256

;============================================================
;==================== Timers ================================
;============================================================

val READ-PACKAGE = TimerLabel("Read Package")

;============================================================
;=================== Package IO =============================
;============================================================

;Cache a .pkg build by the REPL
public defn cache-repl-build (dir:String, p:Pkg) -> String :
  val cname = repl-cache-pkg-name(name(p))
  save-package(dir, p, cname, false)

;Cache a fully-compiled .pkg
public defn cache-std-build (dir:String, p:Pkg) -> String :
  val cname = cache-pkg-name(name(p))
  save-package(dir, p, cname, true)

;Save a .pkg to output directory
public defn save-package (dir:String, p:Pkg) -> String :
  save-package(dir, p, std-pkg-name(name(p)), true)

;Default output mode: no suffix
defn std-pkg-name (pkg-name:Symbol) : mangle-as-filename(pkg-name)
;Default cache mode: Include default parameter suffix
defn cache-pkg-name (pkg-name:Symbol) : mangle-as-filename(pkg-name, param-suffix())
;REPL cache mode:
;Include REPL symbol in parameter suffix: this is a hack to prevent normal compilation
; flows from attempting to decode partially compiled REPL pkgs 
defn repl-cache-pkg-name (pkg-name:Symbol) : mangle-as-filename(pkg-name, param-suffix(`REPL))

;Compute file suffix representing build configuration
defn param-suffix () -> String : param-suffix(compiler-flags())
defn param-suffix (extra:Symbol) -> String : param-suffix(cat([extra], compiler-flags()))
defn param-suffix (flags:Seqable<Symbol>) -> String :
  defn string-to-bytes (str:String) :
    val bytes = ByteArray(length(str))
    for (idx in 0 to false, b in seq(to-byte, str)) do:
      bytes[idx] = b
    bytes
  defn sha256-hash-str (str:String) -> ByteArray :
    sha256-hash(string-to-bytes(str))
  to-hex(sha256-hash-str(string-join(seq(to-string,qsort(flags)))))

defn save-package (dir:String, p:Pkg, name, include-asm?:True|False) -> String :
  val pkg-file = string-join([name, extension(p)])
  val filename = to-string(relative-to-dir(parse-path(dir), pkg-file))
  ensure-directory-exists(dir)
  try :
    if include-asm?: serialize-pkg(filename, p)
    else: serialize-repl-pkg(filename, p)
  catch (e:IOException|FastIOError) : throw(PackageWriteException(filename))
  filename

public defn load-package (filename:String,
                          expected-name:Symbol|False,
                          optimized?:True|False,
                          include-asm?:True|False) :
  ;Sanity check
  if optimized? and not include-asm? :
    fatal("Invalid option: Optimized .pkg files always include asm instructions.")

  val event-name = to-string("Read Package: file = %_, expected-name = %_, optimized? = %_" % [
    filename, expected-name, optimized?])
  within log-time(READ-PACKAGE, event-name) :
    ;Load in the package
    ;val f = FileInputStream(filename)
    val pkg =
      try :
        if include-asm? :
          deserialize-pkg(filename)
        else :
          deserialize-repl-pkg(filename)
      catch (e:WrongPkgVersion) :
        throw(sub-filename(e, filename))
      catch (e:FastIOError|IOException) :
        throw(PackageReadException(filename))
    ;  finally : close(f)
    ;Ensure that name and optimization levels match expected.
    match(expected-name:Symbol) :
      ensure-expected-name!(pkg, filename, expected-name)
    ensure-expected-optimization!(pkg, filename, optimized?)
    ;Return the pkg
    pkg

defn ensure-expected-name! (pkg:Pkg, filename:String, name:Symbol) :
  if /name(pkg) != name :
    throw(WrongPackageNameException(filename, name, /name(pkg)))

defn ensure-expected-optimization! (pkg:Pkg, filename:String, optimized?:True|False) :
  val pkg-optimized? = pkg is FastPkg
  if pkg-optimized? != optimized? :
    throw(WrongPackageOptimization(name(pkg), filename, pkg-optimized?, optimized?))  

;============================================================
;===================== Pkg Search ===========================
;============================================================

public defn find-pkg (name:Symbol, optimized?:True|False, for-repl?:True|False) -> PkgFile|False :
  label<PkgFile|False> return :
    ;Check functions
    defn check-file (filename:String, cache) :
      return(cache(filename)) when file-exists?(filename)
    defn check-dir (dir:String, mangled-name:String, cache) :
      val extension = ".fpkg" when optimized? else ".pkg"
      val pkgfile = string-join([mangled-name, extension])
      val filename = to-string(relative-to-dir(parse-path(dir), parse-path(pkgfile)))
      check-file(filename, cache)
    if for-repl? : ;If pkg will be used in repl, try the repl-specific key
      match(STANZA-PKG-CACHE:String) :
        check-dir(STANZA-PKG-CACHE as String, repl-cache-pkg-name(name), PkgCache{_})
    ;Check cache for default .pkg name
    match(STANZA-PKG-CACHE:String) :
      check-dir(STANZA-PKG-CACHE as String, cache-pkg-name(name), PkgCache{_})
    ;Check normal folders
    for dir in STANZA-PKG-DIRS do :
      check-dir(dir, std-pkg-name(name), PkgDir{_})
    check-dir(system-filepath(StanzaPkgsDir), std-pkg-name(name), PkgDir{_})