;See License.txt for details about licensing.

defpackage stz/compiler :
  import core
  import collections
  import reader
  import macro-utils
  import stz/params
  import stz/utils
  import stz/algorithms
  import stz/input
  import stz/renamer
  import stz/resolver
  import stz/type
  import stz/il-ir
  import stz/tl-ir
  import stz/namemap
  import stz/core-macros
  import stz/tl-to-el
  import stz/tl-to-dl
  import stz/el-to-vm
  import stz/el
  import stz/el-ir
  import stz/vm-ir
  import stz/dl-ir
  import stz/backend
  import stz/reg-alloc with :
    prefix(Ins) => reg-alloc-
  import stz/vm-normalize
  import stz/codegen
  import stz/asm-ir
  import stz/asm-emitter
  import stz/stitcher
  import stz/bindings
  import stz/pkg

public defn compile (filenames:List<String>, output:False|String, pkg-dir:False|String, backend:Backend) :
  defn driver () :
    ;First categorize the files
    val files = categorize(filenames)

    ;Read all the binding files
    val bindings = map(read-bindings, binding-files(files))
    do(println, bindings)
    
    ;For the stanza files, 
    ;first read and macro-expand all the files.
    ;then rename, resolve, and type all the packages.
    val expanded = map(read+expand, stanza-files(files))

    ;Then convert the s-expression forms into IPackages.
    val ipackages = to-ipackages(expanded)

    ;Then convert the packages into typed form, by
    ;renaming, resolving, and typechecking.
    val typed = type(resolve(rename(ipackages)))

    ;If the package typechecks, then we can start compilation
    ;to assembly. The first step is to bring it to EL form.
    val el-ir = to-el-ir(typed)

    ;Optimized packages should be saved if we are compiling in
    ;optimized mode, and a pkg output directory has been specified.
    val save-optimized-packages? = pkg-dir is String and flag-defined?(`OPTIMIZE)
    if save-optimized-packages? :
      for p in el-ir do :
        val pkg = FastPkg(packageio(p), exps(p))
        save-package(pkg-dir as String, pkg)

    ;Then we compile the EL form into VM form.
    val vm-ir = to-vm-ir(el-ir)

    ;- Finally, we assemble the VM form and emit the assembly code.
    match(output:String) :
      assemble(init-order(vm-ir), bindings, output)

  defn categorize (filenames:Seqable<String>) :
    val stanza-files = Vector<String>()
    val binding-files = Vector<String>()
    for f in filenames do :
      switch suffix?{f, _} :
        ".stanza" : add(stanza-files, f)
        ".vmbindings" : add(binding-files, f)
        else : throw(InvalidExtensionError(f))
    [to-tuple(stanza-files), to-tuple(binding-files)]

  defn read+expand (filename:String) -> List :
    val forms = read-file(filename)
    cons(`$begin, parse-syntax[core / #exps!](forms))

  defn to-ipackages (expanded:Tuple) :
    to-tuple $ for e in expanded seq-cat :
      val core-imports = [IImport(`core), IImport(`collections)]
      /to-ipackages(e, core-imports)

  defn rename (ipackages:Tuple<IPackage>) :
    match(rename-il(ipackages)) :
      (renamed:Tuple<IPackage>) : renamed
      (e:RenameErrors) : throw(e)

  defn resolve (ipackages:Tuple<IPackage>) :
    val empty-env = new stz/resolver/Env :
      defmethod packageio (this, package:Symbol) : false
    match(resolve-il(ipackages, empty-env, false)) :
      (e:ResolveErrors) : throw(e)
      (e:Tuple<IPackage>) : e

  defn type (ipackages:Tuple<IPackage>) :
    val empty-env = new stz/type/Env
    match(type-program(ipackages, empty-env)) :
      (e:TProg) : e
      (e:TypeErrors) : throw(e)

  defn to-el-ir (typed:TProg) -> Tuple<EPackage> :
    to-el(typed, false)

  defn to-vm-ir (epackages:Tuple<EPackage>) :
    if flag-defined?(`OPTIMIZE) :
      [compile(lower-optimized(epackages))]
    else :
      map(compile{lower-unoptimized(_)}, epackages)

  defn init-order (vmps:Tuple<VMPackage>) :
    ;Create import graph
    val import-graph = to-hashtable<Symbol, List<Symbol>> $
      for p in vmps seq :
        val io = packageio(p)
        package(io) => to-list(imported-packages(io))
    ;Get proper ordering
    val ordering = initialization-order(import-graph, package-names) where :
      val package-names = map(package{packageio(_)}, vmps)
    ;Get reordered packages
    to-tuple(seq({package-table[_]}, ordering)) where :
      val package-table = to-hashtable<Symbol,VMPackage> $
        for p in vmps seq : package(packageio(p)) => p

  defn assemble (vmpackages:Tuple<VMPackage>, bindings:Collection<Bindings>, filename:String) :
    val stubs = AsmStubs(backend)
    val nvmps = map(normalize{_, backend}, vmpackages)

    for p in nvmps do :
      dump(p, "logs", "normalize")

    val stitcher = Stitcher(nvmps, bindings, stubs)
    val file = FileOutputStream(filename)
    val file-emitter = new CodeEmitter :
      defmethod emit (this, i:Ins) :
        emit(i, backend)

    with-output-file(file, fn () :
      for (vmp in vmpackages, nvmp in nvmps) do :
        val pkg-maker = PkgMaker(vmp)
        val emitter = emitter{_, pkg-maker} $
                      emitter{stitcher, package(vmp), _} $
                      file-emitter
        for f in funcs(nvmp) do :
          emit(emitter, LinkLabel(id(f)))
          allocate-registers(func(f), emitter, backend, stubs, false)
        save-package(".", pkg(pkg-maker))
          
      emit-tables(stitcher, file-emitter)
      emit-stubs(stitcher, file-emitter)
      compile-runtime-stubs(file-emitter, stubs))

  driver()

;============================================================
;==================== Categorization ========================
;============================================================

defstruct CategorizedFiles :
  stanza-files: Tuple<String>
  pkg-files: Tuple<String>
  binding-files: Tuple<String>
  packages: Tuple<Symbol>

defn categorize (filenames:Seqable<String>) :
  val stanza-files = Vector<String>()
  val pkg-files = Vector<String>()
  val binding-files = Vector<String>()
  val packages = Vector<Symbol>()
  for name in filenames do :
    if not has-extension?(name) :
      add(packages, to-symbol(name))
    else :
      switch suffix?{name, _} :
        ".stanza" : add(stanza-files, name)
        ".pkg" : add(pkg-files, name)
        ".vmbindings" : add(binding-files, name)
        else : throw(InvalidExtensionError(name))
  CategorizedFiles(to-tuple(stanza-files), to-tuple(pkg-files),
                   to-tuple(binding-files), to-tuple(packages))

defn has-extension? (s:String) :
  ;Start looking for a dot after the last occurrence of a
  ;/ character
  val start = match(last-index-of-char(s, '/')) :
    (i:Int) : i + 1
    (i:False) : 0
  index-of-char(s, start to false, '.') is Int

;============================================================
;==================== PkgMaker ==============================
;============================================================

deftype PkgMaker
defmulti pkg (m:PkgMaker) -> Pkg
defmulti emitter (emitter:CodeEmitter, m:PkgMaker) -> CodeEmitter

defn PkgMaker (vmp:VMPackage) :
  val buffer = Vector<Ins>()
  new PkgMaker :
    defmethod pkg (this) :
      StdPkg(vmp, to-tuple(buffer))
    defmethod emitter (emitter:CodeEmitter, this) :
      new CodeEmitter :
        defmethod emit (this, i:Ins) :
          add(buffer, i)
          emit(emitter, i)

;============================================================
;===================== Errors ===============================
;============================================================

defn InvalidExtensionError (filename:String) :
  new Exception :
    defmethod print (o:OutputStream, this) :
      print(o, "File %_ does not have a valid Stanza file extension." % [filename])

