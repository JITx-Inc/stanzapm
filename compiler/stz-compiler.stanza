;See License.txt for details about licensing.

defpackage stz/compiler :
  import core
  import collections
  import stz/params
  import stz/proj-manager
  import stz/build-manager
  import stz/proj
  import stz/compiler-main
  import stz/config
  import stz/backend

;============================================================
;==================== System Callbacks ======================
;============================================================

public deftype System
public defmulti call-cc (s:System, platform:Symbol, file:String, ccfiles:Tuple<String>, ccflags:Tuple<String>, output:String) -> False
public defmulti make-temporary-file (s:System) -> String
public defmulti delete-temporary-file (s:System, file:String) -> False

;============================================================
;===================== Build Settings =======================
;============================================================

public deftype BuildInputs
public defstruct BuildStringArgs <: BuildInputs :
  names: Tuple<String>
public defstruct BuildPackages <: BuildInputs :
  packages: Tuple<String|Symbol>
public defstruct BuildTarget <: BuildInputs :
  target: Symbol

public defstruct BuildSettings :
  inputs: BuildInputs
  platform: Symbol|False
  assembly: String|False
  output: String|False
  pkg-dir: String|False
  optimize?: True|False
  ccfiles: Tuple<String>
  ccflags: Tuple<String>
  flags: Tuple<Symbol>

;============================================================
;============= Compile Given Files EntryPoint ===============
;============================================================

public defn compile (settings:BuildSettings, system:System) :
  defn main () :
    read-config-file()
    val build-platform = compute-build-platform()
    val [proj, build-manager, inputs] = classify-inputs(build-platform)
    val [build-flags, build-optimization, build-asm, temporary-asm?, build-out, build-pkg-dir] = compute-build-settings(build-manager)
    setup-system-flags(build-platform, build-flags, build-optimization, build-pkg-dir)
    val proj-manager = ProjManager(proj, ProjParams(compiler-flags(), build-optimization))
    val compiled-packages = compile(proj-manager, inputs, build-asm, build-pkg-dir,
                                    backend(build-platform),
                                    build-optimization)
    link-output-file(build-platform, build-asm, temporary-asm?, build-out, build-manager, compiled-packages)

  defn compute-build-platform () :
    match(platform(settings)) :
      (p:Symbol) : p
      (f:False) : OUTPUT-PLATFORM
    
  defn classify-inputs (platform:Symbol) -> [ProjFile, BuildManager, Collection<Symbol|String>] :
    match(inputs(settings)) :
      (build-inputs:BuildStringArgs) :
        ;Categorize filenames
        val projfiles = to-vector<String> $ ["stanza.proj"]
        val inputs = Vector<String|Symbol>()
        for name in names(build-inputs) do :
          if not has-extension?(name) :
            add(inputs, to-symbol(name))
          else if suffix?(name, ".proj") :
            add(projfiles, name)
          else :
            add(inputs, name)
        ;Read proj file
        val proj = read-proj-files(projfiles, platform)
        ;Return proj and inputs
        [proj, BuildManager(proj), inputs]
      (build-inputs:BuildPackages) :
        ;Categorize filenames
        val projfiles = to-vector<String> $ ["stanza.proj"]
        val inputs = Vector<String|Symbol>()
        for name in packages(build-inputs) do :
          match(name) :
            (name:Symbol) :
              add(inputs, name)
            (name:String) :
              if suffix?(name, ".proj") : add(projfiles, name)
              else : add(inputs, name)
        ;Read proj file
        val proj = read-proj-files(projfiles, platform)
        ;Return proj and inputs
        [proj, BuildManager(proj), inputs]
      (inputs:BuildTarget) :
        val proj = read-proj-files(["stanza.proj"], platform)
        val bm = BuildManager(proj)
        val s = target(bm, target(inputs))
        [proj, bm, /inputs(s)]

  defn compute-build-settings (bm:BuildManager) :
    if inputs(settings) is BuildTarget :
      val s = target(bm, target(inputs(settings) as BuildTarget))
      
      ;Compute build flags
      val build-flags = unique-join(flags(s), flags(settings))

      ;Compute build optimization level
      val build-optimization = optimize?(settings) or optimize(s)

      ;Compute assembly and output
      defn string-or? (a:String|False, b:String|False) :
        match(a:False) : b
        else : a
      val assembly* = string-or?(assembly(settings), value?(assembly(s)))
      val output* = string-or?(output(settings), value?(output(s)))

      ;Compute build assembly file
      val [build-asm, temporary-asm?] =
        match(assembly*, output*) :
          (asm:String, out) : [asm, false]
          (asm:False, out:String) : [make-temporary-file(system), true]
          (asm:False, out:False) : [false, false]

      ;Compute build pkg directory
      val build-pkg-dir = pkg-dir(settings)
      
      ;Return settings
      [build-flags, build-optimization, build-asm, temporary-asm?, output*, build-pkg-dir]
      
    else :
      ;Compute build flags
      val build-flags = flags(settings)

      ;Compute build optimization level
      val build-optimization = optimize?(settings)

      ;Compute build assembly file
      val [build-asm, temporary-asm?] =
        match(assembly(settings), output(settings)) :
          (asm:String, out) : [asm, false]
          (asm:False, out:String) : [make-temporary-file(system), true]
          (asm:False, out:False) : [false, false]

      ;Compute build output file
      val build-out = output(settings)

      ;Compute build pkg directory
      val build-pkg-dir = pkg-dir(settings)
      
      ;Return settings
      [build-flags, build-optimization, build-asm, temporary-asm?, build-out, build-pkg-dir]

  defn setup-system-flags (build-platform:Symbol, build-flags:Tuple<Symbol>, build-optimization:True|False, build-pkg-dir:String|False) :
    ;Platform setting
    OUTPUT-PLATFORM = build-platform

    ;Platform flag
    add-flag $ platform-flag(build-platform)

    ;Optimization flag
    add-flag(`OPTIMIZE) when build-optimization

    ;Add custom build flags
    do(add-flag, build-flags)

    ;Update pkg path
    match(build-pkg-dir:String) :
      STANZA-PKG-DIRS = cons(build-pkg-dir, STANZA-PKG-DIRS)

  defn backend (platform:Symbol) :
    switch(platform) :
      `os-x : X64Backend()
      `linux : L64Backend()
      `windows : W64Backend()

  defn link-output-file (build-platform:Symbol, build-asm:String|False, temporary-asm?:True|False, build-out:String|False,
                         build-manager:BuildManager, compiled-packages:Tuple<Symbol>) :
    match(build-out:String) :
      ;Compute the project external dependencies
      val [ccfiles*, ccflags*] = [unique-join(ccfiles(settings), ccfiles(ds)),
                                  unique-join(ccflags(settings), ccflags(ds))] where :
        val ds = dependencies(build-manager, compiled-packages)
      ;Create the output file
      call-cc(system, build-platform, build-asm as String, ccfiles*, ccflags*, build-out as String)
      ;Delete the temporary asm file if necessary
      delete-temporary-file(system, build-asm as String) when temporary-asm?

  ;Launch!
  main()
    
defn unique-join<?T> (xs:Seqable<?T&Equalable>, ys:Seqable<?T&Equalable>) :
  to-tuple $ unique $ cat(xs, ys)

defn has-extension? (s:String) :
  index-of-char(s, '.') is Int