;See License.txt for details about licensing.

defpackage stz/compiler :
  import core
  import collections
  import reader
  import macro-utils
  import stz/params
  import stz/utils
  import stz/algorithms
  import stz/input
  import stz/renamer
  import stz/resolver
  import stz/type
  import stz/il-ir
  import stz/tl-ir
  import stz/namemap
  import stz/core-macros
  import stz/tl-to-el
  import stz/tl-to-dl
  import stz/el-to-vm
  import stz/el
  import stz/el-ir
  import stz/vm-ir
  import stz/dl-ir
  import stz/backend
  import stz/reg-alloc with :
    prefix(Ins) => reg-alloc-
  import stz/vm-normalize
  import stz/codegen
  import stz/asm-ir
  import stz/asm-emitter
  import stz/stitcher
  import stz/bindings
  import stz/pkg

public defn compile (filenames:List<String>, output:False|String, pkg-dir:False|String, backend:Backend) :
  defn driver () :
    ;First categorize the files
    val files = categorize(filenames)
    
    ;Track where all the packages came from
    val input-package-table = InputPackageTable()

    ;Read all the binding files
    val bindings = map(read-bindings, binding-files(files))
    do(println, bindings)
    
    ;For the stanza files, 
    ;first read and macro-expand all the files.
    ;then rename, resolve, and type all the packages.
    val expanded = map(read+expand, stanza-files(files))

    ;Then convert the s-expression forms into IPackages.
    ;and rename them.
    val ipackages = rename(to-ipackages(expanded, stanza-files(files), input-package-table))

    ;Read in .pkg files and packages.
    val pkgloader = PkgLoader(map(name, ipackages), pkg-files(files), packages(files))
    for entry in file-mapping(pkgloader) do :
      register(input-package-table, key(entry), [value(entry)])

    ;Then convert the packages into typed form, by
    ;renaming, resolving, and typechecking.
    val typed = type(resolve(ipackages, pkgloader), pkgloader)

    ;If the package typechecks, then we can start compilation
    ;to assembly. The first step is to bring it to EL form.
    val src-el-ir = to-el-ir(typed)

    ;Optimized packages should be saved if we are compiling in
    ;optimized mode, and a pkg output directory has been specified.
    val save-optimized-packages? = pkg-dir is String and flag-defined?(`OPTIMIZE)
    if save-optimized-packages? :
      for p in src-el-ir do :
        val pkg = FastPkg(packageio(p), exps(p))
        save-package(pkg-dir as String, pkg)

    ;Add loaded EL to src EL if in optimized mode.
    val el-ir =
      if flag-defined?(`OPTIMIZE) :
        val pkgs = pkgs(pkgloader) as Seqable<FastPkg>
        val epkgs = for pkg in pkgs seq : EPackage(packageio(pkg), exps(pkg))
        val new-epkgs = to-tuple(cat(src-el-ir, epkgs))
        init-order(new-epkgs, all-input-files(files), input-package-table)
      else :
        src-el-ir

    ;Then we compile the EL form into VM form.
    val vm-ir = to-vm-ir(el-ir)

    ;Finally, we assemble the VM form and emit the assembly code.
    match(output:String) :
      val all-pkgs =
        if flag-defined?(`OPTIMIZE) :
          ;Packages are already collapsed from optimizer
          vm-ir
        else :
          val pkgs = to-tuple(cat(vm-ir, pkgs(pkgloader) as Seqable<StdPkg>))
          init-order(pkgs, all-input-files(files), input-package-table)
      assemble(all-pkgs, bindings, output)

  defn read+expand (filename:String) -> List :
    val forms = read-file(filename)
    cons(`$begin, parse-syntax[core / #exps!](forms))

  defn to-ipackages (expanded:Tuple, files:Tuple<String>, ipt:InputPackageTable) :
    to-tuple $ for (e in expanded, file in files) seq-cat :
      val core-imports = [IImport(`core), IImport(`collections)]
      val ipkgs = /to-ipackages(e, core-imports)
      register(ipt, file, map(name, ipkgs))
      ipkgs

  defn rename (ipackages:Tuple<IPackage>) :
    match(rename-il(ipackages)) :
      (renamed:Tuple<IPackage>) : renamed
      (e:RenameErrors) : throw(e)

  defn make-env (pkgloader:PkgLoader) :
    new stz/resolver/Env & stz/type/Env :
      defmethod stz/resolver/exports (this, package:Symbol) :
        package-exports(pkgloader, package)
      defmethod stz/type/exports (this, package:Symbol) :
        package-exports(pkgloader, package) as PackageExports

  defn resolve (ipackages:Tuple<IPackage>, pkgloader:PkgLoader) :
    match(resolve-il(ipackages, make-env(pkgloader), false)) :
      (e:ResolveErrors) : throw(e)
      (e:Tuple<IPackage>) : e

  defn type (ipackages:Tuple<IPackage>, pkgloader:PkgLoader) :
    match(type-program(ipackages, make-env(pkgloader))) :
      (e:TProg) : e
      (e:TypeErrors) : throw(e)

  defn to-el-ir (typed:TProg) -> Tuple<EPackage> :
    to-el(typed, false)

  defn to-vm-ir (epackages:Tuple<EPackage>) :
    if flag-defined?(`OPTIMIZE) :
      [compile(lower-optimized(epackages))]
    else :
      map(compile{lower-unoptimized(_)}, epackages)

  defn init-order (epkgs:Tuple<EPackage>, files:Tuple<String|Symbol>, ipt:InputPackageTable) -> Tuple<EPackage> :
    ;Create import graph
    val import-graph = to-hashtable<Symbol, List<Symbol>> $
      for p in epkgs seq :
        val io = packageio(p)
        package(io) => to-list(imported-packages(io))
    ;Get package names in input order
    val package-names = to-tuple $
      for f in files seq-cat :
        match(f) :
          (f:Symbol) : [f]
          (f:String) : packages(ipt, f)
    ;Compute initialization order
    val ordering = initialization-order(import-graph, package-names, {false})
    ;Compute reordered packages
    val package-table = to-hashtable(name, epkgs)
    to-tuple(seq({package-table[_]}, ordering))

  defn init-order (pkgs:Tuple<VMPackage|StdPkg>, files:Tuple<String|Symbol>, ipt:InputPackageTable) -> Tuple<VMPackage|StdPkg> :
    ;Create import graph
    val import-graph = to-hashtable<Symbol, List<Symbol>> $
      for p in pkgs seq :
        val io = packageio(p)
        package(io) => to-list(imported-packages(io))
    ;Get package names in input order
    val package-names = to-tuple $
      for f in files seq-cat :
        match(f) :
          (f:Symbol) : [f]
          (f:String) : packages(ipt, f)
    ;Get proper ordering
    val ordering = initialization-order(import-graph, package-names, {false})
    println("ordering = %_" % [ordering])
    ;Get reordered packages
    val package-table = to-hashtable(package{packageio(_)}, pkgs)
    to-tuple(seq({package-table[_]}, ordering))

  defn assemble (pkgs:Tuple<VMPackage|StdPkg>,
                 bindings:Collection<Bindings>,
                 filename:String) :
    ;Normalize all of the vmpackages to prepare for register
    ;allocation.
    val nvmps = for p in pkgs map :
      match(p) :
        (p:VMPackage) : normalize(p, backend)
        (p:StdPkg) : p
    
    ;DEBUG
    ;for p in nvmps do :
    ;  dump(p, "logs", "normalize")

    ;Define the assembly stubs for holding the required assembly labels and
    ;code snippets.
    val stubs = AsmStubs(backend)
    
    ;Define the stitcher for lowering the abstract assembly instructions.
    val stitcher = Stitcher(nvmps as Tuple<VMPackage>, bindings, stubs)

    ;Define the file emitter for the output target.
    val file-emitter = new CodeEmitter :
      defmethod emit (this, i:Ins) :
        emit(i, backend)

    ;Write out to file
    with-output-file(FileOutputStream(filename), fn () :
      ;Emit code for all packages
      for (vmp in pkgs, nvmp in nvmps) do :
        ;Function for allocating registers for all functions in package.
        val stitching-emitter = emitter(stitcher, package(vmp as VMPackage), file-emitter)
        defn allocate-registers (emitter:CodeEmitter) :
          for f in funcs(nvmp as VMPackage) do :
            emit(emitter, LinkLabel(id(f)))
            /allocate-registers(func(f), emitter, backend, stubs, false)

        ;Allocate registers while also saving instructions to pkg file
        defn allocate-and-save-pkg (dir:String) :
          val pkg-maker = PkgMaker(vmp as VMPackage)
          val emitter = emitter(stitching-emitter, pkg-maker)
          allocate-registers(emitter)
          save-package(dir, pkg(pkg-maker))

        ;Unoptimized packages should be saved if we are compiling in
        ;unoptimized mode, and a pkg output directory has been specified.
        val save-unoptimized-pkgs? = pkg-dir is String and not flag-defined?(`OPTIMIZE)
        if save-unoptimized-pkgs? :
          allocate-and-save-pkg(pkg-dir as String)
        else :
          allocate-registers(stitching-emitter)
          
      ;Emit stitched tables
      emit-tables(stitcher, file-emitter)
      emit-stubs(stitcher, file-emitter)
      compile-runtime-stubs(file-emitter, stubs))

  driver()

;<doc>=======================================================
;==================== Categorization ========================
;============================================================

Classifies the incoming files into four types:
  myfile.stanza
  myfile.pkg
  myfile.vmbindings
  mypackage

It is assumed that package names have no '.' character in them. This
will be enforced by the language checker.

;============================================================
;=======================================================<doc>

defstruct CategorizedFiles :
  stanza-files: Tuple<String>
  pkg-files: Tuple<String>
  binding-files: Tuple<String>
  packages: Tuple<Symbol>
  all-input-files: Tuple<String|Symbol>

defn categorize (filenames:Seqable<String>) :
  val stanza-files = Vector<String>()
  val pkg-files = Vector<String>()
  val binding-files = Vector<String>()
  val packages = Vector<Symbol>()
  val all-input-files = Vector<String|Symbol>()
  for name in filenames do :
    if not has-extension?(name) :
      add(packages, to-symbol(name))
      add(all-input-files, to-symbol(name))
    else :
      switch suffix?{name, _} :
        ".stanza" :
          add(stanza-files, name)
          add(all-input-files, name)
        ".pkg" :
          add(pkg-files, name)
          add(all-input-files, name)
        ".vmbindings" :
          add(binding-files, name)
        else :
          throw(InvalidExtensionError(name))
  CategorizedFiles(to-tuple(stanza-files), to-tuple(pkg-files),
                   to-tuple(binding-files), to-tuple(packages),
                   to-tuple(all-input-files))

defn has-extension? (s:String) :
  index-of-char(s, '.') is Int

;============================================================
;============================================================
;============================================================

deftype InputPackageTable
defmulti register (ipt:InputPackageTable, file:String, packages:Tuple<Symbol>) -> False
defmulti packages (ipt:InputPackageTable, file:String) -> Tuple<Symbol>
defn InputPackageTable () :
  val table = HashTable<String,Tuple<Symbol>>()
  new InputPackageTable :
    defmethod register (this, file:String, packages:Tuple<Symbol>) :
      table[file] = packages
    defmethod packages (this, file:String) :
      table[file]

;============================================================
;==================== PkgMaker ==============================
;============================================================

deftype PkgMaker
defmulti pkg (m:PkgMaker) -> Pkg
defmulti emitter (emitter:CodeEmitter, m:PkgMaker) -> CodeEmitter

defn PkgMaker (vmp:VMPackage) :
  val buffer = Vector<Ins>()
  new PkgMaker :
    defmethod pkg (this) :
      StdPkg(vmp, to-tuple(buffer))
    defmethod emitter (emitter:CodeEmitter, this) :
      new CodeEmitter :
        defmethod emit (this, i:Ins) :
          add(buffer, i)
          emit(emitter, i)

;============================================================
;===================== Errors ===============================
;============================================================

defn InvalidExtensionError (filename:String) :
  new Exception :
    defmethod print (o:OutputStream, this) :
      print(o, "File %_ does not have a valid Stanza file extension." % [filename])

