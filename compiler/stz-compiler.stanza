;See License.txt for details about licensing.

defpackage stz/compiler :
  import core
  import collections
  import reader
  import macro-utils
  import stz/params
  import stz/utils
  import stz/algorithms
  import stz/input
  import stz/renamer
  import stz/resolver
  import stz/type
  import stz/type-to-kform
  import stz/kform
  import stz/kform-to-tgt
  import stz/il-ir
  import stz/tl-ir
  import stz/kl-ir
  import stz/tgt-ir
  import stz/tgt-utils
  import stz/namemap
  import stz/core-macros
  import stz/pkg
  import stz/fuse
  ;import stz/asm-ir
  ;import stz/backend
  ;import stz/codegen
  ;import stz/asm-emitter

defn macroexpand (forms:List) -> List :
  val es = parse-syntax[core / #exps!](forms)
  cons(`$begin, es)

defn add-default-package (e:IExp) :
  defn first-form (e:IExp) -> Maybe<IExp> :
    match(e) :
      (e:IBegin) : first(first-form, exps(e))
      (e) : One(e)
  defn add-default-pkg (e:IExp) :
    val name = gensym(`default)
    val pkg-form = IPackage(IVar(name, info(e)),
      List(IImport(IVar(`core, info(e)), List(), info(e)),
           IImport(IVar(`collections, info(e)), List(), info(e)))
      info(e))
    IBegin(List(pkg-form, e), info(e))
    
  val add-default? = let :
    val f0 = first-form(e)
    (not empty?(f0)) and value!(f0) is-not IPackage
  if add-default? : add-default-pkg(e)
  else : e

public defn check (filenames:List<String>) -> [TProg, NameMap] :
   ;Read in a file
   defn read-input-file (filename:String) :
      switch suffix?{filename, _} :
         ".stanza" :
            val forms = time-ms("Reading and Lexing", read-file{filename})
            val expanded = time-ms("Macro Expansion", macroexpand{forms})
            val read = time-ms("To Input IR", read-prog{expanded})
            add-default-package(read)
         ".pkg" :
            val pkg = time-ms("Load Pkg", load-package{filename})
            ILoadPackage(filename, pkg, false)
         else :
           throw(InvalidExtensionError(filename)) when contains?(filename, ".")
           val [filename, pkg] = time-ms("Load Pkg", find-and-load-package{to-symbol(filename)})
           ILoadPackage(filename, pkg, false)

   ;Read in all files and combine into single program
   val input = Begin(map(read-input-file, filenames), false)
   ;Check for syntax violations
   time-ms("Check Syntax Violations", check{input})
   ;Perform global renaming and check for naming violations
   val [namemap, renamed] = time-ms("Rename Identifiers", rename{input})
   vheader("Renamed")
   vprintln(renamed)
   ;Perform symbol resolution and check for resolution errors
   val resolved = time-ms("Resolve Identifiers", resolve{namemap, renamed})
   vheader("Resolved")
   vprintln(resolved)
   ;Convert to typed IR and check for type errors
   val typed = time-ms("To Type IR", type-program{namemap, resolved})

   ;Return
   [typed, namemap]

public defn compile (filenames:List<String>, output:False|String, pkg-dir:False|String) :     
  if flag-defined?(`VERBOSE) :
    stz/ids/print-all-ids()

  ;Convert to Typed
  vheader("Check")
  val [typed, namemap] = check(filenames)
  vprintln(typed)

  ;Convert to KForm
  vheader("Convert to KForm")
  var pkgs = time-ms("To KForm IR", to-kform{typed, namemap})
  do(vprintln, pkgs)

  ;Fuse packages together
  vheader("Fuse")
  pkgs = time-ms("Fuse Pkgs", fuse-pkgs{namemap, pkgs})
  do(vprintln, pkgs)
  
  ;Compile kpackages to tgpackages
  vheader("Compiled")
  var tgpkgs:List<TGPackage> = time-ms("Compile to TGT IR", compile{pkgs})

  println("===== Target Packages =====")
  do(println, tgpkgs)

;============================================================
;===================== Errors ===============================
;============================================================

defn InvalidExtensionError (filename:String) :
  new Exception :
    defmethod print (o:OutputStream, this) :
      print(o, "File %_ does not have a valid Stanza file extension." % [filename])