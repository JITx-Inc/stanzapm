;See License.txt for details about licensing.

defpackage stz/compiler :
  import core
  import collections
  import reader
  import macro-utils
  import stz/params
  import stz/utils
  import stz/algorithms
  import stz/input
  import stz/renamer
  import stz/resolver
  import stz/type
  import stz/il-ir
  import stz/tl-ir
  import stz/namemap
  import stz/core-macros
  import stz/tl-to-el
  import stz/tl-to-dl
  import stz/el-to-vm
  import stz/el
  import stz/el-ir
  import stz/vm-ir
  import stz/dl-ir
  import stz/backend
  import stz/reg-alloc with :
    prefix(Ins) => reg-alloc-
  import stz/vm-normalize
  import stz/codegen
  import stz/asm-ir
  import stz/asm-emitter
  import stz/stitcher

public defn compile (filenames:List<String>, output:False|String, pkg-dir:False|String) :
  defn driver () :
    ;For now, assume that the filesnames are all .stanza files
    ;- First read and macro-expand all the files.
    ;- Then rename, resolve, and type all the packages.
    val expanded = map(read+expand, filenames)

    ;- Then convert the s-expression forms into IPackages.
    val ipackages = to-ipackages(expanded)

    ;- Then convert the packages into typed form, by
    ;  renaming, resolving, and typechecking.
    val typed = type(resolve(rename(ipackages)))

    ;- If the package typechecks, then we can start compilation
    ;  to assembly. The first step is to bring it to EL form.
    val el-ir = to-el-ir(typed)

    ;- Then we compile the EL form into VM form.
    val vm-ir = to-vm-ir(el-ir)

    ;- Finally, we assemble the VM form and emit the assembly code.
    match(output:String) :
      assemble(init-order(vm-ir), output)

  defn read+expand (filename:String) :
    val forms = read-file(filename)
    cons(`$begin, parse-syntax[core / #exps!](forms))

  defn to-ipackages (expanded:List) :
    to-tuple $ for e in expanded seq-cat :
      val core-imports = [IImport(`core), IImport(`collections)]
      /to-ipackages(e, core-imports)

  defn rename (ipackages:Tuple<IPackage>) :
    match(rename-il(ipackages)) :
      (renamed:Tuple<IPackage>) : renamed
      (e:RenameErrors) : throw(e)

  defn resolve (ipackages:Tuple<IPackage>) :
    val empty-env = new stz/resolver/Env :
      defmethod packageio (this, package:Symbol) : false
    match(resolve-il(ipackages, empty-env, false)) :
      (e:ResolveErrors) : throw(e)
      (e:Tuple<IPackage>) : e

  defn type (ipackages:Tuple<IPackage>) :
    val empty-env = new stz/type/Env
    match(type-program(ipackages, empty-env)) :
      (e:TProg) : e
      (e:TypeErrors) : throw(e)

  defn to-el-ir (typed:TProg) :
    to-el(typed, false)

  defn to-vm-ir (epackages:Tuple<EPackage>) :
    map(compile{lower(_)}, epackages)

  defn init-order (vmps:Tuple<VMPackage>) :
    ;Create import graph
    val import-graph = to-hashtable<Symbol, List<Symbol>> $
      for p in vmps seq :
        val io = packageio(p)
        package(io) => to-list(imported-packages(io))
    ;Get proper ordering
    val ordering = initialization-order(import-graph, package-names) where :
      val package-names = map(package{packageio(_)}, vmps)
    ;Get reordered packages
    to-tuple(seq({package-table[_]}, ordering)) where :
      val package-table = to-hashtable<Symbol,VMPackage> $
        for p in vmps seq : package(packageio(p)) => p

  defn assemble (vmpackages:Tuple<VMPackage>, output:String) :
    val backend = X64Backend()
    val stubs = AsmStubs(backend)
    val nvmps = map(normalize{_, backend}, vmpackages)
    val stitcher = Stitcher(nvmps, stubs)
    val file = FileOutputStream(output)
    val file-emitter = new CodeEmitter :
      defmethod emit (this, i:Ins) :
        emit(i, backend)

    val print-funcs =
      if file-exists?("printfuncs.txt") : unwrap-all(read-file("printfuncs.txt"))
      else : List()
    println("Print Funcs = %_" % [print-funcs])   

    with-output-file(file, fn () :
      for p in nvmps do :
        val emitter = emitter(stitcher, package(p), file-emitter)
        for f in funcs(p) do :
          emit-label(emitter, id(f))
          val print? = contains?(print-funcs, id(f))
          println("//Allocating function %_ (print? = %_)" % [id(f), print?])
          allocate-registers(func(f), emitter, backend, stubs, print?)
      emit-tables(stitcher, file-emitter)
      emit-stubs(stitcher, file-emitter)
      compile-runtime-stubs(file-emitter, stubs))

  driver()

;============================================================
;===================== Errors ===============================
;============================================================

defn InvalidExtensionError (filename:String) :
  new Exception :
    defmethod print (o:OutputStream, this) :
      print(o, "File %_ does not have a valid Stanza file extension." % [filename])