;See License.txt for details about licensing.

defpackage stz/compiler :
  import core
  import collections
  import reader
  import macro-utils
  import stz/params
  import stz/utils
  import stz/algorithms
  import stz/input
  import stz/renamer
  import stz/resolver
  import stz/type
  import stz/il-ir
  import stz/tl-ir
  import stz/namemap
  import stz/core-macros
  import stz/tl-to-el
  import stz/tl-to-dl

defn macroexpand (forms:List) -> List :
  val es = parse-syntax[core / #exps!](forms)
  cons(`$begin, es)

defn read-input-file (filename:String) -> Tuple<IPackage> :
  switch suffix?{filename, _} :
    ".stanza" :
      val forms = time-ms("Reading and Lexing", read-file{filename})
      val expanded = time-ms("Macro Expansion", macroexpand{forms})
      to-il(expanded)
    ;".pkg" :
    ;   val pkg = time-ms("Load Pkg", load-package{filename})
    ;   ILoadPackage(filename, pkg, false)
    ;else :
    ;  throw(InvalidExtensionError(filename)) when contains?(filename, ".")
    ;  val [filename, pkg] = time-ms("Load Pkg", find-and-load-package{to-symbol(filename)})
    ;  ILoadPackage(filename, pkg, false)  

public defn check (filenames:List<String>) -> [TProg, NameMap] :
   ;Read in all files and combine into single program
   val input = to-tuple $ seq-cat(read-input-file, filenames)
   do(println, input)
   fatal("Done for now")

   ;Check for syntax violations
   ;time-ms("Check Syntax Violations", check{input})
   ;;Perform global renaming and check for naming violations
   ;val [namemap, renamed] = time-ms("Rename Identifiers", rename{input})
   ;vheader("Renamed")
   ;vprintln(renamed)
   ;;Perform symbol resolution and check for resolution errors
   ;val resolved = time-ms("Resolve Identifiers", resolve{namemap, renamed})
   ;vheader("Resolved")
   ;vprintln(resolved)
   ;;Convert to typed IR and check for type errors
   ;val typed = time-ms("To Type IR", type-program{namemap, resolved})
   ;
   ;;Return
   ;[typed, namemap]

public defn compile (filenames:List<String>, output:False|String, pkg-dir:False|String) :     
  if flag-defined?(`VERBOSE) :
    stz/ids/print-all-ids()

  ;Convert to Typed
  vheader("Check")
  val [typed, namemap] = check(filenames)
  vprintln(typed)

  ;Extract descriptors
  val ios = to-tuple $
    for p in packages(typed) seq :
      to-dl(p as TPackage, hier(typed), namemap)

  ;Convert to EL
  val epkgs = to-el(typed, ios, namemap)
  match(output:String) :
    with-output-file(FileOutputStream(output), fn () :
      println("load :")
      within indented() :
        do(println, epkgs))

  ;;Convert to KForm
  ;vheader("Convert to KForm")
  ;var pkgs = time-ms("To KForm IR", to-kform{typed, namemap})
  ;do(vprintln, pkgs)
  ;
  ;;Fuse packages together
  ;vheader("Fuse")
  ;pkgs = time-ms("Fuse Pkgs", fuse-pkgs{namemap, pkgs})
  ;do(vprintln, pkgs)
  ;
  ;;Compile kpackages to vmprog
  ;vheader("Compile")  
  ;val vprog = compile(pkgs as List<KPackage>)
  ;match(output:String) :
  ;  spit(output, vprog)

;============================================================
;===================== Errors ===============================
;============================================================

defn InvalidExtensionError (filename:String) :
  new Exception :
    defmethod print (o:OutputStream, this) :
      print(o, "File %_ does not have a valid Stanza file extension." % [filename])