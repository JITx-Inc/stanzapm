;See License.txt for details about licensing.

defpackage stz/compiler :
  import core
  import collections
  import stz/params
  import stz/proj-manager
  import stz/build-manager
  import stz/proj
  import stz/compiler-main
  import stz/config
  import stz/backend
  import stz/utils

;============================================================
;==================== System Callbacks ======================
;============================================================

public deftype System
public defmulti call-cc (s:System, platform:Symbol, file:String, ccfiles:Tuple<String>, ccflags:Tuple<String>, output:String) -> False
public defmulti call-shell (s:System, platform:Symbol, command:String) -> False
public defmulti make-temporary-file (s:System) -> String
public defmulti delete-temporary-file (s:System, file:String) -> False

;============================================================
;===================== Build Settings =======================
;============================================================

public deftype BuildInputs
public defstruct BuildStringArgs <: BuildInputs :
  names: Tuple<String>
public defstruct BuildPackages <: BuildInputs :
  packages: Tuple<String|Symbol>
public defstruct BuildTarget <: BuildInputs :
  target: Symbol

public defstruct BuildSettings :
  inputs: BuildInputs
  vm-packages: BuildInputs with: (ensure => not-target!)
  platform: Symbol|False
  assembly: String|False
  output: String|False
  pkg-dir: String|False
  optimize?: True|False
  ccfiles: Tuple<String>
  ccflags: Tuple<String>
  flags: Tuple<Symbol>

defn not-target! (description:String, input:BuildInputs) :
  match(input:BuildTarget) :
    fatal("Cannot assign target to %_." % [description])

;============================================================
;============= Compile Given Files EntryPoint ===============
;============================================================

public defn compile (settings:BuildSettings, system:System) :
  defn main () :
    read-config-file()
    val build-platform = compute-build-platform()
    val [proj, build-manager, inputs, vm-packages] = classify-inputs(build-platform)
    if already-built?(/inputs(settings), build-manager) :
      val target = target(/inputs(settings) as BuildTarget)
      println("Build target %~ is already up-to-date." % [target])
    else :
      val [build-flags, build-optimization, build-asm, temporary-asm?, build-out, build-pkg-dir] = compute-build-settings(build-manager)
      setup-system-flags(build-platform, build-flags, build-optimization, build-pkg-dir)
      val proj-manager = ProjManager(proj, ProjParams(compiler-flags(), build-optimization))
      val comp-result = compile(proj-manager, inputs, vm-packages, build-asm, build-pkg-dir,
                                backend(build-platform), build-optimization)
      link-output-file(build-platform, build-asm, temporary-asm?, build-out, build-manager, comp-result)

  defn compute-build-platform () :
    match(platform(settings)) :
      (p:Symbol) : p
      (f:False) : OUTPUT-PLATFORM
    
  defn classify-inputs (platform:Symbol) -> [ProjFile, BuildManager, Collection<Symbol|String>, Tuple<Symbol|String>] :
    defn classify-names (inputs:BuildInputs,
                         return-proj:String -> ?,
                         return-file:String -> ?,
                         return-package:Symbol -> ?) :
      match(inputs) :
        (inputs:BuildStringArgs) :
          for name in names(inputs) do :
            if not has-extension?(name) : return-package(to-symbol(name))
            else if suffix?(name, ".proj") : return-proj(name)
            else : return-file(name)            
        (inputs:BuildPackages) :
          for p in packages(inputs) do :
            match(p) :
              (p:String) : return-file(p)
              (p:Symbol) : return-package(p)
    match(inputs(settings)) :
      (build-inputs:BuildStringArgs|BuildPackages) :
        ;Categorize filenames
        val projfiles = to-vector<String> $ ["stanza.proj"]
        val inputs = Vector<String|Symbol>()        
        classify-names(build-inputs, add-to(projfiles), add-to(inputs), add-to(inputs))

        ;Categorize vmpackage files
        val vmpackages = Vector<String|Symbol>()
        classify-names(/vm-packages(settings), fatal{"Illegal .proj file."}, add-to(vmpackages), add-to(vmpackages))

        ;Read proj file
        val proj = read-proj-files(projfiles, platform)
        
        ;Return proj and inputs
        [proj, BuildManager(proj), inputs, to-tuple(vmpackages)]
      (inputs:BuildTarget) :
        val proj = read-proj-files(["stanza.proj"], platform)
        val bm = BuildManager(proj)
        val s = target(bm, target(inputs))

        ;Categorize vmpackage files
        val vmpackages = to-vector<String|Symbol>(supported-vm-packages(s))
        classify-names(/vm-packages(settings), fatal{"Illegal. proj file"}, add-to(vmpackages), add-to(vmpackages))        

        ;Return proj and inputs
        [proj, bm, /inputs(s), to-tuple(vmpackages)]

  defn already-built? (inputs:BuildInputs, bm:BuildManager) :
    match(inputs:BuildTarget) :
      target-up-to-date?(bm, target(inputs))

  defn compute-build-settings (bm:BuildManager) :
    if inputs(settings) is BuildTarget :
      val s = target(bm, target(inputs(settings) as BuildTarget))
      
      ;Compute build flags
      val build-flags = unique-join(flags(s), flags(settings))

      ;Compute build optimization level
      val build-optimization = optimize?(settings) or optimize(s)

      ;Compute assembly and output
      defn string-or? (a:String|False, b:String|False) :
        match(a:False) : b
        else : a
      val assembly* = string-or?(assembly(settings), value?(assembly(s)))
      val output* = string-or?(output(settings), value?(output(s)))

      ;Compute build assembly file
      val [build-asm, temporary-asm?] =
        match(assembly*, output*) :
          (asm:String, out) : [asm, false]
          (asm:False, out:String) : [make-temporary-file(system), true]
          (asm:False, out:False) : [false, false]

      ;Compute build pkg directory
      val build-pkg-dir = string-or?(pkg-dir(settings), value?(pkg(s)))
      
      ;Return settings
      [build-flags, build-optimization, build-asm, temporary-asm?, output*, build-pkg-dir]
      
    else :
      ;Compute build flags
      val build-flags = flags(settings)

      ;Compute build optimization level
      val build-optimization = optimize?(settings)

      ;Compute build assembly file
      val [build-asm, temporary-asm?] =
        match(assembly(settings), output(settings)) :
          (asm:String, out) : [asm, false]
          (asm:False, out:String) : [make-temporary-file(system), true]
          (asm:False, out:False) : [false, false]

      ;Compute build output file
      val build-out = output(settings)

      ;Compute build pkg directory
      val build-pkg-dir = pkg-dir(settings)
      
      ;Return settings
      [build-flags, build-optimization, build-asm, temporary-asm?, build-out, build-pkg-dir]

  defn setup-system-flags (build-platform:Symbol, build-flags:Tuple<Symbol>, build-optimization:True|False, build-pkg-dir:String|False) :
    ;Platform setting
    OUTPUT-PLATFORM = build-platform

    ;Platform flag
    add-flag $ platform-flag(build-platform)

    ;Optimization flag
    add-flag(`OPTIMIZE) when build-optimization

    ;Add custom build flags
    do(add-flag, build-flags)

    ;Update pkg path
    match(build-pkg-dir:String) :
      STANZA-PKG-DIRS = cons(build-pkg-dir, STANZA-PKG-DIRS)

  defn backend (platform:Symbol) :
    switch(platform) :
      `os-x : X64Backend()
      `linux : L64Backend()
      `windows : W64Backend()

  defn link-output-file (build-platform:Symbol, build-asm:String|False, temporary-asm?:True|False, build-out:String|False,
                         build-manager:BuildManager, comp-result:CompilationResult) :
    ;Accumulate filestamps
    val filestamps = Vector<FileStamp>()

    ;Main algorithm
    defn driver () :
      ;Add package stamps from front end compilation result
      add-all(filestamps, output-pkgs(comp-result))
      ;Categorize cases
      match(build-out, build-asm) :
        (build-out:String, build-asm) : compile-exe(build-asm as String, build-out)
        (build-out:False, build-asm:String) : compile-asm(build-asm)
        (build-out:False, build-asm:False) : compile-pkgs()

    ;Case: Build an executable
    defn compile-exe (build-asm:String, build-out:String) :
      val ds = calc-dependencies()
      add-filestamps(ds)
      ;Run any compilation commands
      val stmts = build-commands(build-manager, ds)
      for command in seq-cat(commands,stmts) do :
        call-shell(system, build-platform, command)
      ;Create the output file
      call-cc(system, build-platform, build-asm, ccfiles(ds), ccflags(ds), build-out)
      ;Delete the temporary asm file if necessary
      delete-temporary-file(system, build-asm) when temporary-asm?
      ;Update the auxiliary file
      add-filestamp(build-asm) when not temporary-asm?
      add-filestamp(build-out)
      write-aux-file()

    ;Case: Compile to assembly without linking final executable
    defn compile-asm (build-asm:String) :
      val ds = calc-dependencies()
      add-filestamps(ds)     
      ;Update the auxiliary file
      add-filestamp(build-asm)
      write-aux-file()

    ;Case: Compile to pkgs
    defn compile-pkgs () :
      write-aux-file()

    ;Utilities
    defn calc-dependencies () :
      ;Compute original dependencies
      val ds = dependencies(build-manager,
                            unique-join(compiled-packages(comp-result),
                                        binding-packages(comp-result)))
      ;Compute the project external dependencies
      ProjDependencies(unique-join(ccfiles(settings), ccfiles(ds)),
                       unique-join(ccflags(settings), ccflags(ds)))

    defn add-filestamp (file:String) :
      add(filestamps, filestamp(file))

    defn add-filestamp? (file:String) :
      add-filestamp(file) when file-exists?(file)

    defn add-filestamps (ds:ProjDependencies) :
      do(add-filestamp?, ccfiles(ds))
      add-all(filestamps, output-pkgs(comp-result))
      
    defn write-aux-file () :
      if inputs(settings) is BuildTarget :
        val target = target(inputs(settings) as BuildTarget)
        update-aux-file(build-manager, target, package-stamps(comp-result), to-tuple(filestamps))
        
    ;Launch!
    driver()

  ;Launch!
  main()

;============================================================
;====================== Utilities ===========================
;============================================================
    
defn unique-join<?T> (xs:Seqable<?T&Equalable>, ys:Seqable<?T&Equalable>) :
  to-tuple $ unique $ cat(xs, ys)

defn has-extension? (s:String) :
  index-of-char(s, '.') is Int

defn add-to<?T> (v:Vector<?T>) : (fn (x:T) : add(v, x))