;See License.txt for details about licensing.

defpackage stz/compiler :
  import core
  import collections
  import reader
  import macro-utils
  import stz/params
  import stz/utils
  import stz/algorithms
  import stz/input
  import stz/renamer
  import stz/resolver
  import stz/type
  import stz/il-ir
  import stz/tl-ir
  import stz/namemap
  import stz/core-macros
  import stz/tl-to-el
  import stz/tl-to-dl
  import stz/el-to-vm
  import stz/el
  import stz/el-ir
  import stz/vm-ir
  import stz/backend
  import stz/reg-alloc with :
    prefix(Ins) => reg-alloc-
  import stz/vm-normalize
  import stz/codegen
  import stz/asm-ir
  import stz/asm-emitter
  import stz/stitcher

defn macroexpand (forms:List) -> List :
  val es = parse-syntax[core / #exps!](forms)
  cons(`$begin, es)

defn read-input-file (filename:String) -> Tuple<IPackage> :
  fatal("Not yet implemented")
  ;switch suffix?{filename, _} :
  ;  ".stanza" :
  ;    val forms = time-ms("Reading and Lexing", read-file{filename})
  ;    val expanded = time-ms("Macro Expansion", macroexpand{forms})
  ;    to-il(expanded)
  ;  ;".pkg" :
  ;  ;   val pkg = time-ms("Load Pkg", load-package{filename})
  ;  ;   ILoadPackage(filename, pkg, false)
  ;  ;else :
  ;  ;  throw(InvalidExtensionError(filename)) when contains?(filename, ".")
  ;  ;  val [filename, pkg] = time-ms("Load Pkg", find-and-load-package{to-symbol(filename)})
  ;  ;  ILoadPackage(filename, pkg, false)  

public defn check (filenames:List<String>) -> [TProg, NameMap] :
   val typed = fatal("A")
   val namemap = fatal("B")
   [typed, namemap]
   
   ;;Read in all files and combine into single program
   ;val input = to-tuple $ seq-cat(read-input-file, filenames)
   ;do(println, input)
   ;
   ;;Rename
   ;val renamed = match(rename-il(input)) :
   ;  (ipkgs:Tuple<IPackage>) : ipkgs
   ;  (e:RenameErrors) : throw(e)
   ;
   ;;Resolve
   ;val env = new Env :
   ;  defmethod packageio (this, package:Symbol) : false
   ;
   ;val resolved = resolve-il(renamed, env)
   ;match(resolved) :
   ;  (rp:ResolvedPackages) :
   ;    val tprog = type-program(packages(rp), environment(rp))
   ;    println(tprog)
   ;
   ;  (rp:ResolveErrors) :
   ;    do(println, errors(rp))
   ;
   ;fatal("Done for now")
   ;
   ;;Check for syntax violations
   ;;time-ms("Check Syntax Violations", check{input})
   ;;;Perform global renaming and check for naming violations
   ;;val [namemap, renamed] = time-ms("Rename Identifiers", rename{input})
   ;;vheader("Renamed")
   ;;vprintln(renamed)
   ;;;Perform symbol resolution and check for resolution errors
   ;;val resolved = time-ms("Resolve Identifiers", resolve{namemap, renamed})
   ;;vheader("Resolved")
   ;;vprintln(resolved)
   ;;;Convert to typed IR and check for type errors
   ;;val typed = time-ms("To Type IR", type-program{namemap, resolved})
   ;;
   ;;;Return
   ;;[typed, namemap]

public defn compile (filenames:List<String>, output:False|String, pkg-dir:False|String) :
  defn driver () :
    ;For now, assume that the filesnames are all .stanza files
    ;- First read and macro-expand all the files.
    ;- Then rename, resolve, and type all the packages.
    val expanded = map(read+expand, filenames)

    ;- Then convert the s-expression forms into IPackages.
    val ipackages = to-ipackages(expanded)

    ;- Then convert the packages into typed form, by
    ;  renaming, resolving, and typechecking.
    val typed = type(resolve(rename(ipackages)))

    ;- If the package typechecks, then we can start compilation
    ;  to assembly. The first step is to bring it to EL form.
    val el-ir = to-el-ir(typed)

    ;- Then we compile the EL form into VM form.
    val vm-ir = to-vm-ir(el-ir)

    ;- Finally, we assemble the VM form and emit the assembly code.
    match(output:String) :
      assemble(vm-ir, output)

  defn read+expand (filename:String) :
    val forms = read-file(filename)
    cons(`$begin, parse-syntax[core / #exps!](forms))

  defn to-ipackages (expanded:List) :
    to-tuple $ for e in expanded seq-cat :
      val core-imports = [IImport(`core), IImport(`collections)]
      /to-ipackages(e, core-imports)

  defn rename (ipackages:Tuple<IPackage>) :
    match(rename-il(ipackages)) :
      (renamed:Tuple<IPackage>) : renamed
      (e:RenameErrors) : throw(e)

  defn resolve (ipackages:Tuple<IPackage>) :
    val empty-env = new stz/resolver/Env :
      defmethod packageio (this, package:Symbol) : false
    match(resolve-il(ipackages, empty-env, false)) :
      (e:ResolveErrors) : throw(e)
      (e:Tuple<IPackage>) : e

  defn type (ipackages:Tuple<IPackage>) :
    val empty-env = new stz/type/Env
    match(type-program(ipackages, empty-env)) :
      (e:TProg) : e
      (e:TypeErrors) : throw(e)

  defn to-el-ir (typed:TProg) :
    to-el(typed, false)

  defn to-vm-ir (epackages:Tuple<EPackage>) :
    map(compile{lower(_)}, epackages)

  defn assemble (vmpackages:Tuple<VMPackage>, output:String) :
    val backend = X64Backend()
    val stubs = AsmStubs(backend)
    val nvmps = map(normalize{_, backend}, vmpackages)
    val stitcher = Stitcher(nvmps, stubs)
    val file = FileOutputStream(output)
    val file-emitter = new CodeEmitter :
      defmethod emit (this, i:Ins) :
        emit(i, backend)
    with-output-file(file, fn () :
      for p in nvmps do :
        val emitter = emitter(stitcher, package(p), file-emitter)
        for f in funcs(p) do :
          emit-label(emitter, id(f))
          allocate-registers(func(f), emitter, backend, stubs)
      emit-tables(stitcher, file-emitter)
      emit-stubs(stitcher, file-emitter)
      compile-runtime-stubs(file-emitter, stubs))

  driver()

;============================================================
;===================== Errors ===============================
;============================================================

defn InvalidExtensionError (filename:String) :
  new Exception :
    defmethod print (o:OutputStream, this) :
      print(o, "File %_ does not have a valid Stanza file extension." % [filename])