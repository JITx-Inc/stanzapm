defpackage stz/kform-to-tgt :
  import core
  import collections
  import stz/kl-ir
  import stz/tgt-ir
  import stz/ids
  import stz/kform
  import stz/primitives

;Expressions to Compile
;[X] KSeq
;[X] KClosureGet
;[X] KLetClosures
;[X] KClosure
;[X] KCall
;[X] KObject
;[X] KObjectGet
;[X] KBoxGet
;[X] KBoxSet
;[X] KBox
;[X] KReifiedCast
;[X] KTypeObject
;[X] KDo!
;[X] KEnsureSet
;[X] KPrim
;[X] KEnsureLength
;[X] KTupleGet
;[X] KTuple
;[X] KLiteral
;[X] KVar
;[X] KDispatch
;[X] KMatch
;[X] KLet
;[X] KSet

;Primitives to Compile
;Machine Primitives
;[X] ADD-OP : TGAddOp
;[X] SUB-OP : TGSubOp
;[X] MUL-OP : TGMulOp
;[X] DIV-OP : TGDivOp
;[X] MOD-OP : TGModOp
;[X] AND-OP : TGAndOp
;[X] OR-OP : TGOrOp
;[X] XOR-OP : TGXorOp
;[X] SHL-OP : TGShlOp
;[X] SHR-OP : TGShrOp
;[X] ASHR-OP : TGAshrOp
;[X] NEG-OP : TGNegOp
;[X] NOT-OP : TGNotOp

;Tagged Boolean Primitives
;[X] EQ-OP : TGEqOp
;[X] NE-OP : TGNeOp
;[X] LT-OP : TGLtOp
;[X] GT-OP : TGGtOp
;[X] LE-OP : TGLeOp
;[X] GE-OP : TGGeOp
;[X] IDENTICAL-OP : TGEqOp

;Inline Primitives
;[X] AGET-OP
;[X] ASET-OP
;[X] ALEN-OP
;[X] CHAR-AGET-OP
;[X] CHAR-ASET-OP
;[X] STRING-GET-OP
;[X] STRING-LEN-OP

;============================================================
;============= Expression Compilation System ================
;============================================================

;Instruction Buffer
var INSTRUCTION-BUFFER : False|Vector<TGIns> = false
defn emit (e:TGIns) : add(INSTRUCTION-BUFFER as Vector<TGIns>, e)

;Base Compiled Expression
deftype CExp
defmulti set (n:Int, c:CExp) -> False
defmulti ignore (c:CExp) -> False
defmulti imm (c:CExp) -> TGImm
defmulti tail (c:CExp) -> False
defmulti return (c:CExp) -> False

;Most default things are defined in terms of set
;Except for ignore
defmethod imm (c:CExp) :
  val n = fresh-id()
  emit(TGDef(n, TGRefT()))
  set(n, c)
  TGVar(n)
defmethod tail (c:CExp) : return(c)
defmethod return (c:CExp) : emit(TGReturn(List(imm(c))))

;If it is continuable, then define everything in terms of kont
deftype Continuable
defmulti kont (c:Continuable, kont:CExp -> False, end?:True|False) -> False
defmulti kont (c:Continuable, kont:CExp -> False) -> False
defmethod kont (c:Continuable, k:CExp -> False, end?:True|False) : kont(c, k)
defmethod tail (c:CExp&Continuable) : kont(c, tail, true)
defmethod return (c:CExp&Continuable) : kont(c, return, true)
defmethod ignore (c:CExp&Continuable) : kont(c, ignore, false)
defmethod set (n:Int, c:CExp&Continuable) : kont(c, set{n, _}, false)

;If it is immediate, then set is defined in terms of imm
deftype Immediate
defmethod set (n:Int, c:CExp&Immediate) : emit(TGSet(TGVar(n), imm(c)))

;If it is ignorable, then ignore does nothing
deftype Ignorable
defmethod ignore (c:CExp&Ignorable) : false

;If it allocates, then define in terms of fields
deftype Allocate
defmulti fields (x:Allocate) -> List<TGImm|CExp>
defmethod set (n:Int, c:CExp&Allocate) :
  val fs = for f in fields(c) map :
    match(f) :
      (f:TGImm) : f
      (f:CExp) : imm(f)
  val size = 8 * length(fs)
  allocate-ref(n, size)
  for (f in fs, i in 0 to false) do :    
    emit(TGStore(TGVar(n), f, 8 * i - REF-TAG-BITS))
defmethod ignore (c:CExp&Allocate) :
  do(ignore, filter-by<CExp>(fields(c)))

;============================================================
;================ Compilation Utilities =====================
;============================================================

defn make-var (t:TGType) :
  val n = fresh-id()
  emit(TGDef(n, t))
  TGVar(n)

defn tcall (f:Int, args:List<TGImm>) :
  emit(TGTCall(length(args), TGMem(f,0), args))
defn tcall (f:Int) :
  tcall(f, List())
defn call (f:Int, args:List<TGImm>) :
  emit(TGCall(length(args), List(), TGMem(f,0), args))
defn call (f:Int) :
  call(f, List())

defn allocate-ref (n:Int, obj-size:Int) :
  val size = TGLong(to-long(obj-size))
  val ref-tag = TGLong(to-long(REF-TAG-BITS))
  val end-lbl = fresh-id()
  val p = make-var(TGLongT())                                    ;  var p : long
  val new-p = make-var(TGLongT())                                ;  var new-p : long
  val limit = make-var(TGLongT())                                ;  var limit : long
  emit(TGLoad(p, TGMem(HEAP-PTR-LBL,0), 0))                      ;  p = [heap-ptr]
  emit(TGLoad(limit, TGMem(HEAP-LIM-LBL,0), 0))                  ;  limit = [heap-lim]
  emit(TGBinOp(new-p, TGAddOp(), p, size))                       ;  new-p = p + size
  emit(TGBinCmp(end-lbl, TGUleOp(), new-p, limit))               ;  goto end-lbl if new-p <= limit
  call(EXTEND-HEAP-ID, List(size))                               ;  extend-heap(size)
  emit(TGLoad(p, TGMem(HEAP-PTR-LBL,0), 0))                      ;  p = [heap-ptr]
  emit(TGBinOp(new-p, TGAddOp(), p, size))                       ;  new-p = p + size
  emit(TGLabel(end-lbl))                                         ;end-lbl:
  emit(TGStore(TGMem(HEAP-PTR-LBL,0), new-p, 0))                 ;  [heap-ptr] = new-p
  emit(TGBinOp(TGVar(n), TGAddOp(), p, ref-tag))                 ;  n = p + REF-TAG-BITS

defn allocate-refs (ns:List<Int>, sizes:List<Int>) :
  val total = TGLong(to-long(sum(sizes)))
  val end-lbl = fresh-id()
  val p = make-var(TGLongT())                                     ;  var p : long
  val new-p = make-var(TGLongT())                                 ;  var new-p : long
  val limit = make-var(TGLongT())                                 ;  var limit : long
  emit(TGLoad(p, TGMem(HEAP-PTR-LBL,0), 0))                       ;  p = [heap-ptr]
  emit(TGLoad(limit, TGMem(HEAP-LIM-LBL,0), 0))                   ;  limit = [heap-lim]
  emit(TGBinOp(new-p, TGAddOp(), p, total))                       ;  new-p = p + total
  emit(TGBinCmp(end-lbl, TGUleOp(), new-p, limit))                ;  goto end-lbl if new-p <= limit
  call(EXTEND-HEAP-ID, List(total))                               ;  extend-heap(total)
  emit(TGLoad(p, TGMem(HEAP-PTR-LBL,0), 0))                       ;  p = [heap-ptr]
  emit(TGBinOp(new-p, TGAddOp(), p, total))                       ;  new-p = p + total
  emit(TGLabel(end-lbl))                                          ;end-lbl:
  emit(TGStore(TGMem(HEAP-PTR-LBL,0), new-p, 0))                  ;  [heap-ptr] = new-p
  val offset-counter = Counter(REF-TAG-BITS)                      ;
  for (n in ns, size in sizes) do :                               ;  (ns ...) = p + (sizes ...) + REF-TAG-BITS
    val offset = resume(offset-counter, size)
    emit(TGBinOp(TGVar(n), TGAddOp(), p, TGLong(to-long(offset))))

defn Counter (init:Int) :
  Coroutine<Int,Int> $ fn (co, sz) :
    let loop (accum:Int = init, sz:Int = sz) :
      loop(accum + sz, suspend(co, accum))

defn bit-representation (value) :
  match(value) :
    (value:Byte) : to-long(value) << 3L + to-long(BYTE-TAG-BITS)
    (value:Char) : to-long(to-int(value) << 3 + CHAR-TAG-BITS)
    (value:Int) : to-long(value) << 32L
    (value:Float) : to-long(value) << 3L + to-long(FLOAT-TAG-BITS)
    (value:True) : 1L << 3L + to-long(MARKER-TAG-BITS)
    (value:False) : to-long(MARKER-TAG-BITS)

val BINARY-OPS = [ADD-OP, SUB-OP, MUL-OP, DIV-OP, MOD-OP, AND-OP,
                  OR-OP, XOR-OP, SHL-OP, SHR-OP, ASHR-OP, EQ-OP, NE-OP,
                  LT-OP, GT-OP, LE-OP, GE-OP, IDENTICAL-OP, AGET-OP,
                  CHAR-AGET-OP, STRING-GET-OP]
val UNARY-OPS = [NOT-OP, NEG-OP, ALEN-OP, STRING-LEN-OP]
val EFFECTFUL-TERNARY-OPS = [ASET-OP, CHAR-ASET-OP]

;============================================================
;================ HiStanza Compilation ======================
;============================================================
;TODO: Don't check (nor set) arity when guaranteed.

public defn compile (dec-table:DecTable, f:KFunc) -> Vector<TGIns> :
  ;===================
  ;==== Utilities ====
  ;===================
  defn foffset (n:Int) :
    field-offset(dec-table, n) + 8 - REF-TAG-BITS
  val length-offset = 8 - REF-TAG-BITS
    
  ;=================================
  ;==== Compiling an Expression ====
  ;=================================
  defn cexp (e:KExp) -> CExp :
    match(e) :
      (e:KSeq) :
        new CExp & Continuable :
          defmethod kont (this, kont:CExp -> False) :
            ignore(cexp(a(e)))
            kont(cexp(b(e)))
      (e:KVar) :
        if global?(dec-table, n(e)) :
          new CExp & Ignorable :
            defmethod set (v:Int, this) :
              emit(TGLoad(TGVar(v), TGMem(n(e),0), 0))
        else :
          new CExp & Ignorable & Immediate :
            defmethod imm (this) :
              TGVar(n(e))
      (e:KLiteral) :
        new CExp & Ignorable & Immediate :
          defmethod imm (this) :
            TGLong(bit-representation(value(e)))
      (e:KSet) :
        new CExp & Immediate :
          defmethod imm (this) :
            ignore(this)
            TGLong(bit-representation(false))
          defmethod ignore (this) :
            emit(TGStore(TGMem(n(e),0), imm(cexp(value(e))), 0))
      (e:KLet) :
        val def = def(e) as KDef
        new CExp & Continuable :
          defmethod kont (this, kont:CExp -> False) :
            emit(TGDef(n(def), TGRefT()))
            set(n(def), cexp(value(def)))
            kont(cexp(body(e)))
      (e:KBoxGet) :
        val box = cexp(exp(e))
        new CExp :
          defmethod set (n:Int, this) :
            emit(TGLoad(TGVar(n), imm(box), foffset(BOX-ITEM-FIELD-ID)))
          defmethod ignore (this) :
            ignore(box)
      (e:KBoxSet) :
        val box = cexp(exp(e))
        val value = cexp(value(e))
        new CExp & Immediate :
          defmethod imm (this) :
            ignore(this)
            TGLong(bit-representation(false))
          defmethod ignore (this) :
            emit(TGStore(imm(box), imm(value), foffset(BOX-ITEM-FIELD-ID)))
      (e:KBox) :
        new CExp & Allocate :
          defmethod fields (this) :
            val v = match(value(e)) :
              (v:KExp) : cexp(v)
              (v:False) : TGLong(to-long(VOID-TAG))
            List(TGTag(BOX-TYPE-ID), v)
      (e:KReifiedCast) :
        val o = cexp(exp(e))
        new CExp & Immediate :
          defmethod imm (this) :
            val o = imm(cexp(exp(e)))
            emit(TGCast(o, tag(e)))
            o
          defmethod ignore (this) :
            imm(this)
            false
      (e:KTypeObject) :
        new CExp & Allocate :
          defmethod fields (this) :
            append(
             [TGTag(TYPE-TYPE-ID)
              TGLong(to-long(length(args(e))))
              TGMem(n(e),0)]
              map(cexp, args(e)))
      (e:KClosureGet) :
        val c = cexp(exp(e))
        new CExp :
          defmethod set (n:Int, this) :
            val offset = 8 * index(e) + foffset(FN-FREE-FIELD-ID)
            emit(TGLoad(TGVar(n), imm(c), offset))
          defmethod ignore (this) :
            ignore(c)
      (e:KClosure) :
        new CExp & Allocate :
          defmethod fields (this) :
            append(
             [TGTag(FN-TYPE-ID)
              TGLong(to-long(length(args(e))))
              TGMem(n(e),0)]
              map(cexp, args(e)))
      (e:KLetClosures) :
        new CExp & Continuable :
          defmethod kont (this, kont:CExp -> False) :
            ;Compile all arguments to closures
            val argss = for c in closures(e) map :
              append(
               [TGTag(FN-TYPE-ID)
                TGLong(to-long(length(args(c))))
                TGMem(n(c), 0)]
                map(imm{cexp(_)}, args(c)))
            ;Allocate closures
            val sizes = map({8 * length(_)}, argss)
            allocate-refs(ns(e), sizes)
            ;Store arguments
            for (n in ns(e), args in argss) do :
              for (arg in args, i in 0 to false) do :
                emit(TGStore(TGVar(n), arg, 8 * i - REF-TAG-BITS))
            ;Continue with body
            kont(cexp(body(e)))
      (e:KObject) :
        new CExp & Allocate :
          defmethod fields (this) :
            cons(
              TGTag(n(e)),
              map(cexp, args(e)))
      (e:KObjectGet) :
        val o = cexp(exp(e))
        new CExp :
          defmethod set (n:Int, this) :
            val offset = 8 * index(e) + 8 - REF-TAG-BITS
            emit(TGLoad(TGVar(n), imm(o), offset))
          defmethod ignore (this) :
            ignore(o)
      (e:KTuple) :
        new CExp & Allocate :
          defmethod fields (this) :
            append(
             [TGTag(TUPLE-TYPE-ID)
              TGLong(to-long(length(exps(e))))]
              map(cexp, exps(e)))
      (e:KTupleGet) :
        val o = cexp(exp(e))
        new CExp :
          defmethod set (n:Int, this) :
            val offset = 8 * index(e) + foffset(TUPLE-ITEMS-FIELD-ID)
            emit(TGLoad(TGVar(n), imm(o), offset))
          defmethod ignore (this) :
            ignore(o)
      (e:KCall) :
        val func = match(extern-label(dec-table, func(e))) :
          (lbl:Symbol) : TGExMem(lbl,0)
          (_:False) : TGMem(func(e),0)
        val args = map(cexp, args(e))
        new CExp :
          defmethod set (n:Int, this) :
            emit(TGCall(arity(e), List(TGVar(n)), func, map(imm, args)))
          defmethod tail (this) :
            emit(TGTCall(arity(e), func, map(imm, args)))
          defmethod ignore (this) :
            emit(TGCall(arity(e), List(), func, map(imm, args)))
      (e:KDo!) :
        val func = cexp(func(e))
        val args = map(cexp, args(e))
        defn code (f:TGImm) :
          val x = make-var(TGLongT())
          emit(TGLoad(x, f, foffset(FN-CODE-FIELD-ID)))
          x
        new CExp :
          defmethod set (n:Int, this) :
            val f = imm(func)
            val code = code(f)
            emit(TGCall(arity(e), List(TGVar(n)), code, cons(f, map(imm, args))))
          defmethod tail (this) :
            val f = imm(func)
            val code = code(f)
            emit(TGTCall(arity(e), code, cons(f, map(imm, args))))
          defmethod ignore (this) :
            val f = imm(func)
            val code = code(f)
            emit(TGCall(arity(e), List(), code, cons(f, map(imm, args))))
      (e:KEnsureSet) :
        new CExp & Immediate :
          defmethod imm (this) :
            val lbl = fresh-id()
            val o = imm(cexp(exp(e)))
            emit(TGBinCmp(lbl, TGNeOp(), o, TGLong(to-long(VOID-TAG))))
            tcall(VARIABLE-UNINITIALIZED-ERROR-ID)
            emit(TGLabel(lbl))
            o
          defmethod ignore (this) :
            imm(this)
            false
      (e:KEnsureLength) :
        new CExp & Immediate :
          defmethod imm (this) :
            val lbl = fresh-id()
            val o = imm(cexp(exp(e)))
            val len = make-var(TGLongT())
            emit(TGLoad(len, o, 8 - REF-TAG-BITS))
            emit(TGBinCmp(lbl, TGEqOp(), len, TGLong(to-long(length(e)))))
            tcall(TUPLE-LENGTH-ERROR-ID)
            emit(TGLabel(lbl))
            o
          defmethod ignore (this) :
            imm(this)
            false
      (e:KMatch|KDispatch) :
        new CExp & Continuable :
          defmethod kont (this, kont:CExp -> False, end?:True|False) :
            val match-args = map(imm{cexp(_)}, args(e))
            val bs = map(TGBranch{tags(_), fresh-id()}, branches(e))
            val done = fresh-id()
            match(e) :
              (e:KMatch) : emit(TGMatch(match-args, bs))
              (e:KDispatch) : emit(TGDispatch(match-args, bs))
            for (b in branches(e), id in seq(n,bs)) do :
              emit(TGLabel(id))
              for (a in args(b), ma in match-args) do :
                emit(TGDef(a, TGRefT()))
                emit(TGSet(TGVar(a), ma))
              kont(cexp(body(b)))
              emit(TGGoto(done)) when not end?
            emit(TGLabel(done)) when not end?
      (e:KPrim) :
        ;Utilities
        defn binop (x:TGVar, op:TGOp, a:TGImm, b:TGImm) :
          emit(TGBinOp(x, op, a, b))
        defn binop (n:Int, op:TGOp, a:TGImm, b:TGImm) :
          binop(TGVar(n), op, a, b)
        defn unaop (x:TGVar, op:TGOp, a:TGImm) :
          emit(TGUnaOp(x, op, a))
        defn unaop (n:Int, op:TGOp, a:TGImm) :
          unaop(TGVar(n), op, a)
        defn detag-int (y:TGImm) :
          val x = make-var(TGLongT())
          binop(x, TGAshrOp(), y, TGLong(32L))
          x
        defn detag-char (y:TGImm) :
          val x = make-var(TGLongT())
          val b = make-var(TGByteT())
          binop(x, TGShrOp(), y, TGLong(3L))
          emit(TGConv(b,x))
          b
        defn tag-as-bool (x:TGVar, y:TGImm) :
          binop(x, TGShlOp(), y, TGLong(3L))
          binop(x, TGAddOp(), x, TGLong(to-long(MARKER-TAG-BITS)))
        defn tag-as-char (x:TGVar, y:TGImm) :
          emit(TGConv(x,y))
          binop(x, TGShlOp(), x, TGLong(3L))
          binop(x, TGAddOp(), x, TGLong(to-long(CHAR-TAG-BITS)))

        ;Dispatch        
        if contains?(BINARY-OPS, op(e)) :
          val a = cexp(args(e)[0])
          val b = cexp(args(e)[1])
          new CExp :
            defmethod set (n:Int, this) :
              val a = imm(a)
              val b = imm(b)
              switch(op(e)) :
                ADD-OP :
                  binop(n, TGAddOp(), a, b)
                SUB-OP :
                  binop(n, TGSubOp(), a, b)
                MUL-OP :
                  binop(n, TGMulOp(), detag-int(a), b)
                DIV-OP :
                  val x = make-var(TGLongT())
                  binop(x, TGDivOp(), a, b)
                  binop(n, TGShlOp(), x, TGLong(32L))
                MOD-OP :
                  binop(n, TGModOp(), a, b)
                AND-OP :
                  binop(n, TGAndOp(), a, b)
                OR-OP :
                  binop(n, TGOrOp(), a, b)
                XOR-OP :
                  binop(n, TGXorOp(), a, b)
                SHL-OP :
                  binop(n, TGShlOp(), a, detag-int(b))
                SHR-OP :
                  val x = make-var(TGLongT())
                  binop(x, TGShrOp(), a, detag-int(b))
                  binop(x, TGShrOp(), x, TGLong(32L))
                  binop(n, TGShlOp(), x, TGLong(32L))
                ASHR-OP :
                  val x = make-var(TGLongT())
                  binop(x, TGAshrOp(), a, detag-int(b))
                  binop(x, TGShrOp(), x, TGLong(32L))
                  binop(n, TGShlOp(), x, TGLong(32L))
                EQ-OP :
                  binop(n, TGEqOp(), a, b)
                  tag-as-bool(TGVar(n), TGVar(n))
                NE-OP :
                  binop(n, TGNeOp(), a, b)
                  tag-as-bool(TGVar(n), TGVar(n))
                LT-OP :
                  binop(n, TGLtOp(), a, b)
                  tag-as-bool(TGVar(n), TGVar(n))
                GT-OP :
                  binop(n, TGGtOp(), a, b)
                  tag-as-bool(TGVar(n), TGVar(n))
                LE-OP :
                  binop(n, TGLeOp(), a, b)
                  tag-as-bool(TGVar(n), TGVar(n))
                GE-OP :
                  binop(n, TGGeOp(), a, b)
                  tag-as-bool(TGVar(n), TGVar(n))
                IDENTICAL-OP :
                  binop(n, TGEqOp(), a, b)
                  tag-as-bool(TGVar(n), TGVar(n))
                AGET-OP :
                  val o = make-var(TGLongT())
                  binop(o, TGAshrOp(), b, TGLong(32L - 3L))
                  binop(o, TGAddOp(), o, a)
                  emit(TGLoad(TGVar(n), o, foffset(RAWARRAY-ITEMS-FIELD-ID)))
                CHAR-AGET-OP :
                  val o = make-var(TGLongT())
                  val c = make-var(TGByteT())
                  binop(o, TGAshrOp(), b, TGLong(32L))
                  binop(o, TGAddOp(), o, a)
                  emit(TGLoad(c, o, foffset(CHARARRAY-CHARS-FIELD-ID)))
                  tag-as-char(TGVar(n), c)
                STRING-GET-OP :
                  val o = make-var(TGLongT())
                  val c = make-var(TGByteT())
                  binop(o, TGAshrOp(), b, TGLong(32L))
                  binop(o, TGAddOp(), o, a)
                  emit(TGLoad(c, o, foffset(STRING-CHARS-FIELD-ID)))
                  tag-as-char(TGVar(n), c)
            defmethod ignore (this) :
              ignore(a)
              ignore(b)
        else if contains?(UNARY-OPS, op(e)) :
          val a = cexp(head(args(e)))
          new CExp :
            defmethod set (n:Int, this) :
              val a = imm(a)
              switch(op(e)) :
                NOT-OP :
                  val x = make-var(TGLongT())
                  unaop(x, TGNotOp(), a)
                  binop(x, TGShrOp(), x, TGLong(32L))
                  binop(n, TGShlOp(), x, TGLong(32L))
                NEG-OP :
                  unaop(n, TGNegOp(), a)
                ALEN-OP :
                  emit(TGLoad(TGVar(n), a, 8 - REF-TAG-BITS))
                  binop(n, TGShlOp(), TGVar(n), TGLong(32L))
                STRING-LEN-OP :
                  emit(TGLoad(TGVar(n), a, 8 - REF-TAG-BITS))
                  binop(n, TGShlOp(), TGVar(n), TGLong(32L))
            defmethod ignore (this) :
              ignore(a)
        else if contains?(EFFECTFUL-TERNARY-OPS, op(e)) :
          val a = cexp(args(e)[0])
          val b = cexp(args(e)[1])
          val c = cexp(args(e)[2])
          new CExp & Immediate :
            defmethod imm (this) :
              ignore(this)
              TGLong(bit-representation(false))
            defmethod ignore (this) :
              val a = imm(a)
              val b = imm(b)
              val c = imm(c)
              switch(op(e)) :
                ASET-OP :
                  val o = make-var(TGLongT())
                  binop(o, TGAshrOp(), b, TGLong(32L - 3L))
                  binop(o, TGAddOp(), o, a)
                  emit(TGStore(o, c, foffset(RAWARRAY-ITEMS-FIELD-ID)))
                CHAR-ASET-OP :
                  val o = make-var(TGLongT())
                  binop(o, TGAshrOp(), b, TGLong(32L))
                  binop(o, TGAddOp(), o, a)
                  emit(TGStore(o, detag-char(c), foffset(CHARARRAY-CHARS-FIELD-ID)))
        else :
          fatal("Cannot compile primitive: %_" % [op(e)])

  ;=====================================
  ;==== Compiling a Single Function ====
  ;=====================================
  ;[3 Reserve stacks]
  ;  - For handling stack overflow
  ;  - For running the GC
  ;  - For handling overflow during GC
  defn cfn (f:KFn!) :
    ;Extend stack if necessary
    defn stack-extension-prelude () :
      ;  goto default if has-space
      ;  new-stack
      ;  vs = args
      ;  goto body if num-free-stacks >= 3 ;See [3 Reserve Stacks]
      ;  extend-stack()
      ;  goto body
      ;default:
      ;  vs = args
      ;body:
      val default-lbl = fresh-id()
      val body-lbl = fresh-id()
      val num-free = make-var(TGLongT())
      emit(TGNullCmp(default-lbl, TGHasStackSpace()))
      emit(TGNewStack())
      emit(TGArgs(map(TGVar, args(f))))
      emit(TGLoad(num-free, TGMem(NUM-FREE-STACKS-LBL,0), 0))
      emit(TGBinCmp(body-lbl, TGGeOp(), num-free, TGLong(3L)))
      call(EXTEND-STACK-ID)
      emit(TGGoto(body-lbl))
      emit(TGLabel(default-lbl))
      emit(TGArgs(map(TGVar, args(f))))
      emit(TGLabel(body-lbl))
      
    ;Always run function in new stack
    defn new-stack-prelude () :
      ;  new-stack
      ;  vs = args
      ;  goto body if num-free-stacks >= 3 ;See [3 Reserve Stacks]
      ;  extend-stack()
      ;body:
      val body-lbl = fresh-id()
      val num-free = make-var(TGLongT())
      emit(TGNewStack())
      emit(TGArgs(map(TGVar, args(f))))
      emit(TGLoad(num-free, TGMem(NUM-FREE-STACKS-LBL,0), 0))
      emit(TGBinCmp(body-lbl, TGGeOp(), num-free, TGLong(3L)))
      call(EXTEND-STACK-ID)
      emit(TGLabel(body-lbl))

    ;Driver
    stack-extension-prelude()
    if tail?(f) : tail(cexp(body(f)))
    else : return(cexp(body(f)))

  ;======================================
  ;==== Compiling Multiple Functions ====
  ;======================================
  defn cfns (fs:List<KFn!>) :
    for f in fs do :
      val fail-lbl = fresh-id()
      emit(TGUnaCmp(fail-lbl, TGArityNeOp(), TGInt(arity(f))))
      cfn(f)
      emit(TGLabel(fail-lbl))      
    emit(TGArgs(List()))
    tcall(ARITY-ERROR-ID)    

  ;===================================
  ;==== Compiling a MultiFunction ====
  ;===================================
  defn cmultifn (func:KMultifn) :
    for f in funcs(func) as List<KFn!> do :
      val fail-lbl = fresh-id()
      emit(TGUnaCmp(fail-lbl, TGArityNeOp(), TGInt(arity(f))))
      cfn(f)
      emit(TGLabel(fail-lbl))      
    emit(TGArgs(List()))
    tcall(ARITY-ERROR-ID)

  ;================
  ;==== Driver ====
  ;================
  val buffer = Vector<TGIns>()
  let-var INSTRUCTION-BUFFER = buffer :
    cfns $ match(f) :
      (f:KMultifn) : funcs(f) as List<KFn!>
      (f:KFn!) : List(f)
    buffer