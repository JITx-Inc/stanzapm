defpackage stz/kform-to-tgt :
  import core
  import collections
  import stz/kl-ir
  import stz/tgt-ir
  import stz/ids
  import stz/kform
  import stz/primitives
  import stz/utils

;Expressions to Compile
;[X] KSeq
;[X] KClosureGet
;[X] KLetClosures
;[X] KClosure
;[X] KCall
;[X] KObject
;[X] KObjectGet
;[X] KBoxGet
;[X] KBoxSet
;[X] KBox
;[X] KReifiedCast
;[X] KTypeObject
;[X] KDo!
;[X] KEnsureSet
;[X] KPrim
;[X] KEnsureLength
;[X] KTupleGet
;[X] KTuple
;[X] KLiteral
;[X] KVar
;[X] KDispatch
;[X] KMatch
;[X] KLet
;[X] KSet

;Primitives to Compile
;Machine Primitives
;[X] ADD-OP : TGAddOp
;[X] SUB-OP : TGSubOp
;[X] MUL-OP : TGMulOp
;[X] DIV-OP : TGDivOp
;[X] MOD-OP : TGModOp
;[X] AND-OP : TGAndOp
;[X] OR-OP : TGOrOp
;[X] XOR-OP : TGXorOp
;[X] SHL-OP : TGShlOp
;[X] SHR-OP : TGShrOp
;[X] ASHR-OP : TGAshrOp
;[X] NEG-OP : TGNegOp
;[X] NOT-OP : TGNotOp

;Tagged Boolean Primitives
;[X] EQ-OP : TGEqOp
;[X] NE-OP : TGNeOp
;[X] LT-OP : TGLtOp
;[X] GT-OP : TGGtOp
;[X] LE-OP : TGLeOp
;[X] GE-OP : TGGeOp
;[X] IDENTICAL-OP : TGEqOp

;Inline Primitives
;[X] AGET-OP
;[X] ASET-OP
;[X] ALEN-OP
;[X] CHAR-AGET-OP
;[X] CHAR-ASET-OP
;[X] STRING-GET-OP
;[X] STRING-LEN-OP

;============================================================
;=================== DecTable Queries =======================
;============================================================

defn struct-size (t:DecTable, n:Int) :
  size(ls-struct(t,n) as KLSDefAnalyzedStruct)

defn struct-length (t:DecTable, n:Int) :
  length(ls-struct(t,n) as KLSDefAnalyzedStruct)

defn size (dt:DecTable, t:KLSType) :
  match(t:KStructT) : struct-size(dt, n(t))
  else : prim-size(t)

defn length (dt:DecTable, t:KLSType) :
  match(t:KStructT) : struct-length(dt, n(t))
  else : 1

defn tgt-types (dt:DecTable, t:KLSType) -> List<TGType> :
  match(t:KStructT) :
    val def = ls-struct(dt, n(t)) as KLSDefAnalyzedStruct
    for f in filter-by<KUserField>(fields(def)) seq-append :
      tgt-types(dt, type(f))
  else :
    List(prim-tgt-type(t))

defn prim-tgt-type (t:KLSType) :
  match(t) :
    (t:KByteT) : TGByteT()
    (t:KIntT) : TGIntT()
    (t:KLongT) : TGLongT()
    (t:KFloatT) : TGFloatT()
    (t:KDoubleT) : TGDoubleT()
    (t:KPtrT) : TGLongT()
    (t:KRefT) : TGRefT()
    (t) : fatal("Not a primitive type: %_" % [t])

defn field-offsets (dt:DecTable, t:KLSType) -> List<Int> :
  defn plus (xs:List<Int>, y:Int) : map({_ + y}, xs)
  match(t:KStructT) :
    val def = ls-struct(dt, n(t)) as KLSDefAnalyzedStruct
    for f in filter-by<KUserField>(fields(def)) seq-append :
      field-offsets(dt, type(f)) + offset(f)
  else :
    List(0)

defn global-mem (dt:DecTable, n:Int) :
  match(extern-label(dt, n)) :
    (lbl:Symbol) : TGExMem(lbl,0)
    (lbl:False) : TGMem(n,0)

;============================================================
;============= Expression Compilation System ================
;============================================================

;Instruction Buffer
var INSTRUCTION-BUFFER : False|Vector<TGIns> = false
defn emit (e:TGIns) : add(INSTRUCTION-BUFFER as Vector<TGIns>, e)

;Base Compiled Expression
deftype CExp
defmulti set (n:Int, c:CExp) -> False
defmulti ignore (c:CExp) -> False
defmulti imm (c:CExp) -> TGImm
defmulti tail (c:CExp) -> False
defmulti return (c:CExp) -> False

;Most default things are defined in terms of set
;Except for ignore
defmethod imm (c:CExp) :
  val n = fresh-id()
  emit(TGDef(n, TGRefT()))
  set(n, c)
  TGVar(n)
defmethod tail (c:CExp) : return(c)
defmethod return (c:CExp) : emit(TGReturn(List(imm(c))))

;If it is continuable, then define everything in terms of kont
deftype Continuable
defmulti kont (c:Continuable, kont:CExp -> False, end?:True|False) -> False
defmulti kont (c:Continuable, kont:CExp -> False) -> False
defmethod kont (c:Continuable, k:CExp -> False, end?:True|False) : kont(c, k)
defmethod tail (c:CExp&Continuable) : kont(c, tail, true)
defmethod return (c:CExp&Continuable) : kont(c, return, true)
defmethod ignore (c:CExp&Continuable) : kont(c, ignore, false)
defmethod set (n:Int, c:CExp&Continuable) : kont(c, set{n, _}, false)

;If it is immediate, then set is defined in terms of imm
deftype Immediate
defmethod set (n:Int, c:CExp&Immediate) : emit(TGSet(TGVar(n), imm(c)))

;If it is ignorable, then ignore does nothing
deftype Ignorable
defmethod ignore (c:CExp&Ignorable) : false

;============================================================
;================ Compilation Utilities =====================
;============================================================

defn make-var (t:TGType) :
  val n = fresh-id()
  emit(TGDef(n, t))
  TGVar(n)

defn tcall (f:Int, args:List<TGImm>) :
  emit(TGTCall(length(args), TGMem(f,0), args))
defn tcall (f:Int) :
  tcall(f, List())
defn call (f:Int, args:List<TGImm>) :
  emit(TGCall(length(args), List(), TGMem(f,0), args))
defn call (f:Int) :
  call(f, List())

defn allocate-ref (n:Int, size:Int) :
  allocate-ref(n, TGLong(to-long(size)))
defn allocate-ref (n:Int, size:TGImm) :
  val ref-tag = TGLong(to-long(REF-TAG-BITS))
  val end-lbl = fresh-id()
  val p = make-var(TGLongT())                                    ;  var p : long
  val new-p = make-var(TGLongT())                                ;  var new-p : long
  val limit = make-var(TGLongT())                                ;  var limit : long
  emit(TGLoad(p, TGMem(HEAP-PTR-LBL,0), 0))                      ;  p = [heap-ptr]
  emit(TGLoad(limit, TGMem(HEAP-LIM-LBL,0), 0))                  ;  limit = [heap-lim]
  emit(TGBinOp(new-p, TGAddOp(), p, size))                       ;  new-p = p + size
  emit(TGBinCmp(end-lbl, TGUleOp(), new-p, limit))               ;  goto end-lbl if new-p <= limit
  call(EXTEND-HEAP-ID, List(size))                               ;  extend-heap(size)
  emit(TGLoad(p, TGMem(HEAP-PTR-LBL,0), 0))                      ;  p = [heap-ptr]
  emit(TGBinOp(new-p, TGAddOp(), p, size))                       ;  new-p = p + size
  emit(TGLabel(end-lbl))                                         ;end-lbl:
  emit(TGStore(TGMem(HEAP-PTR-LBL,0), new-p, 0))                 ;  [heap-ptr] = new-p
  emit(TGBinOp(TGVar(n), TGAddOp(), p, ref-tag))                 ;  n = p + REF-TAG-BITS

defn allocate-refs (ns:List<Int>, sizes:List<Int>) :
  val total = TGLong(to-long(sum(sizes)))
  val end-lbl = fresh-id()
  val p = make-var(TGLongT())                                     ;  var p : long
  val new-p = make-var(TGLongT())                                 ;  var new-p : long
  val limit = make-var(TGLongT())                                 ;  var limit : long
  emit(TGLoad(p, TGMem(HEAP-PTR-LBL,0), 0))                       ;  p = [heap-ptr]
  emit(TGLoad(limit, TGMem(HEAP-LIM-LBL,0), 0))                   ;  limit = [heap-lim]
  emit(TGBinOp(new-p, TGAddOp(), p, total))                       ;  new-p = p + total
  emit(TGBinCmp(end-lbl, TGUleOp(), new-p, limit))                ;  goto end-lbl if new-p <= limit
  call(EXTEND-HEAP-ID, List(total))                               ;  extend-heap(total)
  emit(TGLoad(p, TGMem(HEAP-PTR-LBL,0), 0))                       ;  p = [heap-ptr]
  emit(TGBinOp(new-p, TGAddOp(), p, total))                       ;  new-p = p + total
  emit(TGLabel(end-lbl))                                          ;end-lbl:
  emit(TGStore(TGMem(HEAP-PTR-LBL,0), new-p, 0))                  ;  [heap-ptr] = new-p
  val offset-counter = Counter(REF-TAG-BITS)                      ;
  for (n in ns, size in sizes) do :                               ;  (ns ...) = p + (sizes ...) + REF-TAG-BITS
    val offset = resume(offset-counter, size)
    emit(TGBinOp(TGVar(n), TGAddOp(), p, TGLong(to-long(offset))))

defn Counter (init:Int) :
  Coroutine<Int,Int> $ fn (co, sz) :
    let loop (accum:Int = init, sz:Int = sz) :
      loop(accum + sz, suspend(co, accum))

defn bit-representation (value) :
  match(value) :
    (value:Byte) : to-long(value) << 3L + to-long(BYTE-TAG-BITS)
    (value:Char) : to-long(to-int(value) << 3 + CHAR-TAG-BITS)
    (value:Int) : to-long(value) << 32L
    (value:Float) : to-long(value) << 3L + to-long(FLOAT-TAG-BITS)
    (value:True) : 1L << 3L + to-long(MARKER-TAG-BITS)
    (value:False) : to-long(MARKER-TAG-BITS)

val BINARY-OPS = [ADD-OP, SUB-OP, MUL-OP, DIV-OP, MOD-OP, AND-OP,
                  OR-OP, XOR-OP, SHL-OP, SHR-OP, ASHR-OP, EQ-OP, NE-OP,
                  LT-OP, GT-OP, LE-OP, GE-OP, IDENTICAL-OP, AGET-OP,
                  CHAR-AGET-OP, STRING-GET-OP]
val UNARY-OPS = [NOT-OP, NEG-OP, ALEN-OP, STRING-LEN-OP]
val EFFECTFUL-TERNARY-OPS = [ASET-OP, CHAR-ASET-OP]

val LS-BINARY-OPS = [LS-ADD-OP, LS-SUB-OP, LS-MUL-OP, LS-DIV-OP, LS-MOD-OP,
                     LS-AND-OP, LS-OR-OP, LS-XOR-OP, LS-SHL-OP, LS-SHR-OP,
                     LS-ASHR-OP, LS-EQ-OP, LS-NE-OP, LS-LT-OP, LS-GT-OP,
                     LS-LE-OP, LS-GE-OP, LS-ULT-OP, LS-UGT-OP, LS-ULE-OP, LS-UGE-OP]
val LS-UNARY-OPS = [LS-NOT-OP, LS-NEG-OP, LS-BITS-OP, LS-FNUM-OP]

;============================================================
;================ HiStanza Compilation ======================
;============================================================
;TODO: Don't check (nor set) arity when guaranteed.

public defn compile (dec-table:DecTable, f:KFunc) -> Vector<TGIns> :
  ;===================
  ;==== Utilities ====
  ;===================
  defn foffset (n:Int) :
    field-offset(dec-table, n) + 8 - REF-TAG-BITS
  val length-offset = 8 - REF-TAG-BITS

  defn calloc (fields:Collection<TGImm|CExp>) :
    new CExp :
      defmethod set (n:Int, this) :
        val fs = for f in fields map :
          match(f) :
            (f:TGImm) : f
            (f:CExp) : imm(f)
        val size = 8 * length(fs)
        allocate-ref(n, size)
        for (f in fs, i in 0 to false) do :
          emit(TGStore(TGVar(n), f, 8 * i - REF-TAG-BITS))
      defmethod ignore (this) :
        do(ignore, filter-by<CExp>(fields))

  ;=================================
  ;==== Compiling an Expression ====
  ;=================================
  defn cexp (e:KExp) -> CExp :
    match(e) :
      (e:KSeq) :
        new CExp & Continuable :
          defmethod kont (this, kont:CExp -> False) :
            ignore(cexp(a(e)))
            kont(cexp(b(e)))
      (e:KVar) :
        if global?(dec-table, n(e)) :
          new CExp & Ignorable :
            defmethod set (v:Int, this) :
              emit(TGLoad(TGVar(v), TGMem(n(e),0), 0))
        else :
          new CExp & Ignorable & Immediate :
            defmethod imm (this) :
              TGVar(n(e))
      (e:KLiteral) :
        new CExp & Ignorable & Immediate :
          defmethod imm (this) :
            TGLong(bit-representation(value(e)))
      (e:KSet) :
        new CExp & Immediate :
          defmethod imm (this) :
            ignore(this)
            TGLong(bit-representation(false))
          defmethod ignore (this) :
            emit(TGStore(TGMem(n(e),0), imm(cexp(value(e))), 0))
      (e:KLet) :
        val def = def(e) as KDef
        new CExp & Continuable :
          defmethod kont (this, kont:CExp -> False) :
            emit(TGDef(n(def), TGRefT()))
            set(n(def), cexp(value(def)))
            kont(cexp(body(e)))
      (e:KBoxGet) :
        val box = cexp(exp(e))
        new CExp :
          defmethod set (n:Int, this) :
            emit(TGLoad(TGVar(n), imm(box), foffset(BOX-ITEM-FIELD-ID)))
          defmethod ignore (this) :
            ignore(box)
      (e:KBoxSet) :
        val box = cexp(exp(e))
        val value = cexp(value(e))
        new CExp & Immediate :
          defmethod imm (this) :
            ignore(this)
            TGLong(bit-representation(false))
          defmethod ignore (this) :
            emit(TGStore(imm(box), imm(value), foffset(BOX-ITEM-FIELD-ID)))
      (e:KBox) :
        val v = match(value(e)) :
          (v:KExp) : cexp(v)
          (v:False) : TGLong(to-long(VOID-TAG))
        calloc(List(TGTag(BOX-TYPE-ID), v))
      (e:KReifiedCast) :
        val o = cexp(exp(e))
        new CExp & Immediate :
          defmethod imm (this) :
            val o = imm(cexp(exp(e)))
            emit(TGCast(o, tag(e)))
            o
          defmethod ignore (this) :
            imm(this)
            false
      (e:KTypeObject) :
        calloc $ append(
         [TGTag(TYPE-TYPE-ID)
          TGLong(to-long(length(args(e))))
          TGMem(n(e),0)]
          map(cexp, args(e)))
      (e:KClosureGet) :
        val c = cexp(exp(e))
        new CExp :
          defmethod set (n:Int, this) :
            val offset = 8 * index(e) + foffset(FN-FREE-FIELD-ID)
            emit(TGLoad(TGVar(n), imm(c), offset))
          defmethod ignore (this) :
            ignore(c)
      (e:KClosure) :
        calloc $ append(
         [TGTag(FN-TYPE-ID)
          TGLong(to-long(length(args(e))))
          TGMem(n(e),0)]
          map(cexp, args(e)))
      (e:KLetClosures) :
        new CExp & Continuable :
          defmethod kont (this, kont:CExp -> False) :
            ;Compile all arguments to closures
            val argss = for c in closures(e) map :
              append(
               [TGTag(FN-TYPE-ID)
                TGLong(to-long(length(args(c))))
                TGMem(n(c), 0)]
                map(imm{cexp(_)}, args(c)))
            ;Allocate closures
            val sizes = map({8 * length(_)}, argss)
            allocate-refs(ns(e), sizes)
            ;Store arguments
            for (n in ns(e), args in argss) do :
              for (arg in args, i in 0 to false) do :
                emit(TGStore(TGVar(n), arg, 8 * i - REF-TAG-BITS))
            ;Continue with body
            kont(cexp(body(e)))
      (e:KObject) :
        calloc $ cons(
          TGTag(n(e)),
          map(cexp, args(e)))
      (e:KObjectGet) :
        val o = cexp(exp(e))
        new CExp :
          defmethod set (n:Int, this) :
            val offset = 8 * index(e) + 8 - REF-TAG-BITS
            emit(TGLoad(TGVar(n), imm(o), offset))
          defmethod ignore (this) :
            ignore(o)
      (e:KTuple) :
        calloc $ append(
         [TGTag(TUPLE-TYPE-ID)
          TGLong(to-long(length(exps(e))))]
          map(cexp, exps(e)))
      (e:KTupleGet) :
        val o = cexp(exp(e))
        new CExp :
          defmethod set (n:Int, this) :
            val offset = 8 * index(e) + foffset(TUPLE-ITEMS-FIELD-ID)
            emit(TGLoad(TGVar(n), imm(o), offset))
          defmethod ignore (this) :
            ignore(o)
      (e:KCall) :
        val func = global-mem(dec-table, func(e))
        val args = map(cexp, args(e))
        new CExp :
          defmethod set (n:Int, this) :
            emit(TGCall(arity(e), List(TGVar(n)), func, map(imm, args)))
          defmethod tail (this) :
            emit(TGTCall(arity(e), func, map(imm, args)))
          defmethod ignore (this) :
            emit(TGCall(arity(e), List(), func, map(imm, args)))
      (e:KDo!) :
        val func = cexp(func(e))
        val args = map(cexp, args(e))
        defn code (f:TGImm) :
          val x = make-var(TGLongT())
          emit(TGLoad(x, f, foffset(FN-CODE-FIELD-ID)))
          x
        new CExp :
          defmethod set (n:Int, this) :
            val f = imm(func)
            val code = code(f)
            emit(TGCall(arity(e), List(TGVar(n)), code, cons(f, map(imm, args))))
          defmethod tail (this) :
            val f = imm(func)
            val code = code(f)
            emit(TGTCall(arity(e), code, cons(f, map(imm, args))))
          defmethod ignore (this) :
            val f = imm(func)
            val code = code(f)
            emit(TGCall(arity(e), List(), code, cons(f, map(imm, args))))
      (e:KEnsureSet) :
        new CExp & Immediate :
          defmethod imm (this) :
            val lbl = fresh-id()
            val o = imm(cexp(exp(e)))
            emit(TGBinCmp(lbl, TGNeOp(), o, TGLong(to-long(VOID-TAG))))
            tcall(VARIABLE-UNINITIALIZED-ERROR-ID)
            emit(TGLabel(lbl))
            o
          defmethod ignore (this) :
            imm(this)
            false
      (e:KEnsureLength) :
        new CExp & Immediate :
          defmethod imm (this) :
            val lbl = fresh-id()
            val o = imm(cexp(exp(e)))
            val len = make-var(TGLongT())
            emit(TGLoad(len, o, 8 - REF-TAG-BITS))
            emit(TGBinCmp(lbl, TGEqOp(), len, TGLong(to-long(length(e)))))
            tcall(TUPLE-LENGTH-ERROR-ID)
            emit(TGLabel(lbl))
            o
          defmethod ignore (this) :
            imm(this)
            false
      (e:KMatch|KDispatch) :
        new CExp & Continuable :
          defmethod kont (this, kont:CExp -> False, end?:True|False) :
            val match-args = map(imm{cexp(_)}, args(e))
            val bs = map(TGBranch{tags(_), fresh-id()}, branches(e))
            val done = fresh-id()
            match(e) :
              (e:KMatch) : emit(TGMatch(match-args, bs))
              (e:KDispatch) : emit(TGDispatch(match-args, bs))
            for (b in branches(e), id in seq(n,bs)) do :
              emit(TGLabel(id))
              for (a in args(b), ma in match-args) do :
                emit(TGDef(a, TGRefT()))
                emit(TGSet(TGVar(a), ma))
              kont(cexp(body(b)))
              emit(TGGoto(done)) when not end?
            emit(TGLabel(done)) when not end?
      (e:KPrim) :
        ;Utilities
        defn binop (x:TGVar, op:TGOp, a:TGImm, b:TGImm) :
          emit(TGBinOp(x, op, a, b))
        defn binop (n:Int, op:TGOp, a:TGImm, b:TGImm) :
          binop(TGVar(n), op, a, b)
        defn unaop (x:TGVar, op:TGOp, a:TGImm) :
          emit(TGUnaOp(x, op, a))
        defn unaop (n:Int, op:TGOp, a:TGImm) :
          unaop(TGVar(n), op, a)
        defn detag-int (y:TGImm) :
          val x = make-var(TGLongT())
          binop(x, TGAshrOp(), y, TGLong(32L))
          x
        defn detag-char (y:TGImm) :
          val x = make-var(TGLongT())
          val b = make-var(TGByteT())
          binop(x, TGShrOp(), y, TGLong(3L))
          emit(TGConv(b,x))
          b
        defn tag-as-bool (x:TGVar, y:TGImm) :
          binop(x, TGShlOp(), y, TGLong(3L))
          binop(x, TGAddOp(), x, TGLong(to-long(MARKER-TAG-BITS)))
        defn tag-as-char (x:TGVar, y:TGImm) :
          emit(TGConv(x,y))
          binop(x, TGShlOp(), x, TGLong(3L))
          binop(x, TGAddOp(), x, TGLong(to-long(CHAR-TAG-BITS)))

        ;Dispatch
        switch contains?{_, op(e)} :
          BINARY-OPS :
            val a = cexp(args(e)[0])
            val b = cexp(args(e)[1])
            new CExp :
              defmethod set (n:Int, this) :
                val a = imm(a)
                val b = imm(b)
                switch(op(e)) :
                  ADD-OP :
                    binop(n, TGAddOp(), a, b)
                  SUB-OP :
                    binop(n, TGSubOp(), a, b)
                  MUL-OP :
                    binop(n, TGMulOp(), detag-int(a), b)
                  DIV-OP :
                    val x = make-var(TGLongT())
                    binop(x, TGDivOp(), a, b)
                    binop(n, TGShlOp(), x, TGLong(32L))
                  MOD-OP :
                    binop(n, TGModOp(), a, b)
                  AND-OP :
                    binop(n, TGAndOp(), a, b)
                  OR-OP :
                    binop(n, TGOrOp(), a, b)
                  XOR-OP :
                    binop(n, TGXorOp(), a, b)
                  SHL-OP :
                    binop(n, TGShlOp(), a, detag-int(b))
                  SHR-OP :
                    val x = make-var(TGLongT())
                    binop(x, TGShrOp(), a, detag-int(b))
                    binop(x, TGShrOp(), x, TGLong(32L))
                    binop(n, TGShlOp(), x, TGLong(32L))
                  ASHR-OP :
                    val x = make-var(TGLongT())
                    binop(x, TGAshrOp(), a, detag-int(b))
                    binop(x, TGShrOp(), x, TGLong(32L))
                    binop(n, TGShlOp(), x, TGLong(32L))
                  EQ-OP :
                    binop(n, TGEqOp(), a, b)
                    tag-as-bool(TGVar(n), TGVar(n))
                  NE-OP :
                    binop(n, TGNeOp(), a, b)
                    tag-as-bool(TGVar(n), TGVar(n))
                  LT-OP :
                    binop(n, TGLtOp(), a, b)
                    tag-as-bool(TGVar(n), TGVar(n))
                  GT-OP :
                    binop(n, TGGtOp(), a, b)
                    tag-as-bool(TGVar(n), TGVar(n))
                  LE-OP :
                    binop(n, TGLeOp(), a, b)
                    tag-as-bool(TGVar(n), TGVar(n))
                  GE-OP :
                    binop(n, TGGeOp(), a, b)
                    tag-as-bool(TGVar(n), TGVar(n))
                  IDENTICAL-OP :
                    binop(n, TGEqOp(), a, b)
                    tag-as-bool(TGVar(n), TGVar(n))
                  AGET-OP :
                    val o = make-var(TGLongT())
                    binop(o, TGAshrOp(), b, TGLong(32L - 3L))
                    binop(o, TGAddOp(), o, a)
                    emit(TGLoad(TGVar(n), o, foffset(RAWARRAY-ITEMS-FIELD-ID)))
                  CHAR-AGET-OP :
                    val o = make-var(TGLongT())
                    val c = make-var(TGByteT())
                    binop(o, TGAshrOp(), b, TGLong(32L))
                    binop(o, TGAddOp(), o, a)
                    emit(TGLoad(c, o, foffset(CHARARRAY-CHARS-FIELD-ID)))
                    tag-as-char(TGVar(n), c)
                  STRING-GET-OP :
                    val o = make-var(TGLongT())
                    val c = make-var(TGByteT())
                    binop(o, TGAshrOp(), b, TGLong(32L))
                    binop(o, TGAddOp(), o, a)
                    emit(TGLoad(c, o, foffset(STRING-CHARS-FIELD-ID)))
                    tag-as-char(TGVar(n), c)
              defmethod ignore (this) :
                ignore(a)
                ignore(b)
          UNARY-OPS :
            val a = cexp(head(args(e)))
            new CExp :
              defmethod set (n:Int, this) :
                val a = imm(a)
                switch(op(e)) :
                  NOT-OP :
                    val x = make-var(TGLongT())
                    unaop(x, TGNotOp(), a)
                    binop(x, TGShrOp(), x, TGLong(32L))
                    binop(n, TGShlOp(), x, TGLong(32L))
                  NEG-OP :
                    unaop(n, TGNegOp(), a)
                  ALEN-OP :
                    emit(TGLoad(TGVar(n), a, 8 - REF-TAG-BITS))
                    binop(n, TGShlOp(), TGVar(n), TGLong(32L))
                  STRING-LEN-OP :
                    emit(TGLoad(TGVar(n), a, 8 - REF-TAG-BITS))
                    binop(n, TGShlOp(), TGVar(n), TGLong(32L))
              defmethod ignore (this) :
                ignore(a)
          EFFECTFUL-TERNARY-OPS :
            val a = cexp(args(e)[0])
            val b = cexp(args(e)[1])
            val c = cexp(args(e)[2])
            new CExp & Immediate :
              defmethod imm (this) :
                ignore(this)
                TGLong(bit-representation(false))
              defmethod ignore (this) :
                val a = imm(a)
                val b = imm(b)
                val c = imm(c)
                switch(op(e)) :
                  ASET-OP :
                    val o = make-var(TGLongT())
                    binop(o, TGAshrOp(), b, TGLong(32L - 3L))
                    binop(o, TGAddOp(), o, a)
                    emit(TGStore(o, c, foffset(RAWARRAY-ITEMS-FIELD-ID)))
                  CHAR-ASET-OP :
                    val o = make-var(TGLongT())
                    binop(o, TGAshrOp(), b, TGLong(32L))
                    binop(o, TGAddOp(), o, a)
                    emit(TGStore(o, detag-char(c), foffset(CHARARRAY-CHARS-FIELD-ID)))
          else :
            fatal("Cannot compile primitive: %_" % [op(e)])

  ;=====================================
  ;==== Compiling a Single Function ====
  ;=====================================
  ;[3 Reserve stacks]
  ;  - For handling stack overflow
  ;  - For running the GC
  ;  - For handling overflow during GC
  defn cfn (f:KFn!) :
    ;Extend stack if necessary
    defn stack-extension-prelude () :
      ;  goto default if has-space
      ;  new-stack
      ;  vs = args
      ;  goto body if num-free-stacks >= 3 ;See [3 Reserve Stacks]
      ;  extend-stack()
      ;  goto body
      ;default:
      ;  vs = args
      ;body:
      val default-lbl = fresh-id()
      val body-lbl = fresh-id()
      val num-free = make-var(TGLongT())
      emit(TGNullCmp(default-lbl, TGHasStackSpace()))
      emit(TGNewStack())
      emit(TGArgs(map(TGVar, args(f))))
      emit(TGLoad(num-free, TGMem(NUM-FREE-STACKS-LBL,0), 0))
      emit(TGBinCmp(body-lbl, TGGeOp(), num-free, TGLong(3L)))
      call(EXTEND-STACK-ID)
      emit(TGGoto(body-lbl))
      emit(TGLabel(default-lbl))
      emit(TGArgs(map(TGVar, args(f))))
      emit(TGLabel(body-lbl))

    ;Always run function in new stack
    defn new-stack-prelude () :
      ;  new-stack
      ;  vs = args
      ;  goto body if num-free-stacks >= 3 ;See [3 Reserve Stacks]
      ;  extend-stack()
      ;body:
      val body-lbl = fresh-id()
      val num-free = make-var(TGLongT())
      emit(TGNewStack())
      emit(TGArgs(map(TGVar, args(f))))
      emit(TGLoad(num-free, TGMem(NUM-FREE-STACKS-LBL,0), 0))
      emit(TGBinCmp(body-lbl, TGGeOp(), num-free, TGLong(3L)))
      call(EXTEND-STACK-ID)
      emit(TGLabel(body-lbl))

    ;Driver
    stack-extension-prelude()
    if tail?(f) : tail(cexp(body(f)))
    else : return(cexp(body(f)))

  ;======================================
  ;==== Compiling Multiple Functions ====
  ;======================================
  defn cfns (fs:List<KFn!>) :
    for f in fs do :
      val fail-lbl = fresh-id()
      emit(TGUnaCmp(fail-lbl, TGArityNeOp(), TGInt(arity(f))))
      cfn(f)
      emit(TGLabel(fail-lbl))
    emit(TGArgs(List()))
    tcall(ARITY-ERROR-ID)

  ;===================================
  ;==== Compiling a MultiFunction ====
  ;===================================
  defn cmultifn (func:KMultifn) :
    for f in funcs(func) as List<KFn!> do :
      val fail-lbl = fresh-id()
      emit(TGUnaCmp(fail-lbl, TGArityNeOp(), TGInt(arity(f))))
      cfn(f)
      emit(TGLabel(fail-lbl))
    emit(TGArgs(List()))
    tcall(ARITY-ERROR-ID)

  ;================
  ;==== Driver ====
  ;================
  val buffer = Vector<TGIns>()
  let-var INSTRUCTION-BUFFER = buffer :
    cfns $ match(f) :
      (f:KMultifn) : funcs(f) as List<KFn!>
      (f:KFn!) : List(f)
    buffer



;============================================================
;============= LSExpression Compilation System ==============
;============================================================

;Base Compiled Expression
deftype CLSExp
defmulti types (c:CLSExp) -> List<TGType>
defmulti set (ns:Int, c:CLSExp) -> False
defmulti ignore (c:CLSExp) -> False
defmulti imms (c:CLSExp) -> List<TGImm>
defmulti tail (c:CLSExp) -> False
defmulti return (c:CLSExp) -> False

;Convenience for single immediate
defn imm (c:CLSExp) :
  val xs = imms(c)
  fatal("Not a single immediate.") when length(xs) != 1
  head(xs)
  
defn set (n:Int, c:CLSExp) :
  set(List(n), c)

;Most default things are defined in terms of set
;Except for ignore
defmethod imms (c:CLSExp) :
  val ns = map(fresh-id{}, types(c))
  do(emit{TGDef(_, _)}, ns, types(c))
  set(ns, c)
  map(TGVar, ns)
defmethod tail (c:CLSExp) : return(c)
defmethod return (c:CLSExp) : emit(TGReturn(imms(c)))

;;If it is continuable, then define everything in terms of kont
deftype LSContinuable
defmulti kont (c:LSContinuable, kont:CLSExp -> False, end?:True|False) -> False
defmulti kont (c:LSContinuable, kont:CLSExp -> False) -> False
defmethod kont (c:LSContinuable, k:CLSExp -> False, end?:True|False) : kont(c, k)
defmethod tail (c:CLSExp & LSContinuable) : kont(c, tail, false)
defmethod return (c:CLSExp & LSContinuable) : kont(c, return, false)
defmethod ignore (c:CLSExp & LSContinuable) : kont(c, ignore, false)
defmethod set (ns:List<Int>, c:CLSExp & LSContinuable) : kont(c, set{ns, _}, false)

;If it is immediate, then set is defined in terms of imm
defmethod set (ns:List<Int>, c:CLSExp&Immediate) :
  do(emit{TGSet(TGVar(_), _)}, ns, imms(c))

;;If it is ignorable, then ignore does nothing
;defmethod ignore (c:CLSExp&Ignorable) : false

;============================================================
;================= Pointer Compilation ======================
;============================================================

deftype CLoc
defstruct PtrLoc <: CLoc :
  base: CLSExp
  offset: Int
defstruct ExpLoc <: CLoc :
  base: CLSExp
  index: Int

;============================================================
;================ LoStanza Compilation ======================
;============================================================
;TODO: Slotted retrieval on rest arguments are clumsy still.

public defn compile (dec-table:DecTable, function:KLSFn!) -> Vector<TGIns> :
  val imm-table = HashTable<Int,List<TGImm>>()
  val type-table = HashTable<Int,List<TGType>>()
  val block-arg-table = HashTable<Int,List<List<Int>>>()

  defn calloc (input-size:Int, offsets:List<Int>, fields:Collection<TGImm|CLSExp>) :
    new CLSExp :
      defmethod types (this) :
        List(KRefT())
      defmethod set (ns:List<Int>, this) :
        fatal("Not a single immediate.") when length(ns) != 1
        val n = head(ns)
        val fs = for f in fields seq-append :
          match(f) :
            (f:TGImm) : List(f)
            (f:CLSExp) : imms(f)
        val size = ceil8(input-size)
        allocate-ref(n, size)
        for (f in fs, o in offsets) do :
          emit(TGStore(TGVar(n), f, o - REF-TAG-BITS))

  defn calloc (fields:Collection<TGImm|CLSExp>) :
    val n = length(fields)
    calloc(8 * n, map({8 * _}, 0 to n), fields)

  defn carray (size:Int, rest-size:Int, offsets:List<Int>, fields:Collection<TGImm|CLSExp>) :
    new CLSExp :
      defmethod types (this) :
        List(KRefT())
      defmethod set (ns:List<Int>, this) :
        ;Retrieve destination
        fatal("Not a single immediate.") when length(ns) != 1
        val n = head(ns)
        ;Evaluate fields
        val fs = for f in fields seq-append :
          match(f) :
            (f:TGImm) : List(f)
            (f:CLSExp) : imms(f)
        ;Compute length
        val len = make-var(TGLongT())
        emit(TGBinOp(len, TGMulOp(), fs[1], TGLong(to-long(rest-size))))
        emit(TGBinOp(len, TGAddOp(), len, TGLong(to-long(size + 7))))
        emit(TGBinOp(len, TGAndOp(), len, TGLong(-8L)))
        ;Allocate array
        allocate-ref(n, len)
        ;Store fields
        for (f in fs, o in offsets) do :
          emit(TGStore(TGVar(n), f, o - REF-TAG-BITS))

  defn cloc (e:KLoc) -> CLoc :
    match(e) :
      (e:KValue) :
        match(exp(e)) :
          (e:KLSVar) :
            if global?(dec-table, n(e)) :
              val base = new CLSExp & Immediate :
                defmethod types (this) : List(TGLongT())
                defmethod imms (this) : List(global-mem(dec-table, n(e)))
              PtrLoc(base, 0)
            else : ExpLoc(cexp(e), 0)
          (e) : ExpLoc(cexp(e), 0)
      (e:KDeref) :
        PtrLoc(cexp(exp(e)), 8 - REF-TAG-BITS)
      (e:KDeptr) :
        PtrLoc(cexp(exp(e)), 0)
      (e:KSlot) :        
        ;Compute ptr and offset
        val [ptr, ptr-offset] = match(cloc(exp(e))) :
          (l:PtrLoc) : [base(l), offset(l)]
          (l:ExpLoc) : [base(l), 0]
        ;Compute base cexp
        val base = new CExp :
          defmethod types (this) :
            List(TGLongT())
          defmethod set (ns:List<Int>, this) :
            ;ns = base
            ;offset = index
            ;offset = offset * size
            ;n = n + offset
            set(ns, base)
            val offset = make-var(TGLongT())
            set(n(offset), cexp(index(e)))
            val size = size(dec-table, type(e))
            emit(TGBinOp(offset, TGMulOp(), offset, TGLong(to-long(size)))) when size != 1
            val x = TGVar(head(ns))
            emit(TGBinOp(x, TGAddOp(), x, offset))
        ;Return location
        PtrLoc(base, ptr-offset)
      (e:KField) :
        match(cloc(exp(e))) :
          (l:PtrLoc) :
            PtrLoc(
              base(l),
              offset(l) + field-offset(dec-table, n(e)))
          (l:ExpLoc) :
            ExpLoc(
              base(l),
              index(l) + field-index(dec-table, n(e)))

  defn cexp (e:KLSExp) -> CLSExp :
    match(e) :
      (e:KLSVar) :
        if global?(dec-table, n(e)) :
          new CLSExp :
            defmethod types (this) :
              global-tgt-types(n(e))
            defmethod set (xs:Int, this) :
              for (x in xs, off in global-tgt-offsets(n(e))) do :
                emit(TGLoad(TGVar(x), TGMem(n(e),0), off))   ;TODO: What about C lbls?
        else :
          new CLSExp & Immediate :
            defmethod types (this) :
              type-table[n(e)]
            defmethod imms (this) :
              imm-table[n(e)]
      (e:KLSRef) :
        val size = 8 + struct-size(dec-table, n(e))
        val offsets = cons(0, map({8 + _}, struct-offsets(dec-table, n(e))))
        val fields = cons(TGTag(n(e)), map(cexp, args(e)))
        calloc(size, offsets, fields)
      (e:KLSArray) :
        val size = struct-size(dec-table, n(e))
        val rest-size = struct-rest-size(dec-table, n(e))
        val offsets = cons(0, map({8 + _}, struct-offsets(dec-table, n(e))))
        val fields = cons(TGTag(n(e)), map(cexp, args(e)))
        carray(size, rest-size, offsets, fields)
      (e:KLSStruct) :
        new CLSExp & Immediate :
          defmethod types (this) :
            struct-tgt-types(dec-table, n(e))
          defmethod imms (this) :
            seq-cat(imms{cexp(_)}, args(e))
      (e:KLSPtr) :
        val l = cloc(loc(e)) as PtrLoc
        if offset(l) == 0 :
          base(l)
        else :
          new CExp :
            defmethod types (this) :
              List(TGLongT())
            defmethod set (ns:List<Int>, this) :
              set(ns, base(l))
              val x = TGVar(head(ns))
              val off = TGLong(to-long(offset(l)))
              emit(TGBinOp(x, TGAddOp(), x, off))
      (e:KLSRead) :
        match(cloc(loc(e))) :
          (l:PtrLoc) :
            new CExp :
              defmethod types (this) :
                tgt-types(dec-table, type(e))
              defmethod set (ns:List<Int>, this) :
                val p = imm(base(l))
                for (n in ns, o in field-offsets(dec-table, type(e))) do :
                  emit(TGLoad(TGVar(n), p, offset(l) + o))
          (l:ExpLoc) :
            new CExp & Immediate :
              defmethod types (this) :
                tgt-types(dec-table, type(e))
              defmethod imms (this) :
                val xs = imms(base(l))
                val len = struct-length(dec-table, type(e))
                headn(len, tailn(xs, index(l)))
      (e:KLSDoC) :
        fatal("Not yet supported.")
      (e:KLSLiteral) :
        match(value(e)) :
          (v:Char|Byte|Int|Long|String) :
            new CLSExp & Immediate :
              defmethod types (this) :
                List $ match(v) :
                  (v:Byte) : TGByteT()
                  (v:Char) : TGByteT()
                  (v:Int) : TGIntT()
                  (v:Long) : TGLongT()
                  (v:String) : TGLongT()
              defmethod imms (this) :
                List $ match(v) :
                  (v:Char) : TGByte(to-byte(v))
                  (v:Byte) : TGByte(v)
                  (v:Int) : TGInt(v)
                  (v:Long) : TGLong(v)
                  (v:String) :
                    val c = fresh-id()
                    emit(TGDefConst(c, v))
                    TGMem(c,0)
          (v:Float|Double) :
            new CLSExp :
              defmethod types (this) :
                List $ match(v) :
                  (v:Float) : TGFloatT()
                  (v:Double) : TGDoubleT()
              defmethod set (ns:List<Int>, this) :
                match(v) :
                  (v:Float) :
                    val n = TGVar(head(ns))
                    emit(TGInterpret(n, TGInt(bits(v))))
                  (v:Double) :
                    val c = fresh-id()
                    emit(TGDefConst(c, v))
                    emit(TGLoad(TGVar(head(ns)), TGMem(c,0), 0))
      (e:KLSCast) :
        val t = match(type(e)) :
          (t:KByteT) : TGByteT()
          (t:KIntT) : TGIntT()
          (t:KLongT) : TGLongT()
          (t:KFloatT) : TGFloatT()
          (t:KDoubleT) : TGDoubleT()
          (t:KPtrT) : TGLongT()
          (t:KRefT) : TGRefT()
        new CLSExp :
          defmethod types (this) :
            List(t)
          defmethod set (ns:List<Int>, this) :
            val ys = imms(cexp(exp(e)))
            emit(TGConv(TGVar(head(ns)), head(ys)))
      (e:KLSAnd) :
        new CLSExp :
          defmethod types (this) :
            List(TGLongT())
          defmethod set (ns:List<Int>, this) :
            val done-lbl = fresh-id()
            set(ns, cexp(a(e)))
            emit(TGBinCmp(done-lbl, TGEqOp(), TGVar(head(ns)), TGLong(0L)))
            set(ns, cexp(b(e)))
            emit(TGLabel(done-lbl))
      (e:KLSOr) :
        new CLSExp :
          defmethod types (this) :
            List(TGLongT())
          defmethod set (ns:List<Int>, this) :
            val done-lbl = fresh-id()
            set(ns, cexp(a(e)))
            emit(TGBinCmp(done-lbl, TGNeOp(), TGVar(head(ns)), TGLong(0L)))
            set(ns, cexp(b(e)))
            emit(TGLabel(done-lbl))
      (e:KLSSizeof) :
        new CLSExp & Immediate :
          defmethod types (this) :
            List(TGLongT())
          defmethod imms (this) :
            val size = type-size(dec-table, e)
            List(TGLong(to-long(size)))
      (e:KLSTagof) :
        new CLSExp & Immediate :
          defmethod types (this) : List(TGLongT())
          defmethod imms (this) : List(TGTag(n(e)))
      (e:KLSLet) :
        val b = cexp(body(e))
        new CLSExp & LSContinuable :
          defmethod types (this) :
            types(b)
          defmethod kont (this, kont:CLSExp -> False) :
            val ts = tgt-types(dec-table, type(e))
            val xs = map(make-var, ts)
            imm-table[n(e)] = xs
            type-table[n(e)] = ts
            set(map(n,xs), cexp(value(e)))
            kont(b)
      (e:KLSDispatch) :
        val bs-exps = map(cexp{exp(_)}, branches(e))
        new CLSExp & LSContinuable :
          defmethod types (this) :
            types(head(bs-exps))
          defmethod kont (this, kont:CLSExp -> False, end?:True|False) :
            val match-args = seq-append(imms{cexp(_)}, args(e))
            val bs = map(TGBranch{tags(_), fresh-id()}, branches(e))
            val done = fresh-id()
            emit(TGDispatch(match-args, bs))
            for (b in branches(e), id in seq(n,bs), body in bs-exps) do :
              emit(TGLabel(id))
              for (a in args(b), ma in match-args) do :
                imm-table[a] = List(TGVar(a))
                type-table[a] = List(TGRefT())
                emit(TGDef(a, TGRefT()))
                emit(TGSet(TGVar(a), ma))
              kont(body)
              emit(TGGoto(done)) when not end?
            emit(TGLabel(done)) when not end?
      (e:KLSTypeObject) :
        calloc $ append(
         [TGTag(TYPE-TYPE-ID)
          TGLong(to-long(length(args(e))))
          TGMem(n(e),0)]
          map(cexp, args(e)))
      (e:KLSClosure) :
        calloc $ append(
         [TGTag(FN-TYPE-ID)
          TGLong(to-long(length(args(e))))
          TGMem(n(e),0)]
          map(cexp, args(e)))
      (e:KLSDo!) :
        defn categorize () :
          val f = func(e) as KLSRead
          match(loc(f)) :
            (l:KDeptr) : do-deptr(exp(l))
            (l:KDeref) : do-deref(exp(l))
        defn code (f:TGImm) :
          val x = make-var(TGLongT())
          emit(TGLoad(x, f, foffset(FN-CODE-FIELD-ID)))
          x
        defn do-deptr (f:KLSExp) :
          make-call(cexp(f), map(cexp, args(e)))
        defn do-deref (f:KLSExp) :
          val f* = head(imms(cexp(f)))
          make-call(code(f*), cons(f*, map(cexp, args(e))))
        defn imms? (x:TGImm|CLSExp) :
          match(x) :
            (x:TGImm) : List(x)
            (x:CLSExp) : imms(x)
        defn make-call (f:TGImm|CLSExp, args:List<TGImm|CLSExp>) :
          new CExp :
            defmethod types (this) :
              tgt-types(dec-table, type(e))
            defmethod set (ns:List<Int>, this) :
              val xs = map(TGVar, ns)
              emit(TGCall(arity(e), xs, head(imms?(f)), seq-append(imms?,args)))
            defmethod tail (this) :
              emit(TGTCall(arity(e), head(imms?(f)), seq-append(imms?,args)))
            defmethod ignore (this) :
              emit(TGCall(arity(e), List(), head(imms?(f)), seq-append(imms?,args)))
        categorize()
      (e:KLSCall) :
        val func = global-mem(dec-table, func(e))
        val args = map(cexp, args(e))
        new CExp :
          defmethod types (this) :
            tgt-types(dec-table, type(e))
          defmethod set (ns:List<Int>, this) :
            val xs = map(TGVar, ns)
            emit(TGCall(arity(e), xs, func, seq-append(imms, args)))
          defmethod tail (this) :
            emit(TGTCall(arity(e), func, seq-append(imms, args)))
          defmethod ignore (this) :
            emit(TGCall(arity(e), List(), func, seq-append(imms, args)))
      (e:KDetagPrim) :
        new CExp :
          defmethod types (this) :
            List $ switch(n(e)) :
              BYTE-TYPE-ID : TGByteT()
              CHAR-TYPE-ID : TGByteT()
              INT-TYPE-ID : TGIntT()
              FLOAT-TYPE-ID : TGFloatT()
          defmethod set (ns:List<Int>, this) :
            val x = TGVar(head(ns))
            val y = make-var(TGLongT())
            set(List(n(y)), cexp(exp(e)))
            switch(n(e)) :
              BYTE-TYPE-ID :
                emit(TGBinOp(y, TGAshrOp(), y, TGLong(3L)))
                emit(TGConv(x, y))
              CHAR-TYPE-ID :
                emit(TGBinOp(y, TGAshrOp(), y, TGLong(3L)))
                emit(TGConv(x, y))
              INT-TYPE-ID :
                emit(TGBinOp(y, TGAshrOp(), y, TGLong(32L)))
                emit(TGConv(x, y))
              FLOAT-TYPE-ID :
                emit(TGBinOp(y, TGAshrOp(), y, TGLong(3L)))
                val y2 = make-var(TGIntT())
                emit(TGConv(y2, y))
                emit(TGInterpret(x, y))
      (e:KTagPrim) :
        new CExp :
          defmethod types (this) :
            List(TGRefT())
          defmethod set (ns:List<Int>, this) :
            val x = TGVar(head(ns))
            switch(n(e)) :
              BYTE-TYPE-ID :
                val y = make-var(TGLongT())
                emit(TGConv(y, head(imms(cexp(exp(e))))))
                emit(TGBinOp(y, TGAshlOp(), y, TGLong(3L)))
                emit(TGBinOp(x, TGAddOp(), y, TGLong(to-long(BYTE-TAG-BITS))))
              CHAR-TYPE-ID :
                val y = make-var(TGLongT())
                emit(TGConv(y, head(imms(cexp(exp(e))))))
                emit(TGBinOp(y, TGAshlOp(), y, TGLong(3L)))
                emit(TGBinOp(x, TGAddOp(), y, TGLong(to-long(CHAR-TAG-BITS))))
              INT-TYPE-ID :
                val y = make-var(TGLongT())
                emit(TGConv(y, head(imms(cexp(exp(e))))))
                emit(TGBinOp(x, TGAshlOp(), y, TGLong(32L)))
              FLOAT-TYPE-ID :
                val y1 = make-var(TGIntT())
                emit(TGInterpret(y1, head(imms(cexp(exp(e))))))
                val y2 = make-var(TGLongT())
                emit(TGConv(y2, y1))
                emit(TGBinOp(y2, TGAshlOp(), y2, TGLong(3L)))
                emit(TGBinOp(x, TGAddOp(), y2, TGLong(to-long(FLOAT-TAG-BITS))))
      (e:KLSPrim) :
        match(op(e)) :
          (op:GetterPrimitive) :
            if op == GET-SP-OP :
              new CLSExp & Immediate :
                defmethod types (this) : List(TGLongT())
                defmethod imms (this) : List(TGRegSP())
            else :
              new CLSExp :
                defmethod types (this) :
                  tgt-types(dec-table, type(op))
                defmethod set (ns:List<Int>, this) :
                  val x = TGVar(head(ns))
                  val p = TGMem(lbl(op),0)
                  emit(TGLoad(x, p, 0))
          (op:AddrPrimitive) :
            new CLSExp & Immediate :
              defmethod types (this) : List(TGLongT())
              defmethod imms (this) : List(TGMem(lbl(op),0))          
          (op:SetterPrimitive) :
            val a = cexp(head(args(e)))
            new CLSExp & Immediate :
              defmethod types (this) :
                List(TGLongT())
              defmethod imms (this) :
                val p = TGMem(lbl(op),0)
                emit(TGStore(p, imm(a), 0))                
                List(TGLong(0L))
          (op) :
            if op == LS-YIELD-OP :
              val s = cexp(args(e)[0])
              val y = cexp(args(e)[1])
              new CLSExp :
                defmethod types (this) :
                  List(TGRefT())
                defmethod set (ns:List<Int>, this) :
                  val x = TGVar(head(ns))
                  emit(TGSwitchStack(x, imm(s), imm(y)))
            else :
              switch contains?{_, op} :
                LS-BINARY-OPS :
                  val a = cexp(args(e)[0])
                  val b = cexp(args(e)[1])
                  new CExp :
                    defmethod types (this) :
                      switch(op) :
                        LS-ADD-OP : types(a)
                        LS-SUB-OP : types(a)
                        LS-MUL-OP : types(a)
                        LS-DIV-OP : types(a)
                        LS-MOD-OP : types(a)
                        LS-AND-OP : types(a)
                        LS-OR-OP : types(a)
                        LS-XOR-OP : types(a)
                        LS-SHL-OP : types(a)
                        LS-SHR-OP : types(a)
                        LS-ASHR-OP : types(a)
                        LS-EQ-OP : List(TGLongT())
                        LS-NE-OP : List(TGLongT())
                        LS-LT-OP : List(TGLongT())
                        LS-GT-OP : List(TGLongT())
                        LS-LE-OP : List(TGLongT())
                        LS-GE-OP : List(TGLongT())
                        LS-ULT-OP : List(TGLongT())
                        LS-UGT-OP : List(TGLongT())
                        LS-ULE-OP : List(TGLongT())
                        LS-UGE-OP : List(TGLongT())
                    defmethod set (ns:List<Int>, this) :
                      val op* = switch(op) :
                        LS-ADD-OP : TGAddOp()
                        LS-SUB-OP : TGSubOp()
                        LS-MUL-OP : TGMulOp()
                        LS-DIV-OP : TGDivOp()
                        LS-MOD-OP : TGModOp()
                        LS-AND-OP : TGAndOp()
                        LS-OR-OP : TGOrOp()
                        LS-XOR-OP : TGXorOp()
                        LS-SHL-OP : TGShlOp()
                        LS-SHR-OP : TGShrOp()
                        LS-ASHR-OP : TGAshrOp()
                        LS-EQ-OP : TGEqOp()
                        LS-NE-OP : TGNeOp()
                        LS-LT-OP : TGLtOp()
                        LS-GT-OP : TGGtOp()
                        LS-LE-OP : TGLeOp()
                        LS-GE-OP : TGGeOp()
                        LS-ULT-OP : TGUltOp()
                        LS-UGT-OP : TGUgtOp()
                        LS-ULE-OP : TGUleOp()
                        LS-UGE-OP : TGUgeOp()
                      val x = TGVar(head(ns))
                      emit(TGBinOp(x, op*, imm(a), imm(b)))
                LS-UNARY-OPS :            
                  val a = cexp(head(args(e)))
                  new CExp :
                    defmethod types (this) :
                      switch(op(e)) :
                        LS-NOT-OP : types(a)
                        LS-NEG-OP : types(a)
                        LS-BITS-OP : List(TGIntegerT(head(types(a)) as TGRealT))
                        LS-FNUM-OP : List(TGRealT(head(types(a)) as TGIntegerT))
                    defmethod set (ns:List<Int>, this) :
                      val t = head(types(this))
                      val x = TGVar(head(ns))
                      switch(op(e)) :
                        LS-NOT-OP :
                          emit(TGBinOp(x, TGNotOp(), imm(a)))
                        LS-NEG-OP :
                          match(t) :
                            (t:TGIntegerT) :
                              emit(TGBinOp(x, TGNegOp(), imm(a)))
                            (t:TGRealT) :
                              val zero = make-var(t)
                              emit(TGConv(zero, TGInt(0)))
                              emit(TGBinOp(x, TGSubOp(), zero, imm(a)))
                        LS-BITS-OP :
                          emit(TGInterpret(x, imm(a)))
                        LS-FNUM-OP :
                          emit(TGInterpret(x, imm(a)))
      (e) :
        fatal("Cannot compile: %_" % [e])

  defn ccomm (c:KLSComm) -> False :
    match(c) :
      (c:KLSExec) :
        ignore(cexp(exp(c)))
      (c:KLSSet) :
        match(cloc(loc(c))) :
          (l:PtrLoc) :
            val p = imm(base(l))
            val ys = imms(cexp(value(c)))
            val offsets = field-offsets(dec-table, type(l))
            for (y in ys, o in offsets) do :
              emit(TGStore(p, y, o + offset(l)))
          (l:ExpLoc) :
            val len = field-length(dec-table, type(c))
            val xs = headn(len, tailn(imms(base(l)), index(l)))
            val ns = map(n, xs as List<TGVar>)
            set(ns, cexp(value(c)))
      (c:KLSLabels) :
        ;Create block args
        for b in blocks(c) do :
          val tss = map(tgt-types{dec-table, _}, types(b))
          val xss = map(map{make-var, _}, tss)
          for (a in args(b), xs in xss, ts in tss) do :
            imm-table[a] = xs
            type-table[a] = ts
          block-arg-table[n(b)] = map(map{n, _}, xss)
        ;Compile blocks
        val end-lbl = fresh-id()
        for b in blocks(c) do :
          emit(TGLabel(n(b)))
          ccomm(body(b))
          emit(TGGoto(end-lbl))
        emit(TGLabel(end-lbl))
      (c:KLSGoto) :
        val nss = block-arg-table[n(c)]
        val vs = seq(cexp, args(c))
        do(set, nss, vs)
        emit(TGGoto(n(c)))
      (c:KLSReturn) :
        if tail?(function) : tail(cexp(exp(c)))
        else : return(cexp(exp(c)))
      (c:KLSDefLocal) :
        val ts = tgt-types(dec-table, type(c))
        val v = cexp(value(c))
        imm-table[n(c)] = imms(v)
        type-table[n(c)] = ts
      (c:KLSDefLocalVar) :
        val ts = tgt-types(dec-table, type(c))
        val vs = map(make-var, ts)
        match(value(c)) :
          (v:KLSExp) : set(map(n,vs), cexp(v))
          (v:False) : false
        imm-table[n(c)] = vs
        type-table[n(c)] = ts
      (c:KLSSeq) :
        ccomm(a(c))
        ccomm(b(c))
      (c:KLSIf) :
        val p = imm(cexp(pred(c)))
        emit(TGBinCmp(false-lbl, TGEqOp(), p, TGLong(0L)))
        ccomm(conseq(c))
        emit(TGGoto(done-lbl))
        emit(TGLabel(false-lbl))
        ccomm(alt(c))
        emit(TGLabel(done-lbl))
      (c:KLSMatch) :
        val match-args = seq-append(imms{cexp(_)}, args(e))
        val bs = map(TGBranch{tags(_), fresh-id()}, branches(e))
        val done = fresh-id()
        emit(TGMatch(match-args, bs))
        for (b in branches(e), id in seq(n,bs)) do :
          emit(TGLabel(id))
          for (a in args(b), ma in match-args) do :
            imm-table[a] = List(TGVar(a))
            type-table[a] = List(TGRefT())
            emit(TGDef(a, TGRefT()))
            emit(TGSet(TGVar(a), ma))
          ccomm(body(b))
          emit(TGGoto(done))
        emit(TGLabel(done))
      (c:KLSSkip) :
        false
      (c) :
        fatal("Cannot compile: %_" % [c])

  ;================
  ;==== Driver ====
  ;================
  val buffer = Vector<TGIns>()
  let-var INSTRUCTION-BUFFER = buffer :
    ccomm(body(function))