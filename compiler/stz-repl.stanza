defpackage stz/repl :
  import core
  import collections
  import reader
  import parser
  import macro-utils
  import stz/il-ir
  import stz/dl-ir
  import stz/tl-ir
  import stz/el-ir
  import stz/vm-ir
  import stz/vm
  import stz/tl-to-el
  import stz/tl-to-dl

;============================================================
;===================== REPL Language ========================
;============================================================

deftype RExp
defstruct Load <: RExp :
  filenames: Tuple<String>
with:
  printer => true

defstruct ReplError <: Exception :
  info: FileInfo|False
  message: String
defmethod print (o:OutputStream, e:ReplError) :
  val infostr = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [infostr, message(e)])

defsyntax repl :
  public defproduction rexp! : RExp
  defrule rexp! = (?x:#rexp) : x
  fail-if rexp! = () : ReplError(closest-info(), "Not a repl expression")

  defproduction rexp : RExp
  defrule rexp = (load(?filenames:#string ...)) :
    Load(to-tuple(filenames))  

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction byte : Byte
  defrule byte = (?x) when unwrap-token(x) is Byte : unwrap-token(x)

  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

public defn repl-exps () :
  repeatedly $ fn () :
    let loop () :
      print("stz: ")
      val forms = read-line(STANDARD-INPUT-STREAM)
      try :
        parse-syntax[repl / #rexp!](forms)
      catch (e:NoMatchException) :
        do(println, causes(e))
        loop()

public defn repl () :
  val rexps = repl-exps()
  do(println, rexps)

;============================================================
;============================================================
;============================================================