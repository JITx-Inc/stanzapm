defpackage stz/repl :
  import core
  import collections
  import reader
  import parser
  import macro-utils
  import stz/utils
  import stz/il-ir
  import lang/check
  import stz/dl-ir with:
    prefix(Import) => DL
  import stz/tl-ir
  import stz/el-ir
  import stz/vm-ir
  import stz/vm
  import stz/core-macros
  import stz/input
  import stz/renamer
  import stz/resolver
  import stz/type
  import stz/tl-to-el
  import stz/dl
  import stz/el
  import stz/el-to-vm
  import stz/algorithms

;============================================================
;===================== REPL Language ========================
;============================================================

deftype RExp
defstruct Load <: RExp :
  inputs: Tuple<String|Symbol>
with:
  printer => true
defstruct Update <: RExp  
defstruct Reload <: RExp
defstruct Clear <: RExp
defstruct Import <: RExp :
  import: IImport
with:
  printer => true
defstruct Inside <: RExp :
  package: Symbol|False
with:
  printer => true
defstruct Unimport <: RExp :
  package: Symbol
with:
  printer => true
defstruct Eval <: RExp :
  form
defstruct NoOp <: RExp
with:
  printer => true

defstruct ReplSyntaxError <: Exception :
  info: FileInfo|False
  message: String
defmethod print (o:OutputStream, e:ReplSyntaxError) :
  val infostr = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [infostr, message(e)])

defsyntax repl :
  public defproduction rexp : RExp
  defrule rexp = (load ?inputs:#input! ...) :
    Load(to-tuple(inputs))
  defrule rexp = (?e:#import-clause) :
    Import(e)
  defrule rexp = (inside -) :
    Inside(false)
  defrule rexp = (inside ?p:#symbol!) :
    Inside(p)
  defrule rexp = (unimport ?name:#symbol!) :
    Unimport(name)
  defrule rexp = (update) :
    Update()
  defrule rexp = (reload) :
    Reload()
  defrule rexp = (clear) :
    Clear()
  defrule rexp = (?forms ...) :
    if empty?(forms) : NoOp()
    else : Eval(forms)

  ;===== Inputs =====
  defproduction input! : String|Symbol
  defrule input! = (?file:#string) : file
  defrule input! = (?pkg:#symbol) : pkg
  fail-if input! = () : ReplSyntaxError(closest-info(), "Input must be either a string or a symbol.")

  ;===== Imports =====
  defproduction prefix-clause! : IPrefix
  defrule prefix-clause! = (prefix => ?p:#symbol!) :
    IPrefix(false, to-string(p))
  defrule prefix-clause! = (prefix(?names:#symbol! ...) => ?p:#symbol!) :
    IPrefix(to-tuple(names), to-string(p))
  fail-if prefix-clause! = () :
    ReplSyntaxError(closest-info(), "Expected a prefix clause here.")

  defproduction prefix-clauses : Tuple<IPrefix>
  defrule prefix-clauses = (with #:! (?ps:#prefix-clause! ...)) : to-tuple(ps)
  defrule prefix-clauses = () : []

  defproduction import-clause : IImport
  defrule import-clause = (import ?package:#symbol! ?ps:#prefix-clauses) :
    IImport(package, ps)

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction byte : Byte
  defrule byte = (?x) when unwrap-token(x) is Byte : unwrap-token(x)

  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

  defproduction string! : String
  defrule string! = (?x:#string) : x
  fail-if string! = () : ReplSyntaxError(closest-info(), "Expected a string here.")

  defproduction symbol! : Symbol
  defrule symbol! = (?x:#symbol) : x
  fail-if symbol! = () : ReplSyntaxError(closest-info(), "Expected a symbol here.")

  defproduction :!
  defrule :! = (?x: ~ :) : x
  fail-if :! = () : ReplSyntaxError(closest-info(), "Colon expected here.")

defn read-repl-exp () :
  try :
    let loop () :
      print("> ")
      val forms = read-line(STANDARD-INPUT-STREAM)
      match(parse-syntax[repl / #rexp](forms)) :
        (e:NoOp) : loop()
        (e) : e
  catch (e:LexerException) :
    throw(ReplErrors([e]))
  catch (e:NoMatchException) :
    throw(ReplErrors(causes(e)))

;============================================================
;======================= Package Ordering ===================
;============================================================

defn initialization-order (import-graph:HashTable<Symbol, List<Symbol>>,
                           packages:Collection<Symbol>) -> Collection<Symbol> :
  ;Discover all strong components
  defn list (x:Symbol) : List(x)
  defn list (xs:List<Symbol>) : xs
  val components = to-tuple(seq(list, strong-components(import-graph)))
  val component-table = to-hashtable<Symbol,Int> $
    for (component in components, i in 0 to false) seq-cat :
      for c in component seq : c => i

  ;Natural ordering
  val index-table = to-hashtable<Symbol,Int> $
    for (p in packages, i in 1 to false) seq :
      p => 0 when p == `core else i
  defn order-by-index (ps:Seqable<Symbol>) :
    val ps* = filter(key?{index-table, _}, ps)
    defn cmp (a:Symbol, b:Symbol) : compare(index-table[a], index-table[b])
    lazy-qsort(ps*, cmp)

  ;Traversal
  val visited = IntSet()
  val accum = Vector<Symbol>()
  defn include (c:Int) :
    if add(visited,c) :
      val cs = components[c]
      for c in cs do : include-all(import-graph[c])
      add-all(accum, order-by-index(cs))
  defn include-all (cs:Seqable<Symbol>) :
    for c in cs do :
      include(component-table[c])
  include-all(packages)

  ;Return ordering
  accum

defn initialization-order (packages:Seqable<Symbol>, denv:DEnv) -> Collection<Symbol> :
  ;Create import graph
  val import-graph = to-hashtable<Symbol, List<Symbol>> $
    for io in packageios(denv) seq :
      package(io) => to-list(imported-packages(io))

  ;Compute initialization ordering
  initialization-order(import-graph, to-tuple(packages))

;============================================================
;=================== Default Imports ========================
;============================================================

defn core-imports () :
  [IImport(`core), IImport(`collections)]

;============================================================
;======================= Loading ============================
;============================================================

deftype REPL
defmulti load-files (repl:REPL, inputs:Tuple<String|Symbol>) -> False
defmulti update-files (repl:REPL) -> False
defmulti reload (repl:REPL) -> False
defmulti load-repl (repl:REPL, form) -> False
defmulti import (repl:REPL, import:IImport) -> False
defmulti unimport (repl:REPL, package:Symbol) -> False
defmulti inside (repl:REPL, package:Symbol|False) -> False
defmulti clear (repl:REPL) -> False

defn REPL () :
  ;============================================================
  ;===================== REPL State ===========================
  ;============================================================
  val vm = VirtualMachine()
  val denv = DEnv()
  val repl-env = REPLEnv()
  val file-env = FileEnv()
  val pkg-env = PkgEnv()

  ;============================================================
  ;================== Stages of Loading =======================
  ;============================================================
  ;Read from file
  defn read! (filename:String) -> ? :
    try :
      val timestamp = time-modified(filename)
      FileForm<?>(filename, timestamp, read-file(filename))
    catch (e:IOException) : throw(ReplErrors([e]))
    catch (e:LexerException) : throw(ReplErrors([e]))

  ;Macroexpansion
  defn macroexpand! (x) -> ? :
    match(x:FileForm) :
      sub-form(x, macroexpand!(form(x)))
    else :
      try : cons(`$begin, parse-syntax[core / #exps!](x))
      catch (e:NoMatchException) : throw(ReplErrors(causes(e)))
      catch (e:Exception) : throw(ReplErrors([e]))  ;TODO

  ;Conversion to IL IR
  defn to-ipackages! (expanded:Tuple<FileForm<?>>) -> [Tuple<IPackage>, Tuple<FileForm<Symbol>>] :
    val check-errors = Vector<CheckError>()
    val ipackages = Vector<IPackage>()
    val file-pkgs = Vector<FileForm<Symbol>>()
    for e in expanded do :
      try :
        val pkgs = to-ipackages(form(e), core-imports())
        for p in pkgs do :
          add(ipackages, p)
          add(file-pkgs, sub-form(e, name(p)))
      catch (e:CheckErrors) :
        add-all(check-errors, errors(e))
    throw(ReplErrors(check-errors)) when not empty?(check-errors)
    [to-tuple(ipackages), to-tuple(file-pkgs)]
  defn to-repl-ipackage! (expanded) -> IPackage :
    try : ReplPackage(repl-env, to-il(expanded))
    catch (e:CheckErrors) : throw(ReplErrors(errors(e)))

  ;Extract IPackage
  defn extract-input (file+inputs:Tuple<FileForm<IPackage>>) -> [Tuple<IPackage>, Tuple<FileForm<Symbol>>] :
    val input = map(form, file+inputs)
    val packages = for x in file+inputs map :
      FileForm<Symbol>(filename(x), timestamp(x), name(form(x)))
    [input, packages]

  ;Check that all required types are still defined
  defn check-types-exist (ipkgs:Tuple<IPackage>, live:Tuple<Rec>) :
    val packages = to-hashset<Symbol>(seq(name, ipkgs))
    val types = exported-types(ipkgs)
    check-export-types(denv, packages, types, live)
  defn check-types-exist! (ipkgs:Tuple<IPackage>, live:Tuple<Rec>) :
    match(check-types-exist(ipkgs, live)) :
      (l:LoadSuccess) : false
      (l:LoadErrors) : throw(ReplErrors(errors(l)))

  ;Renaming
  defn rename! (ipkgs:Tuple<IPackage>) :
    match(rename-il(ipkgs)) :
      (renamed:Tuple<IPackage>) : renamed
      (e:RenameErrors) : throw(ReplErrors(errors(e)))
  defn rename! (ipkg:IPackage) :
    rename!([ipkg])[0]

  ;Resolve
  defn resolve! (ipkgs:Tuple<IPackage>, priority:False|(Symbol -> Int)) :
    val env = new stz/resolver/Env :
      defmethod packageio (this, package:Symbol) :
        packageio(denv, package)    
    match(resolve-il(ipkgs, env, priority)) :
      (e:ResolveErrors) : throw(ReplErrors(errors(e)))
      (e:Tuple<IPackage>) : e
  defn resolve! (ipkgs:Tuple<IPackage>) :
    resolve!(ipkgs, false)
  defn resolve-repl! (ipkg:IPackage) :
    resolve!([ipkg], package-priority{repl-env, name(ipkg), _})

  ;Type Checking
  defn type! (ipkgs:Tuple<IPackage>) :
    val env = new stz/type/Env :
      defmethod packageio (this, package:Symbol) :
        packageio(denv, package) as PackageIO
    match(type-program(ipkgs, env)) :
      (e:TProg) : e
      (e:TypeErrors) : throw(ReplErrors(messages(e)))

  ;Check whether any globals have been redefined to be a different type
  defn check-globals! (tprog:TProg) :
    val ios = map(packageio, packages(tprog))
    match(check-globals(denv, ios)) :
      (result:LoadErrors) : throw(ReplErrors(errors(result)))
      (result:LoadSuccess) : false      

  ;Check packages can be loaded into existing environment
  defn check-load (tprog:TProg, live:Tuple<Rec>) :
    val ios = map(packageio, packages(tprog))
    check-exports(denv, ios, live)
  defn check-load! (tprog:TProg, live:Tuple<Rec>) :
    match(check-load(tprog, live)) :
      (result:LoadErrors) : throw(ReplErrors(errors(result)))
      (result:LoadSuccess) : false

  ;Save associations to file environment
  defn save-to-file-env! (file-pkgs:Tuple<FileForm<Symbol>>) :
    do(register{file-env, _}, file-pkgs)

  ;Load into Virtual Machine
  defn load-vm! (tprog:TProg) :
    val epkgs = to-el(tprog, true)
    val vmpkgs = map(compile{lower(_)}, epkgs)
    load(denv, seq(packageio, vmpkgs))
    load(vm, vmpkgs, false)

  ;Run the given packages in the virtual machine
  defn run-vm! (packages:Seqable<Symbol>) :
    for p in initialization-order(packages, denv) do :
      init-package(vm, p)

  ;Load into virtual machine without initialization
  defn update-vm! (tprog:TProg) :
    val epkgs = to-el(tprog, true)
    val vmpkgs = map(compile{lower(_)}, epkgs)
    load(denv, seq(packageio, vmpkgs))
    load(vm, vmpkgs, true)

  ;============================================================
  ;===================== File Loading =========================
  ;============================================================

  ;Load files
  defn load-files (inputs:Tuple<String|Symbol>) :
    ;Ensure that inputs are well-formed
    val errors = Vector<?>()
    for input in inputs do :
      match(input) :
        (filename:String) :
          if not suffix?(filename, ".stanza") :
            add(errors, InvalidExtension(filename))            
        (package:Symbol) :
          if not loaded?(pkg-env,package) :
            add(errors, PackageNotLoaded(package))
    throw(ReplErrors(errors)) when not empty?(errors)

    ;Load all files
    val filenames = filter-by<String>(inputs)
    val expanded = seq({macroexpand! $ read! $ _}, filenames)
    val [input, file-pkgs] = to-ipackages! $ to-tuple $ expanded
    val live = compute-live(vm, seq(name, input))
    check-types-exist!(input, live)
    val typed = type! $ resolve! $ rename! $ input
    check-load!(typed, live)
    save-to-file-env!(file-pkgs)
    do(register{pkg-env, name(_)}, packages(typed))
    load-vm!(typed)
    run-vm!(cat(old-packages, new-packages)) where :
      val old-packages = filter-by<Symbol>(inputs)
      val new-packages = seq(name,/packages(typed))

  ;Reload
  defn reload () :
    run-vm!(packages(pkg-env))

  ;Clear all repl definitions
  defn clear-repl () :
    ;Compute what live repl records are required
    val live = compute-live(vm, repl-packages(repl-env))
    val empty-ios = to-tuple $
      for p in repl-packages(repl-env) seq :
        PackageIO(p, [], [], [])
    match(check-exports(denv, empty-ios, live)) :
      (e:LoadErrors) : throw(ReplErrors(errors(e)))
      (e:LoadSuccess) : false
    ;False
    false

  ;Update files
  defn update-files () :
    ;Compute the changed files
    val changed-files = changed-files(file-env)
    if empty?(changed-files) :
      throw $ ReplErrors([NoChangedFiles()])
    else :
      ;Track the files to reload.
      ;Initialize them with the set of all changed files.
      val reload-files = to-hashset<String>(changed-files)
      let loop () :
        val done? = label<True|False> break :
          let :
            val filenames = to-tuple(reload-files)
            val expanded = map({macroexpand! $ read! $ _}, filenames)
            val [input, file-pkgs] = to-ipackages! $ expanded
            val live = compute-live(vm, [])
            check-load-errors!(check-types-exist(input, live))
            val typed = type! $ resolve! $ rename! $ input
            check-globals!(typed)
            check-load-errors!(check-load(typed, live))
            save-to-file-env!(file-pkgs)
            update-vm!(typed)
            true
          where :
            defn check-load-errors! (e:LoadResult) :
              match(e:LoadErrors) :
                ;Categorize errors into being caused by packages or by live objects
                defn package-source? (e:LoadError) : source(e) is LoadedPackage
                val [package-errors, live-errors] = split!(package-source?,errors(e))
                ;Nothing we can do about errors from live objects
                throw(ReplErrors(live-errors)) when length(live-errors) > 0
                ;If there are package errors then add their source files to the
                ;reload set, and try again
                for e in package-errors do :
                  val package = package(source(e) as LoadedPackage)
                  add(reload-files, source-file(file-env, package))
                break(false)                
        loop() when not done?

  ;Load from repl
  defn load-repl (form) :
    val typed = type! $ resolve-repl! $ rename! $ to-repl-ipackage! $ macroexpand! $ form    
    register(repl-env, packageio(packages(typed)[0]))
    load-vm!(typed)
    run-vm!([name(packages(typed)[0])])

  ;============================================================
  ;===================== REPL Structure =======================
  ;============================================================
  new REPL :
    defmethod load-files (this, inputs:Tuple<String|Symbol>) :
      load-files(inputs)
    defmethod update-files (this) :
      update-files()
    defmethod load-repl (this, form) :
      load-repl(form)
    defmethod clear (this) :
      clear-repl()
    defmethod reload (this) :
      reload()
    defmethod import (this, import:IImport) :
      if not loaded?(pkg-env, package(import)) :
        throw $ ReplErrors $ [PackageNotLoaded(package(import))]
      else : /import(repl-env, import)
    defmethod unimport (this, package:Symbol) :
      if not unimport(repl-env, package) :
        throw $ ReplErrors $ [PackageNotImported(package)]
    defmethod inside (this, package:Symbol) :
      if not loaded?(pkg-env, package) :
        throw $ ReplErrors $ [PackageNotLoaded(package)]
      else : inside(repl-env, package)
    defmethod inside (this, package:False) :
      if current-inside(repl-env) is False :
        throw $ ReplErrors $ [NotInsidePackage()]
      inside(repl-env, false)

defstruct FileForm<T> :
  filename: String
  timestamp: Long
  form:T with: (updater => sub-form)

;============================================================
;=================== Package Environment ====================
;============================================================

deftype PkgEnv
defmulti loaded? (e:PkgEnv, package:Symbol) -> True|False
defmulti register (e:PkgEnv, package:Symbol) -> False
defmulti packages (e:PkgEnv) -> Seqable<Symbol>
defn PkgEnv () :
  val packages = HashSet<Symbol>()
  new PkgEnv :
    defmethod loaded? (this, p:Symbol) :
      packages[p]
    defmethod register (this, p:Symbol) :
      add(packages, p)
      false
    defmethod packages (this) :
      packages

;============================================================
;=================== File Environment =======================
;============================================================

deftype FileEnv
defmulti register (e:FileEnv, file-pkg:FileForm<Symbol>) -> False
defmulti changed-files (e:FileEnv) -> Tuple<String>
defmulti source-file (e:FileEnv, package:Symbol) -> String

defn FileEnv () :
  ;Track which source file each package came from
  val source-file-table = HashTable<Symbol,String>()
  val timestamp-table = HashTable<String,Long>()

  new FileEnv :
    defmethod register (this, file-pkg:FileForm<Symbol>) :
      source-file-table[form(file-pkg)] = filename(file-pkg)
      timestamp-table[filename(file-pkg)] = timestamp(file-pkg)
    defmethod changed-files (this) :
      to-tuple $ for file in values(source-file-table) seq? :
        try :
          val new-timestamp = time-modified(file)
          val old-timestamp = timestamp-table[file]
          if new-timestamp != old-timestamp : One(file)
          else : None()
        catch (e:FileStatException) :
          None()
    defmethod source-file (this, package:Symbol) :
      source-file-table[package]

;============================================================
;=================== REPL User Environment ==================
;============================================================

deftype REPLEnv

;For registering successfully loaded packages
defmulti register (e:REPLEnv, packageio:PackageIO) -> False

;For import/unimport commands
defmulti import (e:REPLEnv, import:IImport) -> False
defmulti unimport (e:REPLEnv, package:Symbol) -> True|False

;For inside command
defmulti inside (e:REPLEnv, package:Symbol|False) -> False
defmulti current-inside (e:REPLEnv) -> Symbol|False

;For resolution
defmulti package-priority (e:REPLEnv, self:Symbol, package:Symbol) -> Int

;For constructing the IPackage
defmulti ReplPackage (e:REPLEnv, exp:IExp) -> IPackage

;List names of all repl packages
defmulti repl-packages (e:REPLEnv) -> Seqable<Symbol>

defn REPLEnv () :
  ;Previous repl packages
  val previous-packages = Vector<PackageIO>()
  val package-index = HashTable<Symbol,Int>()
  ;Current desired imports
  val imports = HashTable<Symbol, IImport>()
  ;Currently inside package
  var inside-package:Symbol|False = false

  ;Initialize imports
  for i in core-imports() do :
    imports[package(i)] = i

  ;Construct IPackage
  defn make-repl-package (exp:IExp) :
    ;First ensure legitimacy
    ensure-repl-expression(exp)
    
    ;Next create import list
    val package-imports = Vector<IImport>()    
    ;Import all previous repl packages
    for p in previous-packages do :
      add(package-imports, IImport(package(p), [], false, true))
    ;Import all current imports
    for i in values(imports) do :
      if package(i) != inside-package :
        add(package-imports, i)
    ;Import the current 'inside' package
    match(inside-package:Symbol) :
      add(package-imports, IImport(inside-package, [], false, true))

    ;Create IPackage
    IPackage(gensym(`repl), to-tuple(package-imports), List(exp), info(exp))

  ;Resolution priority of IPackage
  defn package-priority (self:Symbol, p:Symbol) -> Int :
    if p == inside-package : 1
    else if p == self : INT-MAX
    else if key?(package-index, p) : package-index[p] + 2
    else : 0

  ;Construct environment object
  new REPLEnv :
    defmethod import (this, import:IImport) :
      imports[package(import)] = import
    defmethod unimport (this, package:Symbol) -> True|False :
      remove(imports, package)
    defmethod inside (this, package:Symbol|False) :
      inside-package = package
    defmethod current-inside (this) :
      inside-package
    defmethod register (this, packageio:PackageIO) :
      add(previous-packages, packageio)
      package-index[package(packageio)] = length(previous-packages) - 1
    defmethod package-priority (this, self:Symbol, package:Symbol) -> Int :
      package-priority(self, package)
    defmethod ReplPackage (this, exp:IExp) :
      make-repl-package(exp)
    defmethod repl-packages (this) :
      seq(package, previous-packages)

defn ensure-repl-expression (expression:IExp) :
  ;Detect illegal expressions
  val errors = Vector<Exception>()
  defn not-allowed! (e:IExp) :
    val type-str = match(e) :
      (e:IDefPackage) : "defpackage"
      (e:IDefType) : "deftype"
      (e:IDefmulti) : "defmulti"
      (e:IDefmethod) : "defmethod"
      (e:ILSDefType) : "lostanza deftype"
      (e:ILSDefmethod) : "lostanza defmethod"
      (e:ILSExternFn) : "externfn"
    add(errors, InvalidExp(type-str))        

  ;Sweep through expressions and detect invalid expressions
  let loop (e:IExp = expression) :
    match(e) :
      (e:IBegin) : do(loop, exps(e))
      (e:IVisibility) : loop(exp(e))
      (e:IDefPackage|IDefType|IDefmulti|IDefmethod|
         ILSDefType|ILSDefmethod|ILSExternFn) : not-allowed!(e)
      (e) : false

  ;Throw errors if there are any
  throw(ReplErrors(errors)) when not empty?(errors)

;============================================================
;======================== Errors ============================
;============================================================

defstruct ReplErrors <: Exception :
  messages: Collection

defn PackageNotLoaded (package:Symbol) :
  Exception $ "Could not import package %~. Package has not been loaded." % [package]

defn PackageNotImported (package:Symbol) :
  Exception $ "Could not unimport package %~. Package is not yet imported." % [package]

defn NotInsidePackage () :
  Exception $ "Not currently inside any package."

defn NoChangedFiles () :
  Exception $ "No changes detected in any loaded file."

defn InvalidExtension (file:String) :
  Exception $ "File %~ does not have a valid Stanza file extension." % [file]

defn InvalidExp (exp-type:String) :
  Exception $ "The interactive REPL does not support %_ statements." % [exp-type]

;============================================================
;======================= Driver =============================
;============================================================

public defn repl () :
  val repl = REPL()
  while true :
    try :
      match(read-repl-exp()) :
        (exp:Load) : load-files(repl, inputs(exp))
        (exp:Eval) : load-repl(repl, form(exp))
        (exp:Import) : import(repl, import(exp))
        (exp:Unimport) : unimport(repl, package(exp))
        (exp:Inside) : inside(repl, package(exp))
        (exp:Update) : update-files(repl)
        (exp:Reload) : reload(repl)
        (exp:Clear) : clear(repl)
    catch (e:ReplErrors) :
      do(println, messages(e))
