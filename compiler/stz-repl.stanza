defpackage stz/repl :
  import core
  import collections
  import reader
  import parser
  import macro-utils
  import stz/utils
  import stz/il-ir
  import stz/dl-ir with:
    prefix(Import) => DL
  import stz/tl-ir
  import stz/el-ir
  import stz/vm-ir
  import stz/vm
  import stz/core-macros
  import stz/input
  import stz/renamer
  import stz/resolver
  import stz/type
  import stz/tl-to-el
  import stz/dl
  import stz/el
  import stz/el-to-vm

;============================================================
;===================== REPL Language ========================
;============================================================

deftype RExp
defstruct Load <: RExp :
  filenames: Tuple<String>
with:
  printer => true
defstruct Import <: RExp :
  import: IImport
with:
  printer => true
defstruct Unimport <: RExp :
  package: Symbol
with:
  printer => true
defstruct Eval <: RExp :
  form
defstruct NoOp <: RExp 
with:
  printer => true

defstruct ReplSyntaxError <: Exception :
  info: FileInfo|False
  message: String
defmethod print (o:OutputStream, e:ReplSyntaxError) :
  val infostr = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [infostr, message(e)])

defsyntax repl :
  public defproduction rexp : RExp
  defrule rexp = (load ?filenames:#string! ...) :
    Load(to-tuple(filenames))
  defrule rexp = (?e:#import-clause) :
    Import(e)
  defrule rexp = (unimport ?name:#symbol!) :
    Unimport(name)
  defrule rexp = (?forms ...) :
    if empty?(forms) : NoOp()
    else : Eval(forms)

  ;===== Imports =====
  defproduction prefix-clause! : IPrefix
  defrule prefix-clause! = (prefix => ?p:#symbol!) :
    IPrefix(false, IVar(p,closest-info(p)), closest-info())
  defrule prefix-clause! = (prefix(?xs:#symbol! ...) => ?p:#symbol!) :
    val names = for x in xs map : IVar(x,closest-info(x))
    IPrefix(names, IVar(p,closest-info(p)), closest-info())
  fail-if prefix-clause! = () :
    ReplSyntaxError(closest-info(), "Expected a prefix clause here.")

  defproduction prefix-clauses : List<IPrefix>
  defrule prefix-clauses = (with #:! (?ps:#prefix-clause! ...)) : ps
  defrule prefix-clauses = () : List()

  defproduction import-clause : IImport
  defrule import-clause = (import ?name:#symbol! ?ps:#prefix-clauses) :
    val package = IVar(name, closest-info(name))
    IImport(package, ps, closest-info())

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction byte : Byte
  defrule byte = (?x) when unwrap-token(x) is Byte : unwrap-token(x)

  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

  defproduction string! : String
  defrule string! = (?x:#string) : x
  fail-if string! = () : ReplSyntaxError(closest-info(), "Expected a string here.")

  defproduction symbol! : Symbol
  defrule symbol! = (?x:#symbol) : x
  fail-if symbol! = () : ReplSyntaxError(closest-info(), "Expected a symbol here.")

  defproduction :!
  defrule :! = (?x: ~ :) : x
  fail-if :! = () : ReplSyntaxError(closest-info(), "Colon expected here.")

public defn repl-exps () :
  val input = BufferedInputStream(STANDARD-INPUT-STREAM)
  repeatedly $ fn () :
    let loop () :
      print("> ")
      val forms = read-line(STANDARD-INPUT-STREAM)
      try :
        match(parse-syntax[repl / #rexp](forms)) :
          (e:NoOp) : loop()
          (e) : e
      catch (e:NoMatchException) :
        do(println, causes(e))
        loop()

;============================================================
;======================= Package Ordering ===================
;============================================================

;TODO
defn init-order (vmps:Tuple<VMPackage>, denv:DEnv) -> Tuple<Symbol> :
  defn core-cmp (a:Symbol, b:Symbol) :
    match(a == `core, b == `core) :
      (x:True, y:True) : 0
      (x:True, y:False) : -1
      (x:False, y:True) : 1
      (x:False, y:False) : compare(a, b)
  qsort(seq(package, vmps), core-cmp)    

;============================================================
;======================= Loading ============================
;============================================================

deftype REPL
defmulti load-files (repl:REPL, filenames:Tuple<String>) -> False
defmulti load-repl (repl:REPL, form) -> False
defmulti import (repl:REPL, import:IImport) -> False
defmulti unimport (repl:REPL, package:Symbol) -> False

defn REPL () :
  ;State of the repl
  val vm = VirtualMachine()
  val denv = DEnv()
  val repl-env = REPLEnv()

  ;Load files
  defn load-files (filenames:Tuple<String>) :
    ;===== Stages =====
    defn read! (filename:String) :
      try : read-file(filename)
      catch (e:IOException) : throw(ReplErrors([e]))
    defn macroexpand! (forms) :
      try : cons(`$begin, parse-syntax[core / #exps!](forms))
      catch (e:NoMatchException) : throw(ReplErrors(causes(e)))
      catch (e:Exception) : throw(ReplErrors([e]))  ;TODO
    defn to-input! (expanded:Seqable) :
      to-tuple(seq-cat(to-il, expanded))
    defn check-types! (ipkgs:Tuple<IPackage>, live:Tuple<Rec>) :
      val packages = to-hashset<Symbol>(seq(name, ipkgs))
      val types = exported-types(ipkgs)
      match(check-export-types(denv, packages, types, live)) :
        (l:LoadSuccess) : false
        (l:LoadErrors) : throw(ReplErrors(errors(l)))      
    defn rename! (ipkgs:Tuple<IPackage>) :
      match(rename-il(ipkgs)) :
        (renamed:Tuple<IPackage>) : renamed
        (e:RenameErrors) : throw(ReplErrors(errors(e)))
    defn resolve! (ipkgs:Tuple<IPackage>) :
      val env = new stz/resolver/Env :
        defmethod packageio (this, package:Symbol) :
          packageio(denv, package)
      match(resolve-il(ipkgs, env)) :
        (resolved:Tuple<IPackage>) : resolved
        (e:ResolveErrors) : throw(ReplErrors(errors(e)))
    defn type! (ipkgs:Tuple<IPackage>) :
      val env = new stz/type/Env :
        defmethod packageio (this, package:Symbol) : packageio(denv, package) as PackageIO
      match(type-program(ipkgs, env)) :
        (p:TProg) : p
        (e:TypeErrors) : throw(ReplErrors(messages(e)))
    defn check-load! (tprog:TProg, live:Tuple<Rec>) :      
      val ios = map(packageio, packages(tprog))      
      match(check-exports(denv, ios, live)) :
        (result:LoadErrors) : throw(ReplErrors(errors(result)))
        (result:LoadSuccess) : false
    defn load-vm! (tprog:TProg) :
      val epkgs = to-el(tprog)
      val vmpkgs = map(compile{lower(_)}, epkgs)
      load(denv, seq(packageio, vmpkgs))
      load(vm, vmpkgs)
      val order = init-order(vmpkgs, denv)
      do(init-package{vm, _}, order)
      
    ;===== Driver =====
    val expanded = seq({macroexpand! $ read! $ _}, filenames)
    val input = to-input! $ expanded    
    val live = compute-live(vm, seq(name, input))
    check-types!(input, live)    
    val typed =  type! $ resolve! $ rename! $ input
    check-load!(typed, live)
    load-vm!(typed)

  ;Load repl command
  defn load-repl (form) :
    defn macroexpand! (form) :
      try : cons(`$begin, parse-syntax[core / #exps!](form))
      catch (e:NoMatchException) : throw(ReplErrors(causes(e)))
      catch (e:Exception) : throw(ReplErrors([e]))  ;TODO
    defn to-input! (expanded) :
      val pkgs = to-il(expanded, imports(repl-env))
      fatal("Incorrect number of packages.") when length(pkgs) != 1
      pkgs[0]
    defn rename! (ipkg:IPackage) :
      match(rename-il([ipkg])) :
        (renamed:Tuple<IPackage>) : renamed[0]
        (e:RenameErrors) : throw(ReplErrors(errors(e)))
    defn resolve! (ipkg:IPackage) :
      val env = new stz/resolver/Env :
        defmethod packageio (this, package:Symbol) :
          packageio(denv, package)
      match(resolve-repl-il(ipkg, env, packageio(repl-env))) :
        (resolved:IPackage) : resolved
        (e:ResolveErrors) : throw(ReplErrors(errors(e)))
    defn type! (ipkg:IPackage) :
      val env = new stz/type/Env :
        defmethod packageio (this, package:Symbol) : packageio(denv, package) as PackageIO
      match(type-repl(ipkg, env, packageio(repl-env))) :
        (p:TProg) : p
        (e:TypeErrors) : throw(ReplErrors(messages(e)))
    defn save-to-repl-env! (tprog:TProg) :
      val package = packages(tprog)[0]
      add(repl-env, packageio(package))
    defn load-vm! (tprog:TProg) :
      val epkgs = to-el(tprog)
      val vmpkgs = map(compile{lower(_)}, epkgs)
      load(denv, seq(packageio, vmpkgs))
      load(vm, vmpkgs)
      do(init-package{vm, package(_)}, vmpkgs)
      
    ;===== Driver =====
    val typed = type! $ resolve! $ rename! $ to-input! $ macroexpand!(form)
    save-to-repl-env!(typed)
    load-vm!(typed)      

  ;Return REPL
  new REPL :
    defmethod load-files (this, filenames:Tuple<String>) :
      load-files(filenames)
    defmethod load-repl (this, form) :
      load-repl(form)
    defmethod import (this, import:IImport) :
      val package = name!(package(import))
      if packageio(denv,package) is False :
        throw $ ReplErrors $ [PackageNotLoaded(package)]
      else : add(repl-env, import)
    defmethod unimport (this, package:Symbol) :
      if not unimport(repl-env, package) :
        throw $ ReplErrors $ [PackageNotImported(package)]

deftype REPLEnv
defmulti packageio (e:REPLEnv) -> PackageIO
defmulti imports (e:REPLEnv) -> Collection<IImport>
defmulti add (e:REPLEnv, packageio:PackageIO) -> False
defmulti add (e:REPLEnv, import:IImport) -> False
defmulti unimport (e:REPLEnv, package:Symbol) -> True|False
defn REPLEnv () :
  val package-name = gensym(`repl)
  val exports-table = HashTable<Symbol, List<Export>>(List())
  val imports = HashTable<Symbol, IImport>()  
  val env = new REPLEnv :
    defmethod packageio (this) :
      PackageIO(package-name, [], [], to-tuple(cat-all(values(exports-table))))
    defmethod imports (this) :
      to-tuple(values(imports))
    defmethod add (this, import:IImport) :
      val package = name!(package(import))
      imports[package] = import
    defmethod unimport (this, package:Symbol) -> True|False :
      remove(imports, package)
    defmethod add (this, packageio:PackageIO) :
      val grouped = group-by(name{id(rec(_))}, exports(packageio))
      for entry in grouped do :
        val name = key(entry)
        val entries = value(entry)
        exports-table[name] = entries
  do(add{env, _}, core-imports())
  env

;============================================================
;======================== Errors ============================
;============================================================

defstruct ReplErrors <: Exception :
  messages: Collection

defn PackageNotLoaded (package:Symbol) :
  Exception $ "Could not import package %~. Package has not been loaded." % [package]

defn PackageNotImported (package:Symbol) :
  Exception $ "Could not unimport package %~. Package is not yet imported." % [package]
  
;============================================================
;======================= Driver =============================
;============================================================

public defn repl () :
  val repl = REPL()
  for exp in repl-exps() do :
    try :
      match(exp) :
        (exp:Load) : load-files(repl, filenames(exp))
        (exp:Eval) : load-repl(repl, form(exp))
        (exp:Import) : import(repl, import(exp))
        (exp:Unimport) : unimport(repl, package(exp))
    catch (e:ReplErrors) :
      do(println, messages(e))
  
