defpackage stz/repl :
  import core
  import collections
  import reader
  import parser
  import macro-utils
  import stz/utils
  import stz/il-ir
  import stz/dl-ir
  import stz/tl-ir
  import stz/el-ir
  import stz/vm-ir
  import stz/vm
  import stz/core-macros
  import stz/input
  import stz/renamer
  import stz/resolver
  import stz/type
  import stz/tl-to-el
  import stz/dl
  import stz/el
  import stz/el-to-vm

;============================================================
;===================== REPL Language ========================
;============================================================

deftype RExp
defstruct Load <: RExp :
  filenames: Tuple<String>
with:
  printer => true
defstruct Eval <: RExp :
  form
with:
  printer => true

defstruct ReplSyntaxError <: Exception :
  info: FileInfo|False
  message: String
defmethod print (o:OutputStream, e:ReplSyntaxError) :
  val infostr = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [infostr, message(e)])

defsyntax repl :
  public defproduction rexp! : RExp
  defrule rexp! = (?x:#rexp) : x
  fail-if rexp! = () : ReplSyntaxError(closest-info(), "Not a repl expression")

  defproduction rexp : RExp
  defrule rexp = (: load(?filenames:#string ...)) :
    Load(to-tuple(filenames))
  defrule rexp = (?forms ...) :
    Eval(forms)

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction byte : Byte
  defrule byte = (?x) when unwrap-token(x) is Byte : unwrap-token(x)

  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

public defn repl-exps () :
  val input = BufferedInputStream(STANDARD-INPUT-STREAM)
  repeatedly $ fn () :
    let loop () :
      print("stz: ")
      val forms = read-line(STANDARD-INPUT-STREAM)
      try : parse-syntax[repl / #rexp!](forms)
      catch (e:NoMatchException) :
        do(println, causes(e))
        loop()

;============================================================
;======================= Loading ============================
;============================================================

deftype REPL
defmulti load-files (repl:REPL, filenames:Tuple<String>) -> False
defmulti load-repl (repl:REPL, form) -> False

defn REPL () :
  ;State of the repl
  val vm = VirtualMachine()
  val denv = DEnv()
  val tenv = HashTable<Symbol,TypeDefs>()
  val repl-env = REPLEnv()

  ;Load files
  defn load-files (filenames:Tuple<String>) :
    ;===== Stages =====
    defn read! (filename:String) :
      try : read-file(filename)
      catch (e:IOException) : throw(ReplErrors([e]))
    defn macroexpand! (forms) :
      try : cons(`$begin, parse-syntax[core / #exps!](forms))
      catch (e:NoMatchException) : throw(ReplErrors(causes(e)))
      catch (e:Exception) : throw(ReplErrors([e]))  ;TODO
    defn to-input! (expanded:Seqable) :
      to-tuple(seq-cat(to-il, expanded))
    defn rename! (ipkgs:Tuple<IPackage>) :
      match(rename-il(ipkgs)) :
        (renamed:Tuple<IPackage>) : renamed
        (e:RenameErrors) : throw(ReplErrors(errors(e)))
    defn resolve! (ipkgs:Tuple<IPackage>) :
      val env = new stz/resolver/Env :
        defmethod packageio (this, package:Symbol) :
          packageio(denv, package)
      match(resolve-il(ipkgs, env)) :
        (resolved:Tuple<IPackage>) : resolved
        (e:ResolveErrors) : throw(ReplErrors(errors(e)))
    defn type! (ipkgs:Tuple<IPackage>) :
      val env = new stz/type/Env :
        defmethod packageio (this, package:Symbol) : packageio(denv, package) as PackageIO
        defmethod typedefs (this, package:Symbol) : tenv[package]
      match(type-program(ipkgs, env)) :
        (p:TProg) : p
        (e:TypeErrors) : throw(ReplErrors(messages(e)))
    defn check-load! (tprog:TProg) :
      val live = compute-live(vm, seq(name, packages(tprog)))
      val ios = map(packageio, packages(tprog))
      match(load(denv, ios, live)) :
        (result:LoadErrors) : throw(ReplErrors(errors(result)))
        (result:LoadSuccess) : false
    defn save-to-tenv! (tprog:TProg) :
      for p in packages(tprog) do :
        val def = typedefs(p)
        tenv[package(def)] = def
    defn load-vm! (tprog:TProg) :
      val epkgs = to-el(tprog)
      val vmpkgs = map(compile{lower(_)}, epkgs)
      load(vm, vmpkgs)
      do(init-package{vm, package(_)}, vmpkgs)
      
    ;===== Driver =====
    val expanded = seq({macroexpand! $ read! $ _}, filenames)
    val typed =  type! $ resolve! $ rename! $ to-input! $ expanded
    check-load!(typed)
    save-to-tenv!(typed)
    load-vm!(typed)

  ;Load repl command
  defn load-repl (form) :
    defn macroexpand! (form) :
      try : cons(`$begin, parse-syntax[core / #exps!](form))
      catch (e:NoMatchException) : throw(ReplErrors(causes(e)))
      catch (e:Exception) : throw(ReplErrors([e]))  ;TODO
    defn to-input! (expanded) :
      val pkgs = to-il(expanded)
      fatal("Incorrect number of packages.") when length(pkgs) != 1
      pkgs[0]
    defn rename! (ipkg:IPackage) :
      match(rename-il([ipkg])) :
        (renamed:Tuple<IPackage>) : renamed[0]
        (e:RenameErrors) : throw(ReplErrors(errors(e)))
    defn resolve! (ipkg:IPackage) :
      val env = new stz/resolver/Env :
        defmethod packageio (this, package:Symbol) :
          packageio(denv, package)
      match(resolve-repl-il(ipkg, env, packageio(repl-env))) :
        (resolved:IPackage) : resolved
        (e:ResolveErrors) : throw(ReplErrors(errors(e)))
    defn type! (ipkg:IPackage) :
      val env = new stz/type/Env :
        defmethod packageio (this, package:Symbol) : packageio(denv, package) as PackageIO
        defmethod typedefs (this, package:Symbol) : tenv[package]      
      match(type-repl(ipkg, env, typedefs(repl-env), packageio(repl-env))) :
        (p:TProg) : p
        (e:TypeErrors) : throw(ReplErrors(messages(e)))
    defn save-to-repl-env! (tprog:TProg) :
      val package = packages(tprog)[0]
      add(repl-env, packageio(package))
      add(repl-env, typedefs(package))
    defn load-vm! (tprog:TProg) :
      val epkgs = to-el(tprog)
      val vmpkgs = map(compile{lower(_)}, epkgs)
      load(vm, vmpkgs)
      do(init-package{vm, package(_)}, vmpkgs)
      
    ;===== Driver =====
    val typed = type! $ resolve! $ rename! $ to-input! $ macroexpand!(form)
    save-to-repl-env!(typed)
    load-vm!(typed)      

  ;Return REPL
  new REPL :
    defmethod load-files (this, filenames:Tuple<String>) :
      load-files(filenames)
    defmethod load-repl (this, form) :
      load-repl(form)

deftype REPLEnv
defmulti typedefs (e:REPLEnv) -> TypeDefs
defmulti packageio (e:REPLEnv) -> PackageIO
defmulti add (e:REPLEnv, packageio:PackageIO) -> False
defmulti add (e:REPLEnv, typedefs:TypeDefs) -> False
defn REPLEnv () :
  val package-name = gensym(`repl)
  val exports-table = HashTable<Symbol, List<Export>>(List())
  val tdecls = IntTable<TDecl>()
  new REPLEnv :
    defmethod typedefs (this) :
      TypeDefs(package-name, to-tuple(values(tdecls)))
    defmethod packageio (this) :
      PackageIO(package-name, [], [], to-tuple(cat-all(values(exports-table))))
    defmethod add (this, typedefs:TypeDefs) :
      for d in defs(typedefs) do :
        val decl = d as TDecl
        tdecls[n(decl)] = decl
    defmethod add (this, packageio:PackageIO) :
      val grouped = group-by(name{id(rec(_))}, exports(packageio))
      for entry in grouped do :
        val name = key(entry)
        val entries = value(entry)
        exports-table[name] = entries

;============================================================
;======================== Errors ============================
;============================================================

defstruct ReplErrors <: Exception :
  messages: Collection
  
;============================================================
;======================= Driver =============================
;============================================================

public defn repl () :
  val repl = REPL()
  for exp in repl-exps() do :
    try :
      match(exp) :
        (exp:Load) : load-files(repl, filenames(exp))
        (exp:Eval) : load-repl(repl, form(exp))
    catch (e:ReplErrors) :
      do(println, messages(e))
  
