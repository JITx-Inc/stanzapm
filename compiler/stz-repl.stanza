defpackage stz/repl :
  import core
  import collections
  import reader
  import parser
  import macro-utils
  import stz/il-ir
  import stz/dl-ir
  import stz/tl-ir
  import stz/el-ir
  import stz/vm-ir
  import stz/vm
  import stz/core-macros
  import stz/input
  import stz/renamer
  import stz/resolver
  import stz/type
  import stz/tl-to-el
  import stz/tl-to-dl
  import stz/dl
  import stz/el
  import stz/el-to-vm

;============================================================
;===================== REPL Language ========================
;============================================================

deftype RExp
defstruct Load <: RExp :
  filenames: Tuple<String>
with:
  printer => true

defstruct ReplSyntaxError <: Exception :
  info: FileInfo|False
  message: String
defmethod print (o:OutputStream, e:ReplSyntaxError) :
  val infostr = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [infostr, message(e)])

defsyntax repl :
  public defproduction rexp! : RExp
  defrule rexp! = (?x:#rexp) : x
  fail-if rexp! = () : ReplSyntaxError(closest-info(), "Not a repl expression")

  defproduction rexp : RExp
  defrule rexp = (load(?filenames:#string ...)) :
    Load(to-tuple(filenames))  

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction byte : Byte
  defrule byte = (?x) when unwrap-token(x) is Byte : unwrap-token(x)

  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

public defn repl-exps () :
  repeatedly $ fn () :
    let loop () :
      print("stz: ")
      val forms = read-line(STANDARD-INPUT-STREAM)
      try :
        parse-syntax[repl / #rexp!](forms)
      catch (e:NoMatchException) :
        do(println, causes(e))
        loop()

;============================================================
;======================= Loading ============================
;============================================================

defn load-files (filenames:Tuple<String>, denv:DEnv, vm:VirtualMachine) :
  ;Read in the file, macroexpand it, and convert it to
  val expanded = for file in filenames map :
    ;Read in forms
    val forms =
      try : read-file(file)
      catch (e:IOException) : throw(ReplErrors([e]))
    ;Macroexpand forms
    try : macroexpand(forms)
    catch (e:NoMatchException) : throw(ReplErrors(causes(e)))
    catch (e:Exception) : throw(ReplErrors([e]))
    
  ;Convert to input IR
  val input = to-tuple(seq-cat(to-il, expanded))
  ;Rename identiifers
  val renamed = match(rename-il(input)) :
    (ipkgs:Tuple<IPackage>) : ipkgs
    (e:RenameErrors) : throw(ReplErrors(errors(e)))
  ;Resolve identifiers
  val env = new Env :
    defmethod packageio (this, package:Symbol) : false
  val resolved = match(resolve-il(renamed, env)) :
    (rp:ResolvedPackages) : rp
    (rp:ResolveErrors) : throw(ReplErrors(errors(rp)))
  ;Typecheck identifiers  
  val typed = match(type-program(packages(resolved), imports(resolved))) :
    (tprog:TProg) : load-into-vm(tprog, denv, vm)
    (e:TypeErrors) : throw(ReplErrors(messages(e)))
  typed

defn load-into-vm (tprog:TProg, denv:DEnv, vm:VirtualMachine) :
  ;Extract descriptors
  val ios = to-tuple $
    for p in packages(tprog) seq :
      to-dl(p, hier(tprog), namemap(tprog))
  ;Check against live state   
  val live = compute-live(vm, seq(package, ios))
  match(load(denv, ios, live)) :
    (result:LoadErrors) : throw(ReplErrors(errors(result)))
    (result:LoadSuccess) : false
  ;Convert to EL
  val el = to-el(tprog, ios)
  ;Compile to VM
  val vmps = map(compile{lower(_)}, el)
  ;Load into VM
  load(vm, vmps)
  ;Run initializers
  do(init-package{vm, package(_)}, vmps)

defn macroexpand (forms:List) :
  val es = parse-syntax[core / #exps!](forms)
  cons(`$begin, es)  

;============================================================
;======================== Errors ============================
;============================================================

defstruct ReplErrors <: Exception :
  messages: Collection
  
;============================================================
;======================= Driver =============================
;============================================================

public defn repl () :
  val vm = VirtualMachine()
  val denv = DEnv()
  
  for exp in repl-exps() do :
    try :
      match(exp) :
        (exp:Load) : load-files(filenames(exp), denv, vm)
    catch (e:ReplErrors) :
      do(println, messages(e))
  
