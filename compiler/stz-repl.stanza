defpackage stz/repl :
  import core
  import collections
  import reader
  import parser
  import macro-utils
  import stz/il-ir
  import stz/dl-ir
  import stz/tl-ir
  import stz/el-ir
  import stz/vm-ir
  import stz/vm
  import stz/core-macros
  import stz/input
  import stz/renamer
  import stz/resolver
  import stz/type
  import stz/tl-to-el
  import stz/dl
  import stz/el
  import stz/el-to-vm

;============================================================
;===================== REPL Language ========================
;============================================================

deftype RExp
defstruct Load <: RExp :
  filenames: Tuple<String>
with:
  printer => true

defstruct ReplSyntaxError <: Exception :
  info: FileInfo|False
  message: String
defmethod print (o:OutputStream, e:ReplSyntaxError) :
  val infostr = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [infostr, message(e)])

defsyntax repl :
  public defproduction rexp! : RExp
  defrule rexp! = (?x:#rexp) : x
  fail-if rexp! = () : ReplSyntaxError(closest-info(), "Not a repl expression")

  defproduction rexp : RExp
  defrule rexp = (load(?filenames:#string ...)) :
    Load(to-tuple(filenames))  

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction byte : Byte
  defrule byte = (?x) when unwrap-token(x) is Byte : unwrap-token(x)

  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

public defn repl-exps () :
  repeatedly $ fn () :
    let loop () :
      print("stz: ")
      val forms = read-line(STANDARD-INPUT-STREAM)
      try :
        parse-syntax[repl / #rexp!](forms)
      catch (e:NoMatchException) :
        do(println, causes(e))
        loop()

;============================================================
;======================= Loading ============================
;============================================================

deftype REPL
defmulti load-files (repl:REPL, filenames:Tuple<String>) -> False

defn REPL () :
  ;State of the repl
  val vm = VirtualMachine()
  val denv = DEnv()
  val tenv = HashTable<Symbol,TypeDefs>()

  ;Load files
  defn load-files (filenames:Tuple<String>) :
    ;===== Stages =====
    defn read! (filename:String) :
      try : read-file(filename)
      catch (e:IOException) : throw(ReplErrors([e]))
    defn macroexpand! (forms) :
      try : cons(`$begin, parse-syntax[core / #exps!](forms))
      catch (e:NoMatchException) : throw(ReplErrors(causes(e)))
      catch (e:Exception) : throw(ReplErrors([e]))  ;TODO
    defn to-input! (expanded:Seqable) :
      to-tuple(seq-cat(to-il, expanded))
    defn rename! (ipkgs:Tuple<IPackage>) :
      match(rename-il(ipkgs)) :
        (renamed:Tuple<IPackage>) : renamed
        (e:RenameErrors) : throw(ReplErrors(errors(e)))
    defn resolve! (ipkgs:Tuple<IPackage>) :
      val env = new stz/resolver/Env :
        defmethod packageio (this, package:Symbol) :
          packageio(denv, package)
      match(resolve-il(ipkgs, env)) :
        (resolved:Tuple<IPackage>) : resolved
        (e:ResolveErrors) : throw(ReplErrors(errors(e)))
    defn type! (ipkgs:Tuple<IPackage>) :
      val env = new stz/type/Env :
        defmethod packageio (this, package:Symbol) : packageio(denv, package) as PackageIO
        defmethod typedefs (this, package:Symbol) : tenv[package]
      match(type-program(ipkgs, env)) :
        (p:TProg) : p
        (e:TypeErrors) : throw(ReplErrors(messages(e)))
    defn check-load! (tprog:TProg) :
      val live = compute-live(vm, seq(name, packages(tprog)))
      val ios = map(packageio, packages(tprog))
      match(load(denv, ios, live)) :
        (result:LoadErrors) : throw(ReplErrors(errors(result)))
        (result:LoadSuccess) : false
    defn save-to-tenv! (tprog:TProg) :
      for p in packages(tprog) do :
        val def = typedefs(p)
        tenv[package(def)] = def
    defn load-vm! (tprog:TProg) :
      val epkgs = to-el(tprog)
      val vmpkgs = map(compile{lower(_)}, epkgs)
      load(vm, vmpkgs)
      do(init-package{vm, package(_)}, vmpkgs)
      
    ;===== Driver =====
    val expanded = seq({macroexpand! $ read! $ _}, filenames)
    val typed =  type! $ resolve! $ rename! $ to-input! $ expanded
    check-load!(typed)
    save-to-tenv!(typed)
    load-vm!(typed)
  

  ;Return REPL
  new REPL :
    defmethod load-files (this, filenames:Tuple<String>) :
      load-files(filenames)

;============================================================
;======================== Errors ============================
;============================================================

defstruct ReplErrors <: Exception :
  messages: Collection
  
;============================================================
;======================= Driver =============================
;============================================================

public defn repl () :
  val repl = REPL()
  for exp in repl-exps() do :
    try :
      match(exp) :
        (exp:Load) : load-files(repl, filenames(exp))
    catch (e:ReplErrors) :
      do(println, messages(e))
  
