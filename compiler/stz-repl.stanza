defpackage stz/repl :
  import core
  import collections
  import reader
  import parser
  import macro-utils
  import stz/utils
  import stz/il-ir
  import lang/check
  import stz/dl-ir with:
    prefix(Import) => DL
  import stz/tl-ir
  import stz/el-ir
  import stz/vm-ir
  import stz/vm
  import stz/core-macros
  import stz/input
  import stz/renamer
  import stz/resolver
  import stz/type
  import stz/tl-to-el
  import stz/dl
  import stz/el
  import stz/el-to-vm
  import stz/algorithms

;============================================================
;===================== REPL Language ========================
;============================================================

deftype RExp
defstruct Load <: RExp :
  filenames: Tuple<String>
with:
  printer => true
defstruct Import <: RExp :
  import: IImport
with:
  printer => true
defstruct Unimport <: RExp :
  package: Symbol
with:
  printer => true
defstruct Eval <: RExp :
  form
defstruct NoOp <: RExp 
with:
  printer => true

defstruct ReplSyntaxError <: Exception :
  info: FileInfo|False
  message: String
defmethod print (o:OutputStream, e:ReplSyntaxError) :
  val infostr = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [infostr, message(e)])

defsyntax repl :
  public defproduction rexp : RExp
  defrule rexp = (load ?filenames:#string! ...) :
    Load(to-tuple(filenames))
  defrule rexp = (?e:#import-clause) :
    Import(e)
  defrule rexp = (unimport ?name:#symbol!) :
    Unimport(name)
  defrule rexp = (?forms ...) :
    if empty?(forms) : NoOp()
    else : Eval(forms)

  ;===== Imports =====
  defproduction prefix-clause! : IPrefix
  defrule prefix-clause! = (prefix => ?p:#symbol!) :
    IPrefix(false, IVar(p,closest-info(p)), closest-info())
  defrule prefix-clause! = (prefix(?xs:#symbol! ...) => ?p:#symbol!) :
    val names = for x in xs map : IVar(x,closest-info(x))
    IPrefix(names, IVar(p,closest-info(p)), closest-info())
  fail-if prefix-clause! = () :
    ReplSyntaxError(closest-info(), "Expected a prefix clause here.")

  defproduction prefix-clauses : List<IPrefix>
  defrule prefix-clauses = (with #:! (?ps:#prefix-clause! ...)) : ps
  defrule prefix-clauses = () : List()

  defproduction import-clause : IImport
  defrule import-clause = (import ?name:#symbol! ?ps:#prefix-clauses) :
    val package = IVar(name, closest-info(name))
    IImport(package, ps, closest-info())

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction byte : Byte
  defrule byte = (?x) when unwrap-token(x) is Byte : unwrap-token(x)

  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

  defproduction string! : String
  defrule string! = (?x:#string) : x
  fail-if string! = () : ReplSyntaxError(closest-info(), "Expected a string here.")

  defproduction symbol! : Symbol
  defrule symbol! = (?x:#symbol) : x
  fail-if symbol! = () : ReplSyntaxError(closest-info(), "Expected a symbol here.")

  defproduction :!
  defrule :! = (?x: ~ :) : x
  fail-if :! = () : ReplSyntaxError(closest-info(), "Colon expected here.")

defn read-repl-exp () :
  try :
    let loop () :
      print("> ")
      val forms = read-line(STANDARD-INPUT-STREAM)
      match(parse-syntax[repl / #rexp](forms)) :
        (e:NoOp) : loop()
        (e) : e
  catch (e:LexerException) :
    throw(ReplErrors([e]))
  catch (e:NoMatchException) :
    throw(ReplErrors(causes(e)))  

;============================================================
;======================= Package Ordering ===================
;============================================================

defn initialization-order (import-graph:HashTable<Symbol, List<Symbol>>,
                           packages:Collection<Symbol>) -> Collection<Symbol> :
  ;Discover all strong components
  defn list (x:Symbol) : List(x)
  defn list (xs:List<Symbol>) : xs
  val components = to-tuple(seq(list, strong-components(import-graph)))
  val component-table = to-hashtable<Symbol,Int> $
    for (component in components, i in 0 to false) seq-cat :
      for c in component seq : c => i

  ;Natural ordering
  val index-table = to-hashtable<Symbol,Int> $
    for (p in packages, i in 0 to false) seq :
      p => i
  index-table[`core] = -1
  defn order-by-index (ps:Seqable<Symbol>) :
    val ps* = filter(key?{index-table, _}, ps)
    defn cmp (a:Symbol, b:Symbol) : compare(index-table[a], index-table[b])
    lazy-qsort(ps*, cmp)

  ;Traversal
  val visited = IntSet()
  val accum = Vector<Symbol>()
  defn include (c:Int) :
    if add(visited,c) :
      val cs = components[c]
      for c in cs do : include-all(import-graph[c])
      add-all(accum, order-by-index(cs))
  defn include-all (cs:Seqable<Symbol>) :    
    for c in cs do :
      include(component-table[c])
  include-all(packages)

  ;Return ordering
  accum

defn initialization-order (vmps:Tuple<VMPackage>, denv:DEnv) -> Collection<Symbol> :
  ;Create import graph
  val import-graph = to-hashtable<Symbol, List<Symbol>> $
    for io in packageios(denv) seq :
      package(io) => to-list(imported-packages(io))

  ;Compute initialization ordering
  initialization-order(import-graph, to-tuple(seq(package,vmps)))      

;============================================================
;======================= Loading ============================
;============================================================

deftype REPL
defmulti load-files (repl:REPL, filenames:Tuple<String>) -> False
defmulti load-repl (repl:REPL, form) -> False
defmulti import (repl:REPL, import:IImport) -> False
defmulti unimport (repl:REPL, package:Symbol) -> False

defn REPL () :
  ;State of the repl
  val vm = VirtualMachine()
  val denv = DEnv()
  val repl-env = REPLEnv()

  ;Load files
  defn load-files (filenames:Tuple<String>) :
    ;===== Stages =====
    defn read! (filename:String) :
      try : read-file(filename)
      catch (e:IOException) : throw(ReplErrors([e]))
      catch (e:LexerException) : throw(ReplErrors([e]))
    defn macroexpand! (forms) :
      try : cons(`$begin, parse-syntax[core / #exps!](forms))
      catch (e:NoMatchException) : throw(ReplErrors(causes(e)))
      catch (e:Exception) : throw(ReplErrors([e]))  ;TODO
    defn to-input! (expanded:Seqable) :
      try : to-tuple(seq-cat(to-il, expanded))
      catch (e:CheckErrors) : throw(ReplErrors(errors(e)))
    defn check-types! (ipkgs:Tuple<IPackage>, live:Tuple<Rec>) :
      val packages = to-hashset<Symbol>(seq(name, ipkgs))
      val types = exported-types(ipkgs)
      match(check-export-types(denv, packages, types, live)) :
        (l:LoadSuccess) : false
        (l:LoadErrors) : throw(ReplErrors(errors(l)))      
    defn rename! (ipkgs:Tuple<IPackage>) :
      match(rename-il(ipkgs)) :
        (renamed:Tuple<IPackage>) : renamed
        (e:RenameErrors) : throw(ReplErrors(errors(e)))
    defn resolve! (ipkgs:Tuple<IPackage>) :
      val env = new stz/resolver/Env :
        defmethod packageio (this, package:Symbol) :
          packageio(denv, package)
      match(resolve-il(ipkgs, env)) :
        (resolved:Tuple<IPackage>) : resolved
        (e:ResolveErrors) : throw(ReplErrors(errors(e)))
    defn type! (ipkgs:Tuple<IPackage>) :
      val env = new stz/type/Env :
        defmethod packageio (this, package:Symbol) : packageio(denv, package) as PackageIO
      match(type-program(ipkgs, env)) :
        (p:TProg) : p
        (e:TypeErrors) : throw(ReplErrors(messages(e)))
    defn check-load! (tprog:TProg, live:Tuple<Rec>) :      
      val ios = map(packageio, packages(tprog))      
      match(check-exports(denv, ios, live)) :
        (result:LoadErrors) : throw(ReplErrors(errors(result)))
        (result:LoadSuccess) : false
    defn load-vm! (tprog:TProg) :
      val epkgs = to-el(tprog, false)
      val vmpkgs = map(compile{lower(_)}, epkgs)
      load(denv, seq(packageio, vmpkgs))
      load(vm, vmpkgs)
      for p in initialization-order(vmpkgs, denv) do :
        init-package(vm, p)
      
    ;===== Driver =====
    val expanded = seq({macroexpand! $ read! $ _}, filenames)
    val input = to-input! $ expanded    
    val live = compute-live(vm, seq(name, input))
    check-types!(input, live)    
    val typed =  type! $ resolve! $ rename! $ input
    check-load!(typed, live)
    load-vm!(typed)

  ;Load repl command
  defn load-repl (form) :
    defn macroexpand! (form) :
      try : cons(`$begin, parse-syntax[core / #exps!](form))
      catch (e:NoMatchException) : throw(ReplErrors(causes(e)))
      catch (e:Exception) : throw(ReplErrors([e]))  ;TODO
    defn to-input! (expanded) :
      try :
        val pkgs = to-il(expanded, true, imports(repl-env))
        fatal("Incorrect number of packages.") when length(pkgs) != 1
        pkgs[0]
      catch (e:CheckErrors) :
        throw(ReplErrors(errors(e)))
    defn rename! (ipkg:IPackage) :
      match(rename-il([ipkg])) :
        (renamed:Tuple<IPackage>) : renamed[0]
        (e:RenameErrors) : throw(ReplErrors(errors(e)))
    defn resolve! (ipkg:IPackage) :
      val env = new stz/resolver/Env :
        defmethod packageio (this, package:Symbol) :
          packageio(denv, package)
      match(resolve-repl-il(ipkg, env, packageio(repl-env))) :
        (resolved:IPackage) : resolved
        (e:ResolveErrors) : throw(ReplErrors(errors(e)))
    defn type! (ipkg:IPackage) :
      val env = new stz/type/Env :
        defmethod packageio (this, package:Symbol) : packageio(denv, package) as PackageIO
      match(type-repl(ipkg, env, packageio(repl-env))) :
        (p:TProg) : p
        (e:TypeErrors) : throw(ReplErrors(messages(e)))
    defn save-to-repl-env! (tprog:TProg) :
      val package = packages(tprog)[0]
      add(repl-env, packageio(package))
    defn load-vm! (tprog:TProg) :
      val epkgs = to-el(tprog, true)
      val vmpkgs = map(compile{lower(_)}, epkgs)
      load(denv, seq(packageio, vmpkgs))
      load(vm, vmpkgs)
      for p in initialization-order(vmpkgs, denv) do :
        init-package(vm, p)
      
    ;===== Driver =====
    val typed = type! $ resolve! $ rename! $ to-input! $ macroexpand!(form)
    save-to-repl-env!(typed)
    load-vm!(typed)      

  ;Return REPL
  new REPL :
    defmethod load-files (this, filenames:Tuple<String>) :
      load-files(filenames)
    defmethod load-repl (this, form) :
      load-repl(form)
    defmethod import (this, import:IImport) :
      val package = name!(package(import))
      if packageio(denv,package) is False :
        throw $ ReplErrors $ [PackageNotLoaded(package)]
      else : add(repl-env, import)
    defmethod unimport (this, package:Symbol) :
      if not unimport(repl-env, package) :
        throw $ ReplErrors $ [PackageNotImported(package)]

deftype REPLEnv
defmulti packageio (e:REPLEnv) -> PackageIO
defmulti imports (e:REPLEnv) -> Collection<IImport>
defmulti add (e:REPLEnv, packageio:PackageIO) -> False
defmulti add (e:REPLEnv, import:IImport) -> False
defmulti unimport (e:REPLEnv, package:Symbol) -> True|False
defn REPLEnv () :
  ;Name of repl package
  val package-name = gensym(`repl)
  ;PackageIO of repl environment
  val exports-table = HashTable<Symbol, List<Export>>(List())
  val imports-set = HashSet<Symbol>()
  ;Current imported packages
  val imports = HashTable<Symbol, IImport>()

  ;Construct environment object
  val env = new REPLEnv :
    defmethod packageio (this) :
      val imported-packages = to-tuple(imports-set)
      val exports = to-tuple(cat-all(values(exports-table)))
      PackageIO(package-name, imported-packages, [], exports)
    defmethod imports (this) :
      to-tuple(values(imports))
    defmethod add (this, import:IImport) :
      val package = name!(package(import))
      imports[package] = import
    defmethod unimport (this, package:Symbol) -> True|False :
      remove(imports, package)
    defmethod add (this, packageio:PackageIO) :
      val grouped = group-by(name{id(rec(_))}, exports(packageio))
      for entry in grouped do :
        val name = key(entry)
        val entries = value(entry)
        exports-table[name] = entries
      add-all(imports-set, imported-packages(packageio))

  ;Initialize with core imports (core and collections)
  do(add{env, _}, core-imports())
  env

;============================================================
;======================== Errors ============================
;============================================================

defstruct ReplErrors <: Exception :
  messages: Collection

defn PackageNotLoaded (package:Symbol) :
  Exception $ "Could not import package %~. Package has not been loaded." % [package]

defn PackageNotImported (package:Symbol) :
  Exception $ "Could not unimport package %~. Package is not yet imported." % [package]
  
;============================================================
;======================= Driver =============================
;============================================================

public defn repl () :
  val repl = REPL()
  while true :
    try :
      match(read-repl-exp()) :
        (exp:Load) : load-files(repl, filenames(exp))
        (exp:Eval) : load-repl(repl, form(exp))
        (exp:Import) : import(repl, import(exp))
        (exp:Unimport) : unimport(repl, package(exp))
    catch (e:ReplErrors) :
      do(println, messages(e))
  
