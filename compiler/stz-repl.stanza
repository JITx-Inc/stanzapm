defpackage stz/repl :
  import core
  import collections
  import reader
  import parser
  import macro-utils
  import stz/utils
  import stz/il-ir
  import lang/check
  import stz/dl-ir with:
    prefix(Import) => DL
  import stz/tl-ir
  import stz/el-ir
  import stz/vm-ir
  import stz/vm
  import stz/core-macros
  import stz/input
  import stz/renamer
  import stz/resolver
  import stz/type
  import stz/tl-to-el
  import stz/dl
  import stz/el
  import stz/el-to-vm
  import stz/algorithms

;============================================================
;===================== REPL Language ========================
;============================================================

deftype RExp
defstruct Load <: RExp :
  inputs: Tuple<String|Symbol>
with:
  printer => true
defstruct Update <: RExp  
defstruct Reload <: RExp
defstruct Import <: RExp :
  import: IImport
with:
  printer => true
defstruct Inside <: RExp :
  package: Symbol|False
with:
  printer => true
defstruct Unimport <: RExp :
  package: Symbol
with:
  printer => true
defstruct Eval <: RExp :
  form
defstruct NoOp <: RExp
with:
  printer => true

defstruct ReplSyntaxError <: Exception :
  info: FileInfo|False
  message: String
defmethod print (o:OutputStream, e:ReplSyntaxError) :
  val infostr = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [infostr, message(e)])

defsyntax repl :
  public defproduction rexp : RExp
  defrule rexp = (load ?inputs:#input! ...) :
    Load(to-tuple(inputs))
  defrule rexp = (?e:#import-clause) :
    Import(e)
  defrule rexp = (inside -) :
    Inside(false)
  defrule rexp = (inside ?p:#symbol!) :
    Inside(p)
  defrule rexp = (unimport ?name:#symbol!) :
    Unimport(name)
  defrule rexp = (update) :
    Update()
  defrule rexp = (reload) :
    Reload()
  defrule rexp = (?forms ...) :
    if empty?(forms) : NoOp()
    else : Eval(forms)

  ;===== Inputs =====
  defproduction input! : String|Symbol
  defrule input! = (?file:#string) : file
  defrule input! = (?pkg:#symbol) : pkg
  fail-if input! = () : ReplSyntaxError(closest-info(), "Input must be either a string or a symbol.")

  ;===== Imports =====
  defproduction prefix-clause! : IPrefix
  defrule prefix-clause! = (prefix => ?p:#symbol!) :
    IPrefix(false, to-string(p))
  defrule prefix-clause! = (prefix(?names:#symbol! ...) => ?p:#symbol!) :
    IPrefix(to-tuple(names), to-string(p))
  fail-if prefix-clause! = () :
    ReplSyntaxError(closest-info(), "Expected a prefix clause here.")

  defproduction prefix-clauses : Tuple<IPrefix>
  defrule prefix-clauses = (with #:! (?ps:#prefix-clause! ...)) : to-tuple(ps)
  defrule prefix-clauses = () : []

  defproduction import-clause : IImport
  defrule import-clause = (import ?package:#symbol! ?ps:#prefix-clauses) :
    IImport(package, ps)

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction byte : Byte
  defrule byte = (?x) when unwrap-token(x) is Byte : unwrap-token(x)

  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

  defproduction string! : String
  defrule string! = (?x:#string) : x
  fail-if string! = () : ReplSyntaxError(closest-info(), "Expected a string here.")

  defproduction symbol! : Symbol
  defrule symbol! = (?x:#symbol) : x
  fail-if symbol! = () : ReplSyntaxError(closest-info(), "Expected a symbol here.")

  defproduction :!
  defrule :! = (?x: ~ :) : x
  fail-if :! = () : ReplSyntaxError(closest-info(), "Colon expected here.")

defn read-repl-exp () :
  try :
    let loop () :
      print("> ")
      val forms = read-line(STANDARD-INPUT-STREAM)
      match(parse-syntax[repl / #rexp](forms)) :
        (e:NoOp) : loop()
        (e) : e
  catch (e:LexerException) :
    throw(ReplErrors([e]))
  catch (e:NoMatchException) :
    throw(ReplErrors(causes(e)))

;============================================================
;======================= Package Ordering ===================
;============================================================

defn initialization-order (import-graph:HashTable<Symbol, List<Symbol>>,
                           packages:Collection<Symbol>) -> Collection<Symbol> :
  ;Discover all strong components
  defn list (x:Symbol) : List(x)
  defn list (xs:List<Symbol>) : xs
  val components = to-tuple(seq(list, strong-components(import-graph)))
  val component-table = to-hashtable<Symbol,Int> $
    for (component in components, i in 0 to false) seq-cat :
      for c in component seq : c => i

  ;Natural ordering
  val index-table = to-hashtable<Symbol,Int> $
    for (p in packages, i in 1 to false) seq :
      p => 0 when p == `core else i
  defn order-by-index (ps:Seqable<Symbol>) :
    val ps* = filter(key?{index-table, _}, ps)
    defn cmp (a:Symbol, b:Symbol) : compare(index-table[a], index-table[b])
    lazy-qsort(ps*, cmp)

  ;Traversal
  val visited = IntSet()
  val accum = Vector<Symbol>()
  defn include (c:Int) :
    if add(visited,c) :
      val cs = components[c]
      for c in cs do : include-all(import-graph[c])
      add-all(accum, order-by-index(cs))
  defn include-all (cs:Seqable<Symbol>) :
    for c in cs do :
      include(component-table[c])
  include-all(packages)

  ;Return ordering
  accum

defn initialization-order (packages:Seqable<Symbol>, denv:DEnv) -> Collection<Symbol> :
  ;Create import graph
  val import-graph = to-hashtable<Symbol, List<Symbol>> $
    for io in packageios(denv) seq :
      package(io) => to-list(imported-packages(io))

  ;Compute initialization ordering
  initialization-order(import-graph, to-tuple(packages))

;============================================================
;=================== Default Imports ========================
;============================================================

defn core-imports () :
  [IImport(`core), IImport(`collections)]

;============================================================
;======================= Loading ============================
;============================================================

deftype REPL
defmulti load-files (repl:REPL, inputs:Tuple<String|Symbol>) -> False
defmulti update-files (repl:REPL) -> False
defmulti reload (repl:REPL) -> False
defmulti load-repl (repl:REPL, form) -> False
defmulti import (repl:REPL, import:IImport) -> False
defmulti unimport (repl:REPL, package:Symbol) -> False
defmulti inside (repl:REPL, package:Symbol|False) -> False

defn REPL () :
  ;============================================================
  ;===================== REPL State ===========================
  ;============================================================
  val vm = VirtualMachine()
  val denv = DEnv()
  val repl-env = REPLEnv()
  val file-env = FileEnv()
  val pkg-env = PkgEnv()

  ;============================================================
  ;================== Stages of Loading =======================
  ;============================================================
  ;Read from file
  defn read! (filename:String) -> ? :
    try :
      val timestamp = time-modified(filename)
      FileForm<?>(filename, timestamp, read-file(filename))
    catch (e:IOException) : throw(ReplErrors([e]))
    catch (e:LexerException) : throw(ReplErrors([e]))

  ;Macroexpansion
  defn macroexpand! (x) -> ? :
    match(x:FileForm) :
      sub-form(x, macroexpand!(form(x)))
    else :
      try : cons(`$begin, parse-syntax[core / #exps!](x))
      catch (e:NoMatchException) : throw(ReplErrors(causes(e)))
      catch (e:Exception) : throw(ReplErrors([e]))  ;TODO

  ;Conversion to IL IR
  defn to-ipackages! (expanded:Tuple<FileForm<?>>) -> [Tuple<IPackage>, Tuple<FileForm<Symbol>>] :
    val check-errors = Vector<CheckError>()
    val ipackages = Vector<IPackage>()
    val file-pkgs = Vector<FileForm<Symbol>>()
    for e in expanded do :
      try :
        val pkgs = to-il(form(e), DefaultPackage)
        for p in pkgs do :
          add(ipackages, p)
          add(file-pkgs, sub-form(e, name(p)))
      catch (e:CheckErrors) :
        add-all(check-errors, errors(e))
    throw(ReplErrors(check-errors)) when not empty?(check-errors)
    [to-tuple(ipackages), to-tuple(file-pkgs)]
  ;defn to-repl-ipackage! (expanded) -> IPackage :
  ;  try : to-il(expanded, true, imports(repl-env))[0]
  ;  catch (e:CheckErrors) : throw(ReplErrors(errors(e)))

  ;Extract IPackage
  defn extract-input (file+inputs:Tuple<FileForm<IPackage>>) -> [Tuple<IPackage>, Tuple<FileForm<Symbol>>] :
    val input = map(form, file+inputs)
    val packages = for x in file+inputs map :
      FileForm<Symbol>(filename(x), timestamp(x), name(form(x)))
    [input, packages]

  ;Check that all required types are still defined
  defn check-types-exist (ipkgs:Tuple<IPackage>, live:Tuple<Rec>) :
    val packages = to-hashset<Symbol>(seq(name, ipkgs))
    val types = exported-types(ipkgs)
    check-export-types(denv, packages, types, live)
  defn check-types-exist! (ipkgs:Tuple<IPackage>, live:Tuple<Rec>) :
    match(check-types-exist(ipkgs, live)) :
      (l:LoadSuccess) : false
      (l:LoadErrors) : throw(ReplErrors(errors(l)))

  ;Renaming
  defn rename! (ipkgs:Tuple<IPackage>) :
    match(rename-il(ipkgs)) :
      (renamed:Tuple<IPackage>) : renamed
      (e:RenameErrors) : throw(ReplErrors(errors(e)))
  defn rename! (ipkg:IPackage) :
    rename!([ipkg])[0]

  ;Resolve
  defn resolve-with-env<T> (f:stz/resolver/Env -> T|ResolveErrors) :
    val env = new stz/resolver/Env :
      defmethod packageio (this, package:Symbol) :
        packageio(denv, package)
    match(f(env)) :
      (e:ResolveErrors) : throw(ReplErrors(errors(e)))
      (e:T) : e
  defn resolve! (ipkgs:Tuple<IPackage>) :
    resolve-with-env<Tuple<IPackage>>(resolve-il{ipkgs, _, false})
  ;defn resolve-repl! (ipkg:IPackage) :
  ;  resolve-with-env<IPackage>(resolve-repl-il{ipkg, _, packageio(repl-env)})

  ;Type Checking
  defn typecheck-with-env (f:stz/type/Env -> TProg|TypeErrors) :
    val env = new stz/type/Env :
      defmethod packageio (this, package:Symbol) :
        packageio(denv, package) as PackageIO
    match(f(env)) :
      (e:TProg) : e
      (e:TypeErrors) : throw(ReplErrors(messages(e)))
  defn type! (ipkgs:Tuple<IPackage>) :
    typecheck-with-env(type-program{ipkgs, _})
  ;defn type-repl! (ipkg:IPackage) :
  ;  typecheck-with-env(type-repl{ipkg, _, packageio(repl-env)})

  ;Check whether any globals have been redefined to be a different type
  defn check-globals! (tprog:TProg) :
    val ios = map(packageio, packages(tprog))
    match(check-globals(denv, ios)) :
      (result:LoadErrors) : throw(ReplErrors(errors(result)))
      (result:LoadSuccess) : false      

  ;Check packages can be loaded into existing environment
  defn check-load (tprog:TProg, live:Tuple<Rec>) :
    val ios = map(packageio, packages(tprog))
    check-exports(denv, ios, live)
  defn check-load! (tprog:TProg, live:Tuple<Rec>) :
    match(check-load(tprog, live)) :
      (result:LoadErrors) : throw(ReplErrors(errors(result)))
      (result:LoadSuccess) : false

  ;Save definitions to repl environment
  defn save-to-repl-env! (tprog:TProg) :
    val package = packages(tprog)[0]
    add(repl-env, packageio(package))

  ;Save associations to file environment
  defn save-to-file-env! (file-pkgs:Tuple<FileForm<Symbol>>) :
    do(register{file-env, _}, file-pkgs)

  ;Load into Virtual Machine
  defn load-vm! (tprog:TProg) :
    val epkgs = to-el(tprog, true)
    val vmpkgs = map(compile{lower(_)}, epkgs)
    load(denv, seq(packageio, vmpkgs))
    load(vm, vmpkgs, false)

  ;Run the given packages in the virtual machine
  defn run-vm! (packages:Seqable<Symbol>) :
    for p in initialization-order(packages, denv) do :
      init-package(vm, p)

  ;Load into virtual machine without initialization
  defn update-vm! (tprog:TProg) :
    val epkgs = to-el(tprog, true)
    val vmpkgs = map(compile{lower(_)}, epkgs)
    load(denv, seq(packageio, vmpkgs))
    load(vm, vmpkgs, true)

  ;============================================================
  ;===================== File Loading =========================
  ;============================================================

  ;Load files
  defn load-files (inputs:Tuple<String|Symbol>) :
    ;Ensure that inputs are well-formed
    val errors = Vector<?>()
    for input in inputs do :
      match(input) :
        (filename:String) :
          if not suffix?(filename, ".stanza") :
            add(errors, InvalidExtension(filename))            
        (package:Symbol) :
          if not loaded?(pkg-env,package) :
            add(errors, PackageNotLoaded(package))
    throw(ReplErrors(errors)) when not empty?(errors)

    ;Load all files
    val filenames = filter-by<String>(inputs)
    val expanded = seq({macroexpand! $ read! $ _}, filenames)
    val [input, file-pkgs] = to-ipackages! $ to-tuple $ expanded
    val live = compute-live(vm, seq(name, input))
    check-types-exist!(input, live)
    val typed = type! $ resolve! $ rename! $ input
    check-load!(typed, live)
    save-to-file-env!(file-pkgs)
    do(register{pkg-env, name(_)}, packages(typed))
    load-vm!(typed)
    run-vm!(cat(old-packages, new-packages)) where :
      val old-packages = filter-by<Symbol>(inputs)
      val new-packages = seq(name,/packages(typed))

  ;Reload
  defn reload () :
    run-vm!(packages(pkg-env))

  ;Update files
  defn update-files () :
    ;Compute the changed files
    val changed-files = changed-files(file-env)
    if empty?(changed-files) :
      throw $ ReplErrors([NoChangedFiles()])
    else :
      ;Track the files to reload.
      ;Initialize them with the set of all changed files.
      val reload-files = to-hashset<String>(changed-files)
      let loop () :
        val done? = label<True|False> break :
          let :
            val filenames = to-tuple(reload-files)
            val expanded = map({macroexpand! $ read! $ _}, filenames)
            val [input, file-pkgs] = to-ipackages! $ expanded
            val live = compute-live(vm, [])
            check-load-errors!(check-types-exist(input, live))
            val typed = type! $ resolve! $ rename! $ input
            check-globals!(typed)
            check-load-errors!(check-load(typed, live))
            save-to-file-env!(file-pkgs)
            update-vm!(typed)
            true
          where :
            defn check-load-errors! (e:LoadResult) :
              match(e:LoadErrors) :
                ;Categorize errors into being caused by packages or by live objects
                defn package-source? (e:LoadError) : source(e) is LoadedPackage
                val [package-errors, live-errors] = split!(package-source?,errors(e))
                ;Nothing we can do about errors from live objects
                throw(ReplErrors(live-errors)) when length(live-errors) > 0
                ;If there are package errors then add their source files to the
                ;reload set, and try again
                for e in package-errors do :
                  val package = package(source(e) as LoadedPackage)
                  add(reload-files, source-file(file-env, package))
                break(false)                
        loop() when not done?

  ;Load from repl
  defn load-repl (form) :
    fatal("Not yet implemented")
    ;val typed = type-repl! $ resolve-repl! $ rename! $ to-repl-ipackage! $ macroexpand! $ form
    ;save-to-repl-env!(typed)
    ;load-vm!(typed)
    ;run-vm!(seq(name, packages(typed)))

  ;============================================================
  ;===================== REPL Structure =======================
  ;============================================================
  new REPL :
    defmethod load-files (this, inputs:Tuple<String|Symbol>) :
      load-files(inputs)
    defmethod update-files (this) :
      update-files()
    defmethod load-repl (this, form) :
      load-repl(form)
    defmethod reload (this) :
      reload()
    defmethod import (this, import:IImport) :
      if not loaded?(pkg-env, package(import)) :
        throw $ ReplErrors $ [PackageNotLoaded(package(import))]
      else : add(repl-env, import)
    defmethod unimport (this, package:Symbol) :
      if not unimport(repl-env, package) :
        throw $ ReplErrors $ [PackageNotImported(package)]
    defmethod inside (this, package:Symbol) :
      if not loaded?(pkg-env, package) :
        throw $ ReplErrors $ [PackageNotLoaded(package)]
      else : inside(repl-env, package)
    defmethod inside (this, package:False) :
      if current-inside(repl-env) is False :
        throw $ ReplErrors $ [NotInsidePackage()]
      inside(repl-env, false)

defstruct FileForm<T> :
  filename: String
  timestamp: Long
  form:T with: (updater => sub-form)

;============================================================
;=================== Package Environment ====================
;============================================================

deftype PkgEnv
defmulti loaded? (e:PkgEnv, package:Symbol) -> True|False
defmulti register (e:PkgEnv, package:Symbol) -> False
defmulti packages (e:PkgEnv) -> Seqable<Symbol>
defn PkgEnv () :
  val packages = HashSet<Symbol>()
  new PkgEnv :
    defmethod loaded? (this, p:Symbol) :
      packages[p]
    defmethod register (this, p:Symbol) :
      add(packages, p)
      false
    defmethod packages (this) :
      packages

;============================================================
;=================== File Environment =======================
;============================================================

deftype FileEnv
defmulti register (e:FileEnv, file-pkg:FileForm<Symbol>) -> False
defmulti changed-files (e:FileEnv) -> Tuple<String>
defmulti source-file (e:FileEnv, package:Symbol) -> String

defn FileEnv () :
  ;Track which source file each package came from
  val source-file-table = HashTable<Symbol,String>()
  val timestamp-table = HashTable<String,Long>()

  new FileEnv :
    defmethod register (this, file-pkg:FileForm<Symbol>) :
      source-file-table[form(file-pkg)] = filename(file-pkg)
      timestamp-table[filename(file-pkg)] = timestamp(file-pkg)
    defmethod changed-files (this) :
      to-tuple $ for file in values(source-file-table) seq? :
        try :
          val new-timestamp = time-modified(file)
          val old-timestamp = timestamp-table[file]
          if new-timestamp != old-timestamp : One(file)
          else : None()
        catch (e:FileStatException) :
          None()
    defmethod source-file (this, package:Symbol) :
      source-file-table[package]

;============================================================
;=================== REPL User Environment ==================
;============================================================

deftype REPLEnv
defmulti packageio (e:REPLEnv) -> PackageIO
defmulti imports (e:REPLEnv) -> Collection<IImport>
defmulti add (e:REPLEnv, packageio:PackageIO) -> False
defmulti add (e:REPLEnv, import:IImport) -> False
defmulti unimport (e:REPLEnv, package:Symbol) -> True|False
defmulti inside (e:REPLEnv, package:Symbol|False) -> False
defmulti current-inside (e:REPLEnv) -> Symbol|False
defn REPLEnv () :
  ;Name of repl package
  val package-name = gensym(`repl)
  ;PackageIO of repl environment
  val exports-table = HashTable<Symbol, List<Export>>(List())
  val imports-set = HashSet<Symbol>()
  ;Current imported packages
  val imports = HashTable<Symbol, IImport>()
  ;Currently inside package
  var inside-package:Symbol|False = false

  ;Construct environment object
  val env = new REPLEnv :
    defmethod packageio (this) :
      val imported-packages = to-tuple(imports-set)
      val exports = to-tuple(cat-all(values(exports-table)))
      PackageIO(package-name, imported-packages, [], exports)
    defmethod imports (this) :
      val accum = Vector<IImport>()
      match(inside-package:Symbol) :
        add(accum, IImport(inside-package, [], false, true))
      for import in values(imports) do :
        if package(import) != inside-package :
          add(accum, import)
      to-tuple(accum)
    defmethod add (this, import:IImport) :
      imports[package(import)] = import
    defmethod unimport (this, package:Symbol) -> True|False :
      remove(imports, package)
    defmethod add (this, packageio:PackageIO) :
      val grouped = group-by(name{id(rec(_))}, exports(packageio))
      for entry in grouped do :
        val name = key(entry)
        val entries = value(entry)
        exports-table[name] = entries
      add-all(imports-set, imported-packages(packageio))
    defmethod inside (this, package:Symbol|False) :
      inside-package = package
    defmethod current-inside (this) :
      inside-package

  ;Initialize with core imports (core and collections)
  do(add{env, _}, core-imports())
  env

;============================================================
;=================== Default Packages =======================
;============================================================

defn DefaultPackage (exps:List<IExp>, info:FileInfo|False) :
  val name = gensym(`default)
  IPackage(name, core-imports(), exps, info)

;val REPL-COUNTER = to-seq(0 to false)
;defn DefaultReplPackage (exps:List<IExp>, info:FileInfo|False) :
;  ;Detect illegal expressions
;  val errors = Vector<Exception>()
;  defn not-allowed! (e:IExp) :
;    val type-str = match(e) :
;      (e:IDefPackage) : "defpackage"
;      (e:IDefType) : "deftype"
;      (e:IDefmulti) : "defmulti"
;      (e:IDefmethod) : "defmethod"
;      (e:ILSDefType) : "lostanza deftype"
;      (e:ILSDefmethod) : "lostanza defmethod"
;      (e:ILSExternFn) : "externfn"
;    add(errors, InvalidExp(type-str))        
;
;  ;Sweep through expressions and detect invalid expressions
;  for e in exps do :
;    let loop (e:IExp = e) :
;      match(e) :
;        (e:IBegin) : do(loop, exps(e))
;        (e:IVisibility) : loop(exp(e))
;        (e:IDefPackage|IDefType|IDefmulti|IDefmethod|
;           ILSDefType|ILSDefmethod|ILSExternFn) : not-allowed!(e)
;        (e) : false
;
;  ;Throw errors if there are any
;  throw(ReplErrors(errors)) when not empty?(errors)
;
;  ;Create package
;  val name = symbol-join(["repl", next(REPL-COUNTER)])
;  IPackage(name, ???, exps, info)

defn ensure-repl-expressions (e:IExp) :
  within e = lang/check/run-check(e) :
    defn not-allowed! (e:IExp) :
      val type-str = match(e) :
        (e:IDefPackage) : "defpackage"
        (e:IDefType) : "deftype"
        (e:IDefmulti) : "defmulti"
        (e:IDefmethod) : "defmethod"
        (e:ILSDefType) : "lostanza deftype"
        (e:ILSDefmethod) : "lostanza defmethod"
        (e:ILSExternFn) : "externfn"
      lang/check/error!(info(e), "The interactive REPL does not support %_ statements." % [type-str])
    
    let loop (e:IExp = e) :
      match(e) :
        (e:IBegin) : do(loop, exps(e))
        (e:IVisibility) : loop(exp(e))
        (e:IDefPackage|IDefType|IDefmulti|IDefmethod|
           ILSDefType|ILSDefmethod|ILSExternFn) : not-allowed!(e)
        (e) : false

;============================================================
;======================== Errors ============================
;============================================================

defstruct ReplErrors <: Exception :
  messages: Collection

defn PackageNotLoaded (package:Symbol) :
  Exception $ "Could not import package %~. Package has not been loaded." % [package]

defn PackageNotImported (package:Symbol) :
  Exception $ "Could not unimport package %~. Package is not yet imported." % [package]

defn NotInsidePackage () :
  Exception $ "Not currently inside any package."

defn NoChangedFiles () :
  Exception $ "No changes detected in any loaded file."

defn InvalidExtension (file:String) :
  Exception $ "File %~ does not have a valid Stanza file extension." % [file]

defn InvalidExp (exp-type:String) :
  Exception $ "The interactive REPL does not support %_ statements." % [exp-type]

;============================================================
;======================= Driver =============================
;============================================================

public defn repl () :
  val repl = REPL()
  while true :
    try :
      match(read-repl-exp()) :
        (exp:Load) : load-files(repl, inputs(exp))
        (exp:Eval) : load-repl(repl, form(exp))
        (exp:Import) : import(repl, import(exp))
        (exp:Unimport) : unimport(repl, package(exp))
        (exp:Inside) : inside(repl, package(exp))
        (exp:Update) : update-files(repl)
        (exp:Reload) : reload(repl)
    catch (e:ReplErrors) :
      do(println, messages(e))
