defpackage stz/el-to-vm :
  import core
  import collections
  import stz/el-ir
  import stz/dl-ir
  import stz/vm-ir
  import stz/vm-analyze
  import stz/loaded-ids

;============================================================
;======================== Driver ============================
;============================================================

public defn compile (epackage:EPackage, io:PackageIO, pkgids:LoadedPackageIds) :
  val globals = Vector<VMGlobal>()
  val funcs = Vector<VMFunction>()
  val global-table = GlobalTable(epackage, io, pkgids)
  val init-compiler = Compiler(global-table)
  for e in exps(epackage) do :
    match(e) :
      (e:EDefn) :
        val compiler = Compiler(global-table)
        val func = func(e)
        load-locals(compiler, cat(args(func), locals(func)))
        compile(compiler, ins(func))
        val arglocals = map(local{compiler, n(_)}, args(func))
        add(funcs, VMFunc(pkgids[n(e)], arglocals, defs(compiler), instructions(compiler)))
      (e:EDef) :
        add(globals, VMGlobal(pkgids[n(e)], 8, 0, []))
      (e:EInit) :
        load-locals(init-compiler, locals(e))
        compile(init-compiler, ins(e))
      (e:EDefType) :
        false

  ;Initialization function
  compile(init-compiler, [EReturn(EConst(0))])
  add(funcs, VMFunc(init(pkgids), [], defs(init-compiler), instructions(init-compiler)))

  ;Return program
  analyze $ VMProg(
    to-tuple(globals)
    []
    []
    []
    to-tuple(funcs)
    [])

;============================================================
;==================== Global Table ==========================
;============================================================

deftype GlobalTable
defmulti type (t:GlobalTable, n:Int) -> EType
defmulti function? (t:GlobalTable, n:Int) -> True|False
defmulti address (t:GlobalTable, n:Int) -> VMImm

defn GlobalTable (epackage:EPackage, io:PackageIO, pkgids:LoadedPackageIds) :
  ;Create table from TypeIDs to package-local identifiers
  val type-ids = HashTable<TypeId,Int>()
  for e in cat(imports(io), exports(io)) do :
    match(rec(e)) :
      (r:TypeRec) : type-ids[id(r) as TypeId] = n(e)
      (r) : false  

  ;Convert a descriptor type into an expression type
  defn to-etype (d:DType) :
    match(d) :
      (d:DByte) : EByte()
      (d:DInt) : EInt()
      (d:DLong) : ELong()
      (d:DFloat) : EFloat()
      (d:DDouble) : EDouble()
      (d:DOf) : EOf(type-ids[id(d)])

  ;Populate definition table
  val table = IntTable<ETExp|Rec>()
  for e in exps(epackage) do :
    match(e:EDefn|EDef|EDefType) :
      table[n(e)] = e
  for e in imports(io) do :
    table[n(e)] = rec(e)
    
  new GlobalTable :
    defmethod type (this, n:Int) :
      match(table[n]) :
        (d:EDef) : type(d)
    defmethod function? (this, n:Int) :
      table[n] is EDefn|FnRec
    defmethod address (this, n:Int) :
      match(table[n]) :
        (e:EDefn|FnRec) : CodeId(pkgids[n])
        (e:EDef) : GlobalId(pkgids[n])

;============================================================
;======================= Compiler ===========================
;============================================================

deftype Compiler
defmulti load-locals (c:Compiler, ls:Seqable<ELocal>) -> False
defmulti local (c:Compiler, n:Int) -> Local
defmulti compile (c:Compiler, ins:Seqable<EIns>) -> False
defmulti defs (c:Compiler) -> Tuple<VMDef>
defmulti instructions (c:Compiler) -> Tuple<VMIns>

deftype CVal :
  VMImm <: CVal
defstruct Mem <: CVal :
  address: VMImm
  type: VMType

defn Compiler (global-table:GlobalTable) :
  ;Defs
  val defs = Vector<VMDef>()
  defn makedef (t:VMType) :
    val n = length(defs)
    add(defs, VMDef(n, t, 0))
    Local(n)

  ;Instructions
  val insbuffer = Vector<VMIns>()
  defn emit (c:VMIns) : add(insbuffer, c)

  ;Define locals
  val immtable = IntTable<VMImm>()
  val typetable = IntTable<VMType>()

  ;Put a compiled value into a compiled location
  defn put (x:CVal, y:CVal) :
    match(x, y) :
      (x:Local, y:VMImm) :
        emit(SetIns(x,y))
      (x:Local, y:Mem) :
        emit(LoadIns(x, address(y), NumConst(0), 0))
      (x:Mem, y:VMImm) :
        emit(StoreIns(address(x), NumConst(0), 0, y))
      (x:Mem, y:Mem) :
        val tmp = makedef(type(y))
        put(tmp, y)
        put(x, tmp)

  defn store-into-x (f:Local -> False, x:EVar) :
    match(cval(x)) :
      (m:Mem) :
        val tmp = makedef(type(m))
        f(tmp)
        put(m, tmp)
      (m:Local) :
        f(m)

  defn store-into-xs (f:Tuple<Local> -> False, x:EVar|False) :
    match(x:EVar) : store-into-x(f{[_]}, x)
    else : f([])

  defn cval (x:EImm) -> CVal :
    match(x) :
      (x:EConst) :
        NumConst(value(x))
      (x:EVar) :
        if key?(immtable, n(x)) :
          immtable[n(x)]
        else :
          val t = to-vm-type(type(global-table, n(x)))
          Mem(address(global-table,n(x)), t)

  defn imm (x:CVal) :
    match(x:Mem) :
      val tmp = makedef(type(x))
      put(tmp, x)
      tmp
    else :
      x as VMImm
  defn imm (x:EImm) : imm(cval(x))
  defn imms (xs:Tuple<EImm>) : map(imm, xs)

  ;Compile instructions
  defn compile (ins:EIns) :
    match(ins) :
      (ins:ESet) :
        put(cval(x(ins)), cval(y(ins)))
      (ins:ELabel) :
        emit(LabelIns(n(ins)))
      (ins:EDo) :
        val ys* = imms(ys(ins))
        defn call-global (f:Int) :
          within l = store-into-xs(x(ins)) :
            emit(CallIns(l, address(global-table,f), ys*))
        defn call-imm (f:EImm) :
          within l = store-into-xs(x(ins)) :
            emit(CallIns(l, imm(f), ys*))
        match(/f(ins)) :
          (f:EVar) :
            if function?(global-table, n(f)) : call-global(n(f))
            else : call-imm(f)
          (f) : call-imm(f)
      (ins:EDump) :
        val ys* = for y in imms(ys(ins)) map :
          match(y:Local) :
            y
          else :
            val x = makedef(type(y))
            emit(SetIns(x,y))
            x
        emit(DumpIns(ys*))
      (ins:EReturn) :
        emit(ReturnIns([imm(y(ins))]))

  ;Return compiler
  new Compiler :
    defmethod load-locals (this, locals:Seqable<ELocal>) :
      clear(immtable)
      clear(typetable)
      for x in locals do :
        val t = to-vm-type(type(x))
        typetable[n(x)] = t
        immtable[n(x)] = makedef(t)
    defmethod local (this, n:Int) :
      immtable[n] as Local
    defmethod compile (this, ins:Seqable<EIns>) :
      do(compile, ins)
    defmethod defs (this) :
      to-tuple(defs)
    defmethod instructions (this) :
      to-tuple(insbuffer)

defn to-vm-type (t:EType) :
  match(t) :
    (t:EByte) : VMByte()
    (t:EInt) : VMInt()
    (t:ELong) : VMLong()
    (t:EFloat) : VMFloat()
    (t:EDouble) : VMDouble()
    (t:EOf) : VMRef()