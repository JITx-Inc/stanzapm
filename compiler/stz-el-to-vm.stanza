defpackage stz/el-to-vm :
  import core
  import collections
  import stz/el-ir
  import stz/dl-ir
  import stz/vm-ir
  import stz/vm-analyze
  import stz/loaded-ids

;============================================================
;======================== Driver ============================
;============================================================

public defn compile (epackage:EPackage, io:PackageIO, pkgids:PackageIds) :
  val globals = Vector<VMGlobal>()
  val funcs = Vector<VMFunction>()
  val global-table = GlobalTable(epackage, io, pkgids)
  val init-compiler = Compiler(global-table)
  for e in exps(epackage) do :
    match(e) :
      (e:EDefn) :
        val compiler = Compiler(global-table)
        val func = func(e)
        load-locals(compiler, cat(args(func), locals(func)))
        compile(compiler, ins(func))
        val arglocals = map(local{compiler, n(_)}, args(func))
        val f = pkgids[n(e)]
        add(funcs, VMFunc(id(f), arglocals, defs(compiler), instructions(compiler)))
      (e:EDef) :
        val g = pkgids[n(e)] as GlobalId
        add(globals, VMGlobal(id(g), 8, 0, []))
      (e:EInit) :
        load-locals(init-compiler, locals(e))
        compile(init-compiler, ins(e))
      (e:EDefType) :
        false

  ;Initialization function
  compile(init-compiler, [EReturn(EConst(0))])
  add(funcs, VMFunc(id(init(pkgids)), [], defs(init-compiler), instructions(init-compiler)))

  ;Return program
  analyze $ VMProg(
    to-tuple(globals)
    []
    []
    []
    to-tuple(funcs)
    [])

;============================================================
;================= Dependency Analysis ======================
;============================================================
;
;defn analyze-dependencies (f:EFn) :
;  ;Find locals
;  val locals = IntSet()
;  add-all(locals, targs(f))
;  add-all(locals, seq(n,args(f)))
;  add-all(locals, seq(n,/locals(f)))
;
;  ;Find dependencies
;  val dependencies = IntSet()
;  defn scan (t:EType) :
;    match(t:EOf) :
;      add(dependencies, n(t))
;  defn scan (e:ELocal) :
;    scan(type(e))
;  defn scan (e:EImm) :
;    match(e:EVar) :
;      add(dependencies, n(e)) when not locals[n(e)]  
;
;  ;Scan all immediates and types in all instructions
;  for e in ins(f) do :
;    do-imms(scan, e)
;    do-types(scan, e)
;
;  ;Return dependencies
;  to-tuple(dependencies)
;
;defn do-imms (func:EImm -> ?, ins:EIns) :
;  defn f* (x:EImm) : func(x)
;  defn f* (x:False) : false
;  defn f* (x:Seqable<EImm>) : do(f*, x)  
;  match(ins) :
;    (ins:ESet) : (f*(x(ins)), f*(y(ins)))
;    (ins:EShuffle) : (f*(xs(ins)), f*(ys(ins)))
;    (ins:ELabel) : false
;    (ins:EDo) : (f*(x(ins)), f*(f(ins)), f*(ys(ins)))
;    (ins:EDump) : (f*(ys(ins)))
;    (ins:EReturn) : (f*(y(ins)))
;  
;defn do-types (func:EType -> ?, ins:EIns) :
;  defn f* (x:False) : false
;  defn f* (x:EType) : func(x)
;  match(ins) :
;    (ins:ESet) : false
;    (ins:EShuffle) : false
;    (ins:ELabel) : false
;    (ins:EDo) : f*(xtype(ins))
;    (ins:EDump) : false
;    (ins:EReturn) : false

;============================================================
;==================== Global Table ==========================
;============================================================

;deftype GlobalTable
;
;defn GlobalTable (io:PackageIO, epackage:EPackage, pkgids:PackageIds) :
;  ;Create type table
;  val type-table = DTypeTable(io)
;
;  ;Populate entry table
;  val table = IntTable<ETExp|Rec>()
;  for e in imports(io) do :
;    table[n(e)] = rec(e)
;  for e in exps(epackage) do :
;    match(e:EDefn|EDefmulti|EDefGlobal|EExtern) :
;      table[n(e)] = e
;      
;  new GlobalTable :
;    defmethod address (this, n:Int) :
;      match(table[n]) :
;        (e:EDefn|EDefmulti|)

;
;deftype GlobalTable
;defmulti type (t:GlobalTable, n:Int) -> EType
;defmulti function? (t:GlobalTable, n:Int) -> True|False
;defmulti address (t:GlobalTable, n:Int) -> VMImm
;
;defn GlobalTable (epackage:EPackage, io:PackageIO, pkgids:PackageIds) :
;  ;Create table from TypeIDs to package-local identifiers
;  val type-ids = HashTable<TypeId,Int>()
;  for e in cat(imports(io), exports(io)) do :
;    match(rec(e)) :
;      (r:TypeRec) : type-ids[id(r) as TypeId] = n(e)
;      (r) : false
;
;  ;Convert a descriptor type into an expression type
;  defn to-etype (d:DType) :
;    match(d) :
;      (d:DByte) : EByte()
;      (d:DInt) : EInt()
;      (d:DLong) : ELong()
;      (d:DFloat) : EFloat()
;      (d:DDouble) : EDouble()
;      (d:DOf) :
;        match(get?(type-ids, id(d))) :
;         (i:Int) : EOf(i)
;         (i:False) : fatal("ETop()")
;
;  ;Populate definition table
;  val table = IntTable<ETExp|Rec>()
;  for e in exps(epackage) do :
;    match(e:EDefn|EDef|EDefType) :
;      table[n(e)] = e
;  for e in imports(io) do :
;    table[n(e)] = rec(e)
;    
;  new GlobalTable :
;    defmethod type (this, n:Int) :
;      match(table[n]) :
;        (d:EDef) : type(d)
;    defmethod function? (this, n:Int) :
;      table[n] is EDefn|FnRec
;    defmethod address (this, n:Int) :
;      match(table[n]) :
;        (e:EDefn|FnRec) : pkgids[n] as CodeId
;        (e:EDef) : pkgids[n] as GlobalId
;
;============================================================
;======================= Compiler ===========================
;============================================================

deftype Compiler
defmulti load-locals (c:Compiler, ls:Seqable<ELocal>) -> False
defmulti local (c:Compiler, n:Int) -> Local
defmulti compile (c:Compiler, ins:Seqable<EIns>) -> False
defmulti defs (c:Compiler) -> Tuple<VMDef>
defmulti instructions (c:Compiler) -> Tuple<VMIns>

deftype CVal
defstruct CImm <: CVal :
  imms: Tuple<VMImm>
defstruct CMem <: CVal :
  address: VMImm
  types: Tuple<VMType>
  offsets: Tuple<Int>

defn Compiler (gt:GlobalTable, pkgids:PackageIds) :
  ;Defs
  val defs = Vector<VMDef>()
  defn makedef (t:VMType) :
    val n = length(defs)
    add(defs, VMDef(n, t, 0))
    Local(n)
  defn makedefs (ts:Tuple<VMType>) :
    map(makedef, ts)

  ;Instructions
  val insbuffer = Vector<VMIns>()
  defn emit (c:VMIns) : add(insbuffer, c)

  ;Define locals
  val immtable = IntTable<CImm>()

  ;Put a compiled value into a compiled location
  defn put (x:CVal, y:CVal) :
    match(x, y) :
      (x:CImm, y:CImm) :
        fatal("Mismatch") when length(imms(x)) != length(imms(y))
        for (x in imms(x), y in imms(y)) do :
          emit(SetIns(x as Local, y))
      (x:CImm, y:CMem) :
        fatal("Mismatch") when length(imms(x)) != length(types(y))
        val a = address(y)
        for (x in imms(x), o in offsets(y)) do :
          emit(LoadIns(x, a, NumConst(0), o))
      (x:CMem, y:CImm) :
        fatal("Mismatch") when length(types(x)) != length(imms(y))
        val a = address(a)
        for (o in offsets(x), y in imms(y)) do :
          emit(StoreIns(a, NumConst(0), o, y))
      (x:CMem, y:CMem) :
        fatal("Mismatch") when length(types(x)) != length(types(y))
        val tmp = CImm(makedefs(types(y)))
        put(tmp, y)
        put(x, tmp)

  ;Compile function to location
  defn put (x:CVal, f:Tuple<Local> -> False) :
    match(x) :
      (x:CImm) :
        f(imms(x) as Tuple<Local>)
      (x:CMem) :
        val tmp = CImm(makedefs(types(x)))
        put(tmp, f)
        put(x, tmp)
  defn put (x:CVal, f:Tuple<Local> -> VMIns) :
    put(x, emit{f(_)})
  defn put (x:CVal, f:Local -> VMIns) :
    put(x, emit{f(_[0])})

  ;Retrieve the immediate from a CVal
  defn imms! (x:CVal) :
    match(x) :
      (x:CImm) :
        imms(x)
      (x:CMem) :
        val tmp = makedefs(types(x))
        put(tmp, x)
        tmp
  defn imm! (x:CVal) :
    val xs = imms!(x)
    fatal("Not unary") when length(xs) != 1
    xs[0]

  ;Compile an immediate to a location
  defn cval (x:EImm) -> CVal :   
    match(x) :
      (x:EVar) :
        match(get?(immtable, n(x))) :
          (v:CImm) :
            v
          (_:False) :
            val a = pkgids[n(x)] as VMImm
            val t = type(vt,n(x))
            val ts = vmtypes(gt, t)
            val os = offsets(gt, t)
            CMem(a, ts, os)
      (x:ELSLiteral) :
        match(value(x)) :
          (v:String) :
            val did = make-data-id(pkgids)
            emit(VMData(id(did), string-bytes(v)))
            CImm([did])
          (v:Char|Byte|Int|Long|Float|Double) :
            CImm([NumConst(v)])
      (x:ELiteral) :
        match(value(x)) :
          (v:Char|Byte|Int|Float) :
            CImm([NumConst(v)])            
          (v:True) :
            CImm([Marker(VM-TRUE-TYPE-ID)])
          (v:False) :
            CImm([Marker(VM-FALSE-TYPE-ID)])
          (v:List|String|Symbol|Long|Double) :
            val cid = make-const-id(pkgids)
            emit(VMConst(id(cid), v))
            CMem(cid, [VMRef()], [0])
      (x:ESizeof) :
        val sz = size(gt,type(x))
        CImm([NumConst(to-long(sz))])
      (x:ETagof) :
        val cid = pkgids[n(x)] as ClassId
        CImm([Tag(id(cid))])


  ;Compile instructions
  defn compile (ins:EIns) :
    match(ins) :
      (ins:ESet) :
        put(cval(x(ins)), cval(y(ins)))
      (ins:ELabel) :
        emit(LabelIns(n(ins)))
      (ins:EDo) :
        val ys* = imms(ys(ins))
        defn call-global (f:Int) :
          within l = store-into-xs(x(ins)) :
            emit(CallIns(l, address(global-table,f), ys*))
        defn call-imm (f:EImm) :
          within l = store-into-xs(x(ins)) :
            emit(CallIns(l, imm(f), ys*))
        match(/f(ins)) :
          (f:EVar) :
            if function?(global-table, n(f)) : call-global(n(f))
            else : call-imm(f)
          (f) : call-imm(f)
      (ins:EDump) :
        val ys* = for y in imms(ys(ins)) map :
          match(y:Local) :
            y
          else :
            val x = makedef(type(y))
            emit(SetIns(x,y))
            x
        emit(DumpIns(ys*))
      (ins:EReturn) :
        emit(ReturnIns([imm(y(ins))]))

  ;Return compiler
  new Compiler :
    defmethod compile (this, ins:Seqable<EIns>) :
      do(compile, ins)
    ;defmethod load-locals (this, locals:Seqable<ELocal>) :
    ;  clear(immtable)
    ;  clear(typetable)
    ;  for x in locals do :
    ;    val t = to-vm-type(type(x))
    ;    typetable[n(x)] = t
    ;    immtable[n(x)] = makedef(t)
    ;defmethod local (this, n:Int) :
    ;  immtable[n] as Local
    ;defmethod defs (this) :
    ;  to-tuple(defs)
    ;defmethod instructions (this) :
    ;  to-tuple(insbuffer)

defn to-vm-type (t:EType) :
  match(t) :
    (t:EByte) : VMByte()
    (t:EInt) : VMInt()
    (t:ELong) : VMLong()
    (t:EFloat) : VMFloat()
    (t:EDouble) : VMDouble()
    (t:EOf) : VMRef()

;============================================================
;====================== GlobalTable =========================
;============================================================

deftype GlobalTable
defmulti type (t:GlobalTable, n:Int) -> EType
defmulti vmtypes (t:GlobalTable, t:EType) -> Tuple<VMType>
defmulti alignment (t:GlobalTable, t:EType) -> Int
defmulti size (t:GlobalTable, t:EType) -> Int
defmulti length (t:GlobalTable, t:EType) -> Int

deftype GlobalEntry
defstruct VarEntry <: GlobalEntry :
  type: EType
defstruct FnEntry <: GlobalEntry
defstruct StructEntry <: GlobalEntry :  
  base: Tuple<EType>
  items: False|EType
  offsets: Tuple<Int> with: (default => void)
  alignment: Int with: (default => void)
  size: Int with: (default => void)
  length: Int with: (default => void)
  vmtypes: Tuple<VMType> with: (default => void)

defn GlobalTable (io:PackageIO, epackage:EPackage) :
  ;Conversion to ETypes
  val tt = DTypeTable(io)
  defn to-etype (t:DType) : /to-etype(tt, t, [])
  defn to-etype (t:False) : false

  ;Create global entries
  val table = IntTable<GlobalEntry>()  
  for import in imports(io) do :
    match(rec(import)) :
      (r:FnRec|MultiRec|ExternFnRec) :
        table[n(import)] = FnEntry()
      (r:ValRec|ExternRec) :
        table[n(import)] = VarEntry(to-etype(type(r)))
      (r:StructRec) :
        val base* = map(to-etype, base(r))
        val items* = to-etype(items(r))
        table[n(import)] = StructEntry(base*, items*)
      (r) : false
  for exp in exps(epackage) do :
    match(e) :
      (e:EDefn|EDefmulti|EExternFn) :
        table[n(e)] = FnEntry()
      (e:EDefGlobal|EExtern) :
        table[n(e)] = VarEntry(type(e))
      (e:EDefStruct) :
        table[n(e)] = StructEntry(base(e), items(e))
      (e) :
        false

  ;Compute struct properties
  defn compute-struct-properties (this:GlobalTable) :
    ;Compute the properties for struct n and all
    ;dependents of struct n.
    val analyzed = IntSet()
    defn compute-properties (n:Int) :
      if not analyzed[n] :
        val e = table[n] as StructEntry
        val structs = filter-by<EStructT>(cat(base(e), [items(e)]))
        do(compute-properties{n(_)}, structs)
        table[n] = analyze(e)
        add(analyzed, n)
      
    ;Analyze the given StructEntry
    ;(assumes that all dependencies have been analyzed)
    defn analyze (e:StructEntry) :
      ;Accumulators
      val offsets-list = Vector<Int>()
      val vmtypes-list = Vector<VMType>()
      var alignment-accum:Int = 1
      var size-accum:Int = 0
      var length-accum:Int = 0
      
      ;Analyze each base field
      for t in base(e) do :
        ;Retrieve properties of this type
        val vmts = vm-types(this,t)
        val aln = alignment(this,t)
        val size = size(this,t)
        val len = length(this,t)

        ;Pad to appropriate alignment (assumes aln is power of 2)
        size-accum = (size-accum + aln - 1) & (- aln)
        
        ;Compute offset
        add(offsets-list, size-accum)
        add-all(vmtypes-list, vmts)
        size-accum = size-accum + size
        length-accum = length-accum + len
        alignment-accum = max(alignment-accum, aln)
        
      ;Pad to appropriate alignment to finish
      match(items(e)) :
        (items:EType) :
          val aln = alignment(this, items)
          size-accum = (size-accum + aln - 1) & (- aln)
        (items:False) :
          size-accum = (size-accum + alignment-accum - 1) & (- alignment-accum)
          
      ;Return analyzed StructEntry
      StructEntry(base(e), items(e),
                  to-tuple(offsets-list),
                  alignment-accum,
                  size-accum,
                  length-accum,
                  to-tuple(vmtypes-list))

    ;Driver    
    do(compute-properties, struct-ns) where :
      val structs = filter({value(_) is StructEntry}, table)
      val struct-ns = seq(key, structs)

  ;Create and initialize global table
  val gt = new GlobalTable :
    defmethod type (this, n:Int) :
      type(table[n] as VarEntry)
    defmethod vmtypes (this, t:EType) :
      match(t) :
        (t:EStructT) : vmtypes(table[n(t)] as StructEntry)
        (t:EFnT) : fatal("Invalid argument")
        (t:EUnknown) : fatal("Invalid argument")
        (t:EBot) : fatal("Invalid argument")
        (t:EByte) : VMByte()
        (t:EInt) : VMInt()
        (t:ELong) : VMLong()
        (t:EFloat) : VMFloat()
        (t:EDouble) : VMDouble()
        (t:EPtrT) : VMLong()
        (t) : VMRef()
    defmethod alignment (this, t:EType) :
      match(t) :
        (t:EStructT) : alignment(table[n(t)] as StructEntry)
        (t) : size(this, t)
    defmethod size (this, t:EType) :
      match(t) :
        (t:EStructT) : size(table[n(t)] as StructEntry)
        (t:EFnT) : fatal("Invalid argument")
        (t:EUnknown) : fatal("Invalid argument")
        (t:EBot) : fatal("Invalid argument")
        (t:EByte) : 1
        (t:EInt) : 4
        (t:ELong) : 8
        (t:EFloat) : 4
        (t:EDouble) : 8
        (t) : 8        
    defmethod length (this, t:EType) :
      match(t) :      
        (t:EStructT) : length(table[n(t)] as StructEntry)
        (t:EFnT) : fatal("Invalid argument")
        (t:EUnknown) : fatal("Invalid argument")
        (t:EBot) : fatal("Invalid argument")
        (t) : 1    
  compute-struct-properties(gt)
  gt

