defpackage stz/el-to-vm :
  import core
  import collections
  import stz/el-ir
  import stz/vm-ir

;============================================================
;======================== Driver ============================
;============================================================

public defn compile (epackage:EPackage) :
  val globals = Vector<VMGlobal>()
  val funcs = Vector<VMFunction>()

  val global-table = GlobalTable(epackage)
  val global-counter = to-seq(0 to false by 8)
  for e in exps(epackage) do :
    match(e) :
      (e:EDefn) :
        add(funcs, compile(n(e), func(e), global-table))
      (e:EDef) :
        add(globals, VMGlobal(n(e), 8, next(global-counter), []))
      (e:EInit) :
        false
      (e:EDefType) :
        false

  ;Return program
  VMProg(
    to-tuple(globals)
    []
    []
    []
    to-tuple(funcs)
    [])

;============================================================
;==================== Global Table ==========================
;============================================================

deftype GlobalTable
defmulti type (t:GlobalTable, n:Int) -> EType
defmulti function? (t:GlobalTable, n:Int) -> True|False

defn GlobalTable (epackage:EPackage) :
  val table = IntTable<ETExp>()
  for e in exps(epackage) do :
    match(e:EDefn|EDef|EDefType) :
      table[n(e)] = e
  new GlobalTable :
    defmethod type (this, n:Int) :
      type(table[n] as EDef)
    defmethod function? (this, n:Int) :
      table[n] is EDefn

;============================================================
;=================== Function Compilation ===================
;============================================================
  
defn compile (fid:Int, f:EFn, global-table:GlobalTable) :
  ;Defs
  val defs = Vector<VMDef>()
  defn makedef (t:VMType) :
    val n = length(defs)
    add(defs, VMDef(n, t, 0))
    Local(n)

  ;Instructions
  val insbuffer = Vector<VMIns>()
  defn emit (c:VMIns) : add(insbuffer, c)

  ;Define locals
  val immtable = IntTable<VMImm>()
  val typetable = IntTable<VMType>()
  for x in cat(args(f), locals(f)) do :
    val t = to-vm-type(type(x))
    typetable[n(x)] = t
    immtable[n(x)] = makedef(t)

  ;Compile the give
  defn store-into (f:Local -> False, x:EVar) :
    match(get?(immtable, n(x))) :
      (l:Local) :
        f(l)        
      (_:False) :
        val t = to-vm-type(type(global-table, n(x)))
        val l = makedef(t)
        f(l)
        emit(StoreIns(GlobalId(n(x)), NumConst(0), 0, l))

  ;Compile the given immediate to a VMImm
  defn imm (x:EImm) :
    match(x) :
      (x:EConst) :
        NumConst(value(x))
      (x:EVar) :
        if key?(immtable, n(x)) : 
          immtable[n(x)]
        else :
          val t = to-vm-type(type(global-table, n(x)))
          val l = makedef(t)
          load(l, x)
          l
  defn imms (xs:Tuple<EImm>) :
    map(imm, xs)
  defn local (x:EVar) :
    immtable[n(x)] as Local

  ;Load the given immediate into the given local
  defn load (x:Local, y:EImm) :
    match(y) :
      (y:EVar) :
        if key?(immtable, n(y)) :
          emit(SetIns(x, immtable[n(y)]))
        else :
          emit(LoadIns(x, GlobalId(n(y)), NumConst(0), 0))
      (y:EImm) :
        emit(SetIns(x, imm(y)))

  ;Compile instructions
  for ins in ins(f) do :
    match(ins) :
      (ins:ESet) :
        within xl = store-into(x(ins)) :
          load(xl, y(ins))
      (ins:ELabel) :
        emit(LabelIns(n(ins)))
      (ins:EDo) :
        val ys* = imms(ys(ins))
        defn store-into-x (f: Tuple<Local|False> -> False) :
          match(x(ins)) :
            (x:EVar) : store-into(f{[_]}, x)
            (x:False) : f([])
        defn call-global (f:Int) :
          within l = store-into-x() :
            emit(CallIns(l, GlobalId(f), ys*))
        defn call-imm (f:EImm) :
          within l = store-into-x() :
            emit(CallIns(l, imm(f), ys*))          
        match(/f(ins)) :
          (f:EVar) :
            if function?(global-table, n(f)) : call-global(n(f))
            else : call-imm(f)
          (f) : call-imm(f)
      (ins:EReturn) :
        emit(ReturnIns([imm(y(ins))]))

  ;Return compiled instructions
  val arglocals = for a in args(f) map :
    immtable[n(a)] as Local
  VMFunc(fid, arglocals, to-tuple(defs), to-tuple(insbuffer))

defn to-vm-type (t:EType) :
  match(t) :
    (t:EByte) : VMByte()
    (t:EInt) : VMInt()
    (t:ELong) : VMLong()
    (t:EFloat) : VMFloat()
    (t:EDouble) : VMDouble()
    (t:EOf) : VMRef()