defpackage stz/el-to-vm :
  import core
  import collections
  import stz/el-ir with :
    prefix(IntAddOp, IntSubOp, IntMulOp, IntDivOp, IntModOp, IntAndOp, IntOrOp,
           IntXorOp, IntNotOp, IntShlOp, IntShrOp, IntAshrOp, IntLtOp, IntGtOp,
           IntLeOp, IntGeOp, IntNegOp, RefEqOp, RefNeOp, AddOp, SubOp, MulOp,
           DivOp, ModOp, AndOp, OrOp, XorOp, NotOp, ShlOp, ShrOp, AshrOp, EqOp,
           NeOp, LtOp, GtOp, LeOp, GeOp, UleOp, UltOp, UgtOp, UgeOp, NegOp,
           InstanceofOp, TagOp, DetagOp, ConvOp, InterpretOp, DerefOp,
           CurrentStackOp, GlobalsOp, ConstsOp, ConstsDataOp) => E
  import stz/el
  import stz/dl-ir  
  import stz/vm-ir
  import stz/vm-analyze
  import stz/loaded-ids
  import stz/built-ins with :
    prefix => VM-

;============================================================
;======================== Driver ============================
;============================================================

public defn compile (epackage:EPackage, io:PackageIO, pkgids:PackageIds) :
  false
  ;val globals = Vector<VMGlobal>()
  ;val funcs = Vector<VMFunction>()
  ;val global-table = GlobalTable(epackage, io, pkgids)
  ;val init-compiler = Compiler(global-table)
  ;for e in exps(epackage) do :
  ;  match(e) :
  ;    (e:EDefn) :
  ;      val compiler = Compiler(global-table)
  ;      val func = func(e)
  ;      load-locals(compiler, cat(args(func), locals(func)))
  ;      compile(compiler, ins(func))
  ;      val arglocals = map(local{compiler, n(_)}, args(func))
  ;      val f = pkgids[n(e)]
  ;      add(funcs, VMFunc(id(f), arglocals, defs(compiler), instructions(compiler)))
  ;    (e:EDef) :
  ;      val g = pkgids[n(e)] as GlobalId
  ;      add(globals, VMGlobal(id(g), 8, 0, []))
  ;    (e:EInit) :
  ;      load-locals(init-compiler, locals(e))
  ;      compile(init-compiler, ins(e))
  ;    (e:EDefType) :
  ;      false
  ;
  ;;Initialization function
  ;compile(init-compiler, [EReturn(EConst(0))])
  ;add(funcs, VMFunc(id(init(pkgids)), [], defs(init-compiler), instructions(init-compiler)))
  ;
  ;;Return program
  ;analyze $ VMProg(
  ;  to-tuple(globals)
  ;  []
  ;  []
  ;  []
  ;  to-tuple(funcs)
  ;  [])

;============================================================
;================= Dependency Analysis ======================
;============================================================
;
;defn analyze-dependencies (f:EFn) :
;  ;Find locals
;  val locals = IntSet()
;  add-all(locals, targs(f))
;  add-all(locals, seq(n,args(f)))
;  add-all(locals, seq(n,/locals(f)))
;
;  ;Find dependencies
;  val dependencies = IntSet()
;  defn scan (t:EType) :
;    match(t:EOf) :
;      add(dependencies, n(t))
;  defn scan (e:ELocal) :
;    scan(type(e))
;  defn scan (e:EImm) :
;    match(e:EVar) :
;      add(dependencies, n(e)) when not locals[n(e)]  
;
;  ;Scan all immediates and types in all instructions
;  for e in ins(f) do :
;    do-imms(scan, e)
;    do-types(scan, e)
;
;  ;Return dependencies
;  to-tuple(dependencies)
;
;defn do-imms (func:EImm -> ?, ins:EIns) :
;  defn f* (x:EImm) : func(x)
;  defn f* (x:False) : false
;  defn f* (x:Seqable<EImm>) : do(f*, x)  
;  match(ins) :
;    (ins:ESet) : (f*(x(ins)), f*(y(ins)))
;    (ins:EShuffle) : (f*(xs(ins)), f*(ys(ins)))
;    (ins:ELabel) : false
;    (ins:EDo) : (f*(x(ins)), f*(f(ins)), f*(ys(ins)))
;    (ins:EDump) : (f*(ys(ins)))
;    (ins:EReturn) : (f*(y(ins)))
;  
;defn do-types (func:EType -> ?, ins:EIns) :
;  defn f* (x:False) : false
;  defn f* (x:EType) : func(x)
;  match(ins) :
;    (ins:ESet) : false
;    (ins:EShuffle) : false
;    (ins:ELabel) : false
;    (ins:EDo) : f*(xtype(ins))
;    (ins:EDump) : false
;    (ins:EReturn) : false

;============================================================
;==================== Global Table ==========================
;============================================================

;deftype GlobalTable
;
;defn GlobalTable (io:PackageIO, epackage:EPackage, pkgids:PackageIds) :
;  ;Create type table
;  val type-table = DTypeTable(io)
;
;  ;Populate entry table
;  val table = IntTable<ETExp|Rec>()
;  for e in imports(io) do :
;    table[n(e)] = rec(e)
;  for e in exps(epackage) do :
;    match(e:EDefn|EDefmulti|EDefGlobal|EExtern) :
;      table[n(e)] = e
;      
;  new GlobalTable :
;    defmethod address (this, n:Int) :
;      match(table[n]) :
;        (e:EDefn|EDefmulti|)

;
;deftype GlobalTable
;defmulti type (t:GlobalTable, n:Int) -> EType
;defmulti function? (t:GlobalTable, n:Int) -> True|False
;defmulti address (t:GlobalTable, n:Int) -> VMImm
;
;defn GlobalTable (epackage:EPackage, io:PackageIO, pkgids:PackageIds) :
;  ;Create table from TypeIDs to package-local identifiers
;  val type-ids = HashTable<TypeId,Int>()
;  for e in cat(imports(io), exports(io)) do :
;    match(rec(e)) :
;      (r:TypeRec) : type-ids[id(r) as TypeId] = n(e)
;      (r) : false
;
;  ;Convert a descriptor type into an expression type
;  defn to-etype (d:DType) :
;    match(d) :
;      (d:DByte) : EByte()
;      (d:DInt) : EInt()
;      (d:DLong) : ELong()
;      (d:DFloat) : EFloat()
;      (d:DDouble) : EDouble()
;      (d:DOf) :
;        match(get?(type-ids, id(d))) :
;         (i:Int) : EOf(i)
;         (i:False) : fatal("ETop()")
;
;  ;Populate definition table
;  val table = IntTable<ETExp|Rec>()
;  for e in exps(epackage) do :
;    match(e:EDefn|EDef|EDefType) :
;      table[n(e)] = e
;  for e in imports(io) do :
;    table[n(e)] = rec(e)
;    
;  new GlobalTable :
;    defmethod type (this, n:Int) :
;      match(table[n]) :
;        (d:EDef) : type(d)
;    defmethod function? (this, n:Int) :
;      table[n] is EDefn|FnRec
;    defmethod address (this, n:Int) :
;      match(table[n]) :
;        (e:EDefn|FnRec) : pkgids[n] as CodeId
;        (e:EDef) : pkgids[n] as GlobalId
;
;============================================================
;======================= Compiler ===========================
;============================================================

deftype Compiler
defmulti load-locals (c:Compiler, ls:Seqable<ELocal>) -> False
defmulti local (c:Compiler, n:Int) -> Local
defmulti compile (c:Compiler, ins:Seqable<EIns>) -> False
defmulti defs (c:Compiler) -> Tuple<VMDef>
defmulti instructions (c:Compiler) -> Tuple<VMIns>

deftype CVal
defstruct CImm <: CVal :
  imms: Tuple<VMImm>
defstruct CMem <: CVal :
  address: VMImm
  types: Tuple<VMType>
  offsets: Tuple<Int>

deftype CLoc
defstruct LocalLoc <: CLoc :
  n: Int
  index: Int
defstruct PtrLoc <: CLoc :
  base: CVal
  offset: CVal|False
  const: Int

defn Compiler (gt:GlobalTable, pkgids:PackageIds) :
  ;Defs
  val defs = Vector<VMDef>()
  defn makedef (t:VMType) :
    val n = length(defs)
    add(defs, VMDef(n, t, 0))
    Local(n)
  defn makedefs (ts:Tuple<VMType>) :
    map(makedef, ts)

  ;Instructions
  val insbuffer = Vector<VMIns>()
  defn emit (c:VMIns) : add(insbuffer, c)

  ;Define locals
  val locals-table = IntTable<Table<Local>>()
  val tlocals-table = IntTable<Local>()
  defn locals (x:EVarLoc) :
    locals-table[n(x)]
  defn local (x:EVarLoc) :
    val xs = locals(x)
    fatal("Incorrect length") when length(xs) != 1
    xs[0]
  defn local (x:ETVarLoc) :
    tlocals-table[n(x)]

  ;Define labels  
  val labels-table = IntTable<Int>()
  val num-labels = to-seq(0 to false)
  defn make-label () :
    next(num-labels)
  defn get-label (n:Int) :
    if not key?(labels-table, n) :
      labels-table[n] = next(num-labels)
    labels-table[n]

  ;Put a compiled value into a compiled location
  ;defn put (x:CLoc, y:CVal) :
  ;  match(x, y) :
  ;    (x:LocalLoc, y:CImm) :
  ;      val xs = imms(immtable[n(x)]) as Tuple<Local>
  ;      for (y in imms(y), i in 0 to false) do :
  ;        emit(SetIns(xs[index(x) + i], y))
  ;    (x:LocalLoc, y:CMem) :
  ;      val a = address(y)
  ;      val xs = imms(immtable[n(x)]) as Tuple<Local>
  ;      for (o in offsets(y), i in 0 to false) do :
  ;        emit(LoadIns(xs[index(x) + i], a, NumConst(0), o))
  ;    (x:PtrLoc, y:CImm) :
  ;      val a = imm!(base(x))
  ;      val o = match(offset(x)) :
  ;                (o:CVal) : imm!(o)
  ;                (o:False) : false
  ;      for (y in imms(y),
  defn put (x:EVarLoc, y:CVal) :
    val xs = locals(x)
    match(y) :
      (y:CImm) :
        fatal("Mismatch") when length(xs) != length(imms(y))
        for (x in xs, y in imms(y)) do :
          emit(SetIns(x,y))
      (y:CMem) :
        fatal("Mismatch") when length(xs) != length(offsets(y))
        val a = address(y)
        for (x in xs, o in offsets(y)) do :
          emit(LoadIns(x, a, o))
  ;defn put (x:EVarLoc, f:Tuple<Local> -> False) :
  ;  f(locals(x))
  ;defn put (x:EVarLoc, f:Local -> VMIns) :
  ;  put(x, emit{f(_[0])})


  ;Compile function to location
  ;defn put (x:CVal, f:Tuple<Local> -> False) :
  ;  match(x) :
  ;    (x:CImm) :
  ;      f(imms(x) as Tuple<Local>)
  ;    (x:CMem) :
  ;      val tmp = CImm(makedefs(types(x)))
  ;      put(tmp, f)
  ;      put(x, tmp)
  ;defn put (x:CVal, f:Tuple<Local> -> VMIns) :
  ;  put(x, emit{f(_)})
  ;defn put (x:CVal, f:Local -> VMIns) :
  ;  put(x, emit{f(_[0])})

  ;Retrieve the immediate from a CVal
  defn imms! (x:CVal) :
    match(x) :
      (x:CImm) :
        imms(x)
      (x:CMem) :
        val tmp = makedefs(types(x))
        put(tmp, x)
        tmp
  defn imm! (x:CVal) :
    val xs = imms!(x)
    fatal("Not unary") when length(xs) != 1
    xs[0]

  ;Code generation utilities
  defn CallError (n:Int, args:Tuple<VMImm>) :
    val false-marker = Marker(VM-FALSE-TYPE-ID)
    val arity = NumConst(length(args))
    val ys = to-tuple $ cat([false-marker, arity], args)
    TCallIns(CodeId(n), ys)
  defn CallUtil (x:Local, n:Int, args:Tuple<VMImm>) :
    val false-marker = Marker(VM-FALSE-TYPE-ID)
    val arity = NumConst(length(args))
    val ys = to-tuple $ cat([false-marker, arity], args)
    CallIns(x, CodeId(n), ys)

  ;Compile an immediate to a location
  defn cval (x:EImm) -> CVal :   
    match(x) :
      (x:EVar) :
        match(get?(locals-table, n(x))) :
          (v:Tuple<Local>) :
            CImm(v)
          (_:False) :
            val a = pkgids[n(x)] as VMImm
            val t = type(gt,n(x))
            val ts = vmtypes(gt,t)
            val os = offsets(gt,t)
            CMem(a, ts, os)
      (x:ELSLiteral) :
        match(value(x)) :
          (v:String) :
            val did = make-data-id(pkgids)
            emit(VMData(id(did), string-bytes(v)))
            CImm([did])
          (v:Char|Byte|Int|Long|Float|Double) :
            CImm([NumConst(v)])
      (x:ELiteral) :
        match(value(x)) :
          (v:Char|Byte|Int|Float) :
            CImm([NumConst(v)])            
          (v:True) :
            CImm([Marker(VM-TRUE-TYPE-ID)])
          (v:False) :
            CImm([Marker(VM-FALSE-TYPE-ID)])
          (v:List|String|Symbol|Long|Double) :
            val cid = make-const-id(pkgids)
            emit(VMConst(id(cid), v))
            CMem(cid, [VMRef()], [0])
      (x:ESizeof) :
        val sz = size(gt,type(x))
        CImm([NumConst(to-long(sz))])
      (x:ETagof) :
        val cid = pkgids[n(x)] as ClassId
        CImm([Tag(id(cid))])

  ;Compile a location to a CVal
  defn cloc (x:ELoc) -> CLoc :
    match(x) :
      (x:EVarLoc) :
        if key?(locals-table, n(x)) :
          LocalLoc(n(x), 0)
        else :
          val base = CImm([pkgids[n(x)] as VMImm])
          PtrLoc(base, false, 0)
      (x:EDeref) :
        PtrLoc(cval(y(x)), false, 0)
      (x:EDeptr) :
        PtrLoc(cval(y(x)), false, 0)
      (x:EField) :
        match(cloc(loc(x))) :
          (l:LocalLoc) :
            val fi = field-index(gt, n(x), index(x))
            LocalLoc(n(l), index(l) + fi)
          (l:PtrLoc) :
            val fo = field-offset(gt, n(x), index(x))
            PtrLoc(base(x), offset(x), const(x) + fo)
      (x:ESlot) :
        val size = size(gt, type(x))
        val base-loc = cloc(loc(x)) as PtrLoc
        val offset* = match(offset(base-loc)) :
          (o:CVal) :
            if size == 1 :
              val tmp = makedef(VMLong())
              emit(Op2Ins(tmp, AddOp(), imm!(o), imm!(index(x))))
              CImm([tmp])
            else :
              val tmp = makedef(VMLong())
              emit(Op2Ins(tmp, MulOp(), imm!(index(x)), NumConst(size)))
              emit(Op2Ins(tmp, AddOp(), imm!(o), tmp))
              CImm([tmp])
          (_:False) :
            if size == 1 :
              cval(index(x))
            else :
              val tmp = makedef(VMLong())
              emit(Op2Ins(tmp, MulOp(), imm!(index(x)), NumConst(size)))
              CImm([tmp])
        PtrLoc(base(base-loc), offset*, const(base-loc))  

  defn ctypeof (pass:Int, fail:Int, x:VMImm, t:EType) :
    match(t) :    
      (t:ETVar) :
        val pred = makedef(VMLong())
        val t* = imm!(t)
        emit(CallClosureIns([pred], t*, [t*, NumConst(1), x]))
        emit(Branch1Ins(pass, fail, false, pred))
      (t:EOf) :
        val typeid = id(pkgids[n(t)] as ClassId)
        emit(Branch1Ins(pass, fail, InstanceofOp(typeid), x))
      (t:EAnd) :
        val next = make-label()
        ctypeof(next, fail, x, a(t))
        emit(LabelIns(next))
        ctypeof(pass, fail, x, b(t))        
      (t:EOr) :
        val next = make-label()
        ctypeof(pass, next, x, a(t))
        emit(LabelIns(next))
        ctypeof(pass, fail, x, b(t))

  ;Compile instructions
  defn compile (ins:EIns) :
    match(ins) :
      (ins:EDef) :
        match(y(ins)) :
          ;Initialize local to given value
          (y:EImm) :
            put(x(ins), cval(y))
          ;Initialize local to fresh value
          (y:False) :
            for x in locals(x(ins)) do :
              val t = type(defs[n(x)])
              val v = match(t) :
                (t:VMByte) : NumConst(0Y)
                (t:VMInt) : NumConst(0)
                (t:VMLong) : NumConst(0L)
                (t:VMFloat) : NumConst(0.0f)
                (t:VMDouble) : NumConst(0.0)
                (t:VMRef) : Marker(VM-VOID-TYPE-ID)
              emit(SetIns(x, v))
      (ins:EShuffle) :
        fatal("Not yet implemented")
        ;public defstruct EShuffle <: EIns :
        ;  xs: Tuple<EVarLoc>
        ;  ys: Tuple<EImm>
      (ins:ETuple) :
        val len = length(ys(ins))
        val size = NumConst(8 + 8 * len)
        val x = local(x(ins))
        emit(AllocIns([x], [VM-TUPLE-TYPE-ID], [size]))
        emit(StoreIns(x, 0, LongConst(len)))
        for (y in ys(ins), o in 8 to false by 8) do :
          emit(StoreIns(x, o, imm!(y)))
      (ins:EVoidTuple) :
        val len = LongConst(length(ins))
        emit(CallUtil(local(x(ins)), VM-VOID-TUPLE-FN-ID, [len]))
      (ins:ETupleGet) :
        val x = local(x(ins))
        val o = 8 + 8 * index(ins)
        emit(LoadIns(x, imm!(y(ins)), o))
      (ins:ETupleSet) :
        val y = imm!(y(ins))
        val o = 8 + 8 * index(ins)
        val z = imm!(z(ins))
        emit(StoreIns(y, o, z))
      (ins:ECheckLength) :
        val pass-lbl = make-label()
        val fail-lbl = make-label()
        val len = makedef(VMLong())
        val expected-len = LongConst(length(ins))
        emit(LoadIns(len, y, 0))
        emit(Branch2Ins(pass-lbl, fail-lbl, EqOp(), len, expected-len))
        emit(LabelIns(fail-lbl))
        emit(CallError(VM-LENGTH-ERROR-FN-ID, [len, expected-len]))
        emit(LabelIns(pass-lbl))
      (ins:EObject) :
        val obj-size = size(gt, n(ins))
        val offsets = offsets(gt, n(ins))
        val typeid = id(pkgids[n(x)] as ClassId)
        val x = local(x(ins))
        emit(AllocIns(x, [typeid], [NumConst(obj-size)]))
        for (o in offsets, y in ys(ins)) do :
          emit(StoreIns(x, o, imm!(y)))
      (ins:ENewObject) :
        val ntargs = length(targs(ins))
        val nargs = length(args(ins))
        val nslots = ntargs + nargs
        val typeid = id(pkgids[n(x)] as ClassId)
        val x = local(x(ins))
        emit(AllocIns(x, [typeid], [NumConst(8 * nslots)]))
        for (a in cat(targs(ins), ys(ins)), o in 0 to false by 8) do :
          emit(StoreIns(x, o, imm!(a)))
      (ins:EArray) :
        ;Struct properties
        val base-size = size(gt,n(ins))
        val item-size = item-size(gt,n(ins))
        ;Evaluate arguments
        val ys = map-cat(imms!, ys)
        val len = ys[0]        
        ;Compute size
        val size = makedef(VMLong())
        if item-size == 1 :
          emit(Op2Ins(size, AddOp(), len, LongConst(base-size + 7)))
          emit(Op2Ins(size, AndOp(), size, LongConst(-8)))
        else :
          emit(Op2Ins(size, MulOp(), len, LongConst(item-size)))
          if item-size % 8 == 0 :
            emit(Op2Ins(size, AddOp(), size, LongConst(base-size)))
          else :
            emit(Op2Ins(size, AddOp(), size, LongConst(base-size + 7)))
            emit(Op2Ins(size, AndOp(), size, LongConst(-8)))            
        ;Allocate array
        val x = local(x(ins))
        val typeid = id(pkgids[n(x)] as ClassId)
        emit(AllocIns(x, [typeid], [size]))
        for (y in ys, o in base+item-offsets(gt,n(ins))) do :
          emit(StoreIns(x, o, y))          
      (ins:EStruct) :
        val xs = to-seq(locals(x(ins)))
        for y in ys(ins) do :
          match(cval(y)) :
            (y:CImm) :
              for y in imms(y) do :
                emit(SetIns(next(xs), y))
            (y:CMem) :
              val a = address(y)
              for o in offsets(y) do :
                emit(LoadIns(next(xs), a, o))
      (ins:EPtr) :        
        val x = local(x(ins))
        val ptr = cloc(loc(ins)) as PtrLoc
        if base(loc(ins)) is EDeref :
          emit(Op1Ins(x, DerefOp(), imm!(base(ptr))))
          if offset(ptr) is CVal :
            emit(Op2Ins(x, AddOp(), x, imm!(offset(ptr) as CVal)))
          if const(ptr) > 0 :
            emit(Op2Ins(x, AddOp(), x, LongConst(const(ptr))))
        else :
          match(offset(ptr) is CVal, const(ptr) > 0) :
            (r1:True, r2:True) :
              emit(Op2Ins(x, AddOp(), imm!(base(ptr)), imm!(offset(ptr) as CVal)))
              emit(Op2Ins(x, AddOp(), x, LongConst(const(ptr))))
            (r1:True, r2:False) :
              emit(Op2Ins(x, AddOp(), imm!(base(ptr)), imm!(offset(ptr) as CVal)))
            (r1:False, r2:True) :
              emit(Op2Ins(x, AddOp(), imm!(base(ptr)), LongConst(const(ptr))))
            (r1:False, r2:False) :
              put(/x(ins), base(ptr))       
      (ins:ELoad) :     
        match(cloc(loc(ins))) :
          (l:LocalLoc) :
            val ys = locals-table[n(l)]
            val len = length(gt,xtype(ins))
            for (x in locals(x(ins)), i in 0 to len) do :
              emit(SetIns(x, ys[index(l) + i]))
          (l:PtrLoc) :
            val base = imm!(base(l))
            val base-offset = match(offset(l)) :
              (o:CVal) : imm!(o)
              (o:False) : false
            for (x in locals(x(ins)), o in offsets(gt,xtype(ins))) do :
              emit(LoadIns(x, base, base-offset, const(l) + o))
      (ins:EStore) :
        match(cloc(loc(ins)), cval(y(ins))) :
          (l:LocalLoc, y:CImm) :
            val xs = locals(n(l))
            for (y in imms(y), i in 0 to false) do :
              emit(SetIns(xs[index(l) + i], y))
          (l:LocalLoc, y:CMem) :
            val xs = locals(n(l))
            val a = imm!(base(y))
            for (o in offsets(y), i in 0 to false) do :
              emit(LoadIns(xs[index(l) + i], a, o))
          (l:PtrLoc, y) :
            val base = imm!(base(l))
            val base-offset = match(offset(l)) :
              (o:CVal) : imm!(o)
              (o:False) : false
            for (o in offsets(gt,ytype(ins)), y in imms!(y)) do :
              emit(StoreIns(base, base-offset, const(l) + o, y))                  
      (ins:ELabel) :
        val lbl = make-label(n(ins))
        emit(LabelIns(lbl))
      (ins:EDo) :        
        ;Retrieve arguments
        val xs = match(x(ins)) :
          (x:EVarLoc) : locals(x)
          (x:False) : []
        ;Call a known function
        defn call-code (n:Int, targs:Tuple<EType>, args:Tuple<EImm>) :
          val args* = cat-all $ [
            [Marker(VM-FALSE-TYPE-ID), NumConst(length(args))]
            seq-cat(imms!, cat(targs, args))]
          emit(CallIns(xs, pkgids[n] as VMImm, to-tuple(args*)))
        ;Call a closure
        defn call-closure (f:EImm, targs:Tuple<EType>, args:Tuple<EImm>) :
          val f* = imm!(f)
          val args* = cat-all $ [
            [f*, NumConst(length(args))]
            seq-cat(imms!, cat(targs, args))]
          emit(CallClosureIns(xs, f*, to-tuple(args*)))
        ;Call a function pointer
        defn call-pointer (f:EImm, args:Tuple<EImm>) :
          val f* = imm!(f)
          val args* = cat-all $ [
            [Marker(VM-FALSE-TYPE-ID), NumConst(length(args))]
            seq-cat(imms!, args)]
          emit(CallIns(xs, f*, to-tuple(args*)))
        ;Dispatch
        match(f(ins)) :
          (f:ECurry) :
            call-code(n(x(f)), targs(f), ys(ins))
          (f:EVar) :
            if ptr?(ins) : call-pointer(f, [], ys(ins))
            else if function?(gt, n(f)) : call-code(n(f), [], ys(ins))
            else : call-closure(f, [], ys(ins))
          (f) :
            if ptr?(ins) : call-pointer(f, [], ys(ins))
            else : call-closure(f, [], ys(ins))
      (ins:EDoC) :        
        ;Retrieve arguments
        val xs = match(x(ins)) :
          (x:EVarLoc) : locals(x)
          (x:False) : []
        ;Retrieve function
        val f* = match(f(ins)) :
          (f:EVar) :
            if function?(gt,n(f)) : pkgids[n(f)] as VMImm
            else : imm!(f)
          (f) : imm!(f)
        ;Emit call
        emit(CallCIns(xs, f*, map-cat(imms!,ys(ins))))
      (ins:EDump) :
        val ys* = to-tuple(filter-by<Local>(seq-cat(imms!,ys(ins))))
        emit(DumpIns(ys*))
      (ins:EInterpret) :
        emit(Op1Ins(local(x(ins)), InterpretOp(), imm!(y(ins))))
      (ins:EConv) :        
        emit(Op1Ins(local(x(ins)), ConvOp(), imm!(y(ins))))
      (ins:EGoto) :
        emit(GotoIns(get-label(n(ins))))
      (ins:EPrim) :        
        val x = local(x(ins))
        val vm-op = to-vm-op(op(ins))
        emit $ switch(arity(op(ins))) :
          0 : Op0Ins(x, vm-op)
          1 : Op1Ins(x, vm-op, imm!(ys[0]))
          2 : Op2Ins(x, vm-op, imm!(ys[0]), imm!(ys[1]))
      (ins:EIf) :        
        val pass-lbl = get-label(n1(ins))
        val fail-lbl = get-label(n2(ins))
        emit $ match(op(ins)) :
          (op:EOp) :
            val vm-op = to-vm-op(op(ins))
            switch(arity(op(ins))) :
              1 : Branch1Ins(pass-lbl, fail-lbl, vm-op, imm!(ys[0]))
              2 : Branch2Ins(pass-lbl, fail-lbl, vm-op, imm!(ys[0]), imm!(ys[1]))
          (op:False) :
            Branch1Ins(pass-lbl, fail-lbl, false, imm!(ys[0]))
      (ins:EMatch) :
        val ys* = map(imm!, ys(ins))
        for b in branches(ins) do :
          val fail-lbl = make-label()
          val lasti = length(ys(ins)) - 1
          for (y in ys*, t in types(b), i in 0 to false) do :
            val pass-lbl = get-label(n(b)) when i == lasti
                      else make-label()
            ctypeof(pass-lbl, fail-lbl, y, t)
            emit(LabelIns(pass-lbl))
          emit(LabelIns(fail-lbl))
        emit(CallError(VM-NO-BRANCH-ERROR-FN-ID, []))          
      (ins:EDispatch) :
        ;public defstruct EDispatch <: EIns :
        ;  ys: Tuple<EImm>
        ;  branches: Tuple<EBranch> with: (updater => sub-branches)
        fatal("Not yet implemented")
      (ins:ECheck) :
        val y = imm!(y(ins))
        val pass-lbl = make-label()
        val fail-lbl = make-label()
        ctypeof(pass-lbl, fail-lbl, y, type(ins))
        emit(LabelIns(fail-lbl))
        emit(CallError(VM-CAST-ERROR-FN-ID, []))
        emit(LabelIns(pass-lbl))
      (ins:ECheckSet) :
        val y = imm!(y(ins))
        val pass-lbl = make-label()
        val fail-lbl = make-label()
        emit(Branch2Ins(pass-lbl, fail-lbl, RefNeOp(), y, Marker(VM-VOID-TYPE-ID)))
        emit(LabelIns(fail-lbl))
        emit(CallError(VM-VARIABLE-UNINITIALIZED-ERROR-FN-ID, []))
        emit(LabelIns(pass-lbl))
      (ins:EBox) :
        val x = local(x(ins))
        val v = match(y(ins)) :
          (y:EImm) : imm!(y)
          (y:False) : Marker(VM-VOID-TYPE-ID)
        emit(AllocIns([x], [VM-BOX-TYPE-ID], [8]))
        emit(StoreIns(x, 0, v))
      (ins:EBoxGet) :        
        val x = local(x(ins))
        emit(LoadIns(x, imm!(y(ins)), 0))
      (ins:EBoxSet) :
        val y = imm!(y(ins))
        val z = imm!(z(ins))
        emit(StoreIns(y, 0, z))
      (ins:EReturn) :
        emit(ReturnIns(imms!(y(ins))))
      (ins:EObjectGet) :
        val x = local(x(ins))
        val y = imm!(y(ins))
        val slot-index = num-targs(gt,n(ins)) + index(ins)
        emit(LoadIns(x, y, slot-index * 8))
      (ins:EObjectTGet) :
        val x = local(x(ins))
        val y = imm!(y(ins))
        emit(LoadIns(x, y, index(ins) * 8))
      (ins:EClosureGet) :
        val x = local(x(ins))
        val y = imm!(y(ins))
        val slot-index = num-targs(gt,n(ins)) + index(ins)
        emit(LoadIns(x, y, slot-index * 8))
      (ins:EClosureTGet) :
        val x = local(x(ins))
        val y = imm!(y(ins))
        emit(LoadIns(x, y, index(ins) * 8))
      (ins:ELetRec) :
        val sizes = for c in ys(ins) map :
          val num-slots = length(targs(c)) + length(ys(c))
          NumConst(8 + 8 + num-slots * 8)
        val xs* = map(local, xs(ins))
        val ts = map({VM-FN-TYPE-ID}, xs(ins))
        emit(AllocIns(xs*, ts, sizes))
        for (x in xs*, c in ys(ins)) do :
          val num-slots = length(targs(c)) + length(ys(c))
          emit(StoreIns(x, 0, NumConst(num-slots)))
          emit(StoreIns(x, 8, pkgids[n(c)] as CodeId))
          for (a in cat(targs(c), ys(c)), o in 16 to false by 8) do :
            emit(StoreIns(x, o, imm!(a)))
      (ins:ETypeObject) :
        val x = local(x(ins))
        val size = NumConst(8 + 8 + 8 * length(targs(ins)))
        emit(AllocIns([x], [VM-TYPE-TYPE-ID], [size]))
        emit(StoreIns(x, 0, NumConst(length(targs(ins)))))
        emit(StoreIns(x, 8, pkgids[n(ins)] as CodeId))
        for (a in targs(ins), o in 16 to false by 8) do :
          emit(StoreIns(x, o, imm!(a)))

  ;Return compiler
  new Compiler :
    defmethod compile (this, ins:Seqable<EIns>) :
      do(compile, ins)
    ;defmethod load-locals (this, locals:Seqable<ELocal>) :
    ;  clear(immtable)
    ;  clear(typetable)
    ;  for x in locals do :
    ;    val t = to-vm-type(type(x))
    ;    typetable[n(x)] = t
    ;    immtable[n(x)] = makedef(t)
    ;defmethod local (this, n:Int) :
    ;  immtable[n] as Local
    ;defmethod defs (this) :
    ;  to-tuple(defs)
    ;defmethod instructions (this) :
    ;  to-tuple(insbuffer)

defn to-vm-type (t:EType) :
  match(t) :
    (t:EByte) : VMByte()
    (t:EInt) : VMInt()
    (t:ELong) : VMLong()
    (t:EFloat) : VMFloat()
    (t:EDouble) : VMDouble()
    (t:EOf) : VMRef()

defn base (l:ELoc) :
  match(l) :
    (l:EField) : base(loc(l))
    (l:ESlot) : base(loc(l))
    (l) : l

defn arity (op:EOp) -> Int :
  match(op) :
    (op:CurrentStackOp|GlobalsOp|ConstsOp|ConstsDataOp) : 0
    (op:IntNotOp|IntNegOp|NotOp|NegOp) : 1
    (op:IntAddOp|IntSubOp|IntMulOp|IntDivOp|IntModOp|IntAndOp|
        IntOrOp|IntXorOp|IntShlOp|IntShrOp|IntAshrOp|IntLtOp|
        IntGtOp|IntLeOp|IntGeOp|RefEqOp|RefNeOp|AddOp|SubOp|
        MulOp|DivOp|ModOp|AndOp|OrOp|XorOp|ShlOp|ShrOp|AshrOp|
        EqOp|NeOp|LtOp|GtOp|LeOp|GeOp|UleOp|UltOp|UgtOp|UgeOp) : 2

defn LongConst (x:Int) :
  NumConst(to-long(x))

defn map-cat<?T,?S> (f:T -> Seqable<?S>, xs:Tuple<?T>) :
  to-tuple(seq(f,xs))

defn string-bytes (s:String) :
  val n = length(s)
  val a = ByteArray(n + 1)  
  for (c in s, i in 0 to false) do :
    a[i] = to-byte(c)
  a[n] = 0Y
  a

;============================================================
;====================== GlobalTable =========================
;============================================================

deftype GlobalTable
;Retrieve type of global variable
defmulti type (t:GlobalTable, n:Int) -> EType
defmulti function? (t:GlobalTable, n:Int) -> True|False

;Retrieve struct properties
defmulti offsets (t:GlobalTable, t:EType) -> Int
defmulti size (t:GlobalTable, t:EType) -> Int
defmulti length (t:GlobalTable, t:EType) -> Int
defmulti alignment (t:GlobalTable, t:EType) -> Int
defmulti vmtypes (t:GlobalTable, t:EType) -> Tuple<VMType>
defmulti field-index (t:GlobalTable, n:Int, index:Int) -> Int
defmulti field-offset (t:GlobalTable, n:Int, index:Int) -> Int
defmulti item-size (t:GlobalTable, n:Int) -> Int
defmulti base+item-offsets (t:GlobalTable, n:Int) -> Seq<Int>
defmulti num-targs (t:GlobalTable, n:Int) -> Int

deftype GlobalEntry
defstruct VarEntry <: GlobalEntry :
  type: EType
defstruct FnEntry <: GlobalEntry
defstruct StructEntry <: GlobalEntry :  
  base: Tuple<EType>
  items: False|EType
  offsets: Tuple<Int> with: (default => void)
  size: Int with: (default => void)
  length: Int with: (default => void)
  alignment: Int with: (default => void)
  vmtypes: Tuple<VMType> with: (default => void)
  field-indices: Tuple<Int> with: (default => void)
  field-offsets: Tuple<Int> with: (default => void)
defstruct ClosureEntry <: GlobalEntry :
  ntargs: Int
  nargs: Int
defstruct ObjectEntry <: GlobalEntry :
  ntargs: Int
  nargs: Int

defn GlobalTable (io:PackageIO, epackage:EPackage) :
  ;Conversion to ETypes
  val tt = DTypeTable(io)
  defn to-etype (t:DType) : /to-etype(tt, t, [])
  defn to-etype (t:False) : false

  ;Create global entries
  val table = IntTable<GlobalEntry>()  
  for import in imports(io) do :
    match(rec(import)) :
      (r:FnRec|MultiRec|ExternFnRec) :
        table[n(import)] = FnEntry()
      (r:ValRec|ExternRec) :
        table[n(import)] = VarEntry(to-etype(type(r)))
      (r:StructRec) :
        val base* = map(to-etype, base(r))
        val items* = to-etype(items(r))
        table[n(import)] = StructEntry(base*, items*)
      (r) : false
  for e in exps(epackage) do :
    match(e) :
      (e:EDefn|EDefmulti|EExternFn) :
        table[n(e)] = FnEntry()
      (e:EDefGlobal|EExtern) :
        table[n(e)] = VarEntry(type(e))
      (e:EDefStruct) :
        table[n(e)] = StructEntry(base(e), items(e))
      (e:EDefObject) :
        table[n(e)] = ObjectEntry(ntargs(e), nargs(e))
      (e:EDefClosure) :
        table[n(e)] = ClosureEntry(ntargs(e), nargs(e))
      (e) :
        false

  ;Compute struct properties
  defn compute-struct-properties (this:GlobalTable) :
    ;Compute the properties for struct n and all
    ;dependents of struct n.
    val analyzed = IntSet()
    defn compute-properties (n:Int) :
      if not analyzed[n] :
        val e = table[n] as StructEntry
        val structs = filter-by<EStructT>(cat(base(e), [items(e)]))
        do(compute-properties{n(_)}, structs)
        table[n] = analyze(e)
        add(analyzed, n)
      
    ;Analyze the given StructEntry
    ;(assumes that all dependencies have been analyzed)
    defn analyze (e:StructEntry) :
      ;Accumulators
      val offsets-list = Vector<Int>()
      var size-accum:Int = 0
      var length-accum:Int = 0
      var alignment-accum:Int = 1
      val vmtypes-list = Vector<VMType>()
      val field-indices-list = Vector<Int>()
      val field-offsets-list = Vector<Int>()
      
      ;Analyze each base field
      for t in base(e) do :
        ;Retrieve properties of this type
        val os = offsets(this,t)
        val vmts = vmtypes(this,t)
        val aln = alignment(this,t)
        val size = size(this,t)
        val len = length(this,t)

        ;Pad to appropriate alignment (assumes aln is power of 2)
        size-accum = (size-accum + aln - 1) & (- aln)

        ;Update accumulators
        add(field-offsets-list, size-accum)
        add(field-indices-list, len)
        add-all(offsets-list, seq({size-accum + _}, os))
        add-all(vmtypes-list, vmts)
        size-accum = size-accum + size
        length-accum = length-accum + len
        alignment-accum = max(alignment-accum, aln)
        
      ;Pad to appropriate alignment to finish
      match(items(e)) :
        (items:EType) :
          val aln = alignment(this, items)
          size-accum = (size-accum + aln - 1) & (- aln)
        (items:False) :
          size-accum = (size-accum + alignment-accum - 1) & (- alignment-accum)
          
      ;Return analyzed StructEntry
      StructEntry(base(e), items(e),
                  to-tuple(offsets-list),
                  size-accum,
                  length-accum,
                  alignment-accum,                  
                  to-tuple(vmtypes-list),
                  to-tuple(field-indices-list),
                  to-tuple(field-offsets-list))

    ;Driver    
    do(compute-properties, struct-ns) where :
      val structs = filter({value(_) is StructEntry}, table)
      val struct-ns = seq(key, structs)

  ;Create and initialize global table
  val gt = new GlobalTable :
    defmethod type (this, n:Int) :
      type(table[n] as VarEntry)
    defmethod function? (this, n:Int) :
      table[n] is FnEntry
    defmethod num-targs (this, n:Int) :
      match(table[n]) :
        (e:ClosureEntry) : num-targs(e)
        (e:ObjectEntry) : num-targs(e)
    defmethod vmtypes (this, t:EType) :
      match(t) :
        (t:EStructT) : vmtypes(table[n(t)] as StructEntry)
        (t:EFnT) : fatal("Invalid argument")
        (t:EUnknown) : fatal("Invalid argument")
        (t:EBot) : fatal("Invalid argument")
        (t:EByte) : VMByte()
        (t:EInt) : VMInt()
        (t:ELong) : VMLong()
        (t:EFloat) : VMFloat()
        (t:EDouble) : VMDouble()
        (t:EPtrT) : VMLong()
        (t) : VMRef()
    defmethod alignment (this, t:EType) :
      match(t) :
        (t:EStructT) : alignment(table[n(t)] as StructEntry)
        (t) : size(this, t)
    defmethod size (this, t:EType) :
      match(t) :
        (t:EStructT) : size(table[n(t)] as StructEntry)
        (t:EFnT) : fatal("Invalid argument")
        (t:EUnknown) : fatal("Invalid argument")
        (t:EBot) : fatal("Invalid argument")
        (t:EByte) : 1
        (t:EInt) : 4
        (t:ELong) : 8
        (t:EFloat) : 4
        (t:EDouble) : 8
        (t) : 8        
    defmethod length (this, t:EType) :
      match(t) :      
        (t:EStructT) : length(table[n(t)] as StructEntry)
        (t:EFnT) : fatal("Invalid argument")
        (t:EUnknown) : fatal("Invalid argument")
        (t:EBot) : fatal("Invalid argument")
        (t) : 1
    defmethod offsets (this, t:EType) :
      match(t) :
        (t:EStructT) : offsets(table[n(t)] as StructEntry)
        (t:EFnT) : fatal("Invalid argument")
        (t:EUnknown) : fatal("Invalid argument")
        (t:EBot) : fatal("Invalid argument")
        (t) : [0]
    defmethod field-index (this, n:Int, index:Int) :
      val e = table[n] as StructEntry
      if index < length(field-indices(e)) :
        field-indices(e)[index]
      else if index == length(field-indices(e)) :
        fatal("No rest field") when items(e) is False
        length(e)
      else :
        fatal("Field index out of bounds.")
    defmethod field-offset (this, n:Int, index:Int) :
      val e = table[n] as StructEntry
      if index < length(field-offsets(e)) :
        field-offsets(e)[index]
      else if index == length(field-offsets(e)) :
        fatal("No rest field") when items(e) is False
        size(e)
      else :
        fatal("Field index out of bounds.")
    defmethod item-size (this, n:Int) :
      val e = table[n] as StructEntry
      fatal("Not an array type") when items(e) is False
      size(this, items(e) as EType)
    defmethod base+item-offsets (this, n:Int) :
      val e = table[n] as StructEntry
      fatal("Not an array type") when items(e) is False
      val base-size = size(this, n)
      val item-size = size(this, items(e) as EType)
      val item-os = offsets(this, items(e) as EType)
      val recur-item-os = 
        for offset in base-size to false by item-size seq-cat :
          seq({offset + _}, item-os)
      cat(offsets(this,n), recur-item-os)
      
  compute-struct-properties(gt)
  gt

