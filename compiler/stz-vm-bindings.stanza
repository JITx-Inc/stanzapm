defpackage stz/vm-bindings :
  import core
  import collections
  import macro-utils
  import stz/vm-ir
  import stz/vm


;============================================================
;==================== Generation ============================
;============================================================

defn gen-format (f:CallFormat) :
  defn choice-index (t:VMType) :
    match(t) :
      (t:VMByte) : 0
      (t:VMInt) : 1
      (t:VMLong) : 2
      (t:VMFloat) : 3
      (t:VMDouble) : 4    
  defn gen-type (t:VMType, index:Int) :
    val lostanza-types = [`byte `int `long `float `double]
    val int-types = [`byte `int `long `int `long]
    val vm-types = [`(VMByte()), `(VMInt()), `(VMLong()), `(VMFloat()), `(VMDouble())]
    val i = choice-index(t)
    [`#type => choice(i)
     `#arg => gensym(`arg)
     `#temp => gensym(`temp)
     `#index => index
     `lostanza-type => lostanza-types[i]
     `int-type => int-types[i]
     `vm-type => splice(vm-types[i])]
  val template = `(
    lostanza defn #call-function (f:long, registers:ptr<long>) -> long :
      val fptr = f as ptr<((args{lostanza-type}) -> (ret{lostanza-type}))>
      args{
        #type{
          val #arg = registers[#index]
        }{
          val #arg = registers[#index]
        }{
          val #arg = registers[#index]
        }{
          val #temp = registers[#index] as int-type
          val #arg = ($ls-prim fnum #temp)
        }{
          val #temp = registers[#index] as int-type
          val #arg = ($ls-prim fnum #temp)          
        }
      }
      val result = call-c [fptr](args{#arg})
      ret{
        #type{
          registers[0] = result
        }{
          registers[0] = result
        }{
          registers[0] = result
        }{
          registers[0] = ($ls-prim bits result)
        }{
          registers[0] = ($ls-prim bits result)
        }
      }
      return 0
    defn #CallFormat () :
      CallFormat([ret{vm-type}], [args{vm-type}])
    lostanza let :
      val f = addr(#call-function) as long
      set(FORMAT-TABLE, #CallFormat(), new Long{f}))
  substitute(template, [
    `#call-function => gensym(`call-function)
    `args => nested(to-list(seq(gen-type, ys(f), 0 to false)))
    `ret => nested(to-list(seq(gen-type, xs(f) as Tuple<VMType>, 0 to false)))
    `#CallFormat => gensym(`CallFormat)])

defn gen-fill (filled) :
  val bindings = to-tuple(cat([`filled => filled], GEN-DEFAULT-BINDINGS))
  val filled* = substitute(`filled, bindings)
  fill-template(filled*)

val GEN-DEFAULT-BINDINGS = [
  qualified(`stz/vm/set)
  qualified(`stz/vm/set)
  qualified(`stz/vm/EXTERN-TABLE)
  qualified(`stz/vm/FORMAT-TABLE)
  qualified(`stz/vm/CallFormat)
  qualified(`stz/vm-ir/VMByte)
  qualified(`stz/vm/ir/VMInt)
  qualified(`stz/vm/ir/VMLong)
  qualified(`stz/vm/ir/VMFloat)
  qualified(`stz/vm/ir/VMDouble)
  qualified(`core/Int)
  qualified(`core/Long)]

defn qualified (s:Symbol) :
  val [p, n] = qualifier(s)
  n => deep(s)

;============================================================
;=================== Analysis ===============================
;============================================================

defn analyze-func (f:VMFunc) :
  ;Construct definition table
  val deftable = to-inttable<VMDef> $
    for def in defs(f) seq :
      id(def) => def
  ;Immediate type
  defn imm-type (x:VMImm) :
    match(x:Local) : type(deftable[index(x)])
    else : type(x)
  defn imm-type (f:False) :
    false
  ;Scan through instructions for Call-C
  for ins in ins(f) do :
    match(ins:CallCIns) :    
      val xtypes = map(imm-type, xs(ins))
      val ytypes = map(imm-type, ys(ins))
      val format = CallFormat(xtypes, ytypes)
      println("Call format: %_" % [format])
      println(gen-fill(gen-format(format)))

defn main () :
  val filename = command-line-arguments()[1]
  val prog = read-vm-prog(filename)
  println(prog)

  ;For each extern print it out
  println("===== Externs =====")
  do(println, externs(prog))

  ;Discover all C calling formats
  println("===== C Calling Formats =====")
  do(analyze-func, funcs(prog))

main()














;<PLAN>

===== How do we generate an extern? =====

INPUT:

  extern 0 "helloworld"

OUTPUT:

  extern helloworld : long
  lostanza let :
    val f = addr(helloworld) as long
    stz/vm/set(stz/vm/EXTERN-TABLE, new core/Int{0}, new core/Long{f})

PRELUDE:

  defpackage stz/generated-bindings

===== How do we generate the call formats ====

INPUT:

  CallFormat(xs = [float], ys = [float double])


OUTPUT:

  lostanza defn call-function0 (f:long, registers:ptr<long>) -> long :
    val fptr = f as ptr<((float, double) -> (float))>
    val temp0 = registers[0] as int
    val arg0 = ($ls-prim fnum temp0)
    val temp1 = registers[1]
    val arg1 = ($ls-prim fnum temp1)
    val result = call-c [fptr](arg0, arg1)
    registers[0] = ($ls-prim bits result)
    return 0
  defn format0 () :
    stz/vm/CallFormat([stz/vm-ir/VMFloat()], [stz/vm-ir/VMFloat(), stz/vm-ir/VMDouble()])
  lostanza let :
    val f = addr(call-function0) as long
    stz/vm/set(stz/vm/FORMAT-TABLE, format0(), new core/Long{f})

;<PLAN>