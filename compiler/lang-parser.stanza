defpackage parser-lang :
   import core
   import reader
   import parser
   import collections
   import stz/core-macros
   import macro-utils
;

defsyntax parser :
   ;Temporary Definitions
   defrule :
      ids! = (?xs:#id ... ?rest ...) :
         CSE(rest, "Expected an identifier here.") when not empty?(rest)
         xs
   ;DefSyntax Definitions
   defrule :
      ;Import rule
      from! = (from) : false
      from! = () : CSE(form, "Expected the from keyword here.")      
      rule = (import ?name:#id #from! ?package:#id!) : ImportRule(List(name), package)
      rule = (import (?names:#ids!) #from! ?package:#id!) : ImportRule(names, package)
      
      ;Defproduction rule
      public? = (public) : true
      public? = () : false
      rule = (?p:#public? defproduction ?name:#id! : ?type:#type!) : DefProductionRule(name, type, p)
      rule = (?p:#public? defproduction ?name:#id!) : DefProductionRule(name, `?, p)

      ;Defrule rule      
      rule = (defrule ?e:#id! = (?pat ...) when ?guard:#exp! #:! ?body:#exp!) : DefActionRule(e, pat, One(guard), body)
      rule = (defrule ?e:#id! = (?pat ...) #:! ?body:#exp!) : DefActionRule(e, pat, None(), body)
      rule = (defrule ?e:#id! = inline ?ie:#id!) :
         if not prefix?(ie, "#") :
            CSE(form, "Cannot inline non-production. Productions must begin with # but received: %_." % [ie])
         DefInlineRule(e, ie)         
      rule = (defrule ?e:#id! != (?pat ...) when ?guard:#exp!) : DefNotRule(e, pat, One(guard))      
      rule = (defrule ?e:#id! != (?pat ...)) : DefNotRule(e, pat, None())
      rule != (defrule ?e:#id! (!= | =)) : CSE(form, "Expected a pattern definition for rule.")
      rule != (defrule ?e:#id!) : CSE(form, "Expected either = or != operator after defrule.")

      ;Failif rule
      =! = (=) : false
      =! != () : CSE(form, "Expected the = operator here.")
      rule = (fail-if ?e:#id! #=! (?pat ...) when ?guard:#exp! #:! ?body:#exp!) : DefFailRule(e, pat, One(guard), body)
      rule = (fail-if ?e:#id! #=! (?pat ...) #:! ?body:#exp!) : DefFailRule(e, pat, None(), body)
      rule != (fail-if ?e:#id! #=!) : CSE(form, "Expected a pattern definition for fail-if rule.")

      ;Stanza expression rule
      rule = (?e:#exp) : StanzaExpressionRule(e)

      ;Defsyntax rule
      prefix-op = (defsyntax ?name:#id! #:! (?rs:#rule ... ?rest ...)) :         
         CSE(rest, "Expected either rule definition or expression." % [rest]) when not empty?(rest)
         compile(DefSyntaxRule(name, rs))

   ;MatchSyntax Definitions
   defrule :
      ;Match pattern
      match-pat = ((?pat ...) when ?guard:#exp! #:! ?body:#exp!) : MatchPattern(pat, One(guard), body)
      match-pat = ((?pat ...) #:! ?body:#exp!) : MatchPattern(pat, None(), body)
      ;Match packages
      match-pkg! = (?base:#id! + ?overlays:#ids!) : [base, overlays]
      match-pkg! = (?base:#id! _) : CSE(form, "Expected + operator following base package.")
      match-pkg! = (?base:#id!) : [base, List()]

      prefix-op = (match-syntax[?pkgs:#match-pkg!](?arg:#exp$) #:! (?ps:#match-pat ... ?rest ...)) :
         CSE(rest, "Expected match pattern here.") when not empty?(rest)
         val [base, overlays] = pkgs
         expande(compile(MatchSyntaxRule(base, overlays, arg, ps)))
      prefix-op = (match-syntax(?arg:#exp$) #:! (?ps:#match-pat ... ?rest ...)) :
         CSE(rest, "Expected match pattern here.") when not empty?(rest)
         expande(compile(MatchSyntaxRule(`empty, List(), arg, ps)))
      prefix-op != (match-syntax[?pkgs:#match-pkg!]) :
         CSE(form, "match-syntax must be followed by form to match upon in parenthesis.")
      prefix-op != (match-syntax) :
         CSE(form, "match-syntax must be followed by form to match upon in parenthesis.")

   ;ParseSyntax Definitions
   defrule :
      parse-pat = (?e:#id! ~ ...) : List(e, `...)
      parse-pat = (?e:#id!) : List(e)
      
      parse-props = (?base:#id + ((! /) ?overlays:#id) @... / ?pat:#parse-pat) :
         [base, overlays, pat]
      parse-props = (?base:#id + ((! /) ?overlays:#id) @...) :
         CSE(form, "parse-syntax is missing specified pattern.")
      parse-props = (?base:#id / ?pat:#parse-pat) :
         [base, List(), pat]
      parse-props = () :
         CSE(form, "parse-syntax requires packages followed by pattern.")

      prefix-op = (parse-syntax[?props:#parse-props](?arg:#exp$)) :
         val [base, overlays, pattern] = props
         val template = `(
            match-syntax[base + overlays](form) :
               (?x:pattern) : x)
         expande $ fill-template(template, [
            `base => base
            `overlays => splice(overlays)
            `form => arg
            `pattern => splice(pattern)])

;============================================================
;=================== Temporary ==============================
;============================================================

defn first-info (form) -> FileInfo|False :
   defn loop (form) -> Maybe<FileInfo> :
      match(form) :
         (form:Token) : One(info(form))
         (form:List) : first(loop, form)
         (form) : None()
   value?(loop(form))      

defn CSE (form, msg) :
   throw $ new Exception :
      defmethod print (o:OutputStream, this) :
         match(first-info(form)) :
            (info:FileInfo) : print(o, "%_: Syntax Error: %_" % [info msg])
            (info:False) : print(o, "Syntax Error: %_ Received %~." % [msg, form])

defn expande (x) :
   with-syntax(parser, core) :
      match-syntax(x) :
         (?x:#exp) : x

;============================================================
;====================== Test ================================
;============================================================

defn main () :
   val filename = command-line-arguments()[1]
   with-syntax(parser, core) :
      match-syntax(read-file(filename)) :
         (?es:#exp ...) :
            for e in es do :
               println(e)
               println("\n")

main()
