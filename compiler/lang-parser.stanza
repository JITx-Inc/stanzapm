defpackage parser-lang :
   import core
   import reader
   import collections
   import stz/core-macros
   import macro-utils
   import stz/parser2

defsyntax parser :
   defrule :
      sym = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

      rule = (import ?name:#sym from ?package:#sym) : ImportRule(List(name), package)
      rule = (import (?names:#sym ...) from ?package:#sym) : ImportRule(names, package)
      rule = (public defproduction ?name:#sym : ?type:#type) : DefProductionRule(name, type, true)
      rule = (defproduction ?name:#sym : ?type:#type) : DefProductionRule(name, type, false)
      rule = (public defproduction ?name:#sym) : DefProductionRule(name, `?, true)
      rule = (defproduction ?name:#sym) : DefProductionRule(name, `?, false)
      rule != (defproduction) : fatal("%_: Invalid syntax: %_" % [info, form])

      rule = (defrule ?e:#sym = (?pat ...) : ?body:#exp) : DefActionRule(e, pat, None(), body)
      rule = (defrule ?e:#sym = (?pat ...) when ?guard:#exp : ?body:#exp) : DefActionRule(e, pat, One(guard), body)
      rule = (defrule ?e:#sym != (?pat ...)) : DefNotRule(e, pat, None())
      rule = (defrule ?e:#sym != (?pat ...) when ?guard:#exp) : DefNotRule(e, pat, One(guard))
      rule = (defrule ?e:#sym = inline ?ie:#sym) : DefInlineRule(e, ie)
      rule != (defrule) : fatal("%_: Invalid syntax: %_" % [info, form])
      rule = (fail-if ?e:#sym = (?pat ...) : ?body:#exp) : DefFailRule(e, pat, None(), body)
      rule = (fail-if ?e:#sym = (?pat ...) when ?guard:#exp : ?body:#exp) : DefFailRule(e, pat, One(guard), body)
      rule != (fail-if) : fatal("%_: Invalid syntax: %_" % [info, form])
      rule = (?e:#exp) : StanzaExpressionRule(e)

      prefix-op = (defsyntax ?name:#sym : (?rs:#rule ... ?rest ...)) :
         fatal("Expected rule but got %_." % [rest]) when not empty?(rest)
         compile(DefSyntaxRule(name, rs))

   defrule :
      match-prod = ((?pat ...) : ?body:#exp) : MatchPattern(pat, None(), body)
      match-prod = ((?pat ...) when ?guard:#exp : ?body:#exp) : MatchPattern(pat, One(guard), body)

      match-pkg = (?base:#sym + ?overlays:#sym ...) : [base, overlays]
      match-pkg = (?base:#sym) : [base, List()]

      prefix-op = (match-syntax[?pkgs:#match-pkg](?arg:#exp) : (?ps:#match-prod ... ?rest ...)) :
         fatal("Expected match production but got %_." % [rest]) when not empty?(rest)
         val [base, overlays] = pkgs
         expande(compile(MatchSyntaxRule(base, overlays, arg, ps)))
      prefix-op = (match-syntax(?arg:#exp) : (?ps:#match-prod ... ?rest ...)) :
         fatal("Expected match production but got %_." % [rest]) when not empty?(rest)
         expande(compile(MatchSyntaxRule(`empty, List(), arg, ps)))

;============================================================
;================ Compilation Utilities =====================
;============================================================

defn expande (x) :
   with-syntax(core) :
      match-syntax(x) :
         (?x:#exp) : x

;============================================================
;====================== Test ================================
;============================================================

defn main () :
   val filename = command-line-arguments()[1]
   with-syntax(parser, core) :
      match-syntax(read-file(filename)) :
         (?es:#exp ...) :
            for e in es do :
               println(e)
               println("\n")

main()
