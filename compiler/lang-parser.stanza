defpackage parser-lang :
   import core
   import reader
   import collections
   import stz/core-macros
   import macro-utils
   import stz/parser2

defsyntax parser :
   defrule :
      sym = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

      rule = (import ?name:#sym from ?package:#sym) : ImportRule(List(name), package)
      rule = (import (?names:#sym ...) from ?package:#sym) : ImportRule(names, package)
      rule = (public defproduction ?name:#sym : ?type:#type) : DefProductionRule(name, type, true)
      rule = (defproduction ?name:#sym : ?type:#type) : DefProductionRule(name, type, false)
      rule = (public defproduction ?name:#sym) : DefProductionRule(name, `?, true)
      rule = (defproduction ?name:#sym) : DefProductionRule(name, `?, false)
      rule != (defproduction) : fatal("%_: Invalid syntax: %_" % [info, form])

      rule = (defrule ?e:#sym = (?pat ...) : ?body:#exp) : DefActionRule(e, pat, None(), body)
      rule = (defrule ?e:#sym = (?pat ...) when ?guard:#exp : ?body:#exp) : DefActionRule(e, pat, One(guard), body)
      rule = (defrule ?e:#sym != (?pat ...)) : DefNotRule(e, pat, None())
      rule = (defrule ?e:#sym != (?pat ...) when ?guard:#exp) : DefNotRule(e, pat, One(guard))
      rule != (defrule) : fatal("%_: Invalid syntax: %_" % [info, form])
      rule = (fail-if ?e:#sym = (?pat ...) : ?body:#exp) : DefFailRule(e, pat, None(), body)
      rule = (fail-if ?e:#sym = (?pat ...) when ?guard:#exp : ?body:#exp) : DefFailRule(e, pat, One(guard), body)
      rule != (fail-if) : fatal("%_: Invalid syntax: %_" % [info, form])
      rule = (?e:#exp) : StanzaExpressionRule(e)

      prefix-op = (defsyntax ?name:#sym : (?rs:#rule ... ?rest ...)) :
         fatal("Expected rule but got %_." % [rest]) when not empty?(rest)
         compile(DefSyntaxRule(name, rs))

   defrule :
      match-prod = ((?pat ...) : ?body:#exp) : MatchPattern(pat, None(), body)
      match-prod = ((?pat ...) when ?guard:#exp : ?body:#exp) : MatchPattern(pat, One(guard), body)

      prefix-op = (match-syntax(?arg:#exp) : (?ps:#match-prod ... ?rest ...)) :
         fatal("Expected match production but got %_." % [rest]) when not empty?(rest)
         expande(compile(MatchSyntaxRule(arg, ps)))

   defrule :
      prefix-op = (with-syntax(?name0:#sym (+ ?names:#sym) @...) : ?body:#exp) :
         expande(compile-with-syntax(cons(name0,names), body))
      prefix-op = (with-added-syntax(?name0:#sym (+ ?names:#sym) @...) : ?body:#exp) :
         expande(compile-with-added-syntax(cons(name0,names), body))

;============================================================
;================ Compilation Utilities =====================
;============================================================
;
defn expande (x) :
   with-syntax(core) :
      match-syntax(x) :
         (?x:#exp) : x
;
;defn compile-action (pat:List, body) :
;   val template = `(
;      fn (#bindings) :
;         defn closest-info () : stz/parser2/info(#bindings)
;         defn closest-info (form) : stz/parser2/info(#bindings, form)
;         bindings{
;            val x = stz/parser2/get(#bindings, i)
;         }
;         body)
;   substitute(template, [
;      `#bindings => gensym(`bindings)
;      `bindings => nested $
;         for binding in get-bindings(parse-pattern(pat)) map : [
;            `x => key(binding)
;            `i => value(binding)]
;      `body => body])
;
;defn compile-guard (pat:List, body) :
;   val template = `(
;      fn (#bindings) :
;         defn closest-info () : stz/parser2/info(#bindings)
;         defn closest-info (form) : stz/parser2/info(#bindings, form)
;         bindings{
;            val x = stz/parser2/get(#bindings, i)
;         }
;         body)
;   substitute(template, [
;      `#bindings => gensym(`bindings)
;      `bindings => nested $
;         for binding in get-recomputable-bindings(parse-pattern(pat)) map : [
;            `x => key(binding)
;            `i => value(binding)]
;      `body => body])
;
;;============================================================
;;================== MatchSyntax Macro =======================
;;============================================================
;
;defstruct MatchSyntax :
;   form
;   patterns: List<MatchPattern>
;
;defstruct MatchPattern :
;   pattern: List
;   guard: Maybe
;   body
;
;val MATCH-SYNTAX-COUNTER = to-seq(0 to false)
;
;defn compile (m:MatchSyntax) :
;   ;Compile a matchpattern for executing action idx
;   defn cpl (p:MatchPattern, idx:Int) :
;      var form = substitute(`(parse-pattern(`pat)), [
;         `pat => pattern(p)])
;      if not empty?(guard(p)) :
;         form = substitute(`(Guard(guard, pat)), [
;            `guard => compile-guard(pattern(p), value!(guard(p)))
;            `pat => form])
;      substitute(`(IndexedAction(i, pat)), [
;         `i => idx
;         `pat => form])
;   ;Compile a list of matchpatterns
;   defn cpl (ps:List<MatchPattern>) :
;      substitute(`(Choice{[pats]}), [
;         `pats => splice(map(cpl, ps, 0 to false))])
;   defn cpl (s:MatchSyntax) :
;      fill-template(`(syntax-match(form, id, pats, [actions])), [
;         `form => form(s)
;         `id => next(MATCH-SYNTAX-COUNTER)
;         `pats => cpl(patterns(s)),
;         `actions => splice $ for p in patterns(s) map :
;            compile-action(pattern(p), body(p))
;         `syntax-match => deep(`stz/parser2/syntax-match)
;         `Choice => deep(`stz/parser2/Choice)
;         `IndexedAction => deep(`stz/parser2/IndexedAction)
;         `Guard => deep(`stz/parser2/Guard)
;         `parse-pattern => deep(`stz/parser2/parse-pattern)])
;   ;Driver
;   cpl(m)
;
;============================================================
;================= WithSyntax Macro =========================
;============================================================

defn compile-with-syntax (names:List, body) :
   fill-template(`(stz/parser2/call-with-syntax(`names, fn () : body)), [
      `names => names
      `body => body])

defn compile-with-added-syntax (names:List, body) :
   fill-template(`(stz/parser2/call-with-added-syntax(`names, fn () : body)), [
      `names => names
      `body => body])

;;============================================================
;;================== DefSyntax Macro =========================
;;============================================================
;
;
;defstruct DefSyntax :
;   name: Symbol
;   prods: List<DefProduction>
;defstruct DefProduction :
;   name: Symbol
;   patterns: List<Pattern>
;defstruct Pattern :
;   type: Symbol
;   pattern: List
;   guard: Maybe
;   body
;
;defn compile (s:DefSyntax) :
;   ;Compile a pattern
;   defn cpl (p:Pattern) :
;      var form = substitute(`(parse-pattern(`pat)), [
;         `pat => pattern(p)])
;      if not empty?(guard(p)) :
;         form = substitute(`(Guard(guard, pat)), [
;            `guard => compile-guard(pattern(p), value!(guard(p)))
;            `pat => form])
;      switch {type(p) == _} :
;         `fail-if :
;            form = substitute(`(FailPat(action, pat)), [
;               `action => compile-action(pattern(p), body(p))
;               `pat => form])
;         `rule :
;            form = substitute(`(Action(action, pat)), [
;               `action => compile-action(pattern(p), body(p))
;               `pat => form])
;      form
;   ;Compile a Production
;   defn cpl (p:DefProduction) :
;      substitute(`(DefProduction(`name, to-list([pats]))), [
;         `name => name(p)
;         `pats => splice(map(cpl, patterns(p)))])
;   ;Compile a Syntax Package
;   defn cpl (p:DefSyntax) :
;      fill-template(`(register-syntax-package(SyntaxPackage(`name, to-list([prods])))), [
;         `name => name(p)
;         `prods => splice(map(cpl, prods(p)))
;         `to-list => deep(`core/to-list)
;         `parse-pattern => deep(`stz/parser2/parse-pattern)
;         `Guard => deep(`stz/parser2/Guard)
;         `FailPat => deep(`stz/parser2/FailPat)
;         `Action => deep(`stz/parser2/Action)
;         `DefProduction => deep(`stz/parser2/DefProduction)
;         `SyntaxPackage => deep(`stz/parser2/SyntaxPackage)
;         `register-syntax-package => deep(`stz/parser2/register-syntax-package)])
;   ;Driver
;   cpl(s)

;============================================================
;====================== Test ================================
;============================================================

defn main () :
   val filename = command-line-arguments()[1]
   with-syntax(parser, core) :
      match-syntax(read-file(filename)) :
         (?es:#exp ...) :
            for e in es do :
               println(e)
               println("\n")

main()
