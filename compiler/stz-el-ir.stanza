defpackage stz/el-ir :
  import core

;============================================================
;========================= Types ============================
;============================================================

public deftype EType

;LoStanza Types
public defstruct EByte <: EType
public defstruct EInt <: EType
public defstruct ELong <: EType
public defstruct EFloat <: EType
public defstruct EDouble <: EType
public defstruct EUnknown <: EType
public defstruct EPtrT <: EType : (type:EType)
public defstruct EFnT <: EType : (a:Tuple<EType>, r:False|EType, b:EType)
public defstruct EStructT <: EType : (n:Int)

;HiStanza Types
public defstruct EOf <: EType: (n:Int)
public defstruct ETVar <: EType: (n:Int)
public defstruct EAnd <: EType: (a:EType, b:EType)
public defstruct EOr <: EType: (a:EType, b:EType)
public defstruct ETop <: EType
public defstruct EBot <: EType

;============================================================
;======================= Wrapper ============================
;============================================================

public defstruct EPackage :
  name: Symbol
  exps: Tuple<ETExp> with: (updater => sub-exps)

;============================================================
;================== Top-Level Expressions ===================
;============================================================

public deftype ETExp
public defstruct EDef <: ETExp :
  n: Int
  type: EType
  mutable?: True|False
  lostanza?: True|False
  
public defstruct EDefn <: ETExp :
  n: Int
  func: EFunction with: (updater => sub-func)
  lostanza?: True|False

public defstruct EDefClosure <: ETExp :
  n: Int
  closure: Int
  ntargs: Int
  nargs: Int
  func: EFunction with: (updater => sub-func)

public defstruct EDefmulti <: ETExp :
  n: Int
  targs: Tuple<Int>
  a1: Tuple<EType>
  a2: EType

public defstruct EDefmethod <: ETExp :
  n: Int
  multi: Int
  targs: Tuple<EType>
  func: EFn with: (updater => sub-func)
  lostanza?: True|False

public defstruct EDefStruct <: ETExp :
  n: Int
  parent: False|EType
  base:Tuple<EType>
  items:EType|False

public defstruct EExternFn <: ETExp :
  n: Int
  lbl: Symbol
  func: EFn with: (updater => sub-func)

public defstruct EExtern <: ETExp :
  n: Int
  lbl: Symbol
  type: EType
  
public defstruct EBlock <: ETExp :
  body: EBody
  lostanza?: True|False

public defstruct EDefType <: ETExp :
  n: Int
  parent: False|EType
  children: Tuple<Int>

public defstruct EDefObject <: ETExp :
  n: Int
  parent: EType
  ntargs: Int
  nargs: Int

;============================================================
;======================== Functions =========================
;============================================================

public deftype EFunction

public defstruct EMultifn <: EFunction :
  funcs: Tuple<EFn>

public defstruct EFn <: EFunction :
  targs: Tuple<Int> with: (updater => sub-targs)
  args: Tuple<Int>
  a1: Tuple<EType>
  a2: EType
  body: EBody
  free: Free with: (init => void, updater => sub-free)

public defstruct ELocal :
  n: Int
  type: EType
  mutable?: True|False

public defstruct ELocalType :
  n: Int

public defstruct ELocalFn :
  n: Int
  func: EFunction with: (updater => sub-func)

public defstruct ELocalObj :
  n: Int
  type: EType
  methods: Tuple<EMethod> with: (updater => sub-methods)
public defstruct EMethod :
  multi: Int
  targs: Tuple<EType>
  thisn: Int
  func: EFn with: (updater => sub-func)

public defstruct EBody :
  locals: Tuple<ELocal> with: (updater => sub-locals)
  localtypes: Tuple<ELocalType> with: (updater => sub-localtypes)
  localfns: Tuple<ELocalFn> with: (updater => sub-localfns)
  localobjs: Tuple<ELocalObj> with: (updater => sub-localobjs)
  ins: Tuple<EIns> with: (updater => sub-ins)

public defstruct Free :
  vars: Tuple<Int>
  tvars: Tuple<Int>

;============================================================  
;======================= Instructions =======================
;============================================================  

public deftype EImm
public defstruct ELSLiteral <: EImm :
  value
public defstruct ELiteral <: EImm :
  value
public defstruct EVar <: EImm :
  n: Int
public defstruct EMix <: EImm :
  funcs: Tuple<EVar|ECurry>
public defstruct ECurry <: EImm :
  x: EVar
  targs: Tuple<EType>
public defstruct ESizeof <: EImm :
  type: EType
public defstruct ETagof <: EImm :
  n: Int

public defstruct ETVarLoc <: ELoc :
  n: Int

public deftype ELoc
public defstruct EVarLoc <: ELoc :
  n: Int
public defstruct EDeref <: ELoc :
  y: EImm
public defstruct EDeptr <: ELoc :
  y: EImm
public defstruct EField <: ELoc :
  loc: ELoc
  n: Int
  index: Int
public defstruct ESlot <: ELoc :
  loc: ELoc
  type: EType  ;type of result
  index: EImm

public deftype EIns
public defstruct ESet <: EIns :
  x: EVarLoc
  y: EImm
public defstruct EInit <: EIns :
  x: EVarLoc
  y: EImm|False
public defstruct EInitClosures <: EIns :
  xs: Tuple<EVarLoc>
public defstruct EShuffle <: EIns :
  xs: Tuple<EVarLoc>
  ys: Tuple<EImm>
public defstruct ECheckedDo <: EIns :
  x: EVarLoc
  xtype: EType with: (updater => sub-xtype)
  f: EImm
  ys: Tuple<EImm>
  ytypes: Tuple<EType> with: (updater => sub-ytypes)
public defstruct ENew <: EIns :
  x: EVarLoc
  n: Int
public defstruct ETuple <: EIns :
  x: EVarLoc
  ys: Tuple<EImm>
public defstruct EVoidTuple <: EIns :
  x: EVarLoc
  length: Int
public defstruct ETupleGet <: EIns :
  x: EVarLoc
  y: EImm
  index: Int
public defstruct ETupleSet <: EIns :
  y: EImm
  index: Int
  z: EImm
public defstruct EObject <: EIns :
  x: EVarLoc
  n: Int
  ys: Tuple<EImm>
public defstruct EArray <: EIns :
  x: EVarLoc
  n: Int
  ys: Tuple<EImm>
public defstruct EStruct <: EIns :
  x: EVarLoc
  n: Int
  ys: Tuple<EImm>
public defstruct EPtr <: EIns :
  x: EVarLoc
  loc: ELoc
public defstruct ELoad <: EIns :
  x: EVarLoc
  xtype: EType with: (updater => sub-xtype)
  loc: ELoc
public defstruct EStore <: EIns :
  loc: ELoc
  y: EImm
  ytype: EType with: (updater => sub-ytype)
public defstruct ELabel <: EIns :
  n: Int
public defstruct EDo <: EIns :
  x: EVarLoc|False
  xtype: EType|False with: (updater => sub-xtype)
  f: EImm
  ys: Tuple<EImm>
public defstruct EDoC <: EIns :
  x: EVarLoc|False
  xtype: EType|False with: (updater => sub-xtype)
  f: EImm
  ys: Tuple<EImm>
public defstruct EDump <: EIns :
  ys: Tuple<EImm>
public defstruct EInterpret <: EIns :
  x: EVarLoc
  y: EImm
public defstruct EConv <: EIns :
  x: EVarLoc
  y: EImm
public defstruct EGoto <: EIns :
  n: Int
public defstruct EPrim <: EIns :
  x: EVarLoc
  op: EOp
  ys: Tuple<EImm>  
public defstruct EIf <: EIns :
  n1: Int
  n2: Int
  op: EOp|False
  ys: Tuple<EImm>
public defstruct EMatch <: EIns :
  ys: Tuple<EImm>
  branches: Tuple<EBranch> with: (updater => sub-branches)
public defstruct EDispatch <: EIns :
  ys: Tuple<EImm>
  branches: Tuple<EBranch> with: (updater => sub-branches)
public defstruct ECheckLength <: EIns :
  y: EImm
  length: Int
public defstruct ECheck <: EIns :
  y: EImm
  type: EType
public defstruct ECheckSet <: EIns :
  y: EImm
public defstruct EBox <: EIns :
  x: EVarLoc
  y: EImm|False
public defstruct EBoxGet <: EIns :
  x: EVarLoc
  y: EImm
public defstruct EBoxSet <: EIns :
  y: EImm
  z: EImm  
public defstruct EReturn <: EIns :
  y: EImm
public defstruct ENewObject <: EIns :
  x: EVarLoc
  n: Int
  targs: Tuple<EType>
  ys: Tuple<EImm>
public defstruct EObjectGet <: EIns :
  x: EVarLoc
  y: EImm
  index: Int
public defstruct EObjectTGet <: EIns :
  x: ETVarLoc
  y: EImm
  index: Int
public defstruct EClosureGet <: EIns :
  x: EVarLoc
  y: EImm
  index: Int
public defstruct EClosureTGet <: EIns :
  x: ETVarLoc
  y: EImm
  index: Int
public defstruct ELetRec <: EIns :
  xs: Tuple<EVarLoc>
  ys: Tuple<EClosure>

public defstruct EBranch :
  types: Tuple<EType> with: (updater => sub-types)
  n: Int

public defstruct EClosure :
  n: Int
  targs: Tuple<EType>
  ys: Tuple<EImm>

;============================================================
;======================= Primitives =========================
;============================================================

public deftype EOp
public defstruct IntAddOp <: EOp
public defstruct IntSubOp <: EOp
public defstruct IntMulOp <: EOp
public defstruct IntDivOp <: EOp
public defstruct IntModOp <: EOp
public defstruct IntAndOp <: EOp
public defstruct IntOrOp <: EOp
public defstruct IntXorOp <: EOp
public defstruct IntNotOp <: EOp
public defstruct IntShlOp <: EOp
public defstruct IntShrOp <: EOp
public defstruct IntAshrOp <: EOp
public defstruct IntLtOp <: EOp
public defstruct IntGtOp <: EOp
public defstruct IntLeOp <: EOp
public defstruct IntGeOp <: EOp
public defstruct IntNegOp <: EOp

public defstruct RefEqOp <: EOp
public defstruct RefNeOp <: EOp

public defstruct AddOp <: EOp
public defstruct SubOp <: EOp
public defstruct MulOp <: EOp
public defstruct DivOp <: EOp
public defstruct ModOp <: EOp
public defstruct AndOp <: EOp
public defstruct OrOp <: EOp
public defstruct XorOp <: EOp
public defstruct NotOp <: EOp
public defstruct ShlOp <: EOp
public defstruct ShrOp <: EOp
public defstruct AshrOp <: EOp
public defstruct EqOp <: EOp
public defstruct NeOp <: EOp
public defstruct LtOp <: EOp
public defstruct GtOp <: EOp
public defstruct LeOp <: EOp
public defstruct GeOp <: EOp
public defstruct UleOp <: EOp
public defstruct UltOp <: EOp
public defstruct UgtOp <: EOp
public defstruct UgeOp <: EOp
public defstruct NegOp <: EOp

public defstruct CurrentStackOp <: EOp
public defstruct GlobalsOp <: EOp
public defstruct ConstsOp <: EOp
public defstruct ConstsDataOp <: EOp

;============================================================
;========================= Printer ==========================
;============================================================

defmethod print (o:OutputStream, op:EOp) :
  print{o, _} $ match(op) :
    (op:CurrentStackOp) : "current-stack"
    (op:GlobalsOp) : "globals"
    (op:ConstsOp) : "consts"
    (op:ConstsDataOp) : "consts-data"
    (op:AddOp) : "add"
    (op:SubOp) : "sub"
    (op:MulOp) : "mul"
    (op:DivOp) : "div"
    (op:ModOp) : "mod"
    (op:AndOp) : "and"
    (op:OrOp) : "or"
    (op:XorOp) : "xor"
    (op:NotOp) : "not"
    (op:ShlOp) : "shl"
    (op:ShrOp) : "shr"
    (op:AshrOp) : "ashr"
    (op:EqOp) : "eq"
    (op:NeOp) : "ne"
    (op:LtOp) : "lt"
    (op:GtOp) : "gt"
    (op:LeOp) : "le"
    (op:GeOp) : "ge"
    (op:UleOp) : "ule"
    (op:UltOp) : "ult"
    (op:UgtOp) : "ugt"
    (op:UgeOp) : "uge"
    (op:NegOp) : "neg"
    (op:IntAddOp) : "int-add"
    (op:IntSubOp) : "int-sub"
    (op:IntMulOp) : "int-mul"
    (op:IntDivOp) : "int-div"
    (op:IntModOp) : "int-mod"
    (op:IntAndOp) : "int-and"
    (op:IntOrOp) : "int-or"
    (op:IntXorOp) : "int-xor"
    (op:IntNotOp) : "int-not"
    (op:IntShlOp) : "int-shl"
    (op:IntShrOp) : "int-shr"
    (op:IntAshrOp) : "int-ashr"
    (op:IntLtOp) : "int-lt"
    (op:IntGtOp) : "int-gt"
    (op:IntLeOp) : "int-le"
    (op:IntGeOp) : "int-ge"
    (op:IntNegOp) : "int-neg"
    (op:RefEqOp) : "ref-eq"
    (op:RefNeOp) : "ref-ne"

defmethod print (o:OutputStream, t:EType) :
  print{o, _} $ match(t) :
    (t:EByte) : "byte"
    (t:EInt) : "int"
    (t:ELong) : "long"
    (t:EFloat) : "float"
    (t:EDouble) : "double"
    (t:EUnknown) : "?"
    (t:ETop) : "top"
    (t:EBot) : "bot"
    (t:EPtrT) : "ptr<%_>" % [type(t)]
    (t:EFnT) :
      match(r(t)) :
        (r:EType) : "fn<(%,), %_, %_>" % [a(t), r, b(t)]
        (r:False) : "fn<(%,), %_>" % [a(t), b(t)]
    (t:EStructT) : "T%_" % [n(t)]      
    (t:EOf) : "ref<T%_>" % [n(t)]
    (t:ETVar) : "TV%_" % [n(t)]
    (t:EAnd) : "and(%_, %_)" % [a(t), b(t)]
    (t:EOr) : "or(%_, %_)" % [a(t), b(t)]
    
defmethod print (o:OutputStream, e:EDef) :
  val valstr = "var" when mutable?(e) else "val"
  val ls-str = " lostanza" when lostanza?(e) else ""
  print(o, "def%_%_ V%_:%_" % [valstr, ls-str, n(e), type(e)])

defmethod print (o:OutputStream, e:EDefn) :
  val ls-str = " lostanza" when lostanza?(e) else ""
  print(o, "defn%_ V%_ %_" % [ls-str, n(e), func(e)])

defmethod print (o:OutputStream, e:EDefClosure) :
  print(o, "defclosure V%_ (closure = V%_, ntargs = %_, nargs = %_) %_" % [
    n(e), closure(e), ntargs(e), nargs(e), func(e)])

defmethod print (o:OutputStream, e:EDefmulti) :
  defn tvstr (x:Int) : "TV%_" % [x]
  print(o, "defmulti V%_<%,> (%,) -> %_" % [n(e), seq(tvstr,targs(e)), a1(e), a2(e)])

defmethod print (o:OutputStream, e:EDefmethod) :
  val ls-str = " lostanza" when lostanza?(e) else ""
  print(o, "defmethod%_ V%_<%,> (id = V%_) %_" % [ls-str, multi(e), targs(e), n(e), func(e)])

defmethod print (o:OutputStream, e:EDefStruct) :
  val pstr = "" when parent(e) is False else " <: %_" % [parent(e)]
  match(items(e)) :
    (items:EType) :
      print(o, "defstruct T%_%_ : (%, ...)" % [n(e), pstr, cat(base(e), [items])])
    (items:False) :
      print(o, "defstruct T%_%_ : (%,)" % [n(e), pstr, base(e)])

defmethod print (o:OutputStream, e:EExternFn) :
  print(o, "externfn %~ V%_ %_" % [lbl(e), n(e), func(e)])

defmethod print (o:OutputStream, e:EExtern) :
  print(o, "extern %~ V%_:%_" % [lbl(e), n(e), type(e)])

defmethod print (o:OutputStream, e:EBlock) :
  val ls-str = " lostanza" when lostanza?(e) else ""
  print(o, "block%_ :%_" % [ls-str, body(e)])

defmethod print (o:OutputStream, e:EDefType) :
  val pstr = "" when parent(e) is False
        else " <: %_" % [parent(e)]
  defn tstr (x:Int) : "T%_" % [x]
  print(o, "deftype T%_%_ (%,)" % [n(e), pstr, seq(tstr,children(e))])

defmethod print (o:OutputStream, e:EDefObject) :
  print(o, "defobject T%_ <: %_ (ntargs = %_, nargs = %_)" % [n(e), parent(e), ntargs(e), nargs(e)])

defmethod print (o:OutputStream, f:EFn) :
  defn tvstr (x:Int) : "TV%_" % [x]
  defn astr (x:Int,t:EType) : "V%_:%_" % [x,t]
  print(o, "fn<%,> (%,) -> %_ :%_" % [seq(tvstr,targs(f)), seq(astr, args(f), a1(f)), a2(f), body(f)])

defmethod print (o:OutputStream, b:EBody) :
  bprint(o, cat-all $ [locals(b), localfns(b), localobjs(b), ins(b)])

defmethod print (o:OutputStream, f:EMultifn) :
  print(o, "multifn :")
  bprint(o, funcs(f))

defmethod print (o:OutputStream, l:ELocal) :
  val varstr = "var" when mutable?(l) else "val"
  print(o, "def%_ V%_:%_" % [varstr, n(l), type(l)])

defmethod print (o:OutputStream, l:ELocalType) :
  print(o, "type T%_" % [n(l)])

defmethod print (o:OutputStream, e:ELocalFn) :
  print(o, "defn V%_ %_" % [n(e), func(e)])

defmethod print (o:OutputStream, e:ELocalObj) :
  print(o, "defobj O%_ <: %_ :" % [n(e), type(e)])
  bprint(o, methods(e))

defmethod print (o:OutputStream, e:EMethod) :
  print(o, "defmethod V%_<%,> (this = V%_) %_" % [multi(e), targs(e), thisn(e), func(e)])

defmethod print (o:OutputStream, e:EImm) :
  print{o, _} $ match(e) :
    (e:EVar) : "V%_" % [n(e)]
    (e:ECurry) : "%_<%,>" % [x(e), targs(e)]
    (e:ELSLiteral) : "LV{%_}" % [value(e)]
    (e:ELiteral) : "V{%_}" % [value(e)]
    (e:EMix) : "mix(%,)" % [funcs(e)]
    (e:ESizeof) : "sizeof(%_)" % [type(e)]
    (e:ETagof) : "tagof(T%_)" % [n(e)]  

defmethod print (o:OutputStream, e:EIns) :
  defn P (x) : print(o, x)
  match(e) : 
    (e:ESet) : P $ "%_ = %_" % [x(e), y(e)]
    (e:EInit) :
      val ystr = " = %_" % [y(e)] when y(e) is-not False else ""
      P $ "init %_%_" % [x(e), ystr]
    (e:EShuffle) : P $ "[%,] = [%,]" % [xs(e), ys(e)]
    (e:EInitClosures) : P $ "init-closures (%,)" % [xs(e)]
    (e:ECheckedDo) :
      defn arg (y:EImm, t:EType) : "%_:%_" % [y,t]
      P $ "%_:%_ = check-do %_(%,)" % [x(e), xtype(e), f(e), seq(arg, ys(e), ytypes(e))]
    (e:ENew) : P $ "%_ = new O%_" % [x(e), n(e)]
    (e:ETuple) : P $ "%_ = tuple [%,]" % [x(e), ys(e)]
    (e:EVoidTuple) : P $ "%_ = void-tuple(%_)" % [x(e), length(e)]
    (e:ETupleGet) : P $ "%_ = tuple-get %_[%_]" % [x(e), y(e), index(e)]
    (e:ETupleSet) : P $ "tuple-set %_[%_] = %_" % [y(e),index(e), z(e)]
    (e:ECheckLength) : P $ "check-length(%_) == %_" % [y(e), length(e)]
    (e:EObject) : P $ "%_ = object T%_ (%,)" % [x(e), n(e), ys(e)]
    (e:EArray) : P $ "%_ = array T%_ (%,)" % [x(e), n(e), ys(e)]
    (e:EStruct) : P $ "%_ = struct T%_ (%,)" % [x(e), n(e), ys(e)]
    (e:EPtr) : P $ "%_ = addr(%_)" % [x(e), loc(e)]
    (e:ELoad) : P $ "%_:%_ = load %_" % [x(e), xtype(e), loc(e)]
    (e:EStore) : P $ "store %_ = %_:%_" % [loc(e), y(e), ytype(e)]
    (e:ELabel) : P $ "label L%_" % [n(e)]
    (e:EDo) :
      P $ "%_do %_(%,)" % [xstr, f(e), ys(e)] where :
        val xstr = "" when x(e) is False
              else "%_:%_ = " % [x(e), xtype(e)]
    (e:EDoC) :
      P $ "%_do-c %_(%,)" % [xstr, f(e), ys(e)] where :
        val xstr = "" when x(e) is False
              else "%_:%_ = " % [x(e), xtype(e)]
    (e:EInterpret) : P $ "%_ = interpret %_" % [x(e), y(e)]
    (e:EConv) : P $ "%_ = conv %_" % [x(e), y(e)]
    (e:ECheck) : P $ "check %_ : %_" % [y(e), type(e)]
    (e:EGoto) : P $ "goto L%_" % [n(e)]
    (e:EPrim) : P $ "%_ = prim %_(%,)" % [x(e), op(e), ys(e)]
    (e:EIf) :
      P $ match(op(e)) :
        (op:EOp) : "goto L%_ when prim %_(%,) else L%_" % [n1(e), op, ys(e), n2(e)]
        (op:False) : "goto L%_ when %_ else L%_" % [n1(e), ys(e)[0], n2(e)]
    (e:EMatch) :
      P $ "match(%,) :" % [ys(e)]
      bprint(o, branches(e))
    (e:EDispatch) :
      P $ "dispatch(%,) :" % [ys(e)]
      bprint(o, branches(e))
    (e:ECheckSet) : P $ "check-set %_" % [y(e)]
    (e:EBox) :
      P $ "%_ = box(%_)" % [x(e), vstr] where :
        val vstr = "" when y(e) is False else y(e)
    (e:EBoxGet) : P $ "%_ = box-get %_" % [x(e), y(e)]
    (e:EBoxSet) : P $ "box-set %_ = %_" % [y(e), z(e)]        
    (e:EReturn) : P $ "return %_" % [y(e)]
    (e:ENewObject) : P $ "%_ = new-object T%_<%,> (%,)" % [x(e), n(e), targs(e), ys(e)]
    (e:EObjectGet) : P $ "%_ = object-get %_[%_]" % [x(e), y(e), index(e)]
    (e:EObjectTGet) : P $ "%_ = object-tget %_[%_]" % [x(e), y(e), index(e)]
    (e:EClosureGet) : P $ "%_ = closure-get %_[%_]" % [x(e), y(e), index(e)]
    (e:EClosureTGet) : P $ "%_ = closure-tget %_[%_]" % [x(e), y(e), index(e)]
    (e:ELetRec) : P $ "letrec (%,) = (%,)" % [xs(e), ys(e)]
    (e:EDump) :  P $ "dump (%,)" % [ys(e)]

defmethod print (o:OutputStream, e:EClosure) :
  print(o, "closure V%_<%,>(%,)" % [n(e), targs(e), ys(e)])

defmethod print (o:OutputStream, e:EBranch) :
  print(o, "(%,) : goto L%_" % [types(e), n(e)])

defmethod print (o:OutputStream, p:EPackage) :
  print(o, "package %~ :" % [name(p)])
  bprint(o, exps(p))

defmethod print (o:OutputStream, e:ELoc) :
  print{o, _} $ match(e) :
    (e:EVarLoc) : "V%_" % [n(e)]
    (e:EDeref) : "deref(%_)" % [y(e)]
    (e:EDeptr) : "deptr(%_)" % [y(e)]
    (e:EField) : "field(%_, T%_[%_])" % [loc(e), n(e), index(e)]
    (e:ESlot) : "slot(%_[%_] : %_)" % [loc(e), index(e), type(e)]    

defmethod print (o:OutputStream, t:ETVarLoc) :
  print(o, "TV%_" % [n(t)])

defn lnprint (o:OutputStream, x) :
  print(o, '\n')
  print(o, x)

defn lnprints (o:OutputStream, xs:Seqable) :
  do(lnprint{o, _}, xs)

defn bprint (o:OutputStream, xs:Seqable) :
  val xs-seq = to-seq(xs)
  if empty?(xs-seq) : print(o, " ()")
  else : lnprints(IndentedStream(o), xs-seq)

;============================================================
;========================= Reader ===========================
;============================================================

defsyntax el-ir :
  defn prefix-id? (x, s:String) :
    match(unwrap-token(x)) :
      (x:Symbol) : prefix?(x, s)
      (x) : false
  defn id-prefix (info:FileInfo|False, x:Symbol|Token, len:Int) :
    match(to-int(to-string(unwrap-token(x))[len to false])) :
      (i:Int) : i
      (i) : throw(ELE(info, "Invalid name: %~" % [x]))

  defproduction tvid : Int
  defrule tvid = (?x) when prefix-id?(x,"TV") : id-prefix(closest-info(), x, 2)
  defproduction tid : Int
  defrule tid = (?x) when prefix-id?(x,"T") : id-prefix(closest-info(), x, 1)
  defproduction vid : Int
  defrule vid = (?x) when prefix-id?(x,"V") : id-prefix(closest-info(), x, 1)
  defproduction oid : Int
  defrule oid = (?x) when prefix-id?(x,"O") : id-prefix(closest-info(), x, 1)
  defproduction lid : Int
  defrule lid = (?x) when prefix-id?(x,"L") : id-prefix(closest-info(), x, 1)  

  defproduction eop : EOp
  defrule eop = (current-stack) : CurrentStackOp()
  defrule eop = (globals) : GlobalsOp()
  defrule eop = (consts) : ConstsOp()
  defrule eop = (consts-data) : ConstsDataOp()
  defrule eop = (add) : AddOp()
  defrule eop = (sub) : SubOp()
  defrule eop = (mul) : MulOp()
  defrule eop = (div) : DivOp()
  defrule eop = (mod) : ModOp()
  defrule eop = (and) : AndOp()
  defrule eop = (or) : OrOp()
  defrule eop = (xor) : XorOp()
  defrule eop = (not) : NotOp()
  defrule eop = (shl) : ShlOp()
  defrule eop = (shr) : ShrOp()
  defrule eop = (ashr) : AshrOp()
  defrule eop = (eq) : EqOp()
  defrule eop = (ne) : NeOp()
  defrule eop = (lt) : LtOp()
  defrule eop = (gt) : GtOp()
  defrule eop = (le) : LeOp()
  defrule eop = (ge) : GeOp()
  defrule eop = (ule) : UleOp()
  defrule eop = (ult) : UltOp()
  defrule eop = (ugt) : UgtOp()
  defrule eop = (uge) : UgeOp()
  defrule eop = (neg) : NegOp()
  defrule eop = (int-add) : IntAddOp()
  defrule eop = (int-sub) : IntSubOp()
  defrule eop = (int-mul) : IntMulOp()
  defrule eop = (int-div) : IntDivOp()
  defrule eop = (int-mod) : IntModOp()
  defrule eop = (int-and) : IntAndOp()
  defrule eop = (int-or) : IntOrOp()
  defrule eop = (int-xor) : IntXorOp()
  defrule eop = (int-not) : IntNotOp()
  defrule eop = (int-shl) : IntShlOp()
  defrule eop = (int-shr) : IntShrOp()
  defrule eop = (int-ashr) : IntAshrOp()
  defrule eop = (int-lt) : IntLtOp()
  defrule eop = (int-gt) : IntGtOp()
  defrule eop = (int-le) : IntLeOp()
  defrule eop = (int-ge) : IntGeOp()
  defrule eop = (int-neg) : IntNegOp()
  defrule eop = (ref-eq) : RefEqOp()
  defrule eop = (ref-ne) : RefNeOp()

  defproduction etype : EType
  defrule etype = (byte) : EByte()
  defrule etype = (int) : EInt()
  defrule etype = (long) : ELong()
  defrule etype = (float) : EFloat()
  defrule etype = (double) : EDouble()
  defrule etype = (?) : EUnknown()
  defrule etype = (top) : ETop()
  defrule etype = (bot) : EBot()
  defrule etype = (ptr<?t:#etype>) : EPtrT(t)
  defrule etype = (fn<(?a:#etype ...), ?r:#etype, ?b:#etype>) : EFnT(to-tuple(a), r, b)
  defrule etype = (fn<(?a:#etype ...), ?b:#etype>) : EFnT(to-tuple(a), false, b)
  defrule etype = (?n:#tvid) : ETVar(n)
  defrule etype = (?n:#tid) : EStructT(n)
  defrule etype = (ref<?n:#tid>) : EOf(n)
  defrule etype = (and(?a:#etype,?b:#etype)) : EAnd(a,b)
  defrule etype = (or(?a:#etype,?b:#etype)) : EOr(a,b)

  defproduction lostanza? : True|False
  defrule lostanza? = (lostanza) : true
  defrule lostanza? = () : false

  defproduction etexp : ETExp
  defrule etexp = (defval ?ls:#lostanza? ?n:#vid : ?t:#etype) : EDef(n, t, false, ls)
  defrule etexp = (defvar ?ls:#lostanza? ?n:#vid : ?t:#etype) : EDef(n, t, true, ls)
  defrule etexp = (defn ?ls:#lostanza? ?n:#vid ?f:#efunc) : EDefn(n, f, ls)
  defrule etexp = (defclosure ?n:#vid
                              (closure = ?c:#vid, ntargs = ?ntargs:#int, nargs = ?nargs:#int)
                              ?f:#efunc) :
    EDefClosure(n, c, ntargs, nargs, f)
  defrule etexp = (defmulti ?n:#vid<?targs:#tvid ...> (?a1:#etype ...) -> ?a2:#etype) :
    EDefmulti(n, to-tuple(targs), to-tuple(a1), a2)
  defrule etexp = (defmethod ?ls:#lostanza? ?multi:#vid<?targs:#etype ...> (id = ?n:#vid) ?f:#efn) :
    EDefmethod(n, multi, to-tuple(targs), f, ls)
  defrule etexp = (defstruct ?n:#tid ?p:#parent? : (?ts:#etype ... ~ ...)) :
    EDefStruct(n, p to-tuple(but-last(ts)), last(ts))
  defrule etexp = (defstruct ?n:#tid ?p:#parent? : (?ts:#etype ...)) :
    EDefStruct(n, p, to-tuple(ts), false)
  defrule etexp = (externfn ?lbl:#symbol ?n:#vid ?f:#efn) : EExternFn(n, lbl, f)
  defrule etexp = (extern ?lbl:#symbol ?n:#vid : ?t:#etype) : EExtern(n, lbl, t)
  defrule etexp = (block ?ls:#lostanza? : ?b:#ebody) :
    EBlock(b, ls)
  defrule etexp = (deftype ?n:#tid ?p:#parent? (?cs:#tid ...)) : EDefType(n, p, to-tuple(cs))
  defrule etexp = (defobject ?n:#tid <: ?p:#etype (ntargs = ?ntargs:#int, nargs = ?nargs:#int)) : EDefObject(n, p, ntargs, nargs)

  defproduction ebody : EBody
  defrule ebody = ((?locals:#elocal ...
                    ?localtypes:#elocaltype ...
                    ?localfns:#elocalfn ...
                    ?localobjs:#elocalobj ...
                    ?ins:#eins ... #E)) :
    EBody(to-tuple(locals), to-tuple(localtypes), to-tuple(localfns), to-tuple(localobjs), to-tuple(ins))                

  defproduction parent? : False|EType
  defrule parent? = (<: ?t:#etype) : t
  defrule parent? = () : false

  defproduction elocal : ELocal
  defrule elocal = (defvar ?n:#vid : ?t:#etype) : ELocal(n, t, true)
  defrule elocal = (defval ?n:#vid : ?t:#etype) : ELocal(n, t, false)

  defproduction elocaltype : ELocalType
  defrule elocaltype = (type ?n:#tid) : ELocalType(n)

  defproduction elocalfn : ELocalFn
  defrule elocalfn = (defn ?n:#vid ?f:#efunc) : ELocalFn(n, f)

  defproduction elocalobj : ELocalObj
  defrule elocalobj = (defobj ?n:#oid <: ?t:#etype : (?ms:#emethod ... #E)) : ELocalObj(n,t,to-tuple(ms))
  defproduction emethod : EMethod
  defrule emethod = (defmethod ?multi:#vid<?targs:#etype ...> (this = ?thisn:#vid) ?f:#efn) :
    EMethod(multi, to-tuple(targs), thisn, f)

  defproduction efunc : EFunction
  defrule efunc = (?f:#efn) : f
  defrule efunc = (multifn : (?fs:#efn ... #E)) : EMultifn(to-tuple(fs))
  
  defproduction efn : EFn
  defrule efn = (fn<?targs:#tvid ...> ((?args:#vid : ?a1:#etype) @...) -> ?a2:#etype : ?b:#ebody) :
    EFn(to-tuple(targs), to-tuple(args), to-tuple(a1), a2, b)  

  defproduction eins : EIns
  defrule eins = (init ?x:#vloc = ?y:#eimm) : EInit(x, y)
  defrule eins = (init ?x:#vloc) : EInit(x, false)
  defrule eins = (init-closures (?xs:#vloc ...)) : EInitClosures(to-tuple(xs))
  defrule eins = (letrec (?xs:#vloc ...) = (?cs:#eclosure ...)) : ELetRec(to-tuple(xs), to-tuple(cs))
  defrule eins = (box-set ?y:#eimm = ?z:#eimm) : EBoxSet(y, z)
  defrule eins = (return ?y:#eimm) : EReturn(y)
  defrule eins = (tuple-set ?y:#eimm[?i:#int] = ?z:#eimm) : ETupleSet(y, i, z)
  defrule eins = (check-length(?y:#eimm) == ?len:#int) : ECheckLength(y, len)
  defrule eins = (check ?y:#eimm : ?t:#etype) : ECheck(y,t)
  defrule eins = (dump (?ys:#eimm ...)) : EDump(to-tuple(ys))
  defrule eins = (store ?loc:#eloc = ?y:#eimm : ?t:#etype) : EStore(loc, y, t)
  defrule eins = (label ?n:#lid) : ELabel(n)
  defrule eins = (do ?f:#eimm(?ys:#eimm ...)) : EDo(false, false, f, to-tuple(ys))
  defrule eins = (do-c ?f:#eimm(?ys:#eimm ...)) : EDoC(false, false, f, to-tuple(ys))
  defrule eins = (goto ?n1:#lid when prim ?op:#eop(?ys:#eimm ...) else ?n2:#lid) : EIf(n1, n2, op, to-tuple(ys))
  defrule eins = (goto ?n1:#lid when ?y:#eimm else ?n2:#lid) : EIf(n1, n2, false, [y])
  defrule eins = (goto ?n:#lid) : EGoto(n)
  defrule eins = (match(?ys:#eimm ...) : (?bs:#ebranch ...)) : EMatch(to-tuple(ys), to-tuple(bs))
  defrule eins = (dispatch(?ys:#eimm ...) : (?bs:#ebranch ...)) : EDispatch(to-tuple(ys), to-tuple(bs))
  defrule eins = (check-set ?y:#eimm) : ECheckSet(y)  
  defrule eins = (?x:#vloc = interpret ?y:#eimm) : EInterpret(x,y)
  defrule eins = (?x:#vloc = conv ?y:#eimm) : EConv(x,y)
  defrule eins = (?x:#vloc = prim ?op:#eop(?ys:#eimm ...)) : EPrim(x, op, to-tuple(ys))
  defrule eins = (?x:#vloc = box()) : EBox(x,false)
  defrule eins = (?x:#vloc = box(?y:#eimm)) : EBox(x,y)
  defrule eins = (?x:#vloc = box-get ?y:#eimm) : EBoxGet(x,y)
  defrule eins = (?x:#vloc = new ?n:#oid) : ENew(x,n)
  defrule eins = (?x:#vloc = new-object ?n:#tid<?targs:#etype ...> (?ys:#eimm ...)) : ENewObject(x, n, to-tuple(targs), to-tuple(ys))
  defrule eins = (?x:#vloc = object-get ?y:#eimm[?i:#int]) : EObjectGet(x, y, i)
  defrule eins = (?x:#tvloc = object-tget ?y:#eimm[?i:#int]) : EObjectTGet(x, y, i)
  defrule eins = (?x:#vloc = closure-get ?y:#eimm[?i:#int]) : EClosureGet(x, y, i)
  defrule eins = (?x:#tvloc = closure-tget ?y:#eimm[?i:#int]) : EClosureTGet(x, y, i)
  defrule eins = (?x:#vloc = tuple [?ys:#eimm ...]) : ETuple(x, to-tuple(ys))
  defrule eins = (?x:#vloc = void-tuple(?len:#int)) : EVoidTuple(x, len)
  defrule eins = (?x:#vloc = tuple-get ?y:#eimm[?i:#int]) : ETupleGet(x, y, i)
  defrule eins = (?x:#vloc = object ?n:#tid (?ys:#eimm ...)) : EObject(x, n, to-tuple(ys))
  defrule eins = (?x:#vloc = array ?n:#tid (?ys:#eimm ...)) : EArray(x, n, to-tuple(ys))
  defrule eins = (?x:#vloc = struct ?n:#tid (?ys:#eimm ...)) : EStruct(x, n, to-tuple(ys))
  defrule eins = (?x:#vloc = addr(?loc:#eloc)) : EPtr(x, loc)  
  defrule eins = (?x:#vloc : ?xt:#etype = check-do ?f:#eimm((?ys:#eimm : ?yt:#etype) @...)) : ECheckedDo(x, xt, f, to-tuple(ys), to-tuple(yt))
  defrule eins = (?x:#vloc : ?xt:#etype = load ?loc:#eloc) : ELoad(x, xt, loc)
  defrule eins = (?x:#vloc : ?xt:#etype = do ?f:#eimm(?ys:#eimm ...)) : EDo(x, xt, f, to-tuple(ys))
  defrule eins = (?x:#vloc : ?xt:#etype = do-c ?f:#eimm(?ys:#eimm ...)) : EDoC(x, xt, f, to-tuple(ys))
  defrule eins = (?x:#vloc = ?y:#eimm) : ESet(x, y)
  defrule eins = ([?xs:#vloc ...] = [?ys:#eimm ...]) : EShuffle(to-tuple(xs), to-tuple(ys))

  defproduction eclosure : EClosure
  defrule eclosure = (closure ?n:#vid<?targs:#etype ...>(?ys:#eimm ...)) :
    EClosure(n, to-tuple(targs), to-tuple(ys))

  defproduction ebranch : EBranch
  defrule ebranch = ((?ts:#etype ...) : goto ?n:#lid) : EBranch(to-tuple(ts), n)

  defproduction eimm : EImm
  defrule eimm = (LV{?x}) : ELSLiteral(unwrap-all(x))
  defrule eimm = (V{?x}) : ELiteral(unwrap-all(x))
  defrule eimm = (mix(?fs:#ecurry ...)) : EMix(to-tuple(fs))
  defrule eimm = (sizeof(?t:#etype)) : ESizeof(t)
  defrule eimm = (tagof(?n:#tid)) : ETagof(n)
  defrule eimm = (?x:#ecurry) : x

  defproduction ecurry : EVar|ECurry
  defrule ecurry = (?n:#vid<?targs:#etype ...>) : ECurry(EVar(n), to-tuple(targs))
  defrule ecurry = (?n:#vid) : EVar(n)

  defproduction vloc : EVarLoc
  defrule vloc = (?n:#vid) : EVarLoc(n)

  defproduction tvloc : ETVarLoc
  defrule tvloc = (?n:#tvid) : ETVarLoc(n)

  defproduction eloc : ELoc
  defrule eloc = (?x:#vloc) : x
  defrule eloc = (deref(?y:#eimm)) : EDeref(y)
  defrule eloc = (deptr(?y:#eimm)) : EDeptr(y)
  defrule eloc = (field(?loc:#eloc, ?n:#tid[?i:#int])) : EField(loc, n, i)
  defrule eloc = (slot(?loc:#eloc[?i:#eimm] : ?t:#etype)) : ESlot(loc, t, i)

  defproduction E : False
  fail-if E = (_) : ELE(closest-info(), "Unrecognized input here.")
  defrule E = () : false

  public defproduction epackage : EPackage
  defrule epackage = (package ?name:#symbol : (?es:#etexp ... #E)) : EPackage(name, to-tuple(es))

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

;============================================================
;====================== Errors ==============================
;============================================================

public defstruct ELError <: Exception :
  info: FileInfo|False
  msg

public defn ELE (info:FileInfo|False, msg) :
  ELError(info, msg)

defmethod print (o:OutputStream, e:ELError) :
  val info-str = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [info-str, msg(e)])

;============================================================
;===================== Classification =======================
;============================================================

public defn reftype? (t:EType) :
  t is EOf|ETVar|EAnd|EOr|ETop

;============================================================
;==================== Specific Mappers ======================
;============================================================

public defn do* (f:EType -> ?, item:ELItem) :
  defn f* (x:EType) : (f(x), x)
  map(f*, item)
  false

public defn do* (f:EImm -> ?, item:ELItem) :
  defn f* (x:EImm) : (f(x), x)
  map(f*, item)
  false

public defn do* (f:ELBigItem -> ?, item:ELItem) :
  defn f* (x:ELBigItem) : (f(x), x)
  map(f*, item)
  false

public defn map<?T> (f:EType -> EType, item:ELItem&?T) :
  defn f* (x:ELItem) -> ELItem :
    match(x) :
      (x:EType) : f(x)
      (x) : map(f*, x)
  map(f*, item)

public defn map<?T> (f:EImm -> EImm, item:ELItem&?T) :
  defn f* (x:ELItem) -> ELItem :
    match(x) :
      (x:EImm) : f(x)
      (x:EType) : x
      (x) : map(f*, x)
  map(f*, item)

public defn map<?T> (f:ELBigItem -> ELBigItem, item:ELItem&?T) -> T :
  ;Will be called on every item
  defn map-big (f:ELItem -> ELItem, item:ELItem) :
    defn f*<?T> (x:ELItem&?T) : f(x) as ELItem&T
    match(item) :
      (x:EBody) : EBody(locals(x), localtypes(x), map(f*,localfns(x)), map(f*,localobjs(x)), ins(x))
      (x:ELBigItem) : map(f, x)
      (x) : x
  defn f* (x:ELItem) :
    match(x:ELBigItem) : f(x)
    else : map-big(f*, x)
  map-big(f*, item) as ELItem&T

;============================================================
;====================== Mappers =============================
;============================================================

public deftype ELBigItem :
  EPackage <: ELBigItem
  ETExp <: ELBigItem
  EFunction <: ELBigItem
  EMethod <: ELBigItem
  EBody <: ELBigItem
  ELocalFn <: ELBigItem
  ELocalObj <: ELBigItem

public deftype ELItem :
  EType <: ELItem
  ELocal <: ELItem
  ELocalType <: ELItem
  EImm <: ELItem
  EIns <: ELItem
  ELoc <: ELItem
  ETVarLoc <: ELItem
  EBranch <: ELItem
  EClosure <: ELItem
  ELBigItem <: ELItem  

public defn do (f:ELItem -> ?, item:ELItem) :
  defn g (x:ELItem) : (f(x), x)
  map(g, item)
  false

public defn map<?T> (f:ELItem -> ELItem, item:ELItem&?T) -> T :
  defn h<?T> (x:ELItem&?T) : f(x) as ELItem&T
  defn h<?T> (x:Tuple<ELItem&?T>) : map(h,x)
  defn h? (x:False) : false
  defn h? (x:EType) : h(x)
  defn h? (x:EImm) : h(x)
  defn h? (x:EVarLoc) : h(x)

  {_ as ELItem&T} $ match(item) :
    ;Types
    (t:EByte) : t
    (t:EInt) : t
    (t:ELong) : t
    (t:EFloat) : t
    (t:EDouble) : t
    (t:EUnknown) : t
    (t:EPtrT) : EPtrT(h(type(t)))
    (t:EFnT) : EFnT(h(a(t)), h?(r(t)), h(b(t)))
    (t:EStructT) : t
    (t:EOf) : t
    (t:ETVar) : t
    (t:EAnd) : EAnd(h(a(t)), h(b(t)))
    (t:EOr) : EOr(h(a(t)), h(b(t)))
    (t:ETop) : t
    (t:EBot) : t

    ;EPackage
    (e:EPackage) : EPackage(name(e), h(exps(e)))

    ;ETExps    
    (e:EDef) : EDef(n(e), h(type(e)), mutable?(e), lostanza?(e))
    (e:EDefn) : EDefn(n(e), h(func(e)), lostanza?(e))
    (e:EDefClosure) : EDefClosure(n(e), closure(e), ntargs(e), nargs(e), h(func(e)))
    (e:EDefmulti) : EDefmulti(n(e), targs(e), h(a1(e)), h(a2(e)))
    (e:EDefmethod) : EDefmethod(n(e), multi(e), h(targs(e)), h(func(e)), lostanza?(e))
    (e:EDefStruct) : EDefStruct(n(e), h?(parent(e)), h(base(e)), h?(items(e)))
    (e:EExternFn) : EExternFn(n(e), lbl(e), h(func(e)))
    (e:EExtern) : EExtern(n(e), lbl(e), h(type(e)))
    (e:EBlock) : EBlock(h(body(e)), lostanza?(e))
    (e:EDefType) : EDefType(n(e), h?(parent(e)), children(e))
    (e:EDefObject) : EDefObject(n(e), h(parent(e)), ntargs(e), nargs(e))

    ;Functions
    (e:EMultifn) : EMultifn(h(funcs(e)))
    (e:EFn) : EFn(targs(e), args(e), h(a1(e)), h(a2(e)), h(body(e)))

    ;Bodies
    (e:EBody) : EBody(h(locals(e)), h(localtypes(e)), h(localfns(e)), h(localobjs(e)), h(ins(e)))

    ;Locals
    (e:ELocal) : ELocal(n(e), h(type(e)), mutable?(e))
    (e:ELocalFn) : ELocalFn(n(e), h(func(e)))

    ;Methods
    (e:EMethod) : EMethod(multi(e), h(targs(e)), thisn(e), h(func(e)))

    ;Imms
    (e:ELSLiteral) : e
    (e:ELiteral) : e
    (e:EVar) : e
    (e:ECurry) : ECurry(h(x(e)), h(targs(e)))
    (e:EMix) : EMix(h(funcs(e)))
    (e:ESizeof) : ESizeof(h(type(e)))
    (e:ETagof) : e

    ;Ins
    (e:ESet) : ESet(h(x(e)), h(y(e)))
    (e:EInit) : EInit(h(x(e)), h?(y(e)))
    (e:EInitClosures) : EInitClosures(h(xs(e)))
    (e:EShuffle) : EShuffle(h(xs(e)), h(ys(e)))
    (e:ECheckedDo) : ECheckedDo(h(x(e)), h(xtype(e)), h(/f(e)), h(ys(e)), h(ytypes(e)))
    (e:ENew) : ENew(h(x(e)), n(e))
    (e:ENewObject) : ENewObject(h(x(e)), n(e), h(targs(e)), h(ys(e)))
    (e:EObjectGet) : EObjectGet(h(x(e)), h(y(e)), index(e))
    (e:EObjectTGet) : EObjectTGet(h(x(e)), h(y(e)), index(e))
    (e:EClosureGet) : EClosureGet(h(x(e)), h(y(e)), index(e))
    (e:EClosureTGet) : EClosureTGet(h(x(e)), h(y(e)), index(e))
    (e:ETuple) : ETuple(h(x(e)), h(ys(e)))
    (e:EVoidTuple) : EVoidTuple(h(x(e)), length(e))
    (e:ETupleGet) : ETupleGet(h(x(e)), h(y(e)), index(e))
    (e:ETupleSet) : ETupleSet(h(y(e)), index(e), h(z(e)))
    (e:ECheckLength) : ECheckLength(h(y(e)), length(e))
    (e:EObject) : EObject(h(x(e)), n(e), h(ys(e)))
    (e:EArray) : EArray(h(x(e)), n(e), h(ys(e)))
    (e:EStruct) : EStruct(h(x(e)), n(e), h(ys(e)))
    (e:EPtr) : EPtr(h(x(e)), h(loc(e)))
    (e:ELoad) : ELoad(h(x(e)), h(xtype(e)), h(loc(e)))
    (e:EStore) : EStore(h(loc(e)), h(y(e)), h(ytype(e)))
    (e:ELabel) : e
    (e:EDo) : EDo(h?(x(e)), h?(xtype(e)), h(/f(e)), h(ys(e)))
    (e:EDoC) : EDoC(h?(x(e)), h?(xtype(e)), h(/f(e)), h(ys(e)))
    (e:EDump) : EDump(h(ys(e)))
    (e:EInterpret) : EInterpret(h(x(e)), h(y(e)))
    (e:EConv) : EConv(h(x(e)), h(y(e)))
    (e:ECheck) : ECheck(h(y(e)), h(type(e)))
    (e:EGoto) : e
    (e:EPrim) : EPrim(h(x(e)), op(e), h(ys(e)))
    (e:EIf) : EIf(n1(e), n2(e), op(e), h(ys(e)))
    (e:EMatch) : EMatch(h(ys(e)), h(branches(e)))
    (e:EDispatch) : EDispatch(h(ys(e)), h(branches(e)))
    (e:ECheckSet) : ECheckSet(h(y(e)))
    (e:EBox) : EBox(h(x(e)), h?(y(e)))
    (e:EBoxGet) : EBoxGet(h(x(e)), h(y(e)))
    (e:EBoxSet) : EBoxSet(h(y(e)), h(z(e)))
    (e:EReturn) : EReturn(h(y(e)))
    (e:ELetRec) : ELetRec(h(xs(e)), h(ys(e)))

    ;Locations
    (e:EVarLoc) : e
    (e:EDeref) : EDeref(h(y(e)))
    (e:EDeptr) : EDeptr(h(y(e)))
    (e:EField) : EField(h(loc(e)), n(e), index(e))
    (e:ESlot) : ESlot(h(loc(e)), h(type(e)), h(index(e)))

    ;Type Locations
    (e:ETVarLoc) : e

    ;Branches
    (e:EBranch) : EBranch(h(types(e)), n(e))

    ;Closures
    (e:EClosure) : EClosure(n(e), h(targs(e)), h(ys(e)))