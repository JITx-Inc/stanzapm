defpackage stz/el-ir :
  import core

;============================================================
;========================= Types ============================
;============================================================

public deftype EType

;LoStanza Types
public defstruct EByte <: EType
public defstruct EInt <: EType
public defstruct ELong <: EType
public defstruct EFloat <: EType
public defstruct EDouble <: EType
public defstruct EUnknown <: EType
public defstruct EPtrT <: EType : (type:EType)
public defstruct EFnT <: EType : (a:Tuple<EType>, r:False|EType, b:EType)
public defstruct EStructT <: EType : (n:Int)

;HiStanza Types
public defstruct EOf <: EType: (n:Int)
public defstruct ETVar <: EType: (n:Int)
public defstruct EAnd <: EType: (a:EType, b:EType)
public defstruct EOr <: EType: (a:EType, b:EType)
public defstruct ETop <: EType
public defstruct EBot <: EType

;============================================================
;======================= Wrapper ============================
;============================================================

public defstruct EPackage :
  name: Symbol
  exps: Tuple<ETExp>

;============================================================
;================== Top-Level Expressions ===================
;============================================================

public deftype ETExp
public defstruct EDef <: ETExp :
  n: Int
  type: EType
  mutable?: True|False
  
public defstruct EDefn <: ETExp :
  n: Int
  func: EFunction

public defstruct EDefmulti <: ETExp :
  n: Int
  targs: Tuple<Int>
  a1: Tuple<EType>
  a2: EType

public defstruct EDefmethod <: ETExp :
  n: Int
  multi: Int
  func: EFn

public defstruct EDefStruct <: ETExp :
  n: Int
  parent: False|EType
  base:Tuple<EType>
  items:EType|False

public defstruct EExternFn <: ETExp :
  n: Int
  lbl: Symbol
  func: EFunction

public defstruct EExtern <: ETExp :
  n: Int
  lbl: Symbol
  type: EType
  
public defstruct EInit <: ETExp :
  locals: Tuple<ELocal>
  ins: Tuple<EIns>

public defstruct EDefType <: ETExp :
  n: Int
  parent: False|EType
  children: Tuple<Int>

;============================================================
;======================== Functions =========================
;============================================================

public deftype EFunction

public defstruct EMultifn <: EFunction :
  funcs: Tuple<EFn>

public defstruct EFn <: EFunction :
  targs: Tuple<Int>
  args: Tuple<Int>
  a1: Tuple<EType>
  a2: EType
  locals: Tuple<ELocal>
  localfns: Tuple<ELocalFn>
  ins: Tuple<EIns>

public defstruct ELocal :
  n: Int
  type: EType
  mutable?: True|False

public defstruct ELocalFn :
  n: Int
  func: EFunction

;============================================================  
;======================= Instructions =======================
;============================================================  

public deftype EImm :
  EFunction <: EImm
public defstruct ELSLiteral <: EImm :
  value
public defstruct ELiteral <: EImm :
  value
public defstruct EVar <: EImm :
  n: Int
public defstruct EMix <: EImm :
  funcs: Tuple<ECurry>
public defstruct ECurry <: EImm :
  n: Int
  targs: Tuple<EType>
public defstruct ESizeof <: EImm :
  type: EType
public defstruct ETagof <: EImm :
  n: Int

public deftype EIns
public defstruct ESet <: EIns :
  x: EVar
  y: EImm
public defstruct EShuffle <: EIns :
  xs: Tuple<EVar>
  ys: Tuple<EImm>
public defstruct ELetRec <: EIns :
  xs: Tuple<EVar>
  closures: Tuple<EClosure>
public defstruct ECheckedDo <: EIns :
  x: EVar|False
  xtype: EType|False
  f: EImm
  ys: Tuple<EImm>
  ytypes: Tuple<EType>
public defstruct ENew <: EIns :
  x: EVar
  type: EType
  methods: Tuple<EMethod>
public defstruct ETuple <: EIns :
  x: EVar
  ys: Tuple<EImm>
public defstruct EVoidTuple <: EIns :
  x: EVar
  length: Int
public defstruct ETupleGet <: EIns :
  x: EVar
  y: EImm
  index: Int
public defstruct ETupleSet <: EIns :
  y: EVar
  index: Int
  z: EImm
public defstruct EEnsureLength <: EIns :
  x: EVar
  y: EImm
  length: Int
public defstruct EObject <: EIns :
  x: EVar
  n: Int
  ys: Tuple<EImm>
public defstruct EArray <: EIns :
  x: EVar
  n: Int
  ys: Tuple<EImm>
public defstruct EStruct <: EIns :
  x: EVar
  n: Int
  ys: Tuple<EImm>
public defstruct EPtr <: EIns :
  x: EVar
  loc: ELoc
public defstruct ELoad <: EIns :
  x: EVar
  xtype: EType
  loc: ELoc
public defstruct EStore <: EIns :
  loc: ELoc
  y: EImm
  ytype: EType
public defstruct ELabel <: EIns :
  n: Int
public defstruct EDo <: EIns :
  x: EVar|False
  xtype: EType|False
  f: EImm
  ys: Tuple<EImm>
public defstruct EDoC <: EIns :
  x: EVar|False
  xtype: EType|False
  f: EImm
  ys: Tuple<EImm>
public defstruct EDump <: EIns :
  ys: Tuple<EImm>
public defstruct EInterpret <: EIns :
  x: EVar
  y: EImm
public defstruct EConv <: EIns :
  x: EVar
  y: EImm
public defstruct ECheck <: EIns :
  x: EVar
  y: EImm
public defstruct EGoto <: EIns :
  n: Int
public defstruct EPrim <: EIns :
  x: EVar
  op: EOp
  ys: Tuple<EImm>  
public defstruct EIf <: EIns :
  n1: Int
  n2: Int
  op: EOp|False
  ys: Tuple<EImm>
public defstruct EMatch <: EIns :
  ys: Tuple<EImm>
  branches: Tuple<EBranch>
public defstruct EEnsureSet <: EIns :
  y: EVar
public defstruct EBox <: EIns :
  x: EVar
  y: EImm|False
public defstruct EBoxGet <: EIns :
  x: EVar
  y: EImm
public defstruct EBoxSet <: EIns :
  y: EImm
  z: EImm  
public defstruct EReturn <: EIns :
  y: EImm

public defstruct EClosure :
  n: Int
public defstruct EMethod :
  multi: Int
  targs: Tuple<EType>
  thisn: Int
  func: EFn
public defstruct EBranch :
  types: Tuple<EType>
  n: Int

;============================================================
;======================= Primitives =========================
;============================================================

public deftype EOp
public defstruct IntAddOp <: EOp
public defstruct IntSubOp <: EOp
public defstruct IntMulOp <: EOp
public defstruct IntDivOp <: EOp
public defstruct IntModOp <: EOp
public defstruct IntAndOp <: EOp
public defstruct IntOrOp <: EOp
public defstruct IntXorOp <: EOp
public defstruct IntNotOp <: EOp
public defstruct IntShlOp <: EOp
public defstruct IntShrOp <: EOp
public defstruct IntAshrOp <: EOp
public defstruct IntLtOp <: EOp
public defstruct IntGtOp <: EOp
public defstruct IntLeOp <: EOp
public defstruct IntGeOp <: EOp
public defstruct IntNegOp <: EOp

public defstruct RefEqOp <: EOp
public defstruct RefNeOp <: EOp

public defstruct AddOp <: EOp
public defstruct SubOp <: EOp
public defstruct MulOp <: EOp
public defstruct DivOp <: EOp
public defstruct ModOp <: EOp
public defstruct AndOp <: EOp
public defstruct OrOp <: EOp
public defstruct XorOp <: EOp
public defstruct NotOp <: EOp
public defstruct ShlOp <: EOp
public defstruct ShrOp <: EOp
public defstruct AshrOp <: EOp
public defstruct EqOp <: EOp
public defstruct NeOp <: EOp
public defstruct LtOp <: EOp
public defstruct GtOp <: EOp
public defstruct LeOp <: EOp
public defstruct GeOp <: EOp
public defstruct UleOp <: EOp
public defstruct UltOp <: EOp
public defstruct UgtOp <: EOp
public defstruct UgeOp <: EOp
public defstruct NegOp <: EOp

public defstruct CurrentStackOp <: EOp
public defstruct GlobalsOp <: EOp
public defstruct ConstsOp <: EOp
public defstruct ConstsDataOp <: EOp

;============================================================
;========================= Printer ==========================
;============================================================

defmethod print (o:OutputStream, c:EConst) :
  write(o, value(c))
  
defmethod print (o:OutputStream, v:EVar) :
  print(o, "V%_" % [n(v)])

defmethod print (o:OutputStream, e:EIns) :
  print{o, _} $ match(e) : 
    (e:ESet) : "%_ = %_" % [x(e), y(e)]
    (e:EShuffle) : "[%,] = [%,]" % [xs(e), ys(e)]
    (e:ELabel) : "label %_" % [n(e)]
    (e:EDo) :
      "%_%_(%,)" % [xstr, f(e), ys(e)] where :
        val xstr = "" when x(e) is False
              else "%_:%_ = " % [x(e), xtype(e)]
    (e:EDump) :  "dump (%,)" % [ys(e)]
    (e:EReturn) : "return %_" % [y(e)]


defmethod print (o:OutputStream, l:ELocal) :
  val varstr = "val" when not mutable?(l)
          else "var"
  print(o, "%_ V%_:%_" % [varstr, n(l), type(l)])

defmethod print (o:OutputStream, f:EFn) :
  defn vstr (x:Int) : "V%_" % [x]
  print(o, "fn<%,> (%,) -> %_ :" % [seq(vstr,targs(f)), args(f), a2(f)])
  val o2 = IndentedStream(o)
  for l in locals(f) do :
    print(o2, "\n%_" % [l])
  for i in ins(f) do :
    print(o2, "\n%_" % [i])

defmethod print (o:OutputStream, e:EDefn) :
  print(o, "defn V%_ %_" % [n(e), func(e)])
  
defmethod print (o:OutputStream, e:EDef) :
  print(o, "def V%_:%_" % [n(e), type(e)])

defmethod print (o:OutputStream, e:EInit) :
  print(o, "init :")
  val o2 = IndentedStream(o)
  for l in locals(e) do :
    print(o2, "\n%_" % [l])
  for i in ins(e) do :
    print(o2, "\n%_" % [i])

defmethod print (o:OutputStream, e:EDefType) :
  val pstr = "" when parent(e) is False
        else " <: %_" % [parent(e)]
  print(o, "deftype T%_%_" % [n(e), pstr])

defmethod print (o:OutputStream, t:EType) :
  print{o, _} $ match(t) :
    (t:EByte) : "byte"
    (t:EInt) : "int"
    (t:ELong) : "long"
    (t:EFloat) : "float"
    (t:EDouble) : "double"
    (t:EOf) : "ref<T%_>" % [n(t)]

defmethod print (o:OutputStream, p:EPackage) :
  print(o, "package %~ :" % [name(p)])
  val o2 = IndentedStream(o)
  for e in exps(p) do :
    print(o2, "\n%_" % [e])

;============================================================
;========================= Reader ===========================
;============================================================

defsyntax el-ir :
  defproduction etype : EType
  defrule etype = (byte) : EByte()
  defrule etype = (int) : EInt()
  defrule etype = (long) : ELong()
  defrule etype = (float) : EFloat()
  defrule etype = (double) : EDouble()
  defrule etype = (ref<?id:#tid>) : EOf(id)

  defproduction ins : EIns
  defrule ins = ([?xs:#evar ... #E] = [?ys:#imm ... #E]) : EShuffle(to-tuple(xs), to-tuple(ys))
  defrule ins = (label ?n:#int) : ELabel(n)
  defrule ins = (?f:#imm(?ys:#imm ... #E)) : EDo(false, false, f, to-tuple(ys))
  defrule ins = (?x:#evar:?xtype:#etype = ?f:#imm(?ys:#imm ... #E)) : EDo(x, xtype, f, to-tuple(ys))
  defrule ins = (dump (?ys:#imm ... #E)) : EDump(to-tuple(ys))
  defrule ins = (return ?y:#imm) : EReturn(y)
  defrule ins = (?x:#evar = ?y:#imm) : ESet(x,y)  

  defn char-prefix? (x, c:Char) :
    unwrap-token(x) is Symbol and to-string(x)[0] == c
  defn char-index! (info:FileInfo|False, x:Symbol|Token) :
    val i = to-int(to-string(x)[1 to false])
    match(i:Int) : i
    else : throw(ELE(info, "Invalid name: %~" % [x]))

  defproduction tid : Int
  defrule tid = (?x) when char-prefix?(x, 'T') : char-index!(closest-info(), x)
  
  defproduction vid : Int
  defrule vid = (?x) when char-prefix?(x, 'V') : char-index!(closest-info(), x)

  defproduction evar : EVar
  defrule evar = (?n:#vid) : EVar(n)

  defproduction imm : EImm
  defrule imm = (?v:#evar) : v
  defrule imm = (?v) when unwrap-token(v) is Int : EConst(unwrap-token(v))

  defproduction local : ELocal
  defrule local = (val ?n:#vid : ?t:#etype) : ELocal(n,t,false)
  defrule local = (var ?n:#vid : ?t:#etype) : ELocal(n,t,true)

  defproduction func : EFn
  defrule func = (fn<?targs:#vid ... #E> (?args:#local ... #E) -> ?a2:#etype :
                    ?locals:#local ...
                    ?ins:#ins ...
                    #E) :
    EFn(to-tuple(targs), to-tuple(args), to-tuple(locals), a2, to-tuple(ins))
  
  defproduction texp : ETExp
  defrule texp = (defn ?n:#vid ?f:#func) : EDefn(n,f)
  defrule texp = (def ?n:#vid : ?t:#etype) : EDef(n, t)
  defrule texp = (init : (?locals:#local ... ?ins:#ins ... #E)) : EInit(to-tuple(locals), to-tuple(ins))
  defrule texp = (deftype ?n:#tid <: ?p:#etype) : EDefType(n, p)
  defrule texp = (deftype ?n:#tid) : EDefType(n, false)

  defproduction E : False
  fail-if E = (_) : ELE(closest-info(), "Unrecognized input here.")
  defrule E = () : false

  public defproduction epackage : EPackage
  defrule epackage = (package ?name:#symbol : (?es:#texp ... #E)) : EPackage(name, to-tuple(es))

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction byte : Byte
  defrule byte = (?x) when unwrap-token(x) is Byte : unwrap-token(x)

  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

;============================================================
;====================== Errors ==============================
;============================================================

public defstruct ELError <: Exception :
  info: FileInfo|False
  msg

public defn ELE (info:FileInfo|False, msg) :
  ELError(info, msg)

defmethod print (o:OutputStream, e:ELError) :
  val info-str = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [info-str, msg(e)])

;============================================================
;======================= Scratch ============================
;============================================================

public defn read-el-file (filename:String) :
  val forms = reader/read-file(filename)
  parse-syntax[el-ir / #epackage](forms)