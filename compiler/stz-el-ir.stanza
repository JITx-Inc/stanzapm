defpackage stz/el-ir :
  import core

;============================================================
;========================= Types ============================
;============================================================

public deftype EType
public defstruct EByte <: EType
public defstruct EInt <: EType
public defstruct ELong <: EType
public defstruct EFloat <: EType
public defstruct EDouble <: EType
public defstruct EOf <: EType: (n:Int)

;============================================================
;======================= Wrapper ============================
;============================================================

public defstruct EPackage :  
  exps: Tuple<ETExp>

;============================================================
;================== Top-Level Expressions ===================
;============================================================

public deftype ETExp
public defstruct EDefn <: ETExp :
  n: Int
  func: EFn

public defstruct EDef <: ETExp :
  n: Int
  type: EType
  
public defstruct EInit <: ETExp :
  locals: Tuple<ELocal>
  ins: Tuple<EIns>

public defstruct EDefType <: ETExp :
  n: Int
  parent: False|EType

;============================================================
;======================== Functions =========================
;============================================================

public defstruct EFn :
  targs: Tuple<Int>
  args: Tuple<ELocal>
  locals: Tuple<ELocal>
  a2: EType
  ins: Tuple<EIns>

public defstruct ELocal :
  n: Int
  type: EType
  mutable?: True|False

;============================================================  
;======================= Instructions =======================
;============================================================  

public deftype EImm
public defstruct EConst <: EImm :
  value
public defstruct EVar <: EImm :
  n: Int

public deftype EIns
public defstruct ESet <: EIns :
  x: EVar
  y: EImm
public defstruct EShuffle <: EIns :
  xs: Tuple<EVar>
  ys: Tuple<EImm>
public defstruct ELabel <: EIns :
  n: Int
public defstruct EDo <: EIns :
  x: EVar|False
  xtype: EType|False
  f: EImm
  ys: Tuple<EImm>
public defstruct EDump <: EIns :
  ys: Tuple<EImm>
public defstruct EReturn <: EIns :
  y: EImm


;============================================================
;========================= Printer ==========================
;============================================================

defmethod print (o:OutputStream, c:EConst) :
  write(o, value(c))
  
defmethod print (o:OutputStream, v:EVar) :
  print(o, "V%_" % [n(v)])

defmethod print (o:OutputStream, e:EIns) :
  print{o, _} $ match(e) : 
    (e:ESet) : "%_ = %_" % [x(e), y(e)]
    (e:EShuffle) : "[%,] = [%,]" % [xs(e), ys(e)]
    (e:ELabel) : "label %_" % [n(e)]
    (e:EDo) :
      "%_%_(%,)" % [xstr, f(e), ys(e)] where :
        val xstr = "" when x(e) is False
              else "%_:%_ = " % [x(e), xtype(e)]
    (e:EDump) :  "dump (%,)" % [ys(e)]
    (e:EReturn) : "return %_" % [y(e)]


defmethod print (o:OutputStream, l:ELocal) :
  val varstr = "val" when not mutable?(l)
          else "var"
  print(o, "%_ V%_:%_" % [varstr, n(l), type(l)])

defmethod print (o:OutputStream, f:EFn) :
  defn vstr (x:Int) : "V%_" % [x]
  print(o, "fn<%,> (%,) -> %_ :" % [seq(vstr,targs(f)), args(f), a2(f)])
  val o2 = IndentedStream(o)
  for l in locals(f) do :
    print(o2, "\n%_" % [l])
  for i in ins(f) do :
    print(o2, "\n%_" % [i])

defmethod print (o:OutputStream, e:EDefn) :
  print(o, "defn V%_ %_" % [n(e), func(e)])
  
defmethod print (o:OutputStream, e:EDef) :
  print(o, "def V%_:%_" % [n(e), type(e)])

defmethod print (o:OutputStream, e:EInit) :
  print(o, "init :")
  val o2 = IndentedStream(o)
  for l in locals(e) do :
    print(o2, "\n%_" % [l])
  for i in ins(e) do :
    print(o2, "\n%_" % [i])

defmethod print (o:OutputStream, e:EDefType) :
  val pstr = "" when parent(e) is False
        else " <: %_" % [parent(e)]
  print(o, "deftype T%_%_" % [n(e), pstr])

defmethod print (o:OutputStream, t:EType) :
  print{o, _} $ match(t) :
    (t:EByte) : "byte"
    (t:EInt) : "int"
    (t:ELong) : "long"
    (t:EFloat) : "float"
    (t:EDouble) : "double"
    (t:EOf) : "ref<T%_>" % [n(t)]

defmethod print (o:OutputStream, p:EPackage) :
  print(o, "package :")
  val o2 = IndentedStream(o)
  for e in exps(p) do :
    print(o2, "\n%_" % [e])

;============================================================
;========================= Reader ===========================
;============================================================

defsyntax el-ir :
  defproduction etype : EType
  defrule etype = (byte) : EByte()
  defrule etype = (int) : EInt()
  defrule etype = (long) : ELong()
  defrule etype = (float) : EFloat()
  defrule etype = (double) : EDouble()
  defrule etype = (ref<?id:#tid>) : EOf(id)

  defproduction ins : EIns
  defrule ins = ([?xs:#evar ... #E] = [?ys:#imm ... #E]) : EShuffle(to-tuple(xs), to-tuple(ys))
  defrule ins = (label ?n:#int) : ELabel(n)
  defrule ins = (?f:#imm(?ys:#imm ... #E)) : EDo(false, false, f, to-tuple(ys))
  defrule ins = (?x:#evar:?xtype:#etype = ?f:#imm(?ys:#imm ... #E)) : EDo(x, xtype, f, to-tuple(ys))
  defrule ins = (dump (?ys:#imm ... #E)) : EDump(to-tuple(ys))
  defrule ins = (return ?y:#imm) : EReturn(y)
  defrule ins = (?x:#evar = ?y:#imm) : ESet(x,y)  

  defn char-prefix? (x, c:Char) :
    unwrap-token(x) is Symbol and to-string(x)[0] == c
  defn char-index! (info:FileInfo|False, x:Symbol|Token) :
    val i = to-int(to-string(x)[1 to false])
    match(i:Int) : i
    else : throw(ELE(info, "Invalid name: %~" % [x]))

  defproduction tid : Int
  defrule tid = (?x) when char-prefix?(x, 'T') : char-index!(closest-info(), x)
  
  defproduction vid : Int
  defrule vid = (?x) when char-prefix?(x, 'V') : char-index!(closest-info(), x)

  defproduction evar : EVar
  defrule evar = (?n:#vid) : EVar(n)

  defproduction imm : EImm
  defrule imm = (?v:#evar) : v
  defrule imm = (?v) when unwrap-token(v) is Int : EConst(unwrap-token(v))

  defproduction local : ELocal
  defrule local = (val ?n:#vid : ?t:#etype) : ELocal(n,t,false)
  defrule local = (var ?n:#vid : ?t:#etype) : ELocal(n,t,true)

  defproduction func : EFn
  defrule func = (fn<?targs:#vid ... #E> (?args:#local ... #E) -> ?a2:#etype :
                    ?locals:#local ...
                    ?ins:#ins ...
                    #E) :
    EFn(to-tuple(targs), to-tuple(args), to-tuple(locals), a2, to-tuple(ins))
  
  defproduction texp : ETExp
  defrule texp = (defn ?n:#vid ?f:#func) : EDefn(n,f)
  defrule texp = (def ?n:#vid : ?t:#etype) : EDef(n, t)
  defrule texp = (init : (?locals:#local ... ?ins:#ins ... #E)) : EInit(to-tuple(locals), to-tuple(ins))
  defrule texp = (deftype ?n:#tid <: ?p:#etype) : EDefType(n, p)
  defrule texp = (deftype ?n:#tid) : EDefType(n, false)

  defproduction E : False
  fail-if E = (_) : ELE(closest-info(), "Unrecognized input here.")
  defrule E = () : false

  public defproduction epackage : EPackage
  defrule epackage = (package : (?es:#texp ... #E)) : EPackage(to-tuple(es))

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction byte : Byte
  defrule byte = (?x) when unwrap-token(x) is Byte : unwrap-token(x)

  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

;============================================================
;====================== Errors ==============================
;============================================================

public defstruct ELError <: Exception :
  info: FileInfo|False
  msg

public defn ELE (info:FileInfo|False, msg) :
  ELError(info, msg)

defmethod print (o:OutputStream, e:ELError) :
  val info-str = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [info-str, msg(e)])

;============================================================
;======================= Scratch ============================
;============================================================

public defn read-el-file (filename:String) :
  val forms = reader/read-file(filename)
  parse-syntax[el-ir / #epackage](forms)