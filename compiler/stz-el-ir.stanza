defpackage stz/el-ir :
  import core

;============================================================
;========================= Types ============================
;============================================================

public deftype EType

;LoStanza Types
public defstruct EByte <: EType
public defstruct EInt <: EType
public defstruct ELong <: EType
public defstruct EFloat <: EType
public defstruct EDouble <: EType
public defstruct EUnknown <: EType
public defstruct EPtrT <: EType : (type:EType)
public defstruct EFnT <: EType : (a:Tuple<EType>, r:False|EType, b:EType)
public defstruct EStructT <: EType : (n:Int)

;HiStanza Types
public defstruct EOf <: EType: (n:Int)
public defstruct ETVar <: EType: (n:Int)
public defstruct EAnd <: EType: (a:EType, b:EType)
public defstruct EOr <: EType: (a:EType, b:EType)
public defstruct ETop <: EType
public defstruct EBot <: EType

;============================================================
;======================= Wrapper ============================
;============================================================

public defstruct EPackage :
  name: Symbol
  exps: Tuple<ETExp>

;============================================================
;================== Top-Level Expressions ===================
;============================================================

public deftype ETExp
public defstruct EDef <: ETExp :
  n: Int
  type: EType
  mutable?: True|False
  
public defstruct EDefn <: ETExp :
  n: Int
  func: EFunction

public defstruct EDefmulti <: ETExp :
  n: Int
  targs: Tuple<Int>
  a1: Tuple<EType>
  a2: EType

public defstruct EDefmethod <: ETExp :
  n: Int
  multi: Int
  func: EFn

public defstruct EDefStruct <: ETExp :
  n: Int
  parent: False|EType
  base:Tuple<EType>
  items:EType|False

public defstruct EExternFn <: ETExp :
  n: Int
  lbl: Symbol
  func: EFn

public defstruct EExtern <: ETExp :
  n: Int
  lbl: Symbol
  type: EType
  
public defstruct EInit <: ETExp :
  locals: Tuple<ELocal>
  localfns: Tuple<ELocalFn>
  localobjs: Tuple<ELocalObj>
  ins: Tuple<EIns>

public defstruct EDefType <: ETExp :
  n: Int
  parent: False|EType
  children: Tuple<Int>

;============================================================
;======================== Functions =========================
;============================================================

public deftype EFunction

public defstruct EMultifn <: EFunction :
  funcs: Tuple<EFn>

public defstruct EFn <: EFunction :
  targs: Tuple<Int>
  args: Tuple<Int>
  a1: Tuple<EType>
  a2: EType
  locals: Tuple<ELocal>
  localfns: Tuple<ELocalFn>
  localobjs: Tuple<ELocalObj>
  ins: Tuple<EIns>

public defstruct ELocal :
  n: Int
  type: EType
  mutable?: True|False

public defstruct ELocalFn :
  n: Int
  func: EFunction

public defstruct ELocalObj :
  n: Int
  type: EType
  methods: Tuple<EMethod>
public defstruct EMethod :
  multi: Int
  targs: Tuple<EType>
  thisn: Int
  func: EFn

;============================================================  
;======================= Instructions =======================
;============================================================  

public deftype EImm
public defstruct ELSLiteral <: EImm :
  value
public defstruct ELiteral <: EImm :
  value
public defstruct EVar <: EImm :
  n: Int
public defstruct EMix <: EImm :
  funcs: Tuple<ECurry>
public defstruct ECurry <: EImm :
  n: Int
  targs: Tuple<EType>
public defstruct ESizeof <: EImm :
  type: EType
public defstruct ETagof <: EImm :
  n: Int

public deftype EIns
public defstruct ESet <: EIns :
  x: EVar
  y: EImm
public defstruct EShuffle <: EIns :
  xs: Tuple<EVar>
  ys: Tuple<EImm>
public defstruct ELetRec <: EIns :
  xs: Tuple<EVar>
  closures: Tuple<EClosure>
public defstruct ECheckedDo <: EIns :
  x: EVar
  xtype: EType
  f: EImm
  ys: Tuple<EImm>
  ytypes: Tuple<EType>
public defstruct ENew <: EIns :
  x: EVar
  n: Int
public defstruct ETuple <: EIns :
  x: EVar
  ys: Tuple<EImm>
public defstruct EVoidTuple <: EIns :
  x: EVar
  length: Int
public defstruct ETupleGet <: EIns :
  x: EVar
  y: EImm
  index: Int
public defstruct ETupleSet <: EIns :
  y: EImm
  index: Int
  z: EImm
public defstruct ECheckLength <: EIns :
  y: EImm
  length: Int
public defstruct EObject <: EIns :
  x: EVar
  n: Int
  ys: Tuple<EImm>
public defstruct EArray <: EIns :
  x: EVar
  n: Int
  ys: Tuple<EImm>
public defstruct EStruct <: EIns :
  x: EVar
  n: Int
  ys: Tuple<EImm>
public defstruct EPtr <: EIns :
  x: EVar
  loc: ELoc
public defstruct ELoad <: EIns :
  x: EVar
  xtype: EType
  loc: ELoc
public defstruct EStore <: EIns :
  loc: ELoc
  y: EImm
  ytype: EType
public defstruct ELabel <: EIns :
  n: Int
public defstruct EDo <: EIns :
  x: EVar|False
  xtype: EType|False
  f: EImm
  ys: Tuple<EImm>
public defstruct EDoC <: EIns :
  x: EVar|False
  xtype: EType|False
  f: EImm
  ys: Tuple<EImm>
public defstruct EDump <: EIns :
  ys: Tuple<EImm>
public defstruct EInterpret <: EIns :
  x: EVar
  y: EImm
public defstruct EConv <: EIns :
  x: EVar
  y: EImm
public defstruct ECheck <: EIns :
  x: EVar
  y: EImm
public defstruct EGoto <: EIns :
  n: Int
public defstruct EPrim <: EIns :
  x: EVar
  op: EOp
  ys: Tuple<EImm>  
public defstruct EIf <: EIns :
  n1: Int
  n2: Int
  op: EOp|False
  ys: Tuple<EImm>
public defstruct EMatch <: EIns :
  ys: Tuple<EImm>
  branches: Tuple<EBranch>
public defstruct ECheckSet <: EIns :
  y: EVar
public defstruct EBox <: EIns :
  x: EVar
  y: EImm|False
public defstruct EBoxGet <: EIns :
  x: EVar
  y: EImm
public defstruct EBoxSet <: EIns :
  y: EImm
  z: EImm  
public defstruct EReturn <: EIns :
  y: EImm

public defstruct EClosure :
  n: Int
public defstruct EBranch :
  types: Tuple<EType>
  n: Int

;============================================================
;======================= Locations ==========================
;============================================================

public deftype ELoc :
  EVar <: ELoc

public defstruct EDeref <: ELoc :
  y: EImm
public defstruct EDeptr <: ELoc :
  y: EImm
public defstruct EField <: ELoc :
  loc: ELoc
  n: Int
  index: Int
public defstruct ESlot <: ELoc :
  loc: ELoc
  type: EType  ;type of result
  index: EImm

;============================================================
;======================= Primitives =========================
;============================================================

public deftype EOp
public defstruct IntAddOp <: EOp
public defstruct IntSubOp <: EOp
public defstruct IntMulOp <: EOp
public defstruct IntDivOp <: EOp
public defstruct IntModOp <: EOp
public defstruct IntAndOp <: EOp
public defstruct IntOrOp <: EOp
public defstruct IntXorOp <: EOp
public defstruct IntNotOp <: EOp
public defstruct IntShlOp <: EOp
public defstruct IntShrOp <: EOp
public defstruct IntAshrOp <: EOp
public defstruct IntLtOp <: EOp
public defstruct IntGtOp <: EOp
public defstruct IntLeOp <: EOp
public defstruct IntGeOp <: EOp
public defstruct IntNegOp <: EOp

public defstruct RefEqOp <: EOp
public defstruct RefNeOp <: EOp

public defstruct AddOp <: EOp
public defstruct SubOp <: EOp
public defstruct MulOp <: EOp
public defstruct DivOp <: EOp
public defstruct ModOp <: EOp
public defstruct AndOp <: EOp
public defstruct OrOp <: EOp
public defstruct XorOp <: EOp
public defstruct NotOp <: EOp
public defstruct ShlOp <: EOp
public defstruct ShrOp <: EOp
public defstruct AshrOp <: EOp
public defstruct EqOp <: EOp
public defstruct NeOp <: EOp
public defstruct LtOp <: EOp
public defstruct GtOp <: EOp
public defstruct LeOp <: EOp
public defstruct GeOp <: EOp
public defstruct UleOp <: EOp
public defstruct UltOp <: EOp
public defstruct UgtOp <: EOp
public defstruct UgeOp <: EOp
public defstruct NegOp <: EOp

public defstruct CurrentStackOp <: EOp
public defstruct GlobalsOp <: EOp
public defstruct ConstsOp <: EOp
public defstruct ConstsDataOp <: EOp

;============================================================
;========================= Printer ==========================
;============================================================

defmethod print (o:OutputStream, op:EOp) :
  print{o, _} $ match(op) :
    (op:CurrentStackOp) : "current-stack"
    (op:GlobalsOp) : "globals"
    (op:ConstsOp) : "consts"
    (op:ConstsDataOp) : "consts-data"
    (op:AddOp) : "add"
    (op:SubOp) : "sub"
    (op:MulOp) : "mul"
    (op:DivOp) : "div"
    (op:ModOp) : "mod"
    (op:AndOp) : "and"
    (op:OrOp) : "or"
    (op:XorOp) : "xor"
    (op:NotOp) : "not"
    (op:ShlOp) : "shl"
    (op:ShrOp) : "shr"
    (op:AshrOp) : "ashr"
    (op:EqOp) : "eq"
    (op:NeOp) : "ne"
    (op:LtOp) : "lt"
    (op:GtOp) : "gt"
    (op:LeOp) : "le"
    (op:GeOp) : "ge"
    (op:UleOp) : "ule"
    (op:UltOp) : "ult"
    (op:UgtOp) : "ugt"
    (op:UgeOp) : "uge"
    (op:NegOp) : "neg"
    (op:IntAddOp) : "int-add"
    (op:IntSubOp) : "int-sub"
    (op:IntMulOp) : "int-mul"
    (op:IntDivOp) : "int-div"
    (op:IntModOp) : "int-mod"
    (op:IntAndOp) : "int-and"
    (op:IntOrOp) : "int-or"
    (op:IntXorOp) : "int-xor"
    (op:IntNotOp) : "int-not"
    (op:IntShlOp) : "int-shl"
    (op:IntShrOp) : "int-shr"
    (op:IntAshrOp) : "int-ashr"
    (op:IntLtOp) : "int-lt"
    (op:IntGtOp) : "int-gt"
    (op:IntLeOp) : "int-le"
    (op:IntGeOp) : "int-ge"
    (op:IntNegOp) : "int-neg"
    (op:RefEqOp) : "ref-eq"
    (op:RefNeOp) : "ref-ne"

defmethod print (o:OutputStream, t:EType) :
  print{o, _} $ match(t) :
    (t:EByte) : "byte"
    (t:EInt) : "int"
    (t:ELong) : "long"
    (t:EFloat) : "float"
    (t:EDouble) : "double"
    (t:EUnknown) : "?"
    (t:ETop) : "top "
    (t:EBot) : "bot"
    (t:EPtrT) : "ptr<%_>" % [type(t)]
    (t:EFnT) :
      match(r(t)) :
        (r:EType) : "fn<(%,), %_, %_>" % [a(t), r, b(t)]
        (r:False) : "fn<(%,), %_>" % [a(t), b(t)]
    (t:EStructT) : "T%_" % [n(t)]      
    (t:EOf) : "ref<T%_>" % [n(t)]
    (t:ETVar) : "TV%_" % [n(t)]
    (t:EAnd) : "and(%_, %_)" % [a(t), b(t)]
    (t:EOr) : "or(%_, %_)" % [a(t), b(t)]
    
defmethod print (o:OutputStream, e:EDef) :
  val valstr = "var" when mutable?(e) else "val"
  print(o, "def%_ V%_:%_" % [valstr, n(e), type(e)])

defmethod print (o:OutputStream, e:EDefn) :
  print(o, "defn V%_ %_" % [n(e), func(e)])

defmethod print (o:OutputStream, e:EDefmulti) :
  defn tvstr (x:Int) : "TV%_" % [x]
  print(o, "defmulti V%_<%,> (%,) -> %_" % [n(e), seq(tvstr,targs(e)), a1(e), a2(e)])

defmethod print (o:OutputStream, e:EDefmethod) :
  print(o, "defmethod V%_ (V%_) %_" % [n(e), multi(e), func(e)])

defmethod print (o:OutputStream, e:EDefStruct) :
  val pstr = "" when parent(e) is False else " <: %_" % [parent(e)]
  match(items(e)) :
    (items:EType) :
      print(o, "defstruct T%_%_ : (%, ...)" % [n(e), pstr, cat(base(e), [items])])
    (items:False) :
      print(o, "defstruct T%_%_ : (%,)" % [n(e), pstr, base(e)])

defmethod print (o:OutputStream, e:EExternFn) :
  print(o, "externfn %~ V%_ %~ %_" % [lbl(e), n(e), func(e)])

defmethod print (o:OutputStream, e:EExtern) :
  print(o, "extern %~ V%_:%_" % [lbl(e), n(e), type(e)])

defmethod print (o:OutputStream, e:EInit) :
  print(o, "init :")
  bprint(o, cat-all $ [locals(e), localfns(e), localobjs(e), ins(e)])

defmethod print (o:OutputStream, e:EDefType) :
  val pstr = "" when parent(e) is False
        else " <: %_" % [parent(e)]
  defn tstr (x:Int) : "T%_" % [x]
  print(o, "deftype T%_%_ (%,)" % [n(e), pstr, seq(tstr,children(e))])

defmethod print (o:OutputStream, f:EFn) :
  defn tvstr (x:Int) : "TV%_" % [x]
  defn astr (x:Int,t:EType) : "V%_:%_" % [x,t]
  print(o, "fn<%,> (%,) -> %_ :" % [seq(tvstr,targs(f)), seq(astr, args(f), a1(f)), a2(f)])
  bprint(o, cat-all $ [locals(f), localfns(f), localobjs(f), ins(f)])

defmethod print (o:OutputStream, f:EMultifn) :
  print(o, "multifn :")
  bprint(o, funcs(f))

defmethod print (o:OutputStream, l:ELocal) :
  val varstr = "var" when mutable?(l) else "val"
  print(o, "def%_ V%_:%_" % [varstr, n(l), type(l)])

defmethod print (o:OutputStream, e:ELocalFn) :
  print(o, "defn V%_ %_" % [n(e), func(e)])

defmethod print (o:OutputStream, e:ELocalObj) :
  print(o, "defobj O%_ <: %_ :" % [n(e), type(e)])
  bprint(o, methods(e))

defmethod print (o:OutputStream, e:EMethod) :
  print(o, "defmethod V%_<%,> (this = V%_) %_" % [multi(e), targs(e), thisn(e), func(e)])

defmethod print (o:OutputStream, e:EImm) :
  print{o, _} $ match(e) :
    (e:ELSLiteral) : "LV{%_}" % [value(e)]
    (e:ELiteral) : "V{%_}" % [value(e)]
    (e:EMix) : "mix(%,)" % [funcs(e)]
    (e:ECurry) : "V%_<%,>" % [n(e), targs(e)]
    (e:ESizeof) : "sizeof(%_)" % [type(e)]
    (e:ETagof) : "tagof(T%_)" % [n(e)]
  
defmethod print (o:OutputStream, v:EVar) :
  print(o, "V%_" % [n(v)])

defmethod print (o:OutputStream, e:EIns) :
  defn P (x) : print(o, x)
  match(e) : 
    (e:ESet) : P $ "%_ = %_" % [x(e), y(e)]
    (e:EShuffle) : P $ "[%,] = [%,]" % [xs(e), ys(e)]
    (e:ELetRec) : P $ "letrec [%,] = [%,]" % [xs(e), closures(e)]
    (e:ECheckedDo) :
      defn arg (y:EImm, t:EType) : "%_:%_" % [y,t]
      P $ "%_:%_ = check-do %_(%,)" % [x(e), xtype(e), f(e), seq(arg, ys(e), ytypes(e))]
    (e:ENew) : P $ "%_ = new O%_" % [x(e), n(e)]
    (e:ETuple) : P $ "%_ = tuple [%,]" % [x(e), ys(e)]
    (e:EVoidTuple) : P $ "%_ = void-tuple(%_)" % [x(e), length(e)]
    (e:ETupleGet) : P $ "%_ = tuple-get %_[%_]" % [x(e), y(e), index(e)]
    (e:ETupleSet) : P $ "tuple-set %_[%_] = %_" % [y(e),index(e), z(e)]
    (e:ECheckLength) : P $ "check-length(%_) == %_" % [y(e), length(e)]
    (e:EObject) : P $ "%_ = object T%_ (%,)" % [x(e), n(e), ys(e)]
    (e:EArray) : P $ "%_ = array T%_ (%,)" % [x(e), n(e), ys(e)]
    (e:EStruct) : P $ "%_ = struct T%_ (%,)" % [x(e), n(e), ys(e)]
    (e:EPtr) : P $ "%_ = addr(%_)" % [loc(e)]
    (e:ELoad) : P $ "%_:%_ = load %_" % [x(e), xtype(e), loc(e)]
    (e:EStore) : P $ "store %_ = %_:%_" % [loc(e), y(e), ytype(e)]
    (e:ELabel) : P $ "label L%_" % [n(e)]
    (e:EDo) :
      P $ "%_do %_(%,)" % [xstr, f(e), ys(e)] where :
        val xstr = "" when x(e) is False
              else "%_:%_ = " % [x(e), xtype(e)]
    (e:EDoC) :
      P $ "%_do-c %_(%,)" % [xstr, f(e), ys(e)] where :
        val xstr = "" when x(e) is False
              else "%_:%_ = " % [x(e), xtype(e)]
    (e:EInterpret) : P $ "%_ = interpret %_" % [x(e), y(e)]
    (e:EConv) : P $ "%_ = conv %_" % [x(e), y(e)]
    (e:ECheck) : P $ "%_ = check %_" % [x(e), y(e)]
    (e:EGoto) : P $ "goto L%_" % [n(e)]
    (e:EPrim) : P $ "%_ = prim %_ (%,)" % [x(e), op(e), ys(e)]
    (e:EIf) :
      P $ match(op(e)) :
        (op:EOp) : "goto L%_ when prim %_ (%,) else L%_" % [n1(e), op, ys(e), n2(e)]
        (op:False) : "goto L%_ when %_ else L%_" % [n1(e), ys(e)[0], n2(e)]
    (e:EMatch) :
      P $ "match(%,) :"
      bprint(o, branches(e))
    (e:ECheckSet) : P $ "check-set %_" % [y(e)]
    (e:EBox) :
      P $ "%_ = box(%_)" % [x(e), vstr] where :
        val vstr = "" when y(e) is False else y(e)
    (e:EBoxGet) : P $ "%_ = box-get %_" % [x(e), y(e)]
    (e:EBoxSet) : P $ "box-set %_ = %_" % [y(e), z(e)]        
    (e:EReturn) : P $ "return %_" % [y(e)]    
    (e:EDump) :  P $ "dump (%,)" % [ys(e)]

defmethod print (o:OutputStream, e:EClosure) :
  print(o, "closure(V%_)" % [n(e)])

defmethod print (o:OutputStream, e:EBranch) :
  print(o, "(%,) : goto L%_" % [types(e), n(e)])

defmethod print (o:OutputStream, p:EPackage) :
  print(o, "package %~ :" % [name(p)])
  bprint(o, exps(p))

defmethod print (o:OutputStream, e:ELoc) :
  print{o, _} $ match(e) :
    (e:EDeref) : "deref(%_)" % [y(e)]
    (e:EDeptr) : "deptr(%_)" % [y(e)]
    (e:EField) : "field(%_, T%_[%_])" % [loc(e), n(e), index(e)]
    (e:ESlot) : "slot(%_[%_] : %_)" % [loc(e), index(e), type(e)]    

defn lnprint (o:OutputStream, x) :
  print(o, '\n')
  print(o, x)

defn lnprints (o:OutputStream, xs:Seqable) :
  do(lnprint{o, _}, xs)

defn bprint (o:OutputStream, xs:Seqable) :
  val xs-seq = to-seq(xs)
  if empty?(xs-seq) : print(o, " ()")
  else : do(lnprints{IndentedStream(o), _}, xs-seq)

;============================================================
;========================= Reader ===========================
;============================================================

defsyntax el-ir :
  defn prefix-id? (x, s:String) :
    match(unwrap-token(x)) :
      (x:Symbol) : prefix?(x, s)
      (x) : false
  defn id-prefix (info:FileInfo|False, x:Symbol|Token, len:Int) :
    match(to-int(to-string(unwrap-token(x))[len to false])) :
      (i:Int) : i
      (i) : throw(ELE(info, "Invalid name: %~" % [x]))

  defproduction tvid : Int
  defrule tvid = (?x) when prefix-id?(x,"TV") : id-prefix(closest-info(), x, 2)
  defproduction tid : Int
  defrule tid = (?x) when prefix-id?(x,"T") : id-prefix(closest-info(), x, 1)
  defproduction vid : Int
  defrule vid = (?x) when prefix-id?(x,"V") : id-prefix(closest-info(), x, 1)
  defproduction oid : Int
  defrule oid = (?x) when prefix-id?(x,"O") : id-prefix(closest-info(), x, 1)
  defproduction lid : Int
  defrule lid = (?x) when prefix-id?(x,"L") : id-prefix(closest-info(), x, 1)

  defproduction eop : EOp
  defrule eop = (current-stack) : CurrentStackOp()
  defrule eop = (globals) : GlobalsOp()
  defrule eop = (consts) : ConstsOp()
  defrule eop = (consts-data) : ConstsDataOp()
  defrule eop = (add) : AddOp()
  defrule eop = (sub) : SubOp()
  defrule eop = (mul) : MulOp()
  defrule eop = (div) : DivOp()
  defrule eop = (mod) : ModOp()
  defrule eop = (and) : AndOp()
  defrule eop = (or) : OrOp()
  defrule eop = (xor) : XorOp()
  defrule eop = (not) : NotOp()
  defrule eop = (shl) : ShlOp()
  defrule eop = (shr) : ShrOp()
  defrule eop = (ashr) : AshrOp()
  defrule eop = (eq) : EqOp()
  defrule eop = (ne) : NeOp()
  defrule eop = (lt) : LtOp()
  defrule eop = (gt) : GtOp()
  defrule eop = (le) : LeOp()
  defrule eop = (ge) : GeOp()
  defrule eop = (ule) : UleOp()
  defrule eop = (ult) : UltOp()
  defrule eop = (ugt) : UgtOp()
  defrule eop = (uge) : UgeOp()
  defrule eop = (neg) : NegOp()
  defrule eop = (int-add) : IntAddOp()
  defrule eop = (int-sub) : IntSubOp()
  defrule eop = (int-mul) : IntMulOp()
  defrule eop = (int-div) : IntDivOp()
  defrule eop = (int-mod) : IntModOp()
  defrule eop = (int-and) : IntAndOp()
  defrule eop = (int-or) : IntOrOp()
  defrule eop = (int-xor) : IntXorOp()
  defrule eop = (int-not) : IntNotOp()
  defrule eop = (int-shl) : IntShlOp()
  defrule eop = (int-shr) : IntShrOp()
  defrule eop = (int-ashr) : IntAshrOp()
  defrule eop = (int-lt) : IntLtOp()
  defrule eop = (int-gt) : IntGtOp()
  defrule eop = (int-le) : IntLeOp()
  defrule eop = (int-ge) : IntGeOp()
  defrule eop = (int-neg) : IntNegOp()
  defrule eop = (ref-eq) : RefEqOp()
  defrule eop = (ref-ne) : RefNeOp()

  defproduction etype : EType
  defrule etype = (byte) : EByte()
  defrule etype = (int) : EInt()
  defrule etype = (long) : ELong()
  defrule etype = (float) : EFloat()
  defrule etype = (double) : EDouble()
  defrule etype = (?) : EUnknown()
  defrule etype = (top) : ETop()
  defrule etype = (bot) : EBot()
  defrule etype = (ptr<?t:#etype>) : EPtrT(t)
  defrule etype = (fn<(?a:#etype ...), ?r:#etype, ?b:#etype>) : EFnT(to-tuple(a), r, b)
  defrule etype = (fn<(?a:#etype ...), ?b:#etype>) : EFnT(to-tuple(a), false, b)
  defrule etype = (?n:#tid) : EStructT(n)
  defrule etype = (ref<?n:#tid>) : EOf(n)
  defrule etype = (?n:#tvid) : ETVar(n)
  defrule etype = (and(?a:#etype,?b:#etype)) : EAnd(a,b)
  defrule etype = (or(?a:#etype,?b:#etype)) : EOr(a,b)

  defproduction etexp : ETExp
  defrule etexp = (defval ?n:#vid : ?t:#etype) : EDef(n, t, false)
  defrule etexp = (defvar ?n:#vid : ?t:#etype) : EDef(n, t, true)
  defrule etexp = (defmulti ?n:#vid<?targs:#tvid ...> (?a1:#etype ...) -> ?a2:#etype) :
    EDefmulti(n, to-tuple(targs), to-tuple(a1), a2)
  defrule etexp = (defmethod ?n:#vid (?multi:#vid) ?f:#efn) : EDefmethod(n, multi, f)
  defrule etexp = (defstruct ?n:#tid ?p:#parent? : (?ts:#etype ... ~ ...)) :
    EDefStruct(n, p to-tuple(but-last(ts)), last(ts))
  defrule etexp = (defstruct ?n:#tid ?p:#parent? : (?ts:#etype ...)) :
    EDefStruct(n, p, to-tuple(ts), false)
  defrule etexp = (externfn ?lbl:#symbol ?n:#vid ?f:#efn) : EExternFn(n, lbl, f)
  defrule etexp = (extern ?lbl:#symbol ?n:#vid : ?t:#etype) : EExtern(n, lbl, t)
  defrule etexp = (init : 
                     ?locals:#elocal ...
                     ?localfns:#elocalfn ...
                     ?localobjs:#elocalobj ...
                     ?ins:#eins ...) :
    EInit(to-tuple(locals), to-tuple(localfns), to-tuple(localobjs), to-tuple(ins))
  defrule etexp = (deftype ?n:#tid ?p:#parent? (?cs:#tid ...)) : EDefType(n, p, to-tuple(cs))

  defproduction parent? : False|EType
  defrule parent? = (<: ?t:#etype) : t
  defrule parent? = () : false

  defproduction elocal : ELocal
  defrule elocal = (defvar ?n:#vid : ?t:#etype) : ELocal(n, t, true)
  defrule elocal = (defval ?n:#vid : ?t:#etype) : ELocal(n, t, false)

  defproduction elocalfn : ELocalFn
  defrule elocalfn = (defn ?n:#vid ?f:#efunc) : ELocalFn(n, f)

  defproduction elocalobj : ELocalObj
  defrule elocalobj = (defobj ?n:#oid <: ?t:#etype : (?ms:#emethod ... #E)) : ELocalObj(n,t,to-tuple(ms))
  defproduction emethod : EMethod
  defrule emethod = (defmethod ?multi:#vid<?targs:#etype ...> (this = ?thisn:#vid) ?f:#efn) :
    EMethod(multi, to-tuple(targs), thisn, f)

  defproduction efunc : EFunction
  defrule efunc = (?f:#efn) : f
  defrule efunc = (multifn : (?fs:#efn ... #E)) : EMultifn(to-tuple(fs))
  
  defproduction efn : EFn
  defrule efn = (fn<?targs:#tvid ...> ((?args:#vid : ?a1:#etype) @...) -> ?a2:#etype :
                   ?locals:#elocal ...
                   ?localfns:#elocalfn ...
                   ?localobjs:#elocalobj ...
                   ?ins:#eins ... #E) :
    EFn(to-tuple(targs), to-tuple(args), to-tuple(a1), a2, to-tuple(locals),
        to-tuple(localfns), to-tuple(localobjs), to-tuple(ins))  

  defproduction eins : EIns
  defrule eins = (letrec [?xs:#evar ...] = [?cs:#eclosure ...]) : ELetRec(to-tuple(xs), to-tuple(cs))
  defrule eins = (box-set ?y:#eimm = ?z:#eimm) : EBoxSet(y, z)
  defrule eins = (return ?y:#eimm) : EReturn(y)
  defrule eins = (tuple-set ?y:#eimm[?i:#int] = ?z:#eimm) : ETupleSet(y, i, z)
  defrule eins = (check-length(?y:#eimm) = ?len:#int) : ECheckLength(y, len)
  defrule eins = (dump (?ys:#eimm ...)) : EDump(to-tuple(ys))
  defrule eins = (store ?loc:#eloc = ?y:#eimm : ?t:#etype) : EStore(loc, y, t)
  defrule eins = (label ?n:#lid) : ELabel(n)
  defrule eins = (do ?f:#eimm(?ys:#eimm ...)) : EDo(false, false, f, to-tuple(ys))
  defrule eins = (do-c ?f:#eimm(?ys:#eimm ...)) : EDoC(false, false, f, to-tuple(ys))
  defrule eins = (goto ?n1:#lid when prim ?op:#eop (?ys:#eimm ...) else ?n2:#lid) : EIf(n1, n2, op, to-tuple(ys))
  defrule eins = (goto ?n1:#lid when ?y:#eimm else ?n2:#lid) : EIf(n1, n2, false, [y])
  defrule eins = (goto ?n:#lid) : EGoto(n)
  defrule eins = (match(?ys:#eimm ...) : (?bs:#ebranch ...)) : EMatch(to-tuple(ys), to-tuple(bs))
  defrule eins = (check-set ?y:#evar) : ECheckSet(y)  
  defrule eins = (?x:#evar = interpret ?y:#eimm) : EInterpret(x,y)
  defrule eins = (?x:#evar = conv ?y:#eimm) : EConv(x,y)
  defrule eins = (?x:#evar = check ?y:#eimm) : ECheck(x,y)
  defrule eins = (?x:#evar = prim ?op:#eop (?ys:#eimm ...)) : EPrim(x, op, to-tuple(ys))
  defrule eins = (?x:#evar = box()) : EBox(x,false)
  defrule eins = (?x:#evar = box(?y:#eimm)) : EBox(x,y)
  defrule eins = (?x:#evar = box-get ?y:#eimm) : EBoxGet(x,y)
  defrule eins = (?x:#evar = new ?n:#oid) : ENew(x,n)
  defrule eins = (?x:#evar = tuple [?ys:#eimm ...]) : ETuple(x, to-tuple(ys))
  defrule eins = (?x:#evar = void-tuple(?len:#int)) : EVoidTuple(x, len)
  defrule eins = (?x:#evar = tuple-get ?y:#eimm[?i:#int]) : ETupleGet(x, y, i)
  defrule eins = (?x:#evar = object ?n:#tid (?ys:#eimm ...)) : EObject(x, n, to-tuple(ys))
  defrule eins = (?x:#evar = array ?n:#tid (?ys:#eimm ...)) : EArray(x, n, to-tuple(ys))
  defrule eins = (?x:#evar = struct ?n:#tid (?ys:#eimm ...)) : EStruct(x, n, to-tuple(ys))
  defrule eins = (?x:#evar = addr(?loc:#eloc)) : EPtr(x, loc)  
  defrule eins = (?x:#evar : ?xt:#etype = check-do ?f:#eimm((?ys:#eimm : ?yt:#etype) @...)) : ECheckedDo(x, xt, f, to-tuple(ys), to-tuple(yt))
  defrule eins = (?x:#evar : ?xt:#etype = load ?loc:#eloc) : ELoad(x, xt, loc)
  defrule eins = (?x:#evar : ?xt:#etype = do ?f:#eimm(?ys:#eimm ...)) : EDo(x, xt, f, to-tuple(ys))
  defrule eins = (?x:#evar : ?xt:#etype = do-c ?f:#eimm(?ys:#eimm ...)) : EDoC(x, xt, f, to-tuple(ys))
  defrule eins = (?x:#evar = ?y:#eimm) : ESet(x, y)
  defrule eins = ([?xs:#evar ...] = [?ys:#eimm ...]) : EShuffle(to-tuple(xs), to-tuple(ys))

  defproduction eclosure : EClosure
  defrule eclosure = (closure(?n:#vid)) : EClosure(n)

  defproduction ebranch : EBranch
  defrule ebranch = ((?ts:#etype ...) : goto ?n:#lid) : EBranch(to-tuple(ts), n)

  defproduction evar : EVar
  defrule evar = (?n:#vid) : EVar(n)

  defproduction eimm : EImm
  defrule eimm = (LV{?x}) : ELSLiteral(unwrap-all(x))
  defrule eimm = (V{?x}) : ELiteral(unwrap-all(x))
  defrule eimm = (mix(?fs:#curry ...)) : EMix(to-tuple(fs))
  defrule eimm = (?x:#curry) : x
  defrule eimm = (sizeof(?t:#etype)) : ESizeof(t)
  defrule eimm = (tagof(?n:#tid)) : ETagof(n)  
  defrule eimm = (?x:#evar) : x

  defproduction curry : ECurry
  defrule curry = (?n:#vid<?targs:#etype ...>) : ECurry(n, to-tuple(targs))

  defproduction eloc : ELoc
  defrule eloc = (?x:#evar) : x
  defrule eloc = (deref(?y:#eimm)) : EDeref(y)
  defrule eloc = (deptr(?y:#eimm)) : EDeptr(y)
  defrule eloc = (field(?loc:#eloc, ?n:#tid[?i:#int])) : EField(loc, n, i)
  defrule eloc = (slot(?loc:#eloc[?i:#eimm] : ?t:#etype)) : ESlot(loc, t, i)

  defproduction E : False
  fail-if E = (_) : ELE(closest-info(), "Unrecognized input here.")
  defrule E = () : false

  public defproduction epackage : EPackage
  defrule epackage = (package ?name:#symbol : (?es:#etexp ... #E)) : EPackage(name, to-tuple(es))

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction byte : Byte
  defrule byte = (?x) when unwrap-token(x) is Byte : unwrap-token(x)

  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

;============================================================
;====================== Errors ==============================
;============================================================

public defstruct ELError <: Exception :
  info: FileInfo|False
  msg

public defn ELE (info:FileInfo|False, msg) :
  ELError(info, msg)

defmethod print (o:OutputStream, e:ELError) :
  val info-str = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [info-str, msg(e)])

;============================================================
;======================= Scratch ============================
;============================================================

public defn read-el-file (filename:String) :
  val forms = reader/read-file(filename)
  parse-syntax[el-ir / #epackage](forms)

let :
  val filename = command-line-arguments()[1]
  println(read-el-file(filename))