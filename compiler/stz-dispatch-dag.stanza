defpackage stz/dispatch-dag :
  import core
  import collections

;============================================================
;==================== Input Datastructure ===================
;============================================================

public deftype Arg <: Hashable & Equalable
public defstruct Top <: Arg
public defstruct Nums <: Arg :
  values: Tuple<Int>

public defstruct Branch :
  args: Tuple<Arg>

public defstruct BranchTable :
  branches: Tuple<Branch>
  abstract-nums: IntSet with: (default => IntSet())

public deftype Soln <: Hashable & Equalable
public defstruct NoSoln <: Soln
public defstruct UniqueSoln <: Soln : (index:Int)
public defstruct AmbSoln <: Soln :
  index1:Int,
  index2:Int with: (ensure => different!(index1))
with:
  constructor => #AmbSoln

public defn AmbSoln (a:Int, b:Int) :
  #AmbSoln(min(a,b), max(a,b))

;============================================================
;===================== Error Checking =======================
;============================================================

defn different! (a:Int) :
  fn (description:String, b:Int) :
    if a == b :
      fatal("The value given to %_ (%_) should not be equal to %_." % [
        description, b, a])

;============================================================
;=================== Hash and Equality ======================
;============================================================

defmethod hash (a:Arg) :
  match(a) :
    (a:Top) : 0
    (a:Nums) : hash(values(a))

defmethod equal? (a:Arg, b:Arg) :
  match(a, b) :
    (a:Top, b:Top) : true
    (a:Nums, b:Nums) : values(a) == values(b)
    (a,b) : false

defmethod hash (a:Soln) -> Int:
  match(a):
    (a:NoSoln) : 0
    (a:UniqueSoln) : (- index(a))
    (a:AmbSoln) : index1(a) * index2(a)

defmethod equal? (a:Soln, b:Soln):
  match(a, b):
    (a:NoSoln, b:NoSoln): true
    (a:UniqueSoln, b:UniqueSoln): index(a) == index(b)
    (a:AmbSoln, b:AmbSoln): index1(a) == index1(b) and index2(a) == index2(b)
    (a, b): false

;============================================================
;====================== Printing ============================
;============================================================

defmethod print (o:OutputStream, n:Nums) :
  print("(%,)" % [values(n)])
defmethod print (o:OutputStream, t:Top) :
  print("(TOP)")
defmethod print (o:OutputStream, b:Branch) :
  print(o, args(b))
defmethod print (o:OutputStream, t:BranchTable) :
  print(o, "abstract: %," % [abstract-nums(t)])
  lnprint(o, "%n" % [branches(t)])

defmethod print (o:OutputStream, s:NoSoln) :
  print(o, "NoSoln")
defmethod print (o:OutputStream, s:UniqueSoln) :
  print(o, "UniqueSoln(%_)" % [index(s)])
defmethod print (o:OutputStream, s:AmbSoln) :
  print(o, "AmbSoln(%_, %_)" % [index1(s), index2(s)])

;============================================================
;====================== Relations ===========================
;============================================================

public defn subarg? (x:Arg, y:Arg) :
  match(x, y):
    (x:Top, y:Top) : true
    (x:Nums, y:Top) : true
    (x:Nums, y:Nums) : all?(contains?{values(y), _}, values(x))
    (x, y): false

public defn bottom? (x:Arg) :
  match(x:Nums) :
    empty?(values(x))

val OVERLAP-SET = IntSet()
public defn overlap? (x:Arg, y:Arg) :
  if bottom?(x) or bottom?(y) :
    false
  else :
    match(x, y) :
      (x:Top, y) : true
      (x, y:Top) : true
      (x:Nums, y:Nums) :
        add-all(OVERLAP-SET, values(x))
        val result = any?({OVERLAP-SET[_]}, values(y))
        clear(OVERLAP-SET)
        result

public defn covered? (y:Int, x:Arg) :
  match(x) :
    (x:Top) : true
    (x:Nums) : contains?(values(x), y)

public defn subbranch? (a:Branch, b:Branch) :
  fatal("Mismatched lengths") when length(args(a)) != length(args(b))
  all?(subarg?, args(a), args(b))

public defn strict-subbranch? (a:Branch, b:Branch) :
  subbranch?(a,b) and not subbranch?(b,a)

public defn case? (case:Tuple<Int>, b:Branch) : 
  fatal("Mismatched lengths") when length(case) != length(args(b))
  all?(covered?, case, args(b))

;============================================================
;======================= Soln Checker =======================
;============================================================

public defn check (s:Soln, case:Tuple<Int>, table:BranchTable) -> True|False :
  val bs = branches(table)
  match(s) :
    (s:NoSoln) :
      for i in 0 to length(bs) none? :
        case?(case, bs[i])
    (s:UniqueSoln) :
      for i in 0 to length(bs) all? :
        if i == index(s) :  (case?(case, bs[i]) )
        else : subbranch?(bs[index(s)], bs[i]) or not case?(case, bs[i])
    (s:AmbSoln) :
      defn no-other-satisfying-subbranch? (i:Int) :
        for j in 0 to length(bs) none? :
          i != j and case?(case, bs[j]) and subbranch?(bs[j], bs[i])
      case?(case, bs[index1(s)]) and
      case?(case, bs[index2(s)]) and
      no-other-satisfying-subbranch?(index1(s)) and
      no-other-satisfying-subbranch?(index2(s))

;============================================================
;====================== Ancestor Table ======================
;============================================================

;Returns a strict ancestor table.
defn ancestor-table (branches:Tuple<Branch>) :
  val ancestors = IntListTable<Int>()
  within (ba, bb) = overlaps(branches) :
    match(subbranch?(branches[ba], branches[bb]), subbranch?(branches[bb], branches[ba])) :
      (a-sub-b:True, b-sub-a:False) : add(ancestors, ba, bb)
      (a-sub-b:False, b-sub-a:True) : add(ancestors, bb, ba)
      (a-sub-b, b-sub-a) : false
  ancestors

defn overlaps (return:(Int, Int) -> ?, branches:Tuple<Branch>) :
  val overlap-count = HashTable<[Int,Int],Int>(0)
  val num-coords = length(args(branches[0]))
  for coord in 0 to num-coords do :
    within (branch-a, branch-b) = sweep-line(coordinate-intervals(branches, coord)) :
      val p = [branch-a, branch-b]
      val count = update(overlap-count, {_ + 1}, p)
      return(branch-a, branch-b) when count == num-coords

defn coordinate-intervals (branches:Collection<Branch>, coord:Int) :
  val ints = Vector<IntervalEvent>()
  for (b in branches, branch-id in 0 to false) do :
    val [start,end] = match(args(b)[coord]):
      (a:Top): [INT-MIN, INT-MAX]
      (a:Nums): [minimum(xs), maximum(xs)] where :
                  val xs = values(a)        
    add(ints, IntervalEvent(branch-id, true, start))
    add(ints, IntervalEvent(branch-id, true, end))
  qsort!(ints)
  ints

defn sweep-line (return:(Int, Int) -> ?, intervals:Collection<IntervalEvent>) :
  val id-set = HashSet<Int>()
  for e in intervals do :
    if start?(e) :
      for existing-id in id-set do :
        return(min(id(e), existing-id),
               max(id(e), existing-id))
      add(id-set, id(e))
    else :
      remove(id-set, id(e))

defstruct IntervalEvent <: Comparable<IntervalEvent> :
  id:Int
  start?:True|False
  value:Int

defmethod compare (a:IntervalEvent, b:IntervalEvent) :
  val c = compare(value(a), value(b))
  if c == 0 :
    match(start?(a), start?(b)) :
      (sa:True, sb:False) : -1
      (sa:False, sb:True) : 1
      (sa, sb) : compare(id(a), id(b))
  else : c

;============================================================
;================= Topological Solution =====================
;============================================================

defn topo-order (btable:BranchTable) -> Tuple<Int> :
  val bs = branches(btable)
  defn compare-branch (i:Int, j:Int) :
    match(subbranch?(bs[i], bs[j]), subbranch?(bs[j], bs[i])) :
      (a:True, b:False) : -1
      (a:False, b:True) : 1
      (a, b) : compare(i,j)
  qsort(0 to length(bs), compare-branch)

defn topo-soln (solns:Tuple<Soln>, ancestors:Table<Int,List<Int>>, btable:BranchTable) -> Soln :
  ;Retrieve the first branch index
  val branch0 = index(solns[0] as UniqueSoln)
  
  ;If the number of applicable branches is equal to the number of
  ;ancestors, then the solution is unique.
  if length(solns) == length(ancestors[branch0]) + 1 :
    UniqueSoln(branch0)
  else:
    ;Otherwise it is ambiguous, ie. one of the branches
    ;is not a strict subbranch of branch0.
    val amb-id = for i in 1 to length(solns) find! :
      val b = index(solns[i] as UniqueSoln)
      not strict-subbranch?(branches(btable)[branch0], branches(btable)[b])
    AmbSoln(branch0, amb-id)

;============================================================
;================== Argument Collapsing =====================
;============================================================

defn collapse-args (args:Tuple<Arg>, abstract:IntSet) -> [Tuple<Tuple<Int|Top>>, Vector<List<Int>>] :
  ;Compute all the branches that each Arg is included in.
  val included-in-branches = IntListTable<Int>()
  for (arg in args, branch-id in 0 to false) do :
    match(arg:Nums) :
      for x in values(arg) do:
        if not abstract[x] :
          add(included-in-branches, x, branch-id)

  ;Compute the values that should be in each group.
  val grouped-table = ListTable<List<Int>,Int>()
  for [x,branches] in pairs(included-in-branches) do :
    add(grouped-table, branches, x)

  ;Compute group ids (densely indexed), and mapping from group id to values.
  val group-ids = HashTable<List<Int>,Int>()
  val group-values = Vector<List<Int>>()
  for ([bs, xs] in pairs(grouped-table), i in 0 to false) do :
    group-ids[bs] = i
    group-values[i] = xs

  ;Compute the branches that are in each group
  val branch-groups = IntListTable<Int>()
  for [bs,g] in pairs(group-ids) do :
    for b in bs do :
      add(branch-groups, b, g)

  ;Compute the new mapped arguments
  val args* = to-tuple $
    for (arg in args, b in 0 to false) seq :
      match(arg) :
        (arg:Nums) : to-tuple(branch-groups[b])
        (arg:Top) : to-tuple(cat([Top()], 0 to length(group-values)))
        
  ;Return new mapped arguments and values for each group
  [args*, group-values]

defn form-trie<T> (branches:Tuple<Branch>,
                   targets:Tuple<Soln>,
                   abstract-nums:IntSet,
                   Node: (Int, Tuple<KeyValue<Int|Top,T>>, Vector<List<Int>>) -> T,
                   Leaf: Tuple<Soln> -> T) :
  defn form (depth:Int, branches:Tuple<List<Arg>>, targets:Tuple<Soln>) -> T :
    if empty?(branches[0]) :
      Leaf(targets)
    else :
      val [groups, group-values] = collapse-args(map(head,branches), abstract-nums)
      val table = ListTable<Int|Top, KeyValue<List<Arg>,Soln>>()
      for (group in in-reverse(groups), branch in in-reverse(branches), target in in-reverse(targets)) do :
        for v in group do :
          add(table, v, tail(branch) => target)      
      val trie-entries = to-tuple $
        for [v, entries-list] in pairs(table) seq :
          val entries = to-tuple(entries-list)          
          v => form(depth + 1, map(key,entries), map(value,entries))
      Node(depth, trie-entries, group-values)
  form(0, branch-lists, targets) where :
    val branch-lists = map(to-list{args(_)}, branches)

defn collapse-branches (btable:BranchTable) -> [Tuple<Tuple<Tuple<Int|Top>>>, Vector<Vector<List<Int>>>] :
  val arity = length(args(branches(btable)[0]))
  defn coord-args (i:Int) :
    for b in branches(btable) map :
      args(b)[i]
  val arg-group-values = Vector<Vector<List<Int>>>()
  val branch-args = transpose $ to-tuple $
    for i in 0 to arity seq :
      val [args, group-values] = collapse-args(coord-args(i), abstract-nums(btable))
      add(arg-group-values, group-values)
      args
  [branch-args, arg-group-values]

;============================================================
;================= Construct Cartesian Table ================
;============================================================
;For all possible input arguments list of applicable branches in
;topological order.

defn construct-cartesian-table (branches:Tuple<Tuple<Tuple<Int|Top>>>, ordering:Tuple<Int>) :
  val table = ListTable<Tuple<Int|Top>,Int>()
  for branch-id in ordering do :
    val branch = branches[branch-id]
    within case = cartesian(branch) :
      add(table, case, branch-id)
  table

defn cartesian<?T> (return:Tuple<T> -> ?, xxs:Tuple<Collection<?T>>) :
  val n = length(xxs)
  val buffer = Array<T>(n)
  let loop (i:Int = 0) :
    if i < n :
      for x in xxs[i] do :
        buffer[i] = x
        loop(i + 1)
    else :
      return(to-tuple(buffer))

;============================================================
;============== Compute Ordered Solution ====================
;============================================================

defn compute-ordered-soln (b-table:BranchTable) -> [
                           Seq<KeyValue<Tuple<Int|Top>, Soln>>,
                           Vector<Vector<List<Int>>>] :
  ;Collapse branches into groups
  val [branch-groups, group-values] = collapse-branches(b-table)

  ;Collect all entries
  val entries = Vector<KeyValue<Tuple<Int|Top>,Soln>>()
  for branch-id in reverse(0 to length(branch-groups)) do :
    val branch = branch-groups[branch-id]
    within case = cartesian(branch) :
      add(entries, case => UniqueSoln(branch-id))

  ;Return entries and grouped-values
  [to-seq(entries), group-values]

;============================================================
;============== Compute Dag from Branch Table ===============
;============================================================

defn compute-dag (b-table:BranchTable, branch-order:Collection<Int>, collapse-solns:Tuple<Soln> -> Soln) :
  ;Form DAG entries
  val dag-table = HashTable<DagEntry,Int>(dag-hash, dag-equal?)
  val dag-entries = Vector<DagEntry|False>()
  defn dag-index (e:DagEntry) :
    if not key?(dag-table,e) :
      add(dag-entries, e)
      dag-table[e] = length(dag-entries) - 1
    dag-table[e]

  ;Form a dag entry
  defn make-dag-entry (depth:Int, entries:Tuple<KeyValue<Int|Top, Int|Soln>>, group-values:Vector<List<Int>>) -> Int|Soln :
    val merged-entries = within keys = merge-keys(entries) :
      if any?({_ is Top}, keys) : Top()
      else : Nums $ to-tuple $ seq-cat({group-values[_ as Int]}, keys)
    val [dag-entries, default] = fork-on-seq(merged-entries,
      fn (es) :
        val r = to-tuple(filter({key(_) is Nums}, es))
        r as Tuple<KeyValue<Nums,Int|Soln>>
      fn (es) :
        val v = for e in es first :
          if key(e) is Top : One(value(e))
          else : None()
        value?(v, NoSoln()))
    if empty?(dag-entries) : default
    else : dag-index(DagEntry(depth, dag-entries, default))

  ;Create all dag entries
  val branches* = to-tuple(seq({branches(b-table)[_]}, branch-order))
  val targets* = to-tuple(seq(UniqueSoln, branch-order))
  add(dag-entries, false)
  form-trie<Int|Soln>(branches*, targets*, abstract-nums(b-table), make-dag-entry, collapse-solns)
  dag-entries[0] = pop(dag-entries)

  ;Return Dag datastructure
  val depth = length(args(branches(b-table)[0]))
  Dag(depth, to-tuple(dag-entries) as Tuple<DagEntry>)

defn arg-soln (applicable-branches:List<Int>,
               ancestors:Table<Int,List<Int>>,
               strict-subbranch?: (Int, Int) -> True|False) -> Soln :
  val branch0 = head(applicable-branches)
  val branch-rest = tail(applicable-branches)

  ;If the number of applicable branches is equal to the number of
  ;ancestors, then the solution is unique.
  if length(branch-rest) == length(ancestors[branch0]) :
    UniqueSoln(branch0)
  else:
    ;Otherwise it is ambiguous, ie. one of the branches
    ;is not a strict subbranch of branch0.
    val amb-id = find!({not strict-subbranch?(branch0, _)}, branch-rest)
    AmbSoln(branch0, amb-id)

defn compute-topo-order (branch-table:Tuple<Tuple<Tuple<Int|Top>>>) -> Tuple<Int> :
  ;Compute the levels of each branch
  val levels = for b in branch-table map :
    val sum = sum(seq(length, b))
    (- sum)
  qsort({levels[_]}, 0 to length(branch-table))

;============================================================
;================= Create Trie ==============================
;============================================================

deftype Trie <: Hashable & Equalable
defmulti soln (t:Trie) -> Soln|False
defmulti sub-tries (t:Trie) -> Table<Int|Top,Trie>
defmulti add (t:Trie, case:List<Int|Top>, case-soln:Soln) -> False

defn Trie () :
  val table = HashTable-init<Int|Top,Trie>(Trie{})
  var soln: Soln|False = false

  new Trie :
    defmethod add (this, case:List<Int|Top>, case-soln:Soln) :
      if empty?(case) : soln = case-soln
      else : add(table[head(case)], tail(case), case-soln)        

    defmethod soln (this) :
      soln

    defmethod sub-tries (this) :
      fatal("Leaf trie has no sub-tries.") when soln is Soln
      table

    defmethod hash (this) -> Int:
      match(soln):
        (soln:Soln) : hash(soln)
        (soln:False) : length(table) + sum $ seq(hash, keys(table))

    defmethod print (o: OutputStream, this) :
      match(soln) :
        (soln:Soln) :
          print(o, soln)
        (soln:False) :
          val o2 = IndentedStream(o)
          for ([k,t] in pairs(table), i in 0 to false) do :
            print(o, '\n') when i > 0
            print(o, "case %_:" % [k])
            lnprint(o2, t)

defmethod equal? (a:Trie, b:Trie) -> True|False:
  match(soln(a), soln(b)):
    (a-soln:False, b-soln:False):
       val table-a = sub-tries(a)
       val table-b = sub-tries(b)
       length(table-a) == length(table-b) and
         for [ka, va] in pairs(table-a) all? :
           va == get?(table-b, ka)
    (a-soln, b-soln):
      a-soln == b-soln

defn create-trie (cases:Seqable<KeyValue<Tuple<Int|Top>, Soln>>):
  val trie = Trie()
  for [case, soln] in pairs(cases) do:
    add(trie, to-list(case), soln)
  trie

;============================================================
;======================= Create DAG =========================
;============================================================

public defstruct DagEntry :
  depth: Int
  entries: Tuple<KeyValue<Nums,Int|Soln>>  
  default: Int|Soln

public defstruct Dag :
  depth: Int
  entries: Tuple<DagEntry>

defn dag-equal? (a:DagEntry, b:DagEntry) :
  if depth(a) == depth(b) and default(a) == default(b) and length(entries(a)) == length(entries(b)) :
    val b-set = to-hashset<KeyValue<Nums,Int|Soln>>(entries(b))
    all?({b-set[_]}, entries(a))
  
defn dag-hash (e:DagEntry) :
  hash $ [depth(e), sum(seq(hash, entries(e))), default(e)]

defn dagify-trie (trie:Trie, group-values:Vector<Vector<List<Int>>>, depth:Int) -> Dag:
  val dag-entries = Vector<DagEntry>()
  
  ;Insert dummy node, so we can later reinsert at starting entry of index 0
  add(dag-entries, DagEntry(0, [], 0))

  ;Cache the trie indices
  val trie-indices = HashTable<Trie,Int|Soln>()
  defn get-entry-id (t:Trie, depth:Int) -> Int|Soln :
    match(soln(t)):
      (trie-soln:Soln):
        trie-soln
      (trie-soln:False):
        set?(trie-indices, t, fn () :
          val merged-nums = Vector<Int>()
          val merged-entries = within (ks) = merge-keys(sub-tries(t)) :
            if any?({_ is Top}, ks) :
              Top()
            else :
              Nums $ to-tuple $ for k in ks seq-cat :
                group-values[depth][k as Int]
                
          val entries = Vector<KeyValue<Nums,Int|Soln>>()
          var default:Int|Soln = NoSoln()
          for e in merged-entries do :
            val v = get-entry-id(value(e), depth + 1)
            match(key(e)) :
              (k:Nums) : add(entries, k => v)
              (k:Top) : default = v
          if empty?(entries) :
            default
          else :
            add(dag-entries, DagEntry(depth, to-tuple(entries), default))
            length(dag-entries) - 1)

  ;Put trie into Dag
  get-entry-id(trie, 0)
  
  ;Insert first Dag entry at index 0
  dag-entries[0] = pop(dag-entries)

  ;Return Dag structure
  Dag(depth, to-tuple(dag-entries))

defmethod print (o:OutputStream, dag:Dag) :
  val o2 = IndentedStream(o)
  print(o, "Dag:")
  lnprint(o2, "depth: %_" % [depth(dag)])
  for (e in entries(dag), i in 0 to false) do :
    lnprint(o2, "%_) %_" % [i, e])
    
defmethod print (o:OutputStream, e:DagEntry) :
  val o2 = IndentedStream(o)
  print(o, "DagEntry:")
  lnprint(o2, "depth: %_" % [depth(e)])
  for [n, s] in pairs(entries(e)) do :
    lnprint(o2, "case %_ : %_" % [n, s])
  if default(e) is-not NoSoln :
    lnprint(o2, "else : %_" % [default(e)])    

;============================================================
;================== Computing the Dispatch Dag ==============
;============================================================

val DAG-TIMER = MillisecondTimer("Dag")
public defn compute-dispatch-dag (btable:BranchTable, topological?:True|False) -> ? :
  defn run () :
    ;Empty branch table
    if empty?(branches(btable)) :
      val e = DagEntry(0, [], NoSoln())
      Dag(0, [e])
    ;Topological branch table
    else if topological? :
      val topo-order = topo-order(btable)
      val ancestors = ancestor-table(branches(btable))
      compute-dag(btable, topo-order, topo-soln{_, ancestors, btable})
    ;Ordered branch table
    else :
      defn first-soln (solns:Tuple<Soln>) : solns[0]
      compute-dag(btable, 0 to length(branches(btable)), first-soln)

  start(DAG-TIMER)
  val result = run()
  stop(DAG-TIMER)
  println(DAG-TIMER)
  result

;============================================================
;=================== Resolving a Dag ========================
;============================================================

public defn all-solns (dag:Dag, case:Tuple<Arg>, include-amb?:True|False) -> Tuple<Soln> :
  ;Track whether a dagentry has already been processed
  val visited = Array<True|False>(length(entries(dag)), false)
  
  ;Accumulate all the reachable solutions
  val solns = HashSet<Soln>()

  ;Algorithm
  defn* loop (e:DagEntry) :
    val arg = case[depth(e)]
    if not bottom?(arg) :
      for e in entries(e) do :
        loop(value(e)) when overlap?(key(e), arg)
      loop(default(e))

  defn* loop (e:Int|Soln) :
    match(e) :
      (soln:NoSoln) :
        false
      (soln:AmbSoln) :
        add(solns, soln) when include-amb?
      (soln:Soln) :
        add(solns, soln)
      (dag-index:Int) :
        if not visited[dag-index] :
          visited[dag-index] = true
          loop(entries(dag)[dag-index])

  ;Start from beginning
  loop(0)
  to-tuple(solns)

;============================================================
;======================= Utilities ==========================
;============================================================

defn ListTable<K,V> () :  
  HashTable<K,List<V>>(List())
defn IntListTable<V> () :
  IntTable<List<V>>(List())
defn add<?K,?V> (table:Table<?K,List<?V>>, k:K, v:V) :
  update(table, cons{v, _}, k)

defn pairs<?K,?V> (xs:Seqable<KeyValue<?K,?V>>) -> Seq<[K,V]> :
  for x in xs seq :
    [key(x), value(x)]

defn merge-keys<?K,?V,?K2> (merge:Collection<K> -> ?K2, kvs:Seqable<KeyValue<?K,?V>>) -> Tuple<KeyValue<K2,V>> :
  val table = ListTable<V,K>()
  for [k, v] in pairs(kvs) do:
    add(table, v, k)
  to-tuple $ for [v, ks] in pairs(table) seq:
    merge(ks) => v

defn transpose<?T> (table:Tuple<Tuple<?T>>) -> Tuple<Tuple<T>>:
  to-tuple $ zip-all(table)

