defpackage stz/front-end :
  import core
  import collections

;<doc>=======================================================
;======================== Algorithm =========================
;============================================================

1. Categorize all of the given inputs into their respective types.
There are the following categories:
  - LoadStanzaFile
  - LoadPkgFile
  - LoadPkg
  - LoadBindingsFile

2. The following is the process to follow for loading any source file:
  - The source file needs to be read in.
  - The source file needs to be macroexpanded.
  - The source file needs to be converted into IPackage form.
  - The source file needs to be renamed.
  - The source file needs to be resolved.

3. Using the process outlined above, load all input source files.
Dependencies arrive in one of two ways:
  - While resolving a source file, an import statement attempts to
    bring in a new dependency.
  - A loaded .pkg file comes with a set of dependencies that need to
    be satisfied.

By the end of this step, we should have a collection of IPackage
packages, each representing a source file package, and a collection of
Pkg packages, each representing a loaded .pkg file.

4. Now run the type inferencer on the IPackage packages, constructing
the environment from the given .pkg files. This step should not
involve pulling in any more dependencies. If successful, the IPackage
packages will now be represented as a TProg program.

5. A typed TProg program can be compiled into a collection of EPackage
packages.

6. Given the collection of EPackage packages, we now have to check
their type consistency. Inconsistencies will be caused by out-of-date
packages loaded from .pkg files. If any inconsistency is found, we can
attempt to reload the offending packages from their source files (into
IPackage form), and then restart the type inferencer from step 4.

7. If we reach the end of the algorithm, we will have a series of
EPackage packages ready to be compiled by the backend, or loaded into
the REPL.

;============================================================
;=======================================================<doc>

public deftype FrontEndInputs
inputs -> Tuple<String|Symbol>

public defstruct FrontEndResult :
  ???

public defn compile-to-el (sys:FrontEndInputs) :
  val s = CompileState()
  load-inputs(s, inputs(sys))
  
;============================================================
;====================== State ===============================
;============================================================

defstruct CompileState :
  records: Vector<CRecord>

deftype CRecord

;------------------------------------------------------------
;----------------------- Loading ----------------------------
;------------------------------------------------------------

defstruct LoadStanzaFile <: CRecord :
  filename: String

defstruct LoadPkgFile <: CRecord :
  filename: String

defstruct LoadPkg <: CRecord :
  name: Symbol

defstruct LoadBindingsFile <: CRecord :
  filename: String

defstruct LoadProjFile <: CRecord :
  filename: String

defn load-inputs (s:CompileState, inputs:Seqable<Symbol|String>) :
  for input in inputs do :
    val rec = match(input) :
      (input:Symbol) :
        LoadPkg(input)
      (input:String) :
        switch suffix?{input, _} :
          ".stanza" : LoadStanzaFile(input)
          ".pkg" : LoadPkgFile(input)
          ".fpkg" : LoadPkgFile(input)
          ".vmbindings" : LoadBindingsFile(input)
          ".proj" : LoadProjFile(input)
          else : throw(InvalidExtensionError(input))
    add(records(s), rec)
  