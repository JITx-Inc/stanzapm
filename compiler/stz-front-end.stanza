defpackage stz/front-end :
  import core
  import reader
  import collections
  import stz/pkg
  import stz/il-ir
  import stz/dl-ir
  import stz/el-ir
  import stz/tl-ir
  import stz/input
  import stz/core-macros
  import stz/bindings
  import stz/renamer
  import stz/resolver
  import stz/ids
  import stz/type
  import stz/tl-to-el
  import stz/dl
  import stz/utils
  import stz/proj-manager
  import stz/bindings-extractor
  import stz/bindings-to-vm

;<doc>=======================================================
;======================== Algorithm =========================
;============================================================

1. The following state tables are updated through the algorithm steps:

  package-table: HashTable<Symbol,IPackage|Pkg|False>
  package-exports-table: HashTable<Symbol,PackageExports>

  The package-table associates each successfully loaded and renamed
  package during the algorithm. An IPackage indicates it is a source
  package, a Pkg indicates it is a .pkg file, and False indicates that
  the package could not be found.

  The package-exports-table stores the computed PackageExports
  datastructure for each .pkg file.

2. The first step is to read in all the given inputs. The following
  file types are supported:

  *.stanza - Read, macroexpand, and convert to IL-IR.
  *.pkg - Read in.
  *.fpkg - Read in.
  *.vmbindings - Read in to Bindings file.

  If the input is a Symbol, then we first locate the filename for that
  package, and then read as normal.

  The output is Vector<IPackage|Pkg|Bindings> for representing each
  object.

3. The next step is to rename all of the input packages, and load them
into the package-table. An error is thrown if we detect duplicate
packages, or if something fails during renaming.

4. Next we need to resolve the packages. In order to do that, we need
to implement a resolver environment which is responsible for loading a
package when given its name.

5. Next, we compile the resolved packages to EL, which requires
running the type inferencer and the EL compiler.

6. The last step is to check for type consistency. Whether the types
in the source packages are consistent with their expected types in the
precompiled .pkg packages.

Inconsistencies will be caused by out-of-date packages loaded from
.pkg files. Inconsistencies are classified into either unrecoverable
errors, or errors potentially recoverable by reloading the original
source file corresponding to the .pkg file. 

;============================================================
;=======================================================<doc>

public deftype FrontEndInputs
public defmulti inputs (e:FrontEndInputs) -> Tuple<String|Symbol|IPackage>
public defmulti find-package (inputs:FrontEndInputs, name:Symbol) -> PkgLocation|False
public defmulti environment-package? (inputs:FrontEndInputs, name:Symbol) -> PackageIO|False
public defmulti load-into-denv (inputs:FrontEndInputs, ios:Tuple<PackageIO>) -> LoadResult

;============================================================
;============== Multis with Default Behaviour ===============
;============================================================
public defmulti transient? (inputs:FrontEndInputs) -> True|False
defmethod transient? (inputs:FrontEndInputs) : false

public defmulti package-priority (inputs:FrontEndInputs) -> False|(Symbol -> Int)
defmethod package-priority (inputs:FrontEndInputs) : false

public defmulti conditional-dependencies (inputs:FrontEndInputs, packages:Seqable<Symbol>) -> Tuple<Symbol>
defmethod conditional-dependencies (inputs:FrontEndInputs, packages:Seqable<Symbol>) : []

public defmulti supported-vm-packages (inputs:FrontEndInputs) -> Tuple<String|Symbol>
defmethod supported-vm-packages (inputs:FrontEndInputs) : []

;============================================================
;================== Result Datastructures ===================
;============================================================

public defstruct FrontEndResult :
  import-lists: Tuple<ImportList>
  packages: Tuple<EPackage|Pkg>
  timestamps: Tuple<PackageStamp>
  bindings: Bindings|False
  binding-packages: Tuple<Symbol>

public defstruct PackageStamp :
  location: PkgLocation
  source-timestamp: Long|False
  pkg-timestamp: Long|False
with:
  printer => true

public defn package (stamp:PackageStamp) :
  package(location(stamp))

;============================================================
;================ Main Compilation Algorithm ================
;============================================================
public defn compile-to-el (sys:FrontEndInputs) -> FrontEndResult :
  ;----------------------------------------------------------
  ;--------------------- State ------------------------------
  ;----------------------------------------------------------
  val package-table = PackageTable()
  val package-exports-table = HashTable<Symbol,PackageExports>()
  val package-locations = HashTable<Symbol,PkgLocation|False>()
  val package-stamps = HashTable<Symbol,PackageStamp>()  

  ;----------------------------------------------------------
  ;------------------ Main Algorithm ------------------------
  ;----------------------------------------------------------
  defn main () :
    ;Read all of the given inputs to compiler, and load them into the
    ;compiled package table.
    val input-objs = read-inputs(inputs(sys))
    load-package-table(input-objs)
    ;If we require bindings, then add their required dependencies
    ;to the compiler as well.
    if not empty?(supported-vm-packages(sys)) :
      load-package-table(read-inputs(binding-package-dependencies()))
    ;Being the resolver loop.
    let loop () :
      val resolved = resolve-packages()
      val epackages = compile-to-el(ipackages(resolved))
      val all-pkgs = order-packages(cat(epackages, pkgs(package-table)),
                                    init-order(resolved))
      match(load-into-denv!(all-pkgs)) :
        (f:False) :
          val timestamps = to-tuple(values(package-stamps))
          val [bindings, binding-packages] = vm-bindings?()
          FrontEndResult(import-lists(resolved), all-pkgs, timestamps, bindings, binding-packages)
        (ss:Tuple<PackageSource>) :
          load-package-table $ read-inputs(ss)
          loop()

  defn vm-bindings? () -> [Bindings|False, Tuple<Symbol>] :
    val vm-packages = supported-vm-packages(sys)
    if empty?(vm-packages) :
      [false, []]
    else :
      ;First compute the packages that are already compiled directly
      ;into the program.
      val included-packages = to-hashset<Symbol> $
        seq(name, package-table)
      
      ;Load remaining vm support packages
      val remaining-packages = to-tuple $
        for p in vm-packages filter :
          match(p) :
            (p:Symbol) : not key?(package-table, p)
            (p:String) : true
      load-package-table(read-inputs(remaining-packages))
      resolve-packages()

      ;Compute bindings for all packages not already included
      val binding-packages = to-tuple $
        for p in package-table seq? :
          if included-packages[name(p)] : None()
          else : One(p)
          
      ;Calculate bindings
      val bindings = extract-bindings(binding-packages)
      val binding-package-names = map(name, binding-packages)
      [bindings, binding-package-names]

  ;----------------------------------------------------------
  ;-------------------- Utilities ---------------------------
  ;----------------------------------------------------------
  defn package-location (name:Symbol) :
    set?(package-locations, name, fn () :
      find-package(sys, name))

  defn source-file? (name:Symbol) :
    match(package-location(name)) :
      (l:PkgLocation) : source-file(l)
      (f:False) : false     

  defn record-timestamp (l:PkgLocation) :
    defn timestamp? (file:String|False) -> Long|False :
      match(file:String) :
        time-modified(file) when file-exists?(file)
    val stamp = PackageStamp(l, timestamp?(source-file(l)), timestamp?(pkg-file(l)))
    package-stamps[package(l)] = stamp
    
  ;----------------------------------------------------------
  ;------------------- Reading Inputs -----------------------
  ;----------------------------------------------------------
  defn read-inputs (inputs:Seqable<Symbol|String|PackageSource|IPackage>) -> Vector<IPackage|Pkg|Bindings> :
    ;Read in a package from the given file, containing the given expected package.
    defn read-file (return: IPackage|Pkg|Bindings -> ?, filename:String, expected-package:Symbol|False) :
      switch suffix?{filename, _} :
        ".stanza" :
          val ps = read-ipackages(filename)
          match(expected-package:Symbol) :
            ensure-contains-package!(ps, filename, expected-package)
          do(return, ps)
        ".pkg" :
          return(load-package(filename, expected-package, false))
        ".fpkg" :
          return(load-package(filename, expected-package, true))
        ".vmbindings" :
          return(read-bindings(filename))
        else :
          throw(InvalidExtensionError(filename))

    ;Read all objects to the objects vector.
    val objects = Vector<IPackage|Pkg|Bindings>()
    for input in inputs do :
      ;Read the pkg-location
      defn pkg-location (pkg:IPackage|Pkg, filename:String) :
        match(pkg) :
          (pkg:IPackage) : PkgLocation(name(pkg), filename, false, false)
          (pkg:Pkg) : PkgLocation(name(pkg), false, filename, true)
      
      match(input) :
        (input:String) :
          within pkg = read-file(input, false) :
            add(objects, pkg)
            match(pkg:IPackage|Pkg) :
              record-timestamp $ pkg-location(pkg, input)
        (input:PackageSource) :
          within pkg = read-file(filename(input), name(input)) :
            add(objects, pkg)
            match(pkg:IPackage|Pkg) :
              record-timestamp $ pkg-location(pkg, filename(input))
        (input:Symbol) :
          val loc = package-location!(input)
          within pkg = read-file(filename(loc), input) :
            add(objects, pkg)
            record-timestamp $ loc
        (input:IPackage) :
          add(objects, input)
            
    ;Return objects
    objects  

  defn read-ipackages (filename:String) -> Tuple<IPackage> :
    val forms = read-file(filename)    
    val expanded = parse-syntax[core / #exp!](List(forms))
    val core-imports = [IImport(`core), IImport(`collections)]
    to-ipackages(expanded, core-imports)

  ;----------------------------------------------------------
  ;-------------- Initialize Package Table ------------------
  ;----------------------------------------------------------
  defn load-package-table (objects:Collection<IPackage|Pkg|Bindings>) :
    ensure-no-duplicate-packages!(filter-by<IPackage|Pkg>(objects))
    ensure-not-already-loaded!(filter-by<IPackage|Pkg>(objects))
    val objects* = map-ipackages(rename-il!, objects)
    do(add{package-table, _}, filter-by<IPackage|Pkg>(objects*))

  defn map-ipackages (f:Tuple<IPackage> -> Tuple<IPackage>, objs:Collection<IPackage|Pkg|Bindings>) :
    val ipackages = to-tuple(filter-by<IPackage>(objs))
    val ipackages* = f(ipackages)
    fatal("Invalid parallel map.") when length(ipackages) != length(ipackages*)
    val ipackage-seq = to-seq(ipackages*)
    to-tuple $ for obj in objs seq :
      match(obj) :
        (obj:IPackage) : next(ipackage-seq)
        (obj) : obj

  ;----------------------------------------------------------
  ;--------------- Resolving Package ------------------------
  ;----------------------------------------------------------

  defn package-exports (pkg:Pkg) :
    package-exports(packageio(pkg))
  defn package-exports (io:PackageIO) :
    set?(package-exports-table, package(io), fn () :
      val pexs = to-package-exports(io)
      defn rename-id (e:Export) : sub-n(e, fresh-id())
      sub-exports(pexs, map(rename-id, exports(pexs))))

  defn to-resolver-input (pkg:IPackage) : pkg
  defn to-resolver-input (pkg:False) : pkg
  defn to-resolver-input (pkg:Pkg) : package-exports(pkg)

  defn resolver-environment () :
    defn imported-package (package:Symbol) :
      match(environment-package?(sys, package)) :
        (io:PackageIO) :
          package-exports(io)
        (f:False) :
          ;If there is no entry in the package table, then locate the package
          ;and load it.
          if not key?(package-table, package) :
            match(package-location(package)) :
              (l:PkgLocation) : load-package-table $ read-inputs $ [PackageSource(package, filename(l))]
              (f:False) : set-missing(package-table, package)
          to-resolver-input(package-table[package])
    ;Make environment
    new stz/resolver/Env :
      defmethod imported-package (this, package:Symbol) :
        imported-package(package)
      defmethod conditional-dependencies (this, packages:Seqable<Symbol>) :
        conditional-dependencies(sys, packages)
      defmethod package-priority (this) :
        package-priority(sys)

  defn resolve-packages () -> ResolverResult :
    val packages = to-tuple $
                   seq(to-resolver-input, package-table)                       
    resolve-il!(packages, resolver-environment())

  ;----------------------------------------------------------
  ;------------------- Compile to EL ------------------------
  ;----------------------------------------------------------
  defn compile-to-el (resolved:Tuple<IPackage>) -> Tuple<EPackage> :
    val env = new stz/type/Env :
      defmethod stz/type/exports (this, package:Symbol) :
        match(environment-package?(sys, package)) :
          (io:PackageIO) : package-exports(io)
          (f:False) : package-exports-table[package]        
    val typed = type-program!(resolved, env)
    to-el(typed, transient?(sys))

  ;----------------------------------------------------------
  ;------------------- Order Packages -----------------------
  ;----------------------------------------------------------
  defn order-packages (pkgs:Seqable<EPackage|Pkg>, order:Seqable<Symbol>) :
    val pkg-table = to-hashtable(name, pkgs)
    to-tuple $ for name in order seq? :
      if key?(pkg-table, name) : One(pkg-table[name])
      else : None()

  ;----------------------------------------------------------
  ;------------------ Load into Environment -----------------
  ;----------------------------------------------------------
  ;Returns false is successful.
  ;Otherwise, returns a collection of PackageSources to use to
  ;try on the next iteration.
  
  defn load-into-denv! (pkgs:Seqable<EPackage|Pkg>) -> Tuple<PackageSource>|False :
    val packageios = to-tuple $ seq(packageio, pkgs)
    val result = load-into-denv(sys, packageios)
    match(result:LoadErrors) :
      val package-sources = Vector<PackageSource>()
      val unrecoverable-errors = Vector<LoadError>()
      for e in errors(result) do :
        match(source(e)) :
          (src:LoadedPackage) :
            match(source-file?(package(src))) :
              (file:String) : add(package-sources, PackageSource(package(src), file))
              (file:False) : add(unrecoverable-errors, e)
          (src:LiveObject) :
            add(unrecoverable-errors, e)
      if not empty?(unrecoverable-errors) :
        throw(LoadErrors(to-tuple(unrecoverable-errors)))
      ;Return package sources
      to-tuple(package-sources)

  ;----------------------------------------------------------
  ;------------------ Error Handling ------------------------
  ;----------------------------------------------------------
  defn package-location! (name:Symbol) :
    val loc = package-location(name)
    if loc is False :
      throw(CannotLocatePackage(name))
    loc as PkgLocation
    
  defn rename-il! (ps:Tuple<IPackage>) -> Tuple<IPackage> :
    match(rename-il(ps)) :
      (e:RenameErrors) : throw(e)
      (ps:Tuple<IPackage>) : ps

  defn resolve-il! (ps:Tuple<IPackage|PackageExports>, env:stz/resolver/Env) :
    match(resolve-il(ps, env)) :
      (e:ResolveErrors) : throw(e)
      (r:ResolverResult) : r

  defn type-program! (ipackages:Tuple<IPackage>, env:stz/type/Env) :
    match(type-program(ipackages,env)) :
      (p:TProg) : p
      (e:TypeErrors) : throw(e)

  defn ensure-no-duplicate-packages! (ps:Seqable<IPackage|Pkg>) :
    val added-set = HashSet<Symbol>()
    val duplicates = unique $ for name in seq(name,ps) filter :
      not add(added-set, name)
    if not empty?(duplicates) :
      throw(DuplicatePackages(to-tuple(duplicates)))

  defn ensure-not-already-loaded! (ps:Seqable<IPackage|Pkg>) :
    defn rank (p:IPackage|Pkg|False) :
      match(p) :
        (p:False) : 0
        (p:Pkg) : 1
        (p:IPackage) : 2
    for p in ps do :
      if key?(package-table, name(p)) :
        val old-p = package-table[name(p)]
        if rank(old-p) >= rank(p) :
          throw(PackageAlreadyLoaded(name(p)))    

  defn ensure-contains-package! (ps:Seqable<IPackage>, filename:String, expected-package:Symbol) :
    val exists? = any?({name(_) == expected-package}, ps)
    if not exists? :
      throw(MissingPackageInFile(filename, expected-package))

  ;----------------------------------------------------------
  ;-------------------- Launch! -----------------------------
  ;----------------------------------------------------------
  main()

;============================================================
;==================== Package Table =========================
;============================================================

deftype PackageTable <: Collection<IPackage|Pkg>
defmulti add (p:PackageTable, p:IPackage|Pkg) -> False
defmulti set-missing (p:PackageTable, name:Symbol) -> False
defmulti get (p:PackageTable, name:Symbol) -> IPackage|Pkg|False
defmulti key? (p:PackageTable, name:Symbol) -> True|False
defmulti pkgs (p:PackageTable) -> Seqable<Pkg>

defn PackageTable () :
  val table = HashTable<Symbol,Int|False>()
  val objects = Vector<IPackage|Pkg>()
  defn index (name:Symbol) :
    match(get?(table,name)) :
      (i:Int) : i
      (f:False) :
        val i = length(objects)
        table[name] = i
        i
  new PackageTable :
    defmethod add (this, p:IPackage|Pkg) :
      objects[index(name(p))] = p
    defmethod set-missing (this, name:Symbol) :
      table[name] = false
    defmethod get (this, name:Symbol) :
      val i = table[name]
      match(i:Int) : objects[i]
    defmethod key? (this, name:Symbol) :
      key?(table, name)
    defmethod to-seq (this) :
      to-seq(objects)
    defmethod pkgs (this) :
      filter-by<Pkg>(objects)

;============================================================
;================ Utility Datastructures ====================
;============================================================

defstruct PackageSource :
  name: Symbol
  filename: String

;============================================================
;===================== Errors ===============================
;============================================================

defn InvalidExtensionError (filename:String) :
  new Exception :
    defmethod print (o:OutputStream, this) :
      print(o, "File %_ does not have a valid Stanza file extension." % [filename])

defn CannotLocatePackage (name:Symbol) :
  new Exception :
    defmethod print (o:OutputStream, this) :
      print(o, "Cannot locate .pkg file for package %~." % [name])

defn DuplicatePackages (names:Tuple<Symbol>) :
  new Exception :
    defmethod print (o:OutputStream, this) :
      print(o, "The following packages, %,, has been loaded more than once." % [names])

defn MissingPackageInFile (filename:String, package-name:Symbol) :
  new Exception :
    defmethod print (o:OutputStream, this) :
      print(o, "The file %~ was expected to contain the package %~, but does not." % [filename, package-name])

defn PackageAlreadyLoaded (package-name:Symbol) :
  new Exception :
    defmethod print (o:OutputStream, this) :
      print(o, "The package %~ has already been loaded." % [package-name])