defpackage stz/kform-to-vm :
  import core
  import collections
  import stz/kl-ir
  import stz/pl-ir
  import stz/vm-ir
  import stz/khier
  
;============================================================
;==================== Driver ================================
;============================================================

public defn to-vmprog (kpkg:KPackage) -> VMProg :
  defn compile-te (te:KTExp) :
    for te in exps(kpkg) do :
      match(te) :
        (te:KDef) : println("Not yet implemented")
        (te:KDefVar) : println("Not yet implemented")
        (te:KDefn) : compile-fn(te)
        (te:KDefmulti) : println("Not yet implemented")
        (te:KDefmethod) : println("Not yet implemented")
        (te:KDefType) : println("Not yet implemented")
        (te:KDefStruct) : println("Not yet implemented")
        (te:KExternFn) : println("Not yet implemented")
        (te:KExtern) : println("Not yet implemented")
        (te:KInit) : println("Not yet implemented")
        (te:KDefConst) : println("Not yet implemented")
        (te:KDefObject) : println("Not yet implemented")
        (te:KDefClosure) : println("Not yet implemented")
        (te:KDefTypeObject) : println("Not yet implemented")

  defn compile-fn (te:KDefn) :
    val e = value(te) as KFn
    false
    ;Given:
    ;  tail?(e) : Whether the function is tail recursive
    ;  a1(e) : The types of the arguments
    ;  a2(e) : The return type
    ;  args(e) : The identifiers of the arguments
    ;  body(e) : The body expression
      
  do(compile-te, exps(kpkg))      

;============================================================
;================ Within Function Compilation ===============
;============================================================

defn compile-function (e:KFn) -> VMFunc :
  ;Given:
  ;  tail?(e) : Whether the function is tail recursive
  ;  a1(e) : The types of the arguments
  ;  a2(e) : The return type
  ;  args(e) : The identifiers of the arguments
  ;  body(e) : The body expression

  ;Table for storing defined quantities
  val immtable = IntTable<Tuple<Local>>()
  val typetable = IntTable<Tuple<VMType>>()

  ;Buffer for keeping instructions
  val buffer = Vector<VMIns>()
  defn emit (i:VMIns) : add(buffer, i)

  defn compile (e:KExp) :
    match(e) :
      (e:KLet) : println("Not yet implemented")
      (e:KLetVar) : println("Not yet implemented")
      (e:KLetRec) : println("Not yet implemented")
      (e:KVar) :
        if global?(dec-table, n(e)) :
          val t = var-type(dec-table, n(e))
          new CStore :
            defmethod types (this) : vm-types(dec-table, t)
            defmethod store (this, xs:Tuple<Local>) :
              val m = global-mem(dec-table, n(e))
              for (x in xs, o in field-offsets(dec-table,t)) do :
                emit(LoadIns(x, m, o))
        else if mutables[n(e)] :
          ;TODO: Not necessary if we pull out
          ;mutated variables from expressions first.
          new CImms :
            defmethod types (this) : typetable[n(e)]
            defmethod imms (this) :
              val locals = map(make-def, typetable[n(e)])
              for (x in locals, y in immtable[n(e)]) do :
                emit(SetIns(x, y))
              locals
        else :
          new CImms :
            defmethod types (this) : typetable[n(e)]
            defmethod imms (this) : immtable[n(e)]

        println("Not yet implemented")
      (e:KSet) : println("Not yet implemented")
      (e:KTuple) : println("Not yet implemented")
      (e:KVoidTuple) : println("Not yet implemented")
      (e:KTupleGet) : println("Not yet implemented")
      (e:KTupleSet) : println("Not yet implemented")
      (e:KEnsureLength) : println("Not yet implemented")
      (e:KObject) : println("Not yet implemented")
      (e:KArray) : println("Not yet implemented")
      (e:KStruct) : println("Not yet implemented")
      (e:KPtr) : println("Not yet implemented")
      (e:KRead): println("Not yet implemented")
      (e:KDo) : println("Not yet implemented")
      (e:KDoC) : println("Not yet implemented")
      (e:KLSLiteral) : println("Not yet implemented")
      (e:KLiteral) : println("Not yet implemented")
      (e:KMix) : println("Not yet implemented")
      (e:KCurry) : println("Not yet implemented")
      (e:KInterpret) : println("Not yet implemented")
      (e:KCheck) : println("Not yet implemented")
      (e:KConv) : println("Not yet implemented")
      (e:KAndExp) : println("Not yet implemented")
      (e:KOrExp) : println("Not yet implemented")
      (e:KPrim) : println("Not yet implemented")
      (e:KSizeof) : println("Not yet implemented")
      (e:KTagof) : println("Not yet implemented")
      (e:KMatch) : println("Not yet implemented")
      (e:KLabels) : println("Not yet implemented")
      (e:KBlock) : println("Not yet implemented")
      (e:KIf) : println("Not yet implemented")
      (e:KSeq) : println("Not yet implemented")
      (e:KGoto) : println("Not yet implemented")
      (e:KReturn) : println("Not yet implemented")
      (e:KDispatch) : println("Not yet implemented")
      (e:KEnsureSet) : println("Not yet implemented")
      (e:KNewObject) : println("Not yet implemented")
      (e:KObjectGet) : println("Not yet implemented")
      (e:KObjectTGet) : println("Not yet implemented")
      (e:KLetType) : println("Not yet implemented")
      (e:KBox) : println("Not yet implemented")
      (e:KBoxGet) : println("Not yet implemented")
      (e:KBoxSet) : println("Not yet implemented")
      (e:KClosure) : println("Not yet implemented")
      (e:KTagPrim) : println("Not yet implemented")
      (e:KDetagPrim) : println("Not yet implemented")
  

;============================================================
;================= Compiled Results =========================
;============================================================

;Types of results
deftype CResult

;Used to annotate whether a result has side-effects.
deftype HasSideEffects

;There is no result. The program never executes past that expression.
deftype CVoid <: CResult
defmulti gen-ins (c:CVoid&HasSideEffects) -> False

;Result is represented as a bunch of immediates, to be handled by the context.
deftype CImms <: CResult
defmulti types (c:CImms) -> Tuple<VMType>
defmulti imms (c:CImms) -> Tuple<VMImm>

;Result will generate instructions to store values into destination variables.
;Destination variables will be empty, if result is not used.
deftype CStore <: CResult
defmulti types (c:CStore) -> Tuple<VMType>
defmulti store (c:CStore, xs:Tuple<Local>) -> False

;============================================================
;================= Compiled Contexts ========================
;============================================================

;Types of Contexts
deftype Context

;This context ignores the result
deftype IgnoreContext <: Context

;This context will generate instructions to handle results.
deftype AcceptContext <: Context
defmulti accept (c:AcceptContext, imms:Tuple<VMImm>) -> False

;This context is represented as a set of locals, for the result to be stored into.
deftype TargetContext <: Context
defmulti locals (c:TargetContext) -> Tuple<Local>

;============================================================
;===================== Contexts/Results =====================
;============================================================
;<COMMENT>
       |     SideEffects              No SideEffects
       | CVoid  CImms  CStore      CVoid  CImms  CStore
Ignore |
Accept |
Target |
;<COMMENT>