defpackage stz/kform-to-vm :
  import core
  import collections
  import stz/kl-ir
  import stz/pl-ir
  import stz/vm-ir
  import stz/khier
  import stz/dec-table
  import stz/built-ins with :
    prefix => VM-
  import stz/ids    

;============================================================
;==================== Driver ================================
;============================================================

public defn to-vmprog (dec-table:DecTable, kpkg:KPackage) -> VMProg :
  ;Define accumulators
  val globals = Vector<VMGlobal>()
  val consts = Vector<VMConst>()
  val classes = Vector<VMClass>()
  val funcs = Vector<VMFunction>()
  val externs = Vector<VMExtern>()

  ;Define tables
  val global-defs = GlobalDefs()
  val literal-defs = LiteralDefs()
  val initializers = Initializers()

  ;Compiling a top-level expression
  defn compile-te (te:KTExp) :
    println("Compiling top level expression: %_" % [te])
    match(te) :
      (te:KDef) :
        add(globals, VMGlobal(n(te), size, position, roots)) where :
          val size = size(dec-table, type(te))
          val roots = roots(vm-types(dec-table, type(te)), field-offsets(dec-table, type(te)))
          val position = current-offset(global-defs, size)
        init-global(initializers, n(te), type(te), value(te))
      (te:KDefVar) : fatal("Not yet implemented")
      (te:KDefn) :
        val func = match(value(te)) :
          (value:KMultifn) : fatal("Not yet implemented")
          (value:KFn) : value
        within c = compile-function(n(te), func, dec-table, literal-defs) :
          val targ-locals = for a in targs(func) map :
            val x = make-def(c, VMRef())
            set-imms-types(c, a, [x], [VMRef()])
            x
          val arg-locals = to-list $
            for (a in args(func), t in a1(func)) seq-cat :
              val ts = to-tuple(vm-types(dec-table, t))
              val xs = make-defs(c, ts)
              set-imms-types(c, a, xs, ts)
              xs            
          to-tuple(qquote(false, false, ~@ targ-locals, ~@ arg-locals))
      (te:KDefmulti) : fatal("Not yet implemented")
      (te:KDefmethod) : fatal("Not yet implemented")
      (te:KDefType) :
        add(classes, VMAbstractClass(id, parent-ids)) where :
          val id = to-vm-id(n(te))
          val parent-ids = vm-type-ids(parent(te))
      (te:KDefStruct) :
        match(rfield(te)) :
          (rfield:KStructField) :
            ;Array class
            add(classes, VMArrayClass(id, parent-ids, base-size, item-size, base-roots, item-roots)) where :
              val id = to-vm-id(n(te))
              val parent-ids = vm-type-ids(parent(te))
              val base-size = size(dec-table, n(te))                
              val item-size = rest-size(dec-table, n(te))
              val base-roots = roots(vm-types(dec-table, n(te)), field-offsets(dec-table, n(te)))
              val item-roots = roots(vm-types(dec-table, type(rfield)), field-offsets(dec-table, type(rfield)))
          (rfield:False) :
            ;Leaf class
            add(classes, VMLeafClass(id, parent-ids, size, roots)) where :
              val id = to-vm-id(n(te))
              val parent-ids = vm-type-ids(parent(te))
              val size = size(dec-table, n(te))
              val roots = roots(vm-types(dec-table, n(te)), field-offsets(dec-table, n(te)))
      (te:KExternFn) : fatal("Not yet implemented")
      (te:KExtern) :
        add(externs, VMExtern(n(te), lbl(te)))          
      (te:KInit) :
        add(initializers, exp(te))
      (te:KDefConst) : fatal("Not yet implemented")
      (te:KDefObject) : fatal("Not yet implemented")
      (te:KDefClosure) : fatal("Not yet implemented")
      (te:KDefTypeObject) : fatal("Not yet implemented")

  println("===== Input =====")
  within indented() :
    println(kpkg)

  println("===== Compiling =====")
  within indented() :
    do(compile-te, exps(kpkg))
    add(funcs, compile-init(initializers, dec-table, literal-defs))

  VMProg(to-tuple(globals), defs(literal-defs), to-tuple(consts),
         to-tuple(classes), to-tuple(funcs), to-tuple(externs))

;============================================================
;================== Global Compilation ======================
;============================================================

deftype GlobalDefs
defmulti current-offset (g:GlobalDefs) -> Int
defmulti increment-offset (g:GlobalDefs, size:Int) -> False

defn current-offset (g:GlobalDefs, size:Int) :
  val p = current-offset(g)
  increment-offset(g, size)
  p

defn GlobalDefs () :
  var offset:Int = 0
  new GlobalDefs :
    defmethod current-offset (this) : offset
    defmethod increment-offset (this, size:Int) : offset = (offset + size + 7) & -8

;============================================================
;=================== Literals Compilation ===================
;============================================================

deftype LiteralDefs
defmulti def-data (defs:LiteralDefs, data:ByteArray) -> DataId
defmulti defs (defs:LiteralDefs) -> Tuple<VMData>

defn LiteralDefs () :
  val idcounter = to-seq(0 to false)
  val defs = Vector<VMData>()
  new LiteralDefs :
    defmethod def-data (this, data:ByteArray) :
      val id = next(idcounter)
      add(defs, VMData(id, data))
      DataId(id)
    defmethod defs (this) :
      to-tuple(defs)

;============================================================
;================= Function Compilation =====================
;============================================================
defn compile-function (gen-args:Compiler -> Tuple<Local|False>, id:Int, f:KFn,
                       dec-table:DecTable,
                       literal-defs:LiteralDefs) :
  val compiler = Compiler()
  val args = gen-args(compiler)
  val return-ctxt = TailContext() when tail?(f)
               else ReturnContext()
  compile-exp(compiler, return-ctxt, body(f), dec-table, literal-defs)
  VMFunc(id, args, defs(compiler), instructions(compiler))

;============================================================
;=============== Initializer Compilation ====================
;============================================================
deftype Initializers
defmulti init-global (i:Initializers, n:Int, type:KType, e:KExp) -> False
defmulti add (i:Initializers, e:KExp) -> False
defmulti inits (i:Initializers) -> KExp
    
defn Initializers () :
  val inits = Vector<KExp>()
  new Initializers :
    defmethod init-global (this, n:Int, type:KType, e:KExp) :
      add(inits, KSet(KVarLoc(n), type, e))
    defmethod add (this, e:KExp) :
      add(inits, e)
    defmethod inits (this) :
      if empty?(inits) : KLSLiteral(false)
      else : KSeq(inits)

defn compile-init (i:Initializers, dec-table:DecTable, literal-defs:LiteralDefs) :
  val compiler = Compiler()
  compile-exp(compiler, TargetContext([]), inits(i), dec-table, literal-defs)
  emit(compiler, ReturnIns([]))
  VMFunc(0, [], defs(compiler), instructions(compiler))

;============================================================
;================ Expression Compilation ====================
;============================================================
defn compile-exp (compiler:Compiler, return-ctxt:Context, e:KExp, dec-table:DecTable, literal-defs:LiteralDefs) :
  ;Function address
  defn function-address (n:Int) :
    val lbl = extern-label(dec-table, n)
    match(lbl:Symbol) : ExternId(n)
    else : CodeId(n)

  ;Track mutables
  val mutables = IntSet()

  ;Compiling a location
  defn compile (e:KLoc) -> CLoc :
    match(e) :
      (e:KVarLoc) :
        if global?(dec-table, n(e)) :
          val base = new CImms :
            defmethod types (c, this) : [VMLong()]
            defmethod imms (c, this) :
              val id = 
                if extern-label(dec-table, n(e)) is False : GlobalId(n(e))
                else : ExternId(n(e))
              [id]
          PtrLoc(base, 0)
        else :
          VarLoc(n(e), 0)
      ;(e:KDeref) :
      ;  PtrLoc(cexp(exp(e)), 8 - REF-TAG-BITS)
      ;(e:KDeptr) :
      ;  PtrLoc(cexp(exp(e)), 0)
      ;(e:KField) :
      ;  match(cloc(exp(e))) :
      ;    (l:PtrLoc) :
      ;      PtrLoc(
      ;        base(l),
      ;        offset(l) + field-offset(dec-table, n(e)))
      ;    (l:ExpLoc) :
      ;      ExpLoc(
      ;        base(l),
      ;        index(l) + field-index(dec-table, n(e)))
      ;    (l:VarLoc) :
      ;      VarLoc(
      ;        n(l),
      ;        index(l) + field-index(dec-table, n(e)))
      ;(e:KSlot) :
      ;  ;Compute ptr and offset
      ;  val [ptr, ptr-offset] = match(cloc(exp(e))) :
      ;    (l:PtrLoc) : [base(l), offset(l)]
      ;    (l:ExpLoc) : [base(l), 0]
      ;  ;Compute base cexp
      ;  val base = new CExp :
      ;    defmethod types (this) :
      ;      List(TGLongT())
      ;    defmethod set (ns:List<Int>, this) :
      ;      ;ns = base
      ;      ;offset = index
      ;      ;offset = offset * size
      ;      ;n = n + offset
      ;      set(ns, ptr)
      ;      val offset = make-var(TGLongT())
      ;      set(n(offset), cexp(index(e)))
      ;      val size = size(dec-table, type(e))
      ;      emit(TGBinOp(offset, TGMulOp(), offset, TGLong(to-long(size)))) when size != 1
      ;      val x = TGVar(head(ns))
      ;      emit(TGBinOp(x, TGAddOp(), x, offset))
      ;    defmethod ignore (this) :
      ;      ignore(ptr)
      ;  ;Return location
      ;  PtrLoc(base, ptr-offset)
      ;(e:KValue) :
      ;  ExpLoc(cexp(exp(e)), 0)    
      (e) :
        fatal("Not yet implemented")

  ;Compiling an expression
  defn compile (e:KExp) -> CResult :
    println("Compiling expression %_" % [e])
    match(e) :
      (e:KLet) :
        val v = compile(value(e))
        val body = compile(body(e))
        new CResult :
          defmethod types (c, this) : types(c,body)
          defmethod gen-ins (c, ctxt, this) :
            set-imms-types(c, n(e), imms(c,v), types(c,v))
            gen-ins(c, ctxt, body)
      (e:KInterpret) :
        new CStore :
          defmethod types (c, this) : [to-vm-type(type(e))]
          defmethod store (c, this, xs:Tuple<Local>) :
            val y = compile(exp(e))
            emit(c, Op1Ins(xs[0], InterpretOp(), imm(c,y)))
      (e:KVar) :
        if global?(dec-table, n(e)) :
          val t = var-type(dec-table, n(e))
          new CStore :
            defmethod types (c, this) : to-tuple(vm-types(dec-table, t))
            defmethod store (c, this, xs:Tuple<Local>) :
              for (x in xs, o in field-offsets(dec-table, t)) do :
                emit(c, LoadIns(x, GlobalId(n(e)), NumConst(o)))
        else if mutables[n(e)] :
          ;TODO: Not necessary if we pull out
          ;mutated variables from expressions first.
          new CImms :
            defmethod types (c, this) : types(c, n(e))
            defmethod imms (c, this) :
              val ts = types(c, n(e))
              val xs = make-defs(c, ts)
              set-imms-types(c, n(e), xs, ts)
              for (x in xs, y in imms(c, n(e))) do :
                emit(c, SetIns(x, y))
              xs
        else :
          new CImms :
            defmethod types (c, this) : types(c, n(e))
            defmethod imms (c, this) : imms(c, n(e))
      (e:KDo) :
        ;Result representing a call to known code
        defn ccall-result (get-args: Compiler -> [Int, Tuple<VMImm>, VMImm], closure?:True|False) :
          new CCall :
            defmethod types (c, this) :
              to-tuple(vm-types(dec-table, type(e)))
            defmethod closure? (this) :
              closure?
            defmethod call-args (c, this) :
              val [arity, args, f] = get-args(c)
              val closure = if closure? : f
                            else : Marker(VM-FALSE-TYPE-ID)              
              val arity-imm = NumConst(to-long(arity))
              val arg-imms = to-tuple $ qquote(~ closure, ~ arity-imm, ~@ args)
              [arg-imms, f]
        ;Cases
        defn call-pointer (p:KExp, args:List<KExp>) :
          within c = ccall-result(false) :
            val args* = to-tuple(seq-cat(imms{c, compile(_)}, args))
            val func = imm(c, compile(p))
            [length(args), args*, func]
        defn call-closure (clo:KExp, targs:List<KType>, args:List<KExp>) :
          within c = ccall-result(true) :
            fatal("Not yet implemented") when not empty?(targs)
            val args* = to-tuple $ seq-cat(imms{c, compile(_)}, args)
            ;val args* = to-tuple $ cat(
            ;  seq-cat(imms{c, compile(_)}, targs)
            ;  seq-cat(imms{c, compile(_)}, args))
            val closure* = imm(c, compile(clo))
            [length(args), args*, closure*]
        defn call-code (n:Int, targs:List<KType>, args:List<KExp>) :
          within c = ccall-result(false) :
            fatal("Not yet implemented") when not empty?(targs)
            val args* = to-tuple $ seq-cat(imms{c, compile(_)}, args)
            ;val args* = to-tuple $ cat(
            ;  seq-cat(imms{c, compile(_)}, targs)
            ;  seq-cat(imms{c, compile(_)}, args))
            [length(args), args*, function-address(n)]
        ;Categorize
        match(func(e)) :
          (f:KVar|KCurry) :
            val [f*, targs] = match(f) :
              (f:KVar) : [f, List()]
              (f:KCurry) : [KVar(n(f)), targs(f)]
            if function?(dec-table, n(f)) : call-code(n(f), targs, args(e))
            else : call-closure(f*, targs, args(e))
          (f:KRead) :
            match(loc(f)) :
              (l:KDeptr) : call-pointer(exp(l), args(e))
              (l:KDeref) : call-closure(exp(l), List(), args(e))
          (f:KExp) :
            call-closure(f, List(), args(e))
      (e:KDoC) :
        new CStore :
          defmethod types (c, this) :
            to-tuple(vm-types(dec-table, type(e)))
          defmethod store (c, this, xs:Tuple<Local>) :
            val args* = to-tuple $ cat(
              seq-cat(imms{c, compile(_)}, args(e))
              seq-cat(imms{c, compile(_)}, varargs(e)))
            val f* = match(func(e)) :
              (f:KRead) :
                val l = loc(f) as KDeptr
                imm(c, compile(exp(l)))
              (f:KVar) :
                function-address(n(f))
            emit(c, CallCIns(xs, f*, args*))      
      (e:KReturn) :
        val v = compile(exp(e))
        new CResult :
          defmethod types (c, this) : []
          defmethod gen-ins (c, ctxt, this) :
            gen-ins(c, return-ctxt, v)
      (e:KLSLiteral) :
        match(value(e)) :
          (v:Byte|Int|Long|Float|Double|Char|True|False) :
            val t = prim-vm-type(v)
            val v* = match(v) :
              (v:Char) : NumConst(to-byte(v))
              (v:True) : Marker(VM-TRUE-TYPE-ID)
              (v:False) : Marker(VM-FALSE-TYPE-ID)
              (v:Byte|Int|Long|Float|Double) : NumConst(v)
            new CImms :
              defmethod types (c, this) : [t]
              defmethod imms (c, this) : [v*]
          (v:String) :
            val id = def-data(literal-defs, string-bytes(v))
            new CImms :
              defmethod types (c, this) : [VMLong()]
              defmethod imms (c, this) : [id]
      (e:KObject) :
        if empty?(args(e)) :
          new CImms :
            defmethod types (c, this) : [VMLong()]
            defmethod imms (c, this) : [Marker(to-vm-id(n(e)))]
        else :
          new CStore :
            defmethod types (c, this) : [VMRef()]
            defmethod store (c, this, xs:Tuple<Local>) :
              val size = size(dec-table, n(e))
              val offsets = field-offsets(dec-table, n(e))
              ;Evaluate arguments
              val args* = to-list(seq-cat(imms{c, compile(_)}, args(e)))
              ;Allocate object
              val x = xs[0]
              val typeid = to-vm-id(n(e))
              emit(c, AllocIns(xs, [typeid], [NumConst(size)]))
              ;Store fields
              for (a in args*, o in offsets) do :
                emit(c, StoreIns(x, NumConst(o), a))          
      (e:KArray) :
        new CStore :
          defmethod types (c, this) : [VMRef()]
          defmethod store (c, this, xs:Tuple<Local>) :
            val base-size = size(dec-table, n(e))
            val item-size = rest-size(dec-table, n(e))
            val offsets = field+rest-offsets(dec-table, n(e))
            ;Evaluate arguments
            val args* = to-list(seq-cat(imms{c, compile(_)}, args(e)))
            val len-arg = head(args*)
            ;Compute length
            val len = make-def(c, VMLong())
            emit(c, Op2Ins(len, MulOp(), len-arg, NumConst(to-long(item-size))))
            if item-size % 8 != 0 :
              emit(c, Op2Ins(len, AddOp(), len, NumConst(7L)))
              emit(c, Op2Ins(len, AndOp(), len, NumConst(-8L)))
            ;Allocate array
            val x = xs[0]
            val typeid = to-vm-id(n(e))
            emit(c, AllocIns(xs, [typeid], [len]))
            ;Store fields
            for (a in args*, o in offsets) do :
              emit(c, StoreIns(x, NumConst(o), a))
      (e:KSeq) :
        val a* = compile(a(e))
        val b* = compile(b(e))
        new CResult :
          defmethod types (c,this) : types(c,b*)
          defmethod gen-ins (c, ctxt, this) :
            gen-ins(c, TargetContext([]), a*)
            gen-ins(c, ctxt, b*)
      (e:KSet) :      
        new CImms :
          defmethod types (c, this) :
            [VMRef()]
          defmethod imms (c, this) :
            match(compile(loc(e))) :
              (l:PtrLoc) :
                val p = imm(c, base(l))
                val vs = imms(c, compile(value(e)))
                val os = field-offsets(dec-table, type(e))
                for (v in vs, o in os) do :
                  emit(c, StoreIns(p, v, NumConst(o + offset(l))))
              (l:VarLoc) :
                val base = imms(c, n(l)) as Tuple<Local>
                val len = length(dec-table, type(e))
                val xs = base[index(l) to index(l) + len]
                gen-ins(c, TargetContext(xs), compile(value(e)))
            [Marker(VM-FALSE-TYPE-ID)]
      (e:KConv) :
        val t = to-vm-type(type(e))
        new CStore :
          defmethod types (c, this) : [t]
          defmethod store (c, this, xs:Tuple<Local>) :
            val y = compile(exp(e))
            val x = xs[0]
            emit(c, Op1Ins(x, ConvOp(), imm(c,y)))
      (e) :
        fatal("Not yet implemented")

  ;Driver
  gen-ins(compiler, return-ctxt, compile(e))

;============================================================
;====================== Types ===============================
;============================================================

defn to-vm-type (t:KType) :
  match(t) :
    (t:KByteT) : VMByte()
    (t:KIntT) : VMInt()
    (t:KLongT) : VMLong()
    (t:KFloatT) : VMFloat()
    (t:KDoubleT) : VMDouble()
    (t:KPtrT) : VMPointer()
    (t) : VMRef()

defn prim-vm-type (v) :
  match(v) :
    (v:Char) : VMByte()
    (v:Byte) : VMByte()
    (v:Int) : VMInt()
    (v:Long) : VMLong()
    (v:Float) : VMFloat()
    (v:Double) : VMDouble()
    (v:True) : VMRef()
    (v:False) : VMRef()
    
;============================================================
;=================== Compiler Tools =========================
;============================================================

;Definition of a compiler
deftype Compiler
defmulti emit (c:Compiler, i:VMIns) -> False
defmulti types (c:Compiler, n:Int) -> Tuple<VMType>
defmulti imms (c:Compiler, n:Int) -> Tuple<VMImm>
defmulti set-types (c:Compiler, n:Int, ts:Tuple<VMType>) -> False
defmulti set-imms (c:Compiler, n:Int, imms:Tuple<VMImm>) -> False
defmulti make-def (c:Compiler, t:VMType) -> Local
defmulti defs (c:Compiler) -> Tuple<VMDef>
defmulti instructions (c:Compiler) -> Tuple<VMIns>

defn set-imms-types (c:Compiler, n:Int, imms:Tuple<VMImm>, ts:Tuple<VMType>) :
  set-imms(c, n, imms)
  set-types(c, n, ts)

defn make-defs (c:Compiler, ts:Tuple<VMType>) :
  map(make-def{c, _}, ts)

defn Compiler () :
  val defs = Vector<VMDef>()
  val immtable = IntTable<Tuple<VMImm>>()
  val typetable = IntTable<Tuple<VMType>>()
  val ins = Vector<VMIns>()
  new Compiler :
    defmethod emit (this, i:VMIns) : add(ins, i)
    defmethod types (this, n:Int) : typetable[n]
    defmethod imms (this, n:Int) : immtable[n]
    defmethod set-types (this, n:Int, ts:Tuple<VMType>) : typetable[n] = ts
    defmethod set-imms (this, n:Int, xs:Tuple<VMImm>) : immtable[n] = xs
    defmethod make-def (this, t:VMType) :
      val i = length(defs)
      add(defs, VMDef(i, t, 0))
      Local(i)
    defmethod defs (this) : to-tuple(defs)
    defmethod instructions (this) : to-tuple(ins)

;Representation of a compiled result
deftype CResult
deftype Context
defmulti types (compiler:Compiler, r:CResult) -> Tuple<VMType>
defmulti gen-ins (compiler:Compiler, ctxt:Context, r:CResult) -> False

;Representation of a compiled location
deftype CLoc
defstruct PtrLoc <: CLoc :
  base: CResult
  offset: Int
defstruct VarLoc <: CLoc :
  n: Int
  index: Int
defstruct ExpLoc <: CLoc :
  base: CResult
  index: Int

;============================================================
;============== Specialized Results/Contexts ================
;============================================================
defstruct TargetContext <: Context :
  locals: Tuple<Local>

deftype AcceptContext <: Context
defmulti accept (compiler:Compiler, c:AcceptContext, imms:Tuple<VMImm>) -> False

defstruct TailContext <: Context

;Represents a non-forwarded compiled result. 
deftype CValue <: CResult

deftype CImms <: CValue

deftype CStore <: CValue
defmulti store (compiler:Compiler, c:CStore, xs:Tuple<Local>) -> False

deftype CCall <: CValue
defmulti call-args (compiler:Compiler, c:CCall) -> [Tuple<VMImm>, VMImm]
defmulti closure? (c:CCall) -> True|False

defmulti imms (compiler:Compiler, r:CResult) -> Tuple<VMImm>
defmethod imms (compiler:Compiler, r:CResult) :
  val xs = map(make-def{compiler, _}, types(compiler,r))
  gen-ins(compiler, TargetContext(xs), r)
  xs

defn imm (compiler:Compiler, r:CResult) :
  val xs = imms(compiler, r)
  fatal("Result does not have a single immediate.") when length(xs) != 1
  xs[0]

defmethod gen-ins (compiler:Compiler, ctxt:AcceptContext, c:CImms) :
  accept(compiler, ctxt, imms(compiler, c))

defmethod gen-ins (compiler:Compiler, ctxt:AcceptContext, r:CValue) :
  accept(compiler, ctxt, imms(compiler,r))

defmethod gen-ins (compiler:Compiler, ctxt:TargetContext, c:CStore) :
  store(compiler, c, locals(ctxt))

defmethod gen-ins (compiler:Compiler, ctxt:TargetContext, c:CImms) :
  for (x in locals(ctxt), y in imms(compiler, c)) do :
    emit(compiler, SetIns(x, y))

defmethod gen-ins (compiler:Compiler, ctxt:TargetContext, c:CCall) :
  val [args, func] = call-args(compiler, c)
  emit(compiler, CallIns(locals(ctxt), func, args))

defmethod gen-ins (compiler:Compiler, ctxt:TailContext, c:CCall) :
  val [args, func] = call-args(compiler, c)
  if closure?(c) : emit(compiler, TCallClosureIns(func, args))
  else : emit(compiler, TCallIns(func, args))

defmethod gen-ins (compiler:Compiler, ctxt:TailContext, r:CValue) :
  emit(compiler, ReturnIns(imms(compiler,r)))

;============================================================
;================ Convenience Contexts ======================
;============================================================

defstruct ReturnContext <: AcceptContext
defmethod accept (compiler:Compiler, ctxt:ReturnContext, imms:Tuple<VMImm>) :
  emit(compiler, ReturnIns(imms))

;============================================================
;======================= Roots ==============================
;============================================================

defn roots (types:List<VMType>, offsets:List<Int>) :
  to-tuple $ for (t in types, o in offsets) seq? :
    match(t:VMRef) : One(o / 8)
    else : None()

;============================================================
;=================== Identifiers ============================
;============================================================

defn to-vm-id (n:Int) :
  switch(n) :
    BYTE-TYPE-ID : VM-BYTE-TYPE-ID
    CHAR-TYPE-ID : VM-CHAR-TYPE-ID
    INT-TYPE-ID : VM-INT-TYPE-ID
    LONG-TYPE-ID : VM-LONG-TYPE-ID
    FLOAT-TYPE-ID : VM-FLOAT-TYPE-ID
    DOUBLE-TYPE-ID : VM-DOUBLE-TYPE-ID
    STRING-TYPE-ID : VM-STRING-TYPE-ID
    SYMBOL-TYPE-ID : VM-SYMBOL-TYPE-ID
    LIST-TYPE-ID : VM-LIST-TYPE-ID
    ARRAY-TYPE-ID : VM-ARRAY-TYPE-ID
    CHAR-ARRAY-TYPE-ID : VM-CHAR-ARRAY-TYPE-ID
    TRUE-TYPE-ID : VM-TRUE-TYPE-ID
    FALSE-TYPE-ID : VM-FALSE-TYPE-ID
    TUPLE-TYPE-ID : VM-TUPLE-TYPE-ID
    FN-TYPE-ID : VM-FN-TYPE-ID
    STACK-TYPE-ID : VM-STACK-TYPE-ID
    TYPE-TYPE-ID : VM-TYPE-TYPE-ID
    BOX-TYPE-ID : VM-BOX-TYPE-ID
    else : n

defn vm-type-ids (t:KType|False) :
  match(t:KType) :
    val ids = Vector<Int>()
    let loop (t:KType = t) :
      match(t) :
        (t:KOf) : add(ids, to-vm-id(n(t)))
        (t:KAnd) : (loop(a(t)), loop(b(t)))
    to-tuple(ids)
  else : []

;============================================================
;===================== Small Utilities ======================
;============================================================

defn string-bytes (s:String) :
  val len = length(s)
  val bs = ByteArray(len + 1)
  bs[0 to false] = seq(to-byte, s)
  bs[len] = 0Y
  bs

defn to-byte-array (bs:Seqable<Byte>&Lengthable) :
  val b = ByteArray(length(bs))
  b[0 to false] = bs
  b

;============================================================
;================ Within Function Compilation ===============
;============================================================
;
;defn compile-function (e:KFn) -> VMFunc :
;  ;Given:
;  ;  tail?(e) : Whether the function is tail recursive
;  ;  a1(e) : The types of the arguments
;  ;  a2(e) : The return type
;  ;  args(e) : The identifiers of the arguments
;  ;  body(e) : The body expression
;
;  ;Table for storing defined quantities
;  val immtable = IntTable<Tuple<VMImm>>()
;  val typetable = IntTable<Tuple<VMType>>()
;
;  ;Buffer for keeping instructions
;  val buffer = Vector<VMIns>()
;  defn emit (i:VMIns) : add(buffer, i)
;
;  ;Connect a context with a cresult
;  defn connect (ctxt:Context, r:CResult) :
;    r:CVoid
;    CImms
;    CStore
;    CCall
;    
;    match(ctxt, r) :
;      (ctxt:IgnoreContext) :
;      (ctxt:AcceptContext) :
;      (ctxt:TargetContext) :
;
;  defn imms (r:CResult) :
;
;  defn imm (r:CResult) :
;  
;  ;Compile a K-expression into an abstract CResult structure
;  defn compile (e:KExp) -> CResult :
;    match(e) :
;      (e:KLet) :
;        val v = compile(value(e)) as CValue
;        val def = new CVoid :
;          defmethod gen-ins (this) :
;            type-table[n(e)] = types(v)
;            val ctxt = new AcceptContext :
;              defmethod accept (this, imms:Tuple<VMImm>) :
;                immtable[n(e)] = imms
;            connect(ctxt, v)
;        chain(def, compile(body(e)))
;      (e:KLetVar) :
;        val value* = match(value(e)) :
;          (v:False) : false
;          (v:KExp) : compile(v) as CValue
;        val def = new CVoid :
;          defmethod gen-ins (this) :
;            add(mutables, n(e))
;            val ts = vm-types(dec-table, type(e))
;            val locals = map(make-def, ts)
;            type-table[n(e)] = ts
;            imm-table[n(e)] = locals
;            match(v:CValue) :
;              connect(TargetContext(locals), v)
;        chain(def, compile(body(e)))
;      (e:KLetRec) :
;        val def = new CVoid :
;          defmethod gen-ins (this) :
;            ;Retrieve closures
;            val closures = values(e) as List<KClosure>
;            ;Make
;            val locals = to-tuple(seq(make-def{VMRef()}, ns(e)))
;            val types = to-tuple(seq(VMRef{}, ns(e)))
;            ;Make locals
;            for (n in ns(e), l in locals, t in types) do :
;              type-table[n] = [t]
;              imm-table[n] = [l]
;            ;Allocate closures
;            emit(AllocIns(locals, types, sizes)) where :
;              val sizes = to-tuple $ for c in closures seq :
;                val nslots = length(targs(c)) + length(args(c))
;                VMInt(8           ;length
;                    + 8           ;code
;                    + 8 * nslots) ;number of slots
;            ;Compile closures
;            for (x in locals, c in closures) do :
;              val nslots = length(targs(c)) + length(args(c))
;              emit(StoreIns(x, VMInt(0), VMLong(nslots)))
;              emit(StoreIns(x, VMInt(8), CodeId(n(c))))
;              for (y in append(targs(c), args(c)), i in 0 to false) do :
;                emit(StoreIns(x, VMInt(16 + 8 * i), imm(compile(y))))
;        chain(def, compile(body(e)))
;      (e:KVar) :
;        if global?(dec-table, n(e)) :
;          val t = var-type(dec-table, n(e))
;          new CStore :
;            defmethod types (this) : vm-types(dec-table, t)
;            defmethod store (this, xs:Tuple<Local>) :
;              val m = global-mem(dec-table, n(e))
;              for (x in xs, o in field-offsets(dec-table,t)) do :
;                emit(LoadIns(x, m, o))
;        else if mutables[n(e)] :
;          ;TODO: Not necessary if we pull out
;          ;mutated variables from expressions first.
;          new CImms :
;            defmethod types (this) : typetable[n(e)]
;            defmethod imms (this) :
;              val locals = map(make-def, typetable[n(e)])
;              for (x in locals, y in immtable[n(e)]) do :
;                emit(SetIns(x, y))
;              locals
;        else :
;          new CImms :
;            defmethod types (this) : typetable[n(e)]
;            defmethod imms (this) : immtable[n(e)]
;      (e:KSet) :
;        val v = compile(value(e)) as CValue
;        new CImms :
;          defmethod types (this) : [VMRef()]
;          defmethod imms (this) :
;            match(compile(loc(e))) :
;              (l:PtrLoc) :
;                val p = imm(base(l))
;                val os = field-offsets(dec-table, type(e))
;                for (o in os, v in imms(v)) do :
;                  emit(StoreIns(p, o, v))
;              (l:VarLoc) :
;                val base = imm-table[n(l)] as Tuple<Local>
;                val len = length(dec-table, type(e))
;                val xs = headn(tailn(base, index(l)), len)
;                connect(TargetContext(xs), v)
;            [false-marker]
;      (e:KTuple) :
;        val exps* = map(compile, exps(e)) as List<CValue>
;        new CStore :
;          defmethod types (this) : [VMRef()]
;          defmethod store (this, xs:Tuple<Local>) :
;            val len = length(args(e))
;            val size = 8 + 8 * len
;            emit(AllocIns(xs, [VMRef()], VMInt(size)))
;            emit(StoreIns(xs[0], VMInt(0), VMLong(len)))
;            for (e in exps*, i in 0 to false) do :
;              emit(StoreIns(xs[0], VMInt(8 + 8 * i), imm(e)))
;      (e:KVoidTuple) :
;        val ys = [false-marker, VMLong(1), VMLong(length(e))]
;        new CCall :
;          defmethod types (this) : [VMRef()]
;          defmethod call (this, xs:Tuple<Local>) :
;            emit(CallIns(xs, CodeId(VOID-TUPLE-ID), ys))
;          defmethod tcall (this) :
;            emit(TCallIns(CodeId(VOID-TUPLE-ID), ys))
;      (e:KTupleGet) :
;        val exp* = compile(exp(e)) as CValue
;        new CStore :
;          defmethod types (this) : [VMRef()]
;          defmethod store (this, xs:Tuple<Local>) :
;            val offset = 8 * index(e) + foffset(TUPLE-ITEMS-FIELD-ID)
;            emit(LoadIns(xs[0], imm(exp*), VMInt(offset)))
;      (e:KTupleSet) :
;        val t = compile(tuple(e))
;        val v = compile(exp(e))
;        new CImms :
;          defmethod types (this) : [VMRef()]
;          defmethod imms (this) :
;            val offset = 8 * index(e) + foffset(TUPLE-ITEMS-FIELD-ID)
;            emit(StoreIns(imm(t), VMInt(offset), imm(v)))
;            [false-marker]
;      (e:KEnsureLength) :
;        val exp = compile(exp(e))
;        new CStore :
;          defmethod types (this) : [VMRef()]
;          defmethod store (this, xs:Tuple<Local>) :
;            val x = xs[0]
;            val lbl = make-label()
;            connect(TargetContext(xs), exp)
;            val len = make-def(VMLong())
;            val exp-len = VMLong(length(e))
;            emit(LoadIns(len, x, VMInt(0)))
;            emit(Branch2Ins(lbl, EqOp(), len, exp-len))
;            emit(TCallIns(CodeId(TUPLE-LENGTH-ERROR-ID), [len, exp-len]))
;            emit(LabelIns(lbl))
;      (e:KObject) :
;        ;Marker object
;        if empty?(args(e)) :
;          fatal("Not yet implemented")
;          ;new CImm :
;          ;  defmethod types (this) :
;          ;    List(TGRefT())
;          ;  defmethod imms (this) :
;          ;    List(TGTag(n(e), true))
;        ;Allocated object
;        else :
;          val size = size(dec-table, n(e))
;          val offsets = field-offsets(dec-table, n(e))
;          new CStore :
;            defmethod types (this) : [VMRef()]
;            defmethod store (this, xs:Tuple<Local>) :
;              val x = xs[0]
;              val args* = seq-append(imms{compile(_)}, args(e))
;              emit(AllocIns(xs, [VMRef()], VMInt(size)))
;              for (a in args*, o in offsets) do :
;                emit(StoreIns(x, VMInt(o), a))
;      (e:KArray) :
;        val base-size = size(dec-table, n(e))
;        val item-size = item-size(dec-table, n(e))
;        val offsets = field+rest-offsets(dec-table, n(e))
;          new CStore :
;            defmethod types (this) : [VMRef()]
;            defmethod store (this, xs:Tuple<Local>) :
;              val args* = seq-append(imms{compile(_)}, args(e))
;              ;Compute length
;              val len = make-def(VMLong())
;              emit(Op2Ins(len, MulOp(), head(args*), VMLong(item-size)))
;              emit(Op2Ins(len, AddOp(), len, VMLong(7)))
;              emit(Op2Ins(len, AndOp(), len, VMLong(-8)))
;              ;Allocate array and store fields
;              emit(AllocIns(xs, [VMRef()], VMInt(len)))
;              ;Store fields
;              val x = xs[0]
;              for (a in args*, o in offsets) do :
;                emit(StoreIns(x, VMInt(o), a))
;      (e:KStruct) :
;        new CImms :
;          defmethod types (this) :
;            vm-types(dec-table, n(e))
;          defmethod imms (this) :
;            seq-append(imms{compile(_)}, args(e))
;      (e:KPtr) :
;        val l = compile(loc(e)) as PtrLoc
;        if offset(l) == 0 :
;          base(l)
;        else :
;          new CStore :
;            defmethod types (this) : VMLong()
;            defmethod store (this, xs:Tuple<Local>) :
;              connect(TargetContext(xs[0]), base(l))
;              emit(Op2Ins(x, AddOp(), x, VMLong(offset(l))))
;      (e:KRead):
;        match(compile(loc(e))) :
;          (l:PtrLoc) :
;            new CStore :
;              defmethod types (this) :
;                vm-types(dec-table, type(e))
;              defmethod store (this, xs:Tuple<Local>) :
;                val p = imm(base(l))
;                for (x in xs, o in field-offsets(dec-table,type(e))) do :
;                  emit(LoadIns(x, p, VMInt(offset(l) + o)))
;          (l:ExpLoc) :
;            new CStore :
;              defmethod types (this) :
;                vm-types(dec-table, type(e))
;              defmethod store (this, xs:Tuple<Local>) :
;                val len = length(dec-table, type(e))
;                val xs* = for (t in types(base(l)), i in 0 to false) do :
;                  if i >= index(l) and i < index(l) + len : xs[i - index(l)]
;                  else : make-def(t)
;                connect(TargetContext(xs*), base(l))
;          (l:VarLoc) :
;            defn var-imms () :
;              val xs = imm-table[n(l)]
;              val len = length(dec-table, type(e))
;              headn(tailn(xs, index(l)), len)
;            if mutables[n(l)] :  ;TODO: Not necessary after lifting mutables
;              new CStore :
;                defmethod types (this) :
;                  vm-types(dec-table, type(e))
;                defmethod store (this, xs:Tuple<Local>) :
;                  do(emit{SetIns(_, _)}, xs, var-imms())
;            else :
;              new CImms :
;                defmethod types (this) :
;                  vm-types(dec-table, type(e))
;                defmethod imms (this) :
;                  var-imms()
;      (e:KDo) :
;        ;Result representing a call to known code
;        defn code-ccall (get-args: () -> [Int, Tuple<VMImm>, VMImm]) :
;          new CCall :
;            defmethod types (this) :
;              vm-types(dec-table, type(e))
;            defmethod call (this, xs:Tuple<Local>) :
;              val [arity, args, f] = get-args()
;              val ys = to-tuple $ cat-all $ [
;                [false-marker]
;                [VMLong(arity)]
;                args]
;              emit(CallIns(xs, f, ys))
;            defmethod tcall (this) :
;              val [arity, args, f] = get-args()
;              val ys = to-tuple $ cat-all $ [
;                [false-marker]
;                [VMLong(arity)]
;                args]
;              emit(TCallIns(f, ys))
;        ;Result representing a call to a closure
;        defn closure-ccall (get-args: () -> [Int, Tuple<VMImm>, VMImm]) :
;          new CCall :
;            defmethod types (this) :
;              vm-types(dec-table, type(e))
;            defmethod call (this, xs:Tuple<Local>) :
;              val [arity, args, closure] = get-args()
;              val ys = to-tuple $ cat-all $ [
;                [closure]
;                [VMLong(arity)]
;                args]
;              emit(CallClosureIns(xs, closure, ys))
;            defmethod tcall (this) :
;              val [arity, args, closure] = get-args()
;              val ys = to-tuple $ cat-all $ [
;                [closure]
;                [VMLong(arity)]
;                args]
;              emit(TCallClosureIns(closure, ys))
;        ;Cases
;        defn call-pointer (p:KExp, args:List<KExp>) :
;          within code-ccall() :
;            val args* = to-tuple(seq-cat(imms{compile(_)}, args))
;            val func = imm(compile(p))
;            [length(args), args*, func]
;        defn call-closure (c:KExp, targs:List<KType>, args:List<KExp>) :
;          within closure-ccall() :
;            val args* = to-tuple $ cat(
;              seq-cat(imms{compile(_)}, targs)
;              seq-cat(imms{compile(_)}, args))
;            val closure* = imm(compile(c))
;            [length(args), args*, closure*]
;        defn call-code (n:Int, targs:List<KType>, args:List<KExp>) :
;          within code-ccall() :
;            val args* = to-tuple $ cat(
;              seq-cat(imms{compile(_)}, targs)
;              seq-cat(imms{compile(_)}, args))
;            val func* = CodeId(global-mem(dec-table,n))
;            [length(args), args*, func*]
;        ;Categorize
;        match(func(e)) :
;          (f:KVar|KCurry) :
;            val [f*, targs] = match(f) :
;              (f:KVar) : [f, List()]
;              (f:KCurry) : [KVar(n(f)), targs(f)]
;            if function?(dec-table, n(f)) :
;              call-code(n(f), targs, args(e))
;            else :
;              call-closure(f*, targs, args(e))
;          (f:KRead) :
;            match(loc(f)) :
;              (l:KDeptr) : call-pointer(exp(l), args(e))
;              (l:KDeref) : call-closure(exp(l), List(), args(e))
;          (f:KExp) :
;            call-closure(f, List(), args(e))
;      (e:KDoC) :
;        new CStore :
;          defmethod types (this) :
;            vm-types(dec-table, type(e))
;          defmethod store (this, xs:Tuple<Local>) :
;          val args* = to-tuple $ cat(
;            seq-cat(imms{compile(_)}, args(e))
;            seq-cat(imms{compile(_)}, varargs(e)))
;          val f* = match(func(e)) :
;            (f:KRead) :
;              val l = loc(f) as KDeptr
;              imm(compile(exp(l)))
;            (f:KVar) :
;              CodeId(global-mem(dec-table, n(f)))
;            emit(CallCIns(xs, f*, args*))
;      (e:KLSLiteral) :
;        val [type, imm] = match(value(e)) :
;          (v:Char) : [VMByte(), VMByte(to-byte(v))]
;          (v:Byte) : [VMByte(), VMByte(v)]
;          (v:Int) : [VMInt(), VMInt(v)]
;          (v:Long) : [VMLong(), VMLong(v)]
;          (v:Float) : [VMFloat(), VMFloat()]
;          (v:Double) : [VMDouble(), VMDouble(v)]
;          (v:True) : fatal("Not yet implemented")
;          (v:False) : fatal("Not yet implemented")
;          (v:String) : fatal("Not yet implemented")
;        new CImms :
;          defmethod types (this) : [type]
;          defmethod imms (this) : [imm]
;      (e:KLiteral) : 
;        fatal("Not yet implemented")
;      (e:KInterpret) :
;        val type = match(type(e)) :
;          (t:KByteT) : VMByte()
;          (t:KIntT) : VMInt()
;          (t:KLongT) : VMLong()
;          (t:KFloatT) : VMFloat()
;          (t:KDoubleT) : VMDouble()
;          (t:KPtrT) : VMPointer()
;          (t) : VMRef()
;        new CStore :
;          defmethod types (this) : [type]
;          defmethod store (this, xs:Tuple<Local>) :
;            val y = compile(exp(e))
;            emit(Op1Ins(xs[0], InterpretOp(), imm(y)))
;      (e:KCheck) :
;        match(type(e)) :
;          (t:KBot) :
;            new CVoid :
;              defmethod gen-ins (this) :
;                val obj = imm(compile(exp(e)))
;                val targ* = imm(compile(tobj!(e)))
;                emit(TCallIns(CodeId(CAST-ERROR-ID), [false-marker, VMInt(3), VMInt(option(e)), obj, targ*]))
;          (t) :
;            new CStore :
;              defmethod types (this) :
;                [VMRef()]
;              defmethod store (this, xs:Tuple<Local>) :
;                val pass-lbl = make-label()
;                val fail-lbl = make-label()
;                connect(TargetContext(xs), compile(exp(e)))
;                compile-typeof(xs[0], type(e), pass-lbl, fail-lbl)
;                ;Emit fail code
;                emit(LabelIns(fail-lbl))
;                val targ* = imm(compile(tobj!(e)))
;                emit(TCallIns(CodeId(CAST-ERROR-ID), [false-marker, VMInt(3), VMInt(option(e)), xs[0], targ*]))
;                ;Emit pass code
;                emit(LabelIns(pass-lbl))        
;      (e:KConv) :
;        new CStore :
;          defmethod types (this) :
;            val t = match(type(e)) :
;              (t:KByteT) : VMByte()
;              (t:KIntT) : VMInt()
;              (t:KLongT) : VMLong()
;              (t:KFloatT) : VMFloat()
;              (t:KDoubleT) : VMDouble()
;              (t:KPtrT) : VMPointer()
;              (t) : VMRef()
;            [t]
;          defmethod store (this, xs:Tuple<Local>) :
;            emit(Op1Ins(xs[0], ConvOp(), imm(compile(exp(e)))))
;      (e:KPrim) : fatal("Not yet implemented")
;      (e:KSizeof) : fatal("Not yet implemented")
;      (e:KTagof) : fatal("Not yet implemented")
;      (e:KMatch) : fatal("Not yet implemented")
;      (e:KLabels) : fatal("Not yet implemented")
;      (e:KBlock) : fatal("Not yet implemented")
;      (e:KIf) : fatal("Not yet implemented")
;      (e:KSeq) : fatal("Not yet implemented")
;      (e:KGoto) : fatal("Not yet implemented")
;      (e:KReturn) : fatal("Not yet implemented")
;      (e:KDispatch) : fatal("Not yet implemented")
;      (e:KEnsureSet) : fatal("Not yet implemented")
;      (e:KNewObject) : fatal("Not yet implemented")
;      (e:KObjectGet) : fatal("Not yet implemented")
;      (e:KObjectTGet) : fatal("Not yet implemented")
;      (e:KLetType) : fatal("Not yet implemented")
;      (e:KBox) : fatal("Not yet implemented")
;      (e:KBoxGet) : fatal("Not yet implemented")
;      (e:KBoxSet) : fatal("Not yet implemented")
;      (e:KClosure) : fatal("Not yet implemented")
;      (e:KTagPrim) : fatal("Not yet implemented")
;      (e:KDetagPrim) : fatal("Not yet implemented")
;
;;============================================================
;;================= Forwarding Result ========================
;;============================================================
;
;defn chain (a:CVoid, b:CResult) :
;  match(b) :
;    (b:CVoid) :
;      new CVoid :
;        defmethod side-effects? (this) :
;          side-effects?(a) or side-effects?(b)
;        defmethod gen-ins (this) :
;          gen-ins(a)
;          gen-ins(b) when side-effects?(b)
;    (b:CImms) :
;      new CImms :
;        defmethod types (this) : types(b)
;        defmethod side-effects? (this) :
;          side-effects?(a) or side-effects?(b)
;        defmethod imms (this) :
;          gen-ins(a)
;          imms(b)
;    (b:CStore) :
;      new CStore :
;        defmethod types (this) : types(b)
;        defmethod side-effects? (this) :
;          side-effects?(a) or side-effects?(b)
;        defmethod store (this, xs:Tuple<Local>) :
;          gen-ins(a)
;          store(b, xs)
;
;;============================================================
;;================= Compiled Results =========================
;;============================================================
;
;;Types of results
;deftype CResult
;
;;There is no result. The program never executes past that expression.
;deftype CVoid <: CResult
;defmulti gen-ins (c:CVoid) -> False
;
;;There is a result. You can retrieve its types.
;deftype CValue <: CResult
;defmulti types (c:CValue) -> Tuple<VMType>
;
;;Result is represented as a bunch of immediates, to be handled by the context.
;deftype CImms <: CValue
;defmulti imms (c:CImms) -> Tuple<VMImm>
;
;;Result will generate instructions to store values into destination variables.
;;Destination variables will be empty, if result is not used.
;deftype CStore <: CValue
;defmulti store (c:CStore, xs:Tuple<Local>) -> False
;
;;Result represents a call expression.
;;The specific instructions generated depends upon the context in which it
;;is used.
;deftype CCall <: CValue
;defmulti call (c:CCall, xs:Tuple<Local>) -> False
;defmulti tcall (c:CCall) -> False
;
;;============================================================
;;================= Compiled Contexts ========================
;;============================================================
;
;;Types of Contexts
;deftype Context
;
;;This context ignores the result
;deftype IgnoreContext <: Context
;
;;This context will generate instructions to handle results.
;deftype AcceptContext <: Context
;defmulti accept (c:AcceptContext, imms:Tuple<VMImm>) -> False
;
;;This context is represented as a set of locals, for the result to be stored into.
;deftype TargetContext <: Context
;defmulti locals (c:TargetContext) -> Tuple<Local>