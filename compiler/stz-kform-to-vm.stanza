defpackage stz/kform-to-vm :
  import core
  import collections
  import stz/kl-ir
  import stz/pl-ir
  import stz/vm-ir
  import stz/khier
  import stz/dec-table
  import stz/built-ins with :
    prefix => VM-
  import stz/ids
  import stz/primitives

;============================================================
;==================== Driver ================================
;============================================================

public defn to-vmprog (dec-table:DecTable, kpkg:KPackage) -> VMProg :
  ;Define accumulators
  val classes = Vector<VMClass>()
  val funcs = Vector<VMFunction>()
  val externs = Vector<VMExtern>()

  ;Define tables
  val global-defs = GlobalDefs()
  val literal-defs = LiteralDefs()
  val initializers = Initializers()
  val method-table = MethodTable()

  ;Create KHierarchy
  val khier = KHierarchy(hier-entries(kpkg))

  ;Create class table
  val class-table = ClassTable()
  for t in filter-by<KDefType>(exps(kpkg)) do :
    add(class-table, t)

  ;Compiling a top-level expression
  defn compile-te (te:KTExp) :
    println("Compiling top level expression: %_" % [te])
    match(te) :
      (te:KDef) :
        add(global-defs, VMGlobal(n(te), size, roots)) where :
          val size = size(dec-table, type(te))
          val roots = roots(vm-types(dec-table, type(te)), field-offsets(dec-table, type(te)))
        init-global(initializers, n(te), type(te), value(te))
      (te:KDefVar) : 
        add(global-defs, VMGlobal(n(te), size, roots)) where :
          val size = size(dec-table, type(te))
          val roots = roots(vm-types(dec-table, type(te)), field-offsets(dec-table, type(te)))
        match(value(te)) :
          (v:KExp) : init-global(initializers, n(te), type(te), v)
          (v:False) : false        
      (te:KDefn) :
        val func = match(value(te)) :
          (value:KMultifn) : fatal("Not yet implemented")
          (value:KFn) : value
        val vmfunc = within c = compile-function(n(te), func, khier, dec-table, literal-defs) :
          ;Compute types
          for a in targs(func) do :
            set-types(c, a, [VMRef()])
          for (a in args(func), t in a1(func)) do :
            set-types(c, a, to-tuple(vm-types(dec-table,t)))
          ;Compute locals
          val targ-locals = for a in targs(func) map :
            val x = make-def(c, VMRef())
            comment(c, "%_ is type argument %_" % [x, a])
            set-imms(c, a, [x])
            x
          val arg-locals = to-list $
            for a in args(func) seq-cat :
              val xs = make-defs(c, types(c, a))
              comment(c, "%_ is argument %_" % [xs, a])
              set-imms(c, a, xs)
              xs
          ;Return args
          to-tuple(qquote(false, false, ~@ targ-locals, ~@ arg-locals))
        add(funcs, vmfunc)
      (te:KDefClosure) :
        add(funcs, compile-closure(te, khier, dec-table, literal-defs))
      (te:KDefmulti) :
        add(method-table, te)
      (te:KDefmethod) :
        add(method-table, te)
      (te:KDefType) :
        add(classes, VMAbstractClass(id, parent-ids)) where :
          val id = to-vm-id(n(te))
          val parent-ids = parent-ids(class-table, n(te), parent(te))
      (te:KDefStruct) :
        match(rfield(te)) :
          (rfield:KStructField) :
            ;Array class
            add(classes, VMArrayClass(id, parent-ids, base-size, item-size, base-roots, item-roots)) where :
              val id = to-vm-id(n(te))
              val parent-ids = parent-ids(class-table, n(te), parent(te))
              val base-size = size(dec-table, n(te))
              val item-size = rest-size(dec-table, n(te))
              val base-roots = roots(vm-types(dec-table, n(te)), field-offsets(dec-table, n(te)))
              val item-roots = roots(vm-types(dec-table, type(rfield)), field-offsets(dec-table, type(rfield)))
          (rfield:False) :
            ;Leaf class
            add(classes, VMLeafClass(id, parent-ids, size, roots)) where :
              val id = to-vm-id(n(te))
              val parent-ids = parent-ids(class-table, n(te), parent(te))
              val size = size(dec-table, n(te))
              val roots = roots(vm-types(dec-table, n(te)), field-offsets(dec-table, n(te)))
      (te:KExternFn) : fatal("Not yet implemented")
      (te:KExtern) :
        add(externs, VMExtern(n(te), lbl(te)))
      (te:KInit) :
        add(initializers, exp(te))
      (te:KDefConst) :
        val v = match(value(te)) :
          (v:KTypeObject) :
            fatal("Non-empty type object.") when not empty?(targs(v))
            VMTypeObject(CodeId(n(v)))
          (v:KClosure) :
            fatal("Non-empty closure.") when not empty?(args(v))
            VMClosure(CodeId(n(v)))
          (v:VMValue) : v
        add(global-defs, VMConst(n(te), v))
      (te:KDefObject) :
        add(classes, VMLeafClass(id, parent-ids, size, roots)) where :
          val id = to-vm-id(n(te))
          val parent-ids = parent-ids(class-table, n(te), parent(te))
          val size = 8 * (tarity(te) + arity(te))
          val roots = to-tuple(0 to (tarity(te) + arity(te)))
      (te:KDefTypeObject) :
        add(funcs, compile-type-object(n(te), args(te), type(te), khier, dec-table, literal-defs))

  println("===== Input =====")
  within indented() :
    println(kpkg)

  println("===== Compiling =====")
  within indented() :
    do(compile-te, exps(kpkg))
    for e in method-table do :
      add(funcs, compile(khier, e, dec-table, literal-defs))
    add(funcs, compile-init(initializers, khier, dec-table, literal-defs))

  VMProg(globals(global-defs), defs(literal-defs), consts(global-defs),
         to-tuple(classes), to-tuple(funcs), to-tuple(externs))

;============================================================
;=================== Class Table ============================
;============================================================
deftype ClassTable
defmulti add (ct:ClassTable, t:KDefType) -> False
defmulti parent-ids (ct:ClassTable, n:Int, parent:KType|False) -> Tuple<Int>

defn ClassTable () :
  val delayed-parents = IntTable<List<Int>>(List())
  new ClassTable :
    defmethod add (this, t:KDefType) :
      for c in children(t) do :
        update(delayed-parents, cons{n(t), _}, n(c))
    defmethod parent-ids (this, n:Int, parent:KType|False) :
      to-tuple(seq(to-vm-id, cat(type-ids(parent), delayed-parents[n])))
      
defn type-ids (t:KType|False) :
  match(t:KType) :
    val ids = Vector<Int>()
    let loop (t:KType = t) :
      match(t) :
        (t:KOf) : add(ids, n(t))
        (t:KAnd) : (loop(a(t)), loop(b(t)))
    to-tuple(ids)
  else : []

;============================================================
;================== Global Compilation ======================
;============================================================

deftype GlobalDefs
defmulti add (g:GlobalDefs, def:VMGlobal) -> False
defmulti add (g:GlobalDefs, def:VMConst) -> False
defmulti globals (g:GlobalDefs) -> Tuple<VMGlobal>
defmulti consts (g:GlobalDefs) -> Tuple<VMConst>

defn GlobalDefs () :
  val global-defs = Vector<VMGlobal>()
  val const-defs = Vector<VMConst>()

  new GlobalDefs :
    defmethod add (this, g:VMGlobal) :
      add(global-defs, g)
    defmethod add (this, c:VMConst) :
      add(const-defs, c)
    defmethod globals (this) :
      var offset:Int = 0
      val defs = Vector<VMGlobal>()
      defn push (g:VMGlobal) :
        add(defs, sub-position(g, offset))
        offset = offset + size(g)
      do(push, global-defs)
      to-tuple(defs)
    defmethod consts (this) :
      to-tuple(const-defs)

;============================================================
;=================== Literals Compilation ===================
;============================================================

deftype LiteralDefs
defmulti def-data (defs:LiteralDefs, data:ByteArray) -> DataId
defmulti defs (defs:LiteralDefs) -> Tuple<VMData>

defn LiteralDefs () :
  val idcounter = to-seq(0 to false)
  val defs = Vector<VMData>()
  new LiteralDefs :
    defmethod def-data (this, data:ByteArray) :
      val id = next(idcounter)
      add(defs, VMData(id, data))
      DataId(id)
    defmethod defs (this) :
      to-tuple(defs)

;============================================================
;================== Multis Compilation ======================
;============================================================

defstruct MultiEntry :
  multi: KDefmulti with: (init => void, setter => set-multi)
  methods: Vector<KDefmethod> with: (init => Vector<KDefmethod>())
  
deftype MethodTable <: Collection<MultiEntry>
defmulti add (t:MethodTable, m:KDefmulti) -> False
defmulti add (t:MethodTable, m:KDefmethod) -> False

defn MethodTable () :
  val multis = IntTable-init<MultiEntry>(MultiEntry{})
  new MethodTable :
    defmethod add (this, m:KDefmulti) :
      set-multi(multis[n(m)], m)
    defmethod add (this, m:KDefmethod) :
      add(methods(multis[multi(m)]), m)
    defmethod to-seq (this) :
      to-seq(values(multis))

defn compile (khier:KHierarchy, e:MultiEntry, dec-table:DecTable, literal-defs:LiteralDefs) :
  val compiler = Compiler()
  val exp-compiler = ExpCompiler(khier, compiler, dec-table, literal-defs)

  ;Compute the immediates for representing the arguments
  val targ-imms = for a in targs(multi(e)) map :
    make-def(compiler, VMRef())
  val arg-imms = for a in a1(multi(e)) map :
    make-def(compiler, VMRef())

  ;Compute the dispatch branch ordering
  defn branch-types (m:KDefmethod) : map(erase-tvars, a1(value(m) as KFn))
  val dispatch-branches = map(value, dispatch-ordering(khier, seq(branch-types, methods(e))))

  println("Compiling multi:")
  println(multi(e))
  println(methods(e))
  println("dispatch branches = %_" % [dispatch-branches])

  ;Compile each method
  for dispatch in dispatch-branches do :
    match(dispatch) :
      (dispatch:List<Int>) :
        println("Ambiguity branch %_." % [dispatch])
      (dispatch:Int) :
        val types = branch-types(methods(e)[dispatch])        
        val end-body = make-label(compiler)
        val f = value(methods(e)[dispatch]) as KFn
        for (x in cat(targ-imms, arg-imms), a in cat(targs(f), args(f))) do :
          set-types(compiler, a, [VMRef()])
          set-imms(compiler, a, [x])
        for (x in arg-imms, t in types) do :
          val pass-lbl = make-label(compiler)
          compile-typeof(exp-compiler, x, t, pass-lbl, end-body)
          emit(compiler, LabelIns(pass-lbl))
        val return-ctxt = TailContext() when tail?(multi(e))
                     else ReturnContext()
        compile-exp(exp-compiler, return-ctxt, body(f))
        emit(compiler, LabelIns(end-body))
  emit(compiler, TCallIns(CodeId(VM-NO-BRANCH-ERROR-FN-ID), []))

  ;Create VMFunc 
  val all-args = to-tuple $ cat-all $ [
    [false, false],
    cat(targ-imms, arg-imms)]
  VMFunc(n(multi(e)), all-args, defs(compiler), instructions(compiler))

;============================================================
;================= Function Compilation =====================
;============================================================
defn compile-function (gen-args:Compiler -> Tuple<Local|False>, id:Int, f:KFn,
                       khier:KHierarchy,
                       dec-table:DecTable,
                       literal-defs:LiteralDefs) :
  val compiler = Compiler()
  val exp-compiler = ExpCompiler(khier, compiler, dec-table, literal-defs)
  val args = gen-args(compiler)
  val return-ctxt = TailContext() when tail?(f)
               else ReturnContext()
  compile-exp(exp-compiler, return-ctxt, body(f))
  VMFunc(id, args, defs(compiler), instructions(compiler))

;============================================================
;=================== Closure Compilation ====================
;============================================================
defn compile-closure (e:KDefClosure, khier:KHierarchy, dec-table:DecTable, literal-defs:LiteralDefs) :
  ;Create compiler
  val c = Compiler()
  val exp-compiler = ExpCompiler(khier, c, dec-table, literal-defs)
  comment(c, "Code for closure %_" % [n(e)])

  ;Retrieve function
  val func = match(func(e)) :
    (f:KMultifn) : fatal("Not yet implemented.")
    (f:KFn) : f

  ;Compute arg types
  set-types(c, closure(e), [VMRef()])
  for a in targs(func) do :
    set-types(c, a, [VMRef()])
  for (a in args(func), t in a1(func)) do :
    set-types(c, a, to-tuple(vm-types(dec-table,t)))

  ;Compute arg locals
  val clo = make-def(c, VMRef())
  set-imms(c, closure(e), [clo])
  val targ-locals = for a in targs(func) map :
    val x = make-def(c, VMRef())
    comment(c, "%_ is type argument %_" % [x, a])
    set-imms(c, a, [x])
    x
  val arg-locals = to-list $
    for a in args(func) seq-cat :
      val xs = make-defs(c, types(c,a))
      comment(c, "%_ is argument %_" % [xs, a])
      set-imms(c, a, xs)
      xs

  ;Load free
  for (a in cat(freetypes(e), freevars(e)), i in 0 to false) do :
    val x = make-def(c, VMRef())
    comment(c, "%_ is freevar %_" % [x, a])
    set-imms(c, a, [x])
    set-types(c, a, [VMRef()])
    val offset = 8 * i + field-offset(dec-table, TYPE-FREE-FIELD-ID)
    emit(c, LoadIns(x, clo, NumConst(offset)))

  ;Compile body
  val return-ctxt = TailContext() when tail?(func)
               else ReturnContext()
  compile-exp(exp-compiler, return-ctxt, body(func))
  val args = to-tuple $ cat-all $ [[clo, false], targ-locals, arg-locals]
  VMFunc(n(e), args, defs(c), instructions(c))


;============================================================
;================= Type Object Compilation ==================
;============================================================
defn compile-type-object (n:Int, args:List<Int>, t:KType, khier:KHierarchy, dec-table:DecTable, literal-defs:LiteralDefs) :
  val compiler = Compiler()
  val exp-compiler = ExpCompiler(khier, compiler, dec-table, literal-defs)
  comment(compiler, "Check typeof %_" % [t])
  ;Arguments
  val tobj = make-def(compiler, VMRef())
  val obj = make-def(compiler, VMRef())
  comment(compiler, "tobj is %_" % [tobj])
  comment(compiler, "obj is %_" % [obj])
  ;Freevars
  for (a in args, i in 0 to false) do :
    val local = make-def(compiler, VMRef())
    comment(compiler, "%_ is free var %_" % [local, a])
    val offset = 8 * i + field-offset(dec-table, TYPE-FREE-FIELD-ID)
    emit(compiler, LoadIns(local, tobj, NumConst(offset)))
    set-imms(compiler, a, [local])
    set-types(compiler, a, [VMRef()])
  val pass-lbl = make-label(compiler)
  val fail-lbl = make-label(compiler)
  comment(compiler, "Label %_ returns true" % [pass-lbl])
  comment(compiler, "Label %_ returns false" % [fail-lbl])
  compile-typeof(exp-compiler, obj, t, pass-lbl, fail-lbl)
  emit(compiler, LabelIns(pass-lbl))
  emit(compiler, ReturnIns([NumConst(1L)]))
  emit(compiler, LabelIns(fail-lbl))
  emit(compiler, ReturnIns([NumConst(0L)]))
  VMFunc(n, [tobj, false, obj], defs(compiler), instructions(compiler))

;============================================================
;=============== Initializer Compilation ====================
;============================================================
deftype Initializers
defmulti init-global (i:Initializers, n:Int, type:KType, e:KExp) -> False
defmulti add (i:Initializers, e:KExp) -> False
defmulti inits (i:Initializers) -> KExp

defn Initializers () :
  val inits = Vector<KExp>()
  new Initializers :
    defmethod init-global (this, n:Int, type:KType, e:KExp) :
      add(inits, KSet(KVarLoc(n), type, e))
    defmethod add (this, e:KExp) :
      add(inits, e)
    defmethod inits (this) :
      if empty?(inits) : KLSLiteral(false)
      else : KSeq(inits)

defn compile-init (i:Initializers, khier:KHierarchy, dec-table:DecTable, literal-defs:LiteralDefs) :
  val compiler = Compiler()
  val exp-compiler = ExpCompiler(khier, compiler, dec-table, literal-defs)
  compile-exp(exp-compiler, TargetContext([]), inits(i))
  emit(compiler, ReturnIns([]))
  VMFunc(0, [], defs(compiler), instructions(compiler))

;============================================================
;================ Expression Compilation ====================
;============================================================
deftype ExpCompiler
defmulti compile-typeof (e:ExpCompiler, obj:VMImm, t:KType, pass:Int, fail:Int) -> False
defmulti compile-exp (e:ExpCompiler, ctxt:Context, e:KExp) -> False

defn ExpCompiler (khier:KHierarchy, compiler:Compiler, dec-table:DecTable, literal-defs:LiteralDefs) :
  ;Track mutables
  val mutables = IntSet()

  ;Return context
  var return-ctxt:Context = ReturnContext()

  ;Utilities
  defn function-address (n:Int) :
    val lbl = extern-label(dec-table, n)
    match(lbl:Symbol) : ExternId(n)
    else : CodeId(n)
  defn global-address (n:Int) :
    val lbl = extern-label(dec-table, n)
    match(lbl:Symbol) : ExternId(n)
    else :
      if function?(dec-table, n) : CodeId(n)
      else if const?(dec-table, n) : ConstId(n)
      else : GlobalId(n)
  defn tcall (n:Int, args:Tuple<VMImm>) :
    val false-marker = Marker(VM-FALSE-TYPE-ID)
    val arity = length(args)
    val ys = to-tuple $ cat-all $ [
      [false-marker, NumConst(arity)]
      args]
    TCallIns(CodeId(n), ys)
  defn closure-nslots (k:KClosure) :
    length(targs(k)) + length(args(k))
  defn closure-size (k:KClosure) :
    8 + 8 + 8 * closure-nslots(k)
  defn store-closure-vars (c:Compiler, x:Local, k:KClosure) :
    val targs* = seq(imm{c, compile(_)}, targs(k))
    val args* = seq(imm{c, compile(_)}, args(k))
    emit(c, StoreIns(x, NumConst(0), NumConst(to-long(closure-nslots(k)))))
    emit(c, StoreIns(x, NumConst(8), CodeId(n(k))))
    for (o in 16 to false by 8, v in cat(targs*, args*)) do :
      emit(c, StoreIns(x, NumConst(o), v))

  ;Compiling a location
  defn compile (e:KLoc) -> CLoc :
    match(e) :
      (e:KVarLoc) :
        if global?(dec-table, n(e)) :
          val base = new CImms :
            defmethod types (this) : [VMLong()]
            defmethod imms (c, this) :
              [global-address(n(e))]
          PtrLoc(base, 0)
        else :
          VarLoc(n(e), 0)
      (e:KDeref) :        
        PtrLoc(compile(exp(e)), 0)
      (e:KDeptr) :
        PtrLoc(compile(exp(e)), 0)
      (e:KField) :
        match(compile(exp(e))) :
          (l:PtrLoc) :
            PtrLoc(
              base(l),
              offset(l) + field-offset(dec-table, n(e)))
          (l:ExpLoc) :
            ExpLoc(
              base(l),
              index(l) + field-index(dec-table, n(e)))
          (l:VarLoc) :
            VarLoc(
              n(l),
              index(l) + field-index(dec-table, n(e)))
      (e:KSlot) :
        ;Compute ptr and offset
        val [ptr, ptr-offset] = match(compile(exp(e))) :
          (l:PtrLoc) : [base(l), offset(l)]
          (l:ExpLoc) : [base(l), 0]
        ;Compute base compiled result
        val base = new CStore :
          defmethod types (this) :
            [VMLong()]
          defmethod store (c:Compiler, this, xs:Tuple<Local>) :
            ;ns = base
            ;offset = index
            ;offset = offset * size
            ;n = n + offset
            gen-ins(c, TargetContext(xs), ptr)
            val offset = make-def(c, VMLong())
            gen-ins(c, TargetContext([offset]), compile(index(e)))
            val size = to-long(size(dec-table, type(e)))
            emit(c, Op2Ins(offset, MulOp(), offset, NumConst(size))) when size != 1L
            emit(c, Op2Ins(xs[0], AddOp(), xs[0], offset))
        ;Return location
        PtrLoc(base, ptr-offset)
      (e:KValue) :
        ExpLoc(compile(exp(e)), 0)

  ;Compiling a type object
  defn compile (t:KType) -> CResult :
    println("compiling type %_" % [t])
    match(t) :
      (t:KTVar) :
        if global?(dec-table, n(t)) :
          fatal("Not yet implemented")
        else :
          new CImms :
            defmethod types (this) : [VMRef()]
            defmethod imms (c, this) : imms(c, n(t))
      (t:KTypeObject) :
        new CStore :
          defmethod types (this) : [VMRef()]
          defmethod store (c, this, xs:Tuple<Local>) :
            val ntargs = length(targs(t))
            val size = 8          ;length
                     + 8          ;code
                     + 8 * ntargs ;free
            ;Freevars
            val targs* = to-list(seq(imm{c, compile(_)}, targs(t)))
            ;Allocate object
            val x = xs[0]
            emit(c, AllocIns(xs, [VM-TYPE-TYPE-ID], [NumConst(size)]))
            ;Store fields
            val ys = cat-all $ [[NumConst(to-long(ntargs)), CodeId(n(t))], targs*]
            for (y in ys, o in 0 to false by 8) do :
              emit(c, StoreIns(x, NumConst(o), y))

  ;Compiling a typeof expression
  defn compile-typeof (c:Compiler, obj:VMImm, t:KType, pass:Int, fail:Int) :
    comment(c, "if %_ typeof %_: goto %_ else %_" % [obj, t, pass, fail])
    defn branch-when-instanceof (t:KOf, true-lbl:Int, false-lbl:Int) :
      val typeid = to-vm-id(n(t))
      emit(c, Branch1Ins(true-lbl, InstanceofOp(typeid), obj))
      emit(c, GotoIns(false-lbl))
    let loop (t:KType = t, true-lbl:Int = pass, false-lbl:Int = fail) :
      match(t) :
        (t:KTVar) :
          val pred = make-def(c, VMLong())
          val timm = imms(c, n(t))[0]
          emit(c, CallClosureIns([pred], timm, [timm, NumConst(1), obj]))
          emit(c, Branch1Ins(true-lbl, false, pred))
          emit(c, GotoIns(false-lbl))
        (t:KOf) :
          val typeid = to-vm-id(n(t))
          emit(c, Branch1Ins(true-lbl, InstanceofOp(typeid), obj))
          emit(c, GotoIns(false-lbl))
        (t:KAnd) :
          val next-lbl = make-label(c)
          loop(a(t), next-lbl, false-lbl)
          emit(c, LabelIns(next-lbl))
          loop(b(t), true-lbl, false-lbl)
        (t:KOr) :
          val next-lbl = make-label(c)
          loop(a(t), true-lbl, next-lbl)
          emit(c, LabelIns(next-lbl))
          loop(b(t), true-lbl, false-lbl)
        (t:KTop) :
          emit(c, GotoIns(true-lbl))
        (t:KBot) :
          emit(c, GotoIns(false-lbl))
    comment(c, "endif %_ typeof %_" % [obj, t])

  ;Compiling an expression
  defn compile (e:KExp) -> CResult :
    println("Compiling expression %_" % [e])
    match(e) :
      (e:KLet) :
        val v = compile(value(e))
        set-types(compiler, n(e), types(v))
        val body = compile(body(e))
        new CResult :
          defmethod types (this) : types(body)
          defmethod gen-ins (c, ctxt, this) :
            val xs = imms(c,v)
            set-imms(c, n(e), xs)
            comment(c, "val %_ = %_" % [n(e), xs])
            gen-ins(c, ctxt, body)
      (e:KLetType) :
        val v = compile(value(e))
        set-types(compiler, n(e), types(v))
        val body = compile(body(e))
        new CResult :
          defmethod types (this) : types(body)
          defmethod gen-ins (c:Compiler, ctxt:Context, this) :
            val xs = imms(c,v)
            set-imms(c, n(e), xs)
            comment(c, "reified type %_ = %_" % [n(e), xs])
            gen-ins(c, ctxt, body)            
      (e:KLetVar) :
        val v = match(value(e)) :
          (v:KExp) : compile(v)
          (v:False) : v
        val ts = to-tuple(vm-types(dec-table, type(e)))
        set-types(compiler, n(e), ts)
        add(mutables, n(e))
        val body = compile(body(e))
        new CResult :
          defmethod types (this) : types(body)
          defmethod gen-ins (c, ctxt, this) :
            val xs = make-defs(c, ts)
            set-imms(c, n(e), xs)
            comment(c, "var %_ = %_" % [n(e), xs])
            match(v:CResult) :
              gen-ins(c, TargetContext(xs), v)
            gen-ins(c, ctxt, body)
      (e:KLetRec) :
        ;Set types
        for n in ns(e) do :
          set-types(compiler, n, [VMRef()])
        val body = compile(body(e))
        val closures = values(e) as List<KClosure>
        new CResult :
          defmethod types (this) : types(body)
          defmethod gen-ins (c, ctxt, this) :
            ;Make locals and allocate closures
            val xs = to-tuple $ for n in ns(e) seq :
              val local = make-def(c, VMRef())
              set-imms(c, n, [local])
              local
            ;Compute sizes
            val sizes = to-tuple $ seq(NumConst{closure-size(_)}, closures)
            ;Allocate closures
            val types = to-tuple(repeat(VM-FN-TYPE-ID, length(ns(e))))
            comment(c, "Allocate closures %_ into %_" % [closures, xs])
            emit(c, AllocIns(xs, types, sizes))
            do(store-closure-vars{c, _, _}, xs, closures)
            comment(c, "Done allocating closures")
            ;Compile body
            gen-ins(c, ctxt, body)
      (e:KInterpret) :
        new CStore :
          defmethod types (this) : [to-vm-type(type(e))]
          defmethod store (c, this, xs:Tuple<Local>) :
            val y = compile(exp(e))
            emit(c, Op1Ins(xs[0], InterpretOp(), imm(c,y)))
      (e:KVar) :
        if global?(dec-table, n(e)) :
          val t = var-type(dec-table, n(e))
          new CStore :
            defmethod types (this) : to-tuple(vm-types(dec-table, t))
            defmethod store (c, this, xs:Tuple<Local>) :
              for (x in xs, o in field-offsets(dec-table, t)) do :
                emit(c, LoadIns(x, global-address(n(e)), NumConst(o)))
        else if mutables[n(e)] :
          ;TODO: Not necessary if we pull out
          ;mutated variables from expressions first.
          val ts = types(compiler, n(e))
          new CImms :
            defmethod types (this) : ts
            defmethod imms (c, this) :
              val xs = make-defs(c, types(c, n(e)))
              for (x in xs, y in imms(c, n(e))) do :
                emit(c, SetIns(x, y))
              xs
        else :
          val ts = types(compiler, n(e))
          new CImms :
            defmethod types (this) : ts
            defmethod imms (c, this) : imms(c, n(e))
      (e:KDo) :
        ;Result representing a call to known code
        defn ccall-result (get-args: Compiler -> [Int, Tuple<VMImm>, VMImm], closure?:True|False) :
          new CCall :
            defmethod types (this) :
              to-tuple(vm-types(dec-table, type(e)))
            defmethod closure? (this) :
              closure?
            defmethod call-args (c, this) :
              val [arity, args, f] = get-args(c)
              val closure = if closure? : f
                            else : Marker(VM-FALSE-TYPE-ID)
              val arity-imm = NumConst(to-long(arity))
              val arg-imms = to-tuple $ qquote(~ closure, ~ arity-imm, ~@ args)
              [arg-imms, f]
        ;Cases
        defn call-pointer (p:KExp, args:List<KExp>) :
          within c = ccall-result(false) :
            val args* = to-tuple(seq-cat(imms{c, compile(_)}, args))
            val func = imm(c, compile(p))
            [length(args), args*, func]
        defn call-closure (clo:KExp, targs:List<KType>, args:List<KExp>) :
          within c = ccall-result(true) :
            val args* = to-tuple $ cat(
              seq-cat(imms{c, compile(_)}, targs)
              seq-cat(imms{c, compile(_)}, args))
            val closure* = imm(c, compile(clo))
            [length(args), args*, closure*]
        defn call-code (n:Int, targs:List<KType>, args:List<KExp>) :
          within c = ccall-result(false) :
            val args* = to-tuple $ cat(
              seq-cat(imms{c, compile(_)}, targs)
              seq-cat(imms{c, compile(_)}, args))
            [length(args), args*, function-address(n)]
        ;Categorize
        match(func(e)) :
          (f:KVar|KCurry) :
            val [f*, targs] = match(f) :
              (f:KVar) : [f, List()]
              (f:KCurry) : [KVar(n(f)), targs(f)]
            if function?(dec-table, n(f)) : call-code(n(f), targs, args(e))
            else : call-closure(f*, targs, args(e))
          (f:KRead) :
            match(loc(f)) :
              (l:KDeptr) : call-pointer(exp(l), args(e))
              (l:KDeref) : call-closure(exp(l), List(), args(e))
          (f:KExp) :
            call-closure(f, List(), args(e))
      (e:KDoC) :
        new CStore :
          defmethod types (this) :
            to-tuple(vm-types(dec-table, type(e)))
          defmethod store (c, this, xs:Tuple<Local>) :
            val args* = to-tuple $ cat(
              seq-cat(imms{c, compile(_)}, args(e))
              seq-cat(imms{c, compile(_)}, varargs(e)))
            val f* = match(func(e)) :
              (f:KRead) :
                val l = loc(f) as KDeptr
                imm(c, compile(exp(l)))
              (f:KVar) :
                function-address(n(f))
            emit(c, CallCIns(xs, f*, args*))
      (e:KReturn) :
        val v = compile(exp(e))
        new CResult :
          defmethod types (this) : []
          defmethod gen-ins (c, ctxt, this) :
            gen-ins(c, return-ctxt, v)
      (e:KLSLiteral) :
        match(value(e)) :
          (v:Byte|Int|Long|Float|Double|Char|True|False) :
            val t = prim-vm-type(v)
            val v* = match(v) :
              (v:Char) : NumConst(to-byte(v))
              (v:True) : Marker(VM-TRUE-TYPE-ID)
              (v:False) : Marker(VM-FALSE-TYPE-ID)
              (v:Byte|Int|Long|Float|Double) : NumConst(v)
            new CImms :
              defmethod types (this) : [t]
              defmethod imms (c, this) : [v*]
          (v:String) :
            val id = def-data(literal-defs, string-bytes(v))
            new CImms :
              defmethod types (this) : [VMLong()]
              defmethod imms (c, this) : [id]
      (e:KLiteral) :
        defn tag (typeid:Int) :
          new CStore :
            defmethod types (this) : [VMRef()]
            defmethod store (c, this, xs:Tuple<Local>) :
              emit(c, Op1Ins(xs[0], TagOp(typeid), NumConst(value(e))))
        defn marker (typeid:Int) :
          new CImms :
            defmethod types (this) : [VMRef()]
            defmethod imms (c, this) : [Marker(typeid)]
        match(value(e)) :
          (v:Char) : tag(VM-CHAR-TYPE-ID)
          (v:Byte) : tag(VM-BYTE-TYPE-ID)
          (v:Int) : tag(VM-INT-TYPE-ID)
          (v:Float) : tag(VM-FLOAT-TYPE-ID)
          (v:True) : marker(VM-TRUE-TYPE-ID)
          (v:False) : marker(VM-FALSE-TYPE-ID)
      (e:KObject) :
        if empty?(args(e)) :
          new CImms :
            defmethod types (this) : [VMRef()]
            defmethod imms (c, this) : [Marker(to-vm-id(n(e)))]
        else :
          new CStore :
            defmethod types (this) : [VMRef()]
            defmethod store (c, this, xs:Tuple<Local>) :
              val size = size(dec-table, n(e))
              val offsets = field-offsets(dec-table, n(e))
              ;Evaluate arguments
              val args* = to-list(seq-cat(imms{c, compile(_)}, args(e)))
              ;Allocate object
              val x = xs[0]
              val typeid = to-vm-id(n(e))
              emit(c, AllocIns(xs, [typeid], [NumConst(size)]))
              ;Store fields
              for (a in args*, o in offsets) do :
                emit(c, StoreIns(x, NumConst(o), a))
      (e:KNewObject) :
        if empty?(targs(e)) and empty?(args(e)) :
          new CImms :
            defmethod types (this) : [VMRef()]
            defmethod imms (c, this) : [Marker(to-vm-id(n(e)))]
        else :
          new CStore :
            defmethod types (this) : [VMRef()]
            defmethod store (c:Compiler, this, xs:Tuple<Local>) :
              val ntargs = length(targs(e))
              val nargs = length(args(e))
              val nslots = ntargs + nargs
              ;Evaluate arguments
              val args* = to-list(seq(imm{c, compile(_)}, cat(targs(e), args(e))))
              ;Allocate object
              val typeid = to-vm-id(n(e))
              emit(c, AllocIns(xs, [typeid], [NumConst(8 * nslots)]))
              ;Store fields
              for (a in args*, o in 0 to false by 8) do :
                emit(c, StoreIns(xs[0], NumConst(o), a))
      (e:KArray) :
        new CStore :
          defmethod types (this) : [VMRef()]
          defmethod store (c, this, xs:Tuple<Local>) :
            val base-size = size(dec-table, n(e))
            val item-size = rest-size(dec-table, n(e))
            val offsets = field+rest-offsets(dec-table, n(e))
            ;Evaluate arguments
            val args* = to-list(seq-cat(imms{c, compile(_)}, args(e)))
            val len-arg = head(args*)
            ;Compute length
            val len = make-def(c, VMLong())
            emit(c, Op2Ins(len, MulOp(), len-arg, NumConst(to-long(item-size))))
            emit(c, Op2Ins(len, AddOp(), len, NumConst(to-long(base-size))))
            if item-size % 8 != 0 :
              emit(c, Op2Ins(len, AddOp(), len, NumConst(7L)))
              emit(c, Op2Ins(len, AndOp(), len, NumConst(-8L)))
            ;Allocate array
            val x = xs[0]
            val typeid = to-vm-id(n(e))
            emit(c, AllocIns(xs, [typeid], [len]))
            ;Store fields
            for (a in args*, o in offsets) do :
              emit(c, StoreIns(x, NumConst(o), a))
      (e:KStruct) :
        new CImms :
          defmethod types (this) : to-tuple(vm-types(dec-table, n(e)))
          defmethod imms (c, this) :
            to-tuple(seq-cat(imms{c, compile(_)}, args(e)))
      (e:KPtr) :
        val l = compile(loc(e)) as PtrLoc
        if offset(l) == 0 :
          base(l)
        else :
          new CStore :
            defmethod types (this) : [VMLong()]
            defmethod store (c, this, xs:Tuple<Local>) :
              gen-ins(c, TargetContext(xs), base(l))
              emit(c, Op2Ins(x, AddOp(), x, offset)) where :
                val x = xs[0]
                val offset = NumConst(to-long(offset(l)))
      (e:KSeq) :
        val a* = compile(a(e))
        val b* = compile(b(e))
        new CResult :
          defmethod types (this) : types(b*)
          defmethod gen-ins (c, ctxt, this) :
            gen-ins(c, TargetContext([]), a*)
            gen-ins(c, ctxt, b*)
      (e:KSet) :
        new CImms :
          defmethod types (this) :
            [VMRef()]
          defmethod imms (c, this) :
            match(compile(loc(e))) :
              (l:PtrLoc) :
                val p = imm(c, base(l))
                val vs = imms(c, compile(value(e)))
                val os = field-offsets(dec-table, type(e))
                for (v in vs, o in os) do :
                  emit(c, StoreIns(p, NumConst(o + offset(l)), v))
              (l:VarLoc) :
                val base = imms(c, n(l)) as Tuple<Local>
                val len = length(dec-table, type(e))
                val xs = base[index(l) to index(l) + len]
                gen-ins(c, TargetContext(xs), compile(value(e)))
            [Marker(VM-FALSE-TYPE-ID)]
      (e:KConv) :
        val t = to-vm-type(type(e))
        new CStore :
          defmethod types (this) : [t]
          defmethod store (c, this, xs:Tuple<Local>) :
            val y = compile(exp(e))
            val x = xs[0]
            emit(c, Op1Ins(x, ConvOp(), imm(c,y)))
      (e:KCheck) :
        match(type(e)) :
          (t:KBot) :
            new CResult :
              defmethod types (this) : []
              defmethod gen-ins (c, ctxt, this) :
                val obj = imm(c, compile(exp(e)))
                val targ* = imm(c, compile(tobj!(e)))
                emit(c, tcall(VM-CAST-ERROR-FN-ID, [NumConst(option(e)), obj, targ*]))
          (t) :
            new CStore :
              defmethod types (this) : [VMRef()]
              defmethod store (c, this, xs:Tuple<Local>) :
                val x = xs[0]
                val pass-lbl = make-label(c)
                val fail-lbl = make-label(c)
                gen-ins(c, TargetContext(xs), compile(exp(e)))
                compile-typeof(c, x, type(e), pass-lbl, fail-lbl)
                emit(c, LabelIns(fail-lbl))
                val targ* = imm(c, compile(tobj!(e)))
                emit(c, tcall(VM-CAST-ERROR-FN-ID, [NumConst(option(e)), x, targ*]))
                emit(c, LabelIns(pass-lbl))
      (e:KPrim) :
        ;Utilities
        ;defn binop (x:TGVar, op:TGOp, a:TGImm, b:TGImm) :
        ;  emit(TGBinOp(x, op, a, b))
        ;defn binop (n:Int, op:TGOp, a:TGImm, b:TGImm) :
        ;  binop(TGVar(n), op, a, b)
        ;defn unaop (x:TGVar, op:TGOp, a:TGImm) :
        ;  emit(TGUnaOp(x, op, a))
        ;defn unaop (n:Int, op:TGOp, a:TGImm) :
        ;  unaop(TGVar(n), op, a)
        ;defn detag-int (y:TGImm) :
        ;  val x = make-var(TGLongT())
        ;  binop(x, TGAshrOp(), y, TGLong(32L))
        ;  x
        ;defn detag-char (y:TGImm) :
        ;  val x = make-var(TGLongT())
        ;  val b = make-var(TGByteT())
        ;  binop(x, TGShrOp(), y, TGLong(3L))
        ;  emit(TGConv(b,x))
        ;  b
        ;defn tag-as-bool (x:TGVar, y:TGImm) :
        ;  binop(x, TGShlOp(), y, TGLong(3L))
        ;  binop(x, TGAddOp(), x, TGLong(to-long(MARKER-TAG-BITS)))
        ;defn tag-as-char (x:TGVar, y:TGImm) :
        ;  emit(TGConv(x,y))
        ;  binop(x, TGShlOp(), x, TGLong(3L))
        ;  binop(x, TGAddOp(), x, TGLong(to-long(CHAR-TAG-BITS)))

        ;Dispatch
        match(op(e)) :
          (op:Primitive) :
            switch contains?{_, op} :
              BINARY-OPS :
                val a = compile(args(e)[0])
                val b = compile(args(e)[1])
                new CStore :
                  defmethod types (this) : [VMRef()]
                  defmethod store (c, this, xs:Tuple<Local>) :
                    val a = imm(c, a)
                    val b = imm(c, b)
                    val op* = switch(op) :
                      ADD-OP : IntAddOp()
                      SUB-OP : IntSubOp()
                      MUL-OP : IntMulOp()
                      DIV-OP : IntDivOp()
                      MOD-OP : IntModOp()
                      AND-OP : IntAndOp()
                      OR-OP : IntOrOp()
                      XOR-OP : IntXorOp()
                      SHL-OP : IntShlOp()
                      SHR-OP : IntShrOp()
                      ASHR-OP : IntAshrOp()
                      LT-OP : IntLtOp()
                      GT-OP : IntGtOp()
                      LE-OP : IntLeOp()
                      GE-OP : IntGeOp()
                      NE-OP : RefNeOp()
                      EQ-OP : RefEqOp()
                      IDENTICAL-OP : RefEqOp()
                      else : fatal("Primitive op %_ not supported." % [op])                    
                    emit(c, Op2Ins(xs[0], op*, a, b))
                      ;AGET-OP :
                      ;  val o = make-var(TGLongT())
                      ;  binop(o, TGAshrOp(), b, TGLong(32L - 3L))
                      ;  binop(o, TGAddOp(), o, a)
                      ;  emit(TGLoad(TGVar(n), o, foffset(RAWARRAY-ITEMS-FIELD-ID)))
                      ;CHAR-AGET-OP :
                      ;  val o = make-var(TGLongT())
                      ;  val c = make-var(TGByteT())
                      ;  binop(o, TGAshrOp(), b, TGLong(32L))
                      ;  binop(o, TGAddOp(), o, a)
                      ;  emit(TGLoad(c, o, foffset(CHARARRAY-CHARS-FIELD-ID)))
                      ;  tag-as-char(TGVar(n), c)
                      ;STRING-GET-OP :
                      ;  val o = make-var(TGLongT())
                      ;  val c = make-var(TGByteT())
                      ;  binop(o, TGAshrOp(), b, TGLong(32L))
                      ;  binop(o, TGAddOp(), o, a)
                      ;  emit(TGLoad(c, o, foffset(STRING-CHARS-FIELD-ID)))
                      ;  tag-as-char(TGVar(n), c)
              UNARY-OPS :
                val a = compile(head(args(e)))
                new CStore :
                  defmethod types (this) : [VMRef()]
                  defmethod store (c, this, xs:Tuple<Local>) :
                    val a = imm(c, a)
                    val op* = switch(op) :
                      NOT-OP : IntNotOp()
                      NEG-OP : IntNegOp()
                      else : fatal("Primitive op %_ not supported." % [op])
                    emit(c, Op1Ins(xs[0], op*, a))

                    ;  ALEN-OP :
                    ;    emit(TGLoad(TGVar(n), a, 8 - REF-TAG-BITS))
                    ;    binop(n, TGShlOp(), TGVar(n), TGLong(32L))
                    ;  STRING-LEN-OP :
                    ;    emit(TGLoad(TGVar(n), a, 8 - REF-TAG-BITS))
                    ;    binop(n, TGShlOp(), TGVar(n), TGLong(32L))
              EFFECTFUL-TERNARY-OPS :
                fatal("Not yet implemented")
                ;val a = cexp(args(e)[0])
                ;val b = cexp(args(e)[1])
                ;val c = cexp(args(e)[2])
                ;new CImm :
                ;  defmethod types (this) :
                ;    List(TGRefT())
                ;  defmethod imms (this) :
                ;    val a = imm(a)
                ;    val b = imm(b)
                ;    val c = imm(c)
                ;    switch(op) :
                ;      ASET-OP :
                ;        val o = make-var(TGLongT())
                ;        binop(o, TGAshrOp(), b, TGLong(32L - 3L))
                ;        binop(o, TGAddOp(), o, a)
                ;        emit(TGStore(o, c, foffset(RAWARRAY-ITEMS-FIELD-ID)))
                ;      CHAR-ASET-OP :
                ;        val o = make-var(TGLongT())
                ;        binop(o, TGAshrOp(), b, TGLong(32L))
                ;        binop(o, TGAddOp(), o, a)
                ;        emit(TGStore(o, detag-char(c), foffset(CHARARRAY-CHARS-FIELD-ID)))
                ;    List(false-marker)
          (op:GetterPrimitive) :
            defn get-op (t:VMType, op:VMOp) : 
              new CStore :
                defmethod types (this) : [t]
                defmethod store (c:Compiler, this, xs:Tuple<Local>) :
                  emit(c, Op0Ins(xs[0], op))
            switch(op) :
              GET-GLOBAL-TABLE-OP : get-op(VMLong(), GlobalsOp())
              GET-CONSTS-OP : get-op(VMLong(), ConstsOp())
              GET-CONSTS-DATA-OP : get-op(VMLong(), ConstsDataOp())
              GET-STACK-OP : get-op(VMRef(), CurrentStackOp())
              else :
                fatal("Not yet implemented")
            ;if op == GET-SP-OP :
            ;  new CImm & Ignorable :
            ;    defmethod types (this) : List(TGLongT())
            ;    defmethod imms (this) : List(TGRegSP())
            ;else :
            ;  new CExp & Ignorable :
            ;    defmethod types (this) :
            ;      tgt-types(dec-table, type(e))
            ;    defmethod set (ns:List<Int>, this) :
            ;      val x = TGVar(head(ns))
            ;      val p = TGMem(lbl(op),0)
            ;      emit(TGLoad(x, p, 0))
          (op:LSPrimitive) :
            if op == LS-YIELD-OP :
              val s = compile(args(e)[0])
              val y = compile(args(e)[1])
              new CStore :
                defmethod types (this) : [VMRef()]
                defmethod store (c:Compiler, this, xs:Tuple<Local>) :
                  emit(c, YieldIns(xs, imm(c,s), [imm(c,y)]))
            else if op == LS-ENTER-OP :
              val s = compile(args(e)[0])
              val y = compile(args(e)[1])
              new CStore :
                defmethod types (this) : [VMRef()]
                defmethod store (c:Compiler, this, xs:Tuple<Local>) :
                  emit(c, YieldIns(xs, imm(c,s), [Marker(VM-FALSE-TYPE-ID), NumConst(1L), imm(c,y)]))
            else if op == LS-NEW-STACK-OP :
              val f = compile(args(e)[0])
              new CStore :
                defmethod types (this): [VMRef()]
                defmethod store (c:Compiler, this, xs:Tuple<Local>) :
                  emit(c, NewStackIns(xs[0], imm(c,f)))
            else :
              switch contains?{_, op} :
                LS-BINARY-OPS :
                  val a = compile(args(e)[0])
                  val b = compile(args(e)[1])
                  new CStore :
                    defmethod types (this) :
                      switch(op) :
                        LS-ADD-OP : types(a)
                        LS-SUB-OP : types(a)
                        LS-MUL-OP : types(a)
                        LS-DIV-OP : types(a)
                        LS-MOD-OP : types(a)
                        LS-AND-OP : types(a)
                        LS-OR-OP : types(a)
                        LS-XOR-OP : types(a)
                        LS-SHL-OP : types(a)
                        LS-SHR-OP : types(a)
                        LS-ASHR-OP : types(a)
                        LS-EQ-OP : [VMLong()]
                        LS-NE-OP : [VMLong()]
                        LS-LT-OP : [VMLong()]
                        LS-GT-OP : [VMLong()]
                        LS-LE-OP : [VMLong()]
                        LS-GE-OP : [VMLong()]
                        LS-ULT-OP : [VMLong()]
                        LS-UGT-OP : [VMLong()]
                        LS-ULE-OP : [VMLong()]
                        LS-UGE-OP : [VMLong()]
                    defmethod store (c:Compiler, this, xs:Tuple<Local>) :
                      val op* = switch(op) :
                        LS-ADD-OP : AddOp()
                        LS-SUB-OP : SubOp()
                        LS-MUL-OP : MulOp()
                        LS-DIV-OP : DivOp()
                        LS-MOD-OP : ModOp()
                        LS-AND-OP : AndOp()
                        LS-OR-OP : OrOp()
                        LS-XOR-OP : XorOp()
                        LS-SHL-OP : ShlOp()
                        LS-SHR-OP : ShrOp()
                        LS-ASHR-OP : AshrOp()
                        LS-EQ-OP : EqOp()
                        LS-NE-OP : NeOp()
                        LS-LT-OP : LtOp()
                        LS-GT-OP : GtOp()
                        LS-LE-OP : LeOp()
                        LS-GE-OP : GeOp()
                        LS-ULT-OP : UltOp()
                        LS-UGT-OP : UgtOp()
                        LS-ULE-OP : UleOp()
                        LS-UGE-OP : UgeOp()
                      emit(c, Op2Ins(xs[0], op*, imm(c,a), imm(c,b)))
                LS-UNARY-OPS :
                  ;Translation between different types
                  defn to-IntType (t:VMType) :
                    match(t) :
                      (t:VMFloat) : VMInt()
                      (t:VMDouble) : VMLong()
                  defn to-RealType (t:VMType) :
                    match(t) :
                      (t:VMInt) : VMFloat()
                      (t:VMLong) : VMDouble()
                  
                  val a = compile(head(args(e)))
                  new CStore :
                    defmethod types (this) :
                      switch(op) :
                        LS-NOT-OP : types(a)
                        LS-NEG-OP : types(a)
                        LS-BITS-OP : [to-IntType(types(a)[0])]
                        LS-FNUM-OP : [to-RealType(types(a)[0])]
                    defmethod store (c:Compiler, this, xs:Tuple<Local>) :
                      switch(op) :
                        LS-NOT-OP :
                          emit(c, Op1Ins(xs[0], NotOp(), imm(c,a)))
                        LS-NEG-OP :
                          emit(c, Op1Ins(xs[0], NegOp(), imm(c,a)))
                        LS-BITS-OP :
                          emit(c, Op1Ins(xs[0], InterpretOp(), imm(c,a)))
                        LS-FNUM-OP :
                          emit(c, Op1Ins(xs[0], InterpretOp(), imm(c,a)))
          (op:AddrPrimitive) :
            fatal("Not yet implemented")
            ;new CImm & Ignorable :
            ;  defmethod types (this) : List(TGLongT())
            ;  defmethod imms (this) : List(TGMem(lbl(op),0))
          (op:SetterPrimitive) :
            fatal("Not yet implemented")
            ;val a = cexp(head(args(e)))
            ;new CImm :
            ;  defmethod types (this) :
            ;    List(TGLongT())
            ;  defmethod imms (this) :
            ;    val p = TGMem(lbl(op),0)
            ;    emit(TGStore(p, imm(a), 0))
            ;    List(TGLong(0L))
      (e:KTagPrim) :
        val type = to-vm-id(n(e))
        val e* = compile(exp(e))
        new CStore :
          defmethod types (this) : [VMRef()]
          defmethod store (c, this, xs:Tuple<Local>) :
            emit(c, Op1Ins(xs[0], TagOp(type), imm(c,e*)))
      (e:KDetagPrim) :
        val type = to-vm-id(n(e))
        val e* = compile(exp(e))
        new CStore :
          defmethod types (this) :
            val t = switch(type) :
              VM-BYTE-TYPE-ID : VMByte()
              VM-CHAR-TYPE-ID : VMByte()
              VM-INT-TYPE-ID : VMInt()
              VM-FLOAT-TYPE-ID : VMFloat()
            [t]
          defmethod store (c, this, xs:Tuple<Local>) :
            emit(c, Op1Ins(xs[0], DetagOp(type), imm(c, e*)))
      (e:KLabels) :
        ;Compute types
        val kblocks = blocks(e) as List<KBlock>
        for b in kblocks do :
          for a in targs(b) do :
            set-types(compiler, a, [VMRef()])
          for (a in args(b), t in types(b)) do :
            set-types(compiler, a, to-tuple(vm-types(dec-table,t)))

        new CResult :
          defmethod types (this) : []
          defmethod gen-ins (c, ctxt, this) :
            ;Create locals for each argument to each block
            for b in blocks(e) as List<KBlock> do :
              ;Locals for type arguments
              val targ-locals = to-tuple $
                for a in targs(b) seq :
                  val local = make-def(c, VMRef())
                  set-imms(c, a, [local])
                  local
              ;Locals for arguments
              val arg-locals = to-tuple $
                for a in args(b) seq-cat :
                  val locals = make-defs(c, types(c,a))
                  set-imms(c, a, locals)
                  locals
              ;Register as immediates for blocks as well
              set-block-locals(c, n(b), to-tuple(cat(targ-locals, arg-locals)))
              ;Register block label
              set-block-label(c, n(b), make-label(c))
            ;Generate instructions for each block
            val end-label = make-label(c)
            for b in blocks(e) as List<KBlock> do :
              emit(c, LabelIns(block-label(c, n(b))))
              gen-ins(c, ctxt, compile(body(b)))
              emit(c, GotoIns(end-label))
            emit(c, LabelIns(end-label))
      (e:KGoto) :
        new CResult :
          defmethod types (this) : []
          defmethod gen-ins (c, ctxt, this) :
            ;Locals for type arguments
            val targ-locals = to-tuple $
              for a in targs(e) seq :
                val local = make-def(c, VMRef())
                gen-ins(c, TargetContext([local]), compile(a))
                local
            ;Locals for arguments
            val arg-locals = to-tuple $
              for a in args(e) seq-cat :
                val a* = compile(a)
                val locals = make-defs(c, types(a*))
                gen-ins(c, TargetContext(locals), a*)
                locals
            ;Set label arguments
            for (x in block-locals(c, n(e)), y in cat(targ-locals, arg-locals)) do :
              emit(c, SetIns(x,y))
            ;Jump
            emit(c, GotoIns(block-label(c,n(e))))
      (e:KMatch) :
        new CResult :
          defmethod types (this) : []
          defmethod gen-ins (c, ctxt, this) :
            ;Compile arguments
            val args* = map(imm{c, compile(_)}, args(e))
            ;Compile branches
            val end-lbl = make-label(c)
            for b in branches(e) as List<KBranch> do :
              ;Compute typeof
              val fail-lbl = make-label(c)
              for (a in args*, t in types(b)) do :
                val pass-lbl = make-label(c)
                compile-typeof(c, a, t, pass-lbl, fail-lbl)
                emit(c, LabelIns(pass-lbl))
              ;Compute types and locals
              for (a in args(b), a* in args*, t in types(b)) do :
                val ts = to-tuple(vm-types(dec-table, t))
                val xs = make-defs(c,ts)
                set-types(c, a, ts)
                set-imms(c, a, xs)
                emit(c, SetIns(xs[0], a*))
              ;Compile body
              gen-ins(c, ctxt, compile(body(b)))
              emit(c, GotoIns(end-lbl))
              ;If fail
              emit(c, LabelIns(fail-lbl))
            tcall(VM-NO-BRANCH-ERROR-FN-ID, [])
            ;Ending label
            emit(c, LabelIns(end-lbl))
      (e:KDispatch) :
        new CResult :
          defmethod types (this) : []
          defmethod gen-ins (c:Compiler, ctxt:Context, this) :            
            ;Compute dispatch ordering
            val branches = to-tuple(branches(e) as List<KBranch>)
            defn branch-types (e:KBranch) : map(erase-tvars, types(e))
            val dispatches = map(value, dispatch-ordering(khier, seq(branch-types, branches)))
            ;Compile arguments
            val args* = map(imm{c, compile(_)}, args(e))
            ;Compile branches
            val end-lbl = make-label(c)
            for dispatch in dispatches do :
              match(dispatch) :
                (dispatch:List<Int>) :
                  println("Ambiguity branch %_." % [dispatch])
                (dispatch:Int) :
                  val b = branches[dispatch]
                  val types = branch-types(b)
                  val end-body = make-label(c)
                  for (a in args(b), x in args*) do :
                    set-types(c, a, [VMRef()])
                    set-imms(c, a, [x])
                  for (x in args*, t in types) do :
                    val pass-lbl = make-label(c)
                    compile-typeof(c, x, t, pass-lbl, end-body)
                    emit(c, LabelIns(pass-lbl))
                  gen-ins(c, ctxt, compile(body(b)))
                  emit(c, GotoIns(end-lbl))
                  emit(c, LabelIns(end-body))
            tcall(VM-NO-BRANCH-ERROR-FN-ID, [])
            emit(c, LabelIns(end-lbl))
      (e:KBox) :
        new CStore :
          defmethod types (this) : [VMRef()]
          defmethod store (c, this, xs:Tuple<Local>) :
            val size = size(dec-table, BOX-TYPE-ID)
            val v = match(exp(e)) :
              (v:KExp) : imm(c, compile(v))
              (f:False) : Marker(VM-VOID-TYPE-ID)
            emit(c, AllocIns(xs, [to-vm-id(BOX-TYPE-ID)], [NumConst(size)]))
            emit(c, StoreIns(xs[0], NumConst(0), v))
      (e:KBoxGet) :
        new CStore :
          defmethod types (this) : [VMRef()]
          defmethod store (c, this, xs:Tuple<Local>) :
            val box = imm(c, compile(exp(e)))
            emit(c, LoadIns(xs[0], box, NumConst(0)))
      (e:KBoxSet) :
        new CImms :
          defmethod types (this) : [VMRef()]
          defmethod imms (c, this) :
            val box = imm(c, compile(exp(e)))
            val v = imm(c, compile(value(e)))
            emit(c, StoreIns(box, NumConst(0), v))
            [Marker(VM-FALSE-TYPE-ID)]
      (e:KClosure) :
        new CStore :
          defmethod types (this) : [VMRef()]
          defmethod store (c, this, xs:Tuple<Local>) :
            comment(c, "Allocate closure %_ into %_" % [e, xs[0]])
            emit(c, AllocIns(xs, [VM-FN-TYPE-ID], [NumConst(closure-size(e))]))
            store-closure-vars(c, xs[0], e)
            comment(c, "Done allocating closure")            
      (e:KTuple) :
        new CStore :
          defmethod types (this) : [VMRef()]
          defmethod store (c, this, xs:Tuple<Local>) :
            val size = NumConst(8 + 8 * length(exps(e)))
            val exps* = to-list(seq(imm{c, compile(_)}, exps(e)))
            emit(c, AllocIns(xs, [VM-TUPLE-TYPE-ID], [size]))
            for (a in exps*, o in 8 to false by 8) do :
              emit(c, StoreIns(xs[0], NumConst(o), a))
      (e:KVoidTuple) :
        new CStore :
          defmethod types (this) : [VMRef()]
          defmethod store (c, this, xs:Tuple<Local>) :
            emit(c, CallIns(xs, void-fn, [mfalse, one, len])) where :
              val void-fn = CodeId(VM-VOID-TUPLE-FN-ID)
              val mfalse = Marker(VM-FALSE-TYPE-ID)
              val one = NumConst(1L)
              val len = NumConst(to-long(length(e)))
      (e:KTupleGet) :
        new CStore :
          defmethod types (this) : [VMRef()]
          defmethod store (c, this, xs:Tuple<Local>) :
            val tuple = imm(c, compile(exp(e)))
            val offset = 8 * index(e) + field-offset(dec-table, TUPLE-ITEMS-FIELD-ID)
            emit(c, LoadIns(xs[0], tuple, NumConst(offset)))
      (e:KTupleSet) :
        new CStore :
          defmethod types (this) : [VMRef()]
          defmethod store (c, this, xs:Tuple<Local>) :
            val tuple = imm(c, compile(tuple(e)))
            val value = imm(c, compile(exp(e)))
            val offset = 8 * index(e) + field-offset(c, TUPLE-ITEMS-FIELD-ID)
            emit(c, StoreIns(tuple, NumConst(offset), value))
      (e:KEnsureLength) :
        new CStore :
          defmethod types (this) : [VMRef()]
          defmethod store (c, this, xs:Tuple<Local>) :
            gen-ins(c, TargetContext(xs), compile(exp(e)))
            val pass-lbl = make-label(c)
            val len = make-def(c, VMLong())
            val expected-len = NumConst(to-long(length(e)))
            emit(c, LoadIns(len, xs[0], NumConst(8)))
            emit(c, Branch2Ins(pass-lbl, EqOp(), len, expected-len))
            tcall(VM-LENGTH-ERROR-FN-ID, [len, expected-len])
            emit(c, LabelIns(pass-lbl))
      (e:KEnsureSet) :
        new CStore :
          defmethod types (this) : [VMRef()]
          defmethod store (c:Compiler, this, xs:Tuple<Local>) :
            gen-ins(c, TargetContext(xs), compile(exp(e)))
            val pass-lbl = make-label(c)
            emit(c, Branch2Ins(pass-lbl, RefNeOp(), xs[0], Marker(VM-VOID-TYPE-ID)))
            tcall(VM-VARIABLE-UNINITIALIZED-ERROR-FN-ID, [])
            emit(c, LabelIns(pass-lbl))
      (e:KIf) :
        new CResult :
          defmethod types (this) : []
          defmethod gen-ins (c:Compiler, ctxt:Context, this) :
            ;Compile predicate
            defn compile-pred (pred:KExp, true-lbl:Int, false-lbl:Int) :
              match(pred) :
                (pred:KAndExp) :
                  val kont-lbl = make-label(c)
                  compile-pred(a(pred), kont-lbl, false-lbl)
                  emit(c, LabelIns(kont-lbl))
                  compile-pred(b(pred), true-lbl, false-lbl)
                (pred:KOrExp) :
                  val kont-lbl = make-label(c)
                  compile-pred(a(pred), true-lbl, kont-lbl)
                  emit(c, LabelIns(kont-lbl))
                  compile-pred(b(pred), true-lbl, false-lbl)
                (pred:KExp) :
                  val p = imm(c, compile(pred))
                  emit(c, Branch1Ins(true-lbl, false, p))
                  emit(c, GotoIns(false-lbl))

            ;Body
            val true-lbl = make-label(c)
            val false-lbl = make-label(c)
            val end-lbl = make-label(c)
            compile-pred(pred(e), true-lbl, false-lbl)
            emit(c, LabelIns(true-lbl))
            gen-ins(c, ctxt, compile(conseq(e)))
            emit(c, GotoIns(end-lbl))
            emit(c, LabelIns(false-lbl))
            gen-ins(c, ctxt, compile(alt(e)))
            emit(c, GotoIns(end-lbl))
            emit(c, LabelIns(end-lbl))
      (e:KSizeof) :
        new CImms :
          defmethod types (this) : [VMLong()]
          defmethod imms (c, this) :
            val size = size(dec-table, type(e))
            [NumConst(to-long(size))]
      (e:KTagof) :
        new CImms :
          defmethod types (this) : [VMLong()]
          defmethod imms (c, this) : [Tag(n(e))]            
      (e:KRead) :
        match(compile(loc(e))) :
          (l:PtrLoc) :
            new CStore :
              defmethod types (this) :
                to-tuple(vm-types(dec-table, type(e)))
              defmethod store (c, this, xs:Tuple<Local>) :
                val b = imm(c, base(l))
                for (x in xs, o in field-offsets(dec-table, type(e))) do :
                  emit(c, LoadIns(x, b, NumConst(to-long(offset(l) + o))))
          (l:ExpLoc) :
            new CImms :
              defmethod types (this) :
                to-tuple(vm-types(dec-table, type(e)))
              defmethod imms (c, this) :
                val xs = imms(c, base(l))
                val len = length(dec-table, type(e))
                xs[index(l) to index(l) + len]
          (l:VarLoc) :
            defn slice<?T> (xs:Tuple<?T>) :
              val len = length(dec-table, type(e))
              xs[index(l) to index(l) + len]
              
            if mutables[n(l)] :
              ;Not necessary if mutables pulled out
              new CImms :
                defmethod types (this) :
                  to-tuple(vm-types(dec-table, type(e)))
                defmethod imms (c, this) :
                  val ts = slice(types(c,n(l)))
                  val xs = make-defs(c, ts)
                  val ys = slice(imms(c,n(l)))
                  for (x in xs, y in ys) do :
                    emit(c, SetIns(x,y))
                  xs
            else :
              new CImms :
                defmethod types (this) :
                  to-tuple(vm-types(dec-table, type(e)))
                defmethod imms (c, this) :
                  slice(imms(c,n(l)))                  
      (e:KObjectGet) : 
        new CStore :
          defmethod types (this) : [VMRef()]
          defmethod store (c, this, xs:Tuple<Local>) :
            val obj = imm(c, compile(object(e)))
            val num-targs = object-tarity(dec-table, n(e))
            val offset = 8 * (num-targs + index(e))
            emit(c, LoadIns(xs[0], obj, NumConst(offset)))
      (e:KObjectTGet) : 
        new CStore :
          defmethod types (this) : [VMRef()]
          defmethod store (c, this, xs:Tuple<Local>) :
            val obj = imm(c, compile(object(e)))
            val offset = 8 * index(e)
            emit(c, LoadIns(xs[0], obj, NumConst(offset)))
      (e) :
        fatal("Not yet implemented")

  ;Return compiler
  new ExpCompiler :
    defmethod compile-exp (this, ctxt:Context, e:KExp) :
      let-var return-ctxt = ctxt :
        gen-ins(compiler, ctxt, compile(e))
    defmethod compile-typeof (this, obj:VMImm, t:KType, pass:Int, fail:Int) :
      compile-typeof(compiler, obj, t, pass, fail)

;============================================================
;================== Primitive Operations ====================
;============================================================

val BINARY-OPS = [ADD-OP, SUB-OP, MUL-OP, DIV-OP, MOD-OP, AND-OP,
                  OR-OP, XOR-OP, SHL-OP, SHR-OP, ASHR-OP, EQ-OP, NE-OP,
                  LT-OP, GT-OP, LE-OP, GE-OP, IDENTICAL-OP, AGET-OP,
                  CHAR-AGET-OP, STRING-GET-OP]
val UNARY-OPS = [NOT-OP, NEG-OP, ALEN-OP, STRING-LEN-OP]
val EFFECTFUL-TERNARY-OPS = [ASET-OP, CHAR-ASET-OP]
val LS-BINARY-OPS = [LS-ADD-OP, LS-SUB-OP, LS-MUL-OP, LS-DIV-OP, LS-MOD-OP,
                     LS-AND-OP, LS-OR-OP, LS-XOR-OP, LS-SHL-OP, LS-SHR-OP,
                     LS-ASHR-OP, LS-EQ-OP, LS-NE-OP, LS-LT-OP, LS-GT-OP,
                     LS-LE-OP, LS-GE-OP, LS-ULT-OP, LS-UGT-OP, LS-ULE-OP, LS-UGE-OP]
val LS-UNARY-OPS = [LS-NOT-OP, LS-NEG-OP, LS-BITS-OP, LS-FNUM-OP]

;============================================================
;====================== Types ===============================
;============================================================

defn to-vm-type (t:KType) :
  match(t) :
    (t:KByteT) : VMByte()
    (t:KIntT) : VMInt()
    (t:KLongT) : VMLong()
    (t:KFloatT) : VMFloat()
    (t:KDoubleT) : VMDouble()
    (t:KPtrT) : VMLong()
    (t) : VMRef()

defn prim-vm-type (v) :
  match(v) :
    (v:Char) : VMByte()
    (v:Byte) : VMByte()
    (v:Int) : VMInt()
    (v:Long) : VMLong()
    (v:Float) : VMFloat()
    (v:Double) : VMDouble()
    (v:True) : VMRef()
    (v:False) : VMRef()

;============================================================
;=================== Compiler Tools =========================
;============================================================

;Definition of a compiler
deftype Compiler
defmulti emit (c:Compiler, i:VMIns) -> False
defmulti types (c:Compiler, n:Int) -> Tuple<VMType>
defmulti imms (c:Compiler, n:Int) -> Tuple<VMImm>
defmulti set-types (c:Compiler, n:Int, ts:Tuple<VMType>) -> False
defmulti set-imms (c:Compiler, n:Int, imms:Tuple<VMImm>) -> False
defmulti make-def (c:Compiler, t:VMType) -> Local
defmulti make-label (c:Compiler) -> Int
defmulti defs (c:Compiler) -> Tuple<VMDef>
defmulti instructions (c:Compiler) -> Tuple<VMIns>
defmulti set-block-locals (c:Compiler, n:Int, locals:Tuple<Local>) -> False
defmulti set-block-label (c:Compiler, n:Int, lbl:Int) -> False
defmulti block-label (c:Compiler, n:Int) -> Int
defmulti block-locals (c:Compiler, n:Int) -> Tuple<Local>

defn comment (c:Compiler, msg) :
  emit(c, CommentIns(to-string(msg)))

defn make-defs (c:Compiler, ts:Tuple<VMType>) :
  map(make-def{c, _}, ts)

defn Compiler () :
  val defs = Vector<VMDef>()
  val immtable = IntTable<Tuple<VMImm>>()
  val typetable = IntTable<Tuple<VMType>>()
  val ins = Vector<VMIns>()
  val labelcounter = to-seq(0 to false)
  val block-labels = IntTable<Int>()
  new Compiler :
    defmethod emit (this, i:VMIns) : add(ins, i)
    defmethod types (this, n:Int) : typetable[n]
    defmethod imms (this, n:Int) : immtable[n]
    defmethod set-types (this, n:Int, ts:Tuple<VMType>) : typetable[n] = ts
    defmethod set-imms (this, n:Int, xs:Tuple<VMImm>) : immtable[n] = xs
    defmethod make-def (this, t:VMType) :
      val i = length(defs)
      add(defs, VMDef(i, t, i))
      Local(i)
    defmethod defs (this) : to-tuple(defs)
    defmethod instructions (this) : to-tuple(ins)
    defmethod make-label (this) : next(labelcounter)
    defmethod set-block-locals (this, n:Int, locals:Tuple<Local>) : immtable[n] = locals
    defmethod block-locals (this, n:Int) : immtable[n] as Tuple<Local>
    defmethod set-block-label (this, n:Int, lbl:Int) : block-labels[n] = lbl
    defmethod block-label (this, n:Int) : block-labels[n]

;Representation of a compiled result
deftype CResult
deftype Context
defmulti types (r:CResult) -> Tuple<VMType>
defmulti gen-ins (compiler:Compiler, ctxt:Context, r:CResult) -> False

;Representation of a compiled location
deftype CLoc
defstruct PtrLoc <: CLoc :
  base: CResult
  offset: Int
defstruct VarLoc <: CLoc :
  n: Int
  index: Int
defstruct ExpLoc <: CLoc :
  base: CResult
  index: Int

;============================================================
;============== Specialized Results/Contexts ================
;============================================================
defstruct TargetContext <: Context :
  locals: Tuple<Local>

deftype AcceptContext <: Context
defmulti accept (compiler:Compiler, c:AcceptContext, imms:Tuple<VMImm>) -> False

defstruct TailContext <: Context

;Represents a non-forwarded compiled result.
deftype CValue <: CResult

deftype CImms <: CValue

deftype CStore <: CValue
defmulti store (compiler:Compiler, c:CStore, xs:Tuple<Local>) -> False

deftype CCall <: CValue
defmulti call-args (compiler:Compiler, c:CCall) -> [Tuple<VMImm>, VMImm]
defmulti closure? (c:CCall) -> True|False

defmulti imms (compiler:Compiler, r:CResult) -> Tuple<VMImm>
defmethod imms (compiler:Compiler, r:CResult) :
  val xs = map(make-def{compiler, _}, types(r))
  gen-ins(compiler, TargetContext(xs), r)
  xs

defn imm (compiler:Compiler, r:CResult) :
  val xs = imms(compiler, r)
  fatal("Result does not have a single immediate.") when length(xs) != 1
  xs[0]

defmethod gen-ins (compiler:Compiler, ctxt:AcceptContext, c:CImms) :
  accept(compiler, ctxt, imms(compiler, c))

defmethod gen-ins (compiler:Compiler, ctxt:AcceptContext, r:CValue) :
  accept(compiler, ctxt, imms(compiler,r))

defmethod gen-ins (compiler:Compiler, ctxt:TargetContext, c:CStore) :
  store(compiler, c, locals(ctxt))

defmethod gen-ins (compiler:Compiler, ctxt:TargetContext, c:CImms) :
  for (x in locals(ctxt), y in imms(compiler, c)) do :
    emit(compiler, SetIns(x, y))

defmethod gen-ins (compiler:Compiler, ctxt:TargetContext, c:CCall) :
  val [args, func] = call-args(compiler, c)
  if closure?(c) : emit(compiler, CallClosureIns(locals(ctxt), func, args))
  else : emit(compiler, CallIns(locals(ctxt), func, args))

defmethod gen-ins (compiler:Compiler, ctxt:TailContext, c:CCall) :
  val [args, func] = call-args(compiler, c)
  if closure?(c) : emit(compiler, TCallClosureIns(func, args))
  else : emit(compiler, TCallIns(func, args))

defmethod gen-ins (compiler:Compiler, ctxt:TailContext, r:CValue) :
  emit(compiler, ReturnIns(imms(compiler,r)))

;============================================================
;================ Convenience Contexts ======================
;============================================================

defstruct ReturnContext <: AcceptContext
defmethod accept (compiler:Compiler, ctxt:ReturnContext, imms:Tuple<VMImm>) :
  emit(compiler, ReturnIns(imms))

;============================================================
;======================= Roots ==============================
;============================================================

defn roots (types:List<VMType>, offsets:List<Int>) :
  to-tuple $ for (t in types, o in offsets) seq? :
    match(t:VMRef) : One(o / 8)
    else : None()

;============================================================
;=================== Identifiers ============================
;============================================================

defn to-vm-id (n:Int) :
  switch(n) :
    BYTE-TYPE-ID : VM-BYTE-TYPE-ID
    CHAR-TYPE-ID : VM-CHAR-TYPE-ID
    INT-TYPE-ID : VM-INT-TYPE-ID
    LONG-TYPE-ID : VM-LONG-TYPE-ID
    FLOAT-TYPE-ID : VM-FLOAT-TYPE-ID
    DOUBLE-TYPE-ID : VM-DOUBLE-TYPE-ID
    STRING-TYPE-ID : VM-STRING-TYPE-ID
    SYMBOL-TYPE-ID : VM-SYMBOL-TYPE-ID
    LIST-TYPE-ID : VM-LIST-TYPE-ID
    ARRAY-TYPE-ID : VM-ARRAY-TYPE-ID
    CHAR-ARRAY-TYPE-ID : VM-CHAR-ARRAY-TYPE-ID
    TRUE-TYPE-ID : VM-TRUE-TYPE-ID
    FALSE-TYPE-ID : VM-FALSE-TYPE-ID
    TUPLE-TYPE-ID : VM-TUPLE-TYPE-ID
    FN-TYPE-ID : VM-FN-TYPE-ID
    STACK-TYPE-ID : VM-STACK-TYPE-ID
    TYPE-TYPE-ID : VM-TYPE-TYPE-ID
    BOX-TYPE-ID : VM-BOX-TYPE-ID
    else : n

;============================================================
;===================== Small Utilities ======================
;============================================================

defn string-bytes (s:String) :
  val len = length(s)
  val bs = ByteArray(len + 1)
  bs[0 to len] = seq(to-byte, s)
  bs[len] = 0Y
  bs

defn to-byte-array (bs:Seqable<Byte>&Lengthable) :
  val b = ByteArray(length(bs))
  b[0 to false] = bs
  b

