defpackage stz/kform-to-vm :
  import core
  import collections
  import stz/kl-ir
  import stz/pl-ir
  import stz/vm-ir
  import stz/khier
  
;============================================================
;==================== Driver ================================
;============================================================

public defn to-vmprog (kpkg:KPackage) -> VMProg :
  defn compile-te (te:KTExp) :
    for te in exps(kpkg) do :
      match(te) :
        (te:KDef) : println("Not yet implemented")
        (te:KDefVar) : println("Not yet implemented")
        (te:KDefn) : compile-fn(te)
        (te:KDefmulti) : println("Not yet implemented")
        (te:KDefmethod) : println("Not yet implemented")
        (te:KDefType) : println("Not yet implemented")
        (te:KDefStruct) : println("Not yet implemented")
        (te:KExternFn) : println("Not yet implemented")
        (te:KExtern) : println("Not yet implemented")
        (te:KInit) : println("Not yet implemented")
        (te:KDefConst) : println("Not yet implemented")
        (te:KDefObject) : println("Not yet implemented")
        (te:KDefClosure) : println("Not yet implemented")
        (te:KDefTypeObject) : println("Not yet implemented")

  defn compile-fn (te:KDefn) :
    val e = value(te) as KFn
    false
    ;Given:
    ;  tail?(e) : Whether the function is tail recursive
    ;  a1(e) : The types of the arguments
    ;  a2(e) : The return type
    ;  args(e) : The identifiers of the arguments
    ;  body(e) : The body expression
      
  do(compile-te, exps(kpkg))      

;============================================================
;================ Within Function Compilation ===============
;============================================================

defn compile-function (e:KFn) -> VMFunc :
  ;Given:
  ;  tail?(e) : Whether the function is tail recursive
  ;  a1(e) : The types of the arguments
  ;  a2(e) : The return type
  ;  args(e) : The identifiers of the arguments
  ;  body(e) : The body expression

  ;Table for storing defined quantities
  val immtable = IntTable<Tuple<VMImm>>()
  val typetable = IntTable<Tuple<VMType>>()

  ;Buffer for keeping instructions
  val buffer = Vector<VMIns>()
  defn emit (i:VMIns) : add(buffer, i)

  defn compile (e:KExp) :
    match(e) :
      (e:KLet) :
        match(compile(value(e))) :
          (v:CVoid) :
            v
          (v:CImms|CStore) :
            val def = new CVoid :
              defmethod side-effects? (this) :
                side-effects?(v)
              defmethod gen-ins (this) :
                type-table[n(e)] = types(v)
                val ctxt = new AcceptContext :
                  defmethod accept (this, imms:Tuple<VMImm>) :
                    immtable[n(e)] = imms
                connect(ctxt, v)
            chain(def, compile(body(e)))
      (e:KLetVar) :
        val value* = match(value(e)) :
          (v:False) : false
          (v:KExp) : compile(v)
        match(value*) :
          (v:CVoid) :
            v
          (v) :
            val def = new CVoid :
              defmethod side-effects? (this) :
                match(v:CImms|CStore) :
                  side-effects?(v)
              defmethod gen-ins (this) :
                add(mutables, n(e))
                val ts = vm-types(dec-table, type(e))
                val locals = map(make-def, ts)
                type-table[n(e)] = ts
                imm-table[n(e)] = locals
                match(v:CImms|CStore) : set-to(locals, v)
            chain(def, compile(body(e)))
      (e:KLetRec) :
        val def = new CVoid :
          defmethod side-effects? (this) : false
          defmethod gen-ins (this) :
            ;Retrieve closures
            val closures = values(e) as List<KClosure>
            ;Make
            val locals = to-tuple(seq(make-def{VMRef()}, ns(e)))
            val types = to-tuple(seq(VMRef{}, ns(e)))
            ;Make locals
            for (n in ns(e), l in locals, t in types) do :
              type-table[n] = [t]
              imm-table[n] = [l]              
            ;Allocate closures
            emit(AllocIns(locals, types, sizes)) where :
              val sizes = to-tuple $ for c in closures seq :
                val nslots = length(targs(c)) + length(args(c))
                VMInt(8           ;length
                    + 8           ;code
                    + 8 * nslots) ;number of slots
            ;Compile closures
            for (x in locals, c in closures) do :
              val nslots = length(targs(c)) + length(args(c))
              add(StoreIns(x, VMInt(0), VMLong(nslots)))
              add(StoreIns(x, VMInt(8), CodeId(n(c))))
              for (y in append(targs(c), args(c)), i in 0 to false) do :
                store-to(x, 16 + 8 * i, compile(y))
        chain(def, compile(body(e)))
      (e:KVar) :
        if global?(dec-table, n(e)) :
          val t = var-type(dec-table, n(e))
          new CStore :
            defmethod types (this) : vm-types(dec-table, t)
            defmethod store (this, xs:Tuple<Local>) :
              val m = global-mem(dec-table, n(e))
              for (x in xs, o in field-offsets(dec-table,t)) do :
                emit(LoadIns(x, m, o))
        else if mutables[n(e)] :
          ;TODO: Not necessary if we pull out
          ;mutated variables from expressions first.
          new CImms :
            defmethod types (this) : typetable[n(e)]
            defmethod imms (this) :
              val locals = map(make-def, typetable[n(e)])
              for (x in locals, y in immtable[n(e)]) do :
                emit(SetIns(x, y))
              locals
        else :
          new CImms :
            defmethod types (this) : typetable[n(e)]
            defmethod imms (this) : immtable[n(e)]
      (e:KSet) :
        match(compile(value(e))) :
          (v:CVoid) :
            v
          (v:CImms|CStore) :
            new CImms :
              defmethod side-effects? (this) : true
              defmethod types (this) : [VMRef()]
              defmethod imms (this) :
                match(compile(loc(e))) :
                  (l:PtrLoc) :
                    val p = imm(base(l))
                    val os = field-offsets(dec-table, type(e))
                    store-to(p, os, v)
                  (l:VarLoc) :
                    val base = imm-table[n(l)] as Tuple<Local>
                    val len = length(dec-table, type(e))
                    val xs = headn(tailn(base, index(l)), len)
                    set-to(xs, v)
                [false-marker]
      (e:KTuple) : println("Not yet implemented")
      (e:KVoidTuple) : println("Not yet implemented")
      (e:KTupleGet) : println("Not yet implemented")
      (e:KTupleSet) : println("Not yet implemented")
      (e:KEnsureLength) : println("Not yet implemented")
      (e:KObject) : println("Not yet implemented")
      (e:KArray) : println("Not yet implemented")
      (e:KStruct) : println("Not yet implemented")
      (e:KPtr) : println("Not yet implemented")
      (e:KRead): println("Not yet implemented")
      (e:KDo) : println("Not yet implemented")
      (e:KDoC) : println("Not yet implemented")
      (e:KLSLiteral) : println("Not yet implemented")
      (e:KLiteral) : println("Not yet implemented")
      (e:KMix) : println("Not yet implemented")
      (e:KCurry) : println("Not yet implemented")
      (e:KInterpret) : println("Not yet implemented")
      (e:KCheck) : println("Not yet implemented")
      (e:KConv) : println("Not yet implemented")
      (e:KAndExp) : println("Not yet implemented")
      (e:KOrExp) : println("Not yet implemented")
      (e:KPrim) : println("Not yet implemented")
      (e:KSizeof) : println("Not yet implemented")
      (e:KTagof) : println("Not yet implemented")
      (e:KMatch) : println("Not yet implemented")
      (e:KLabels) : println("Not yet implemented")
      (e:KBlock) : println("Not yet implemented")
      (e:KIf) : println("Not yet implemented")
      (e:KSeq) : println("Not yet implemented")
      (e:KGoto) : println("Not yet implemented")
      (e:KReturn) : println("Not yet implemented")
      (e:KDispatch) : println("Not yet implemented")
      (e:KEnsureSet) : println("Not yet implemented")
      (e:KNewObject) : println("Not yet implemented")
      (e:KObjectGet) : println("Not yet implemented")
      (e:KObjectTGet) : println("Not yet implemented")
      (e:KLetType) : println("Not yet implemented")
      (e:KBox) : println("Not yet implemented")
      (e:KBoxGet) : println("Not yet implemented")
      (e:KBoxSet) : println("Not yet implemented")
      (e:KClosure) : println("Not yet implemented")
      (e:KTagPrim) : println("Not yet implemented")
      (e:KDetagPrim) : println("Not yet implemented")
  
;============================================================
;================= Forwarding Result ========================
;============================================================

defn chain (a:CVoid, b:CResult) :
  match(b) :
    (b:CVoid) :
      new CVoid :
        defmethod side-effects? (this) :
          side-effects?(a) or side-effects?(b)
        defmethod gen-ins (this) :
          gen-ins(a)
          gen-ins(b) when side-effects?(b)
    (b:CImms) :
      new CImms :
        defmethod types (this) : types(b)
        defmethod side-effects? (this) :
          side-effects?(a) or side-effects?(b)
        defmethod imms (this) :
          gen-ins(a)
          imms(b)
    (b:CStore) :
      new CStore :
        defmethod types (this) : types(b)
        defmethod side-effects? (this) :
          side-effects?(a) or side-effects?(b)
        defmethod store (this, xs:Tuple<Local>) :
          gen-ins(a)
          store(b, xs)

;============================================================
;================= Compiled Results =========================
;============================================================

;Types of results
deftype CResult

;Returns true if the result has side effects
defmulti side-effects? (r:CResult) -> True|False

;There is no result. The program never executes past that expression.
deftype CVoid <: CResult

;Generate the side-effecting instructions for CVoid.
;Guaranteed to be called only if it has side effects.
defmulti gen-ins (c:CVoid) -> False

;Result is represented as a bunch of immediates, to be handled by the context.
deftype CImms <: CResult
defmulti types (c:CImms|CStore) -> Tuple<VMType>
defmulti imms (c:CImms) -> Tuple<VMImm>

;Result will generate instructions to store values into destination variables.
;Destination variables will be empty, if result is not used.
deftype CStore <: CResult
defmulti store (c:CStore, xs:Tuple<Local>) -> False

;============================================================
;================= Compiled Contexts ========================
;============================================================

;Types of Contexts
deftype Context

;This context ignores the result
deftype IgnoreContext <: Context

;This context will generate instructions to handle results.
deftype AcceptContext <: Context
defmulti accept (c:AcceptContext, imms:Tuple<VMImm>) -> False

;This context is represented as a set of locals, for the result to be stored into.
deftype TargetContext <: Context
defmulti locals (c:TargetContext) -> Tuple<Local>

;============================================================
;===================== Contexts/Results =====================
;============================================================
;<COMMENT>
       |     SideEffects              No SideEffects
       | CVoid  CImms  CStore      CVoid  CImms  CStore
Ignore |
Accept |
Target |
;<COMMENT>