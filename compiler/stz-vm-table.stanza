defpackage stz/vm-table :
  import core
  import collections
  import stz/vm-ir
  import stz/vm
  import stz/algorithms

extern memcpy : (ptr<?>, ptr<?>, long) -> int

;============================================================
;=============== Low-Level Expanding Buffer =================
;============================================================

public lostanza deftype Buffer :
  size:long
  capacity:long
  mem:ptr<?>

public lostanza defn Buffer () -> ref<Buffer> :
  val cap = 1024L
  val mem = call-c clib/malloc(cap)
  return new Buffer{0L, cap, mem}

public lostanza defn alloc (b:ref<Buffer>, size:long) -> long :
  val size2 = b.size + size
  ensure-capacity(b, size2)
  val offset = b.size
  b.size = size2
  return offset

lostanza defn ensure-capacity (b:ref<Buffer>, capacity:long) -> int :
  if b.capacity >= capacity : return 0
  var c:long = b.capacity * 2L
  while c < capacity : c = c * 2L
  val mem2 = call-c clib/malloc(c)
  call-c memcpy(mem2, b.mem, b.size)
  call-c clib/free(b.mem)
  b.capacity = c
  b.mem = mem2
  return 0

public lostanza defn alloc (b:ref<Buffer>, size:ref<Int>) -> ref<Int> :
  return new Int{alloc(b, size.value) as int}

;============================================================
;================ Definition of all Tables ==================
;============================================================

public lostanza deftype VMTable :
  ;Initializers
  package-inits:ref<HashTable<Symbol,Int|False>> ;For initializing a package

  ;Branches
  branch-table:ref<BranchTable>
  
  ;Globals
  global-table:ref<IntTable<LoadedGlobal>>  ;For globals
  globals:ref<Buffer>

  ;Classes
  class-table:ref<ClassTable>

  ;Constants
  const-positions:ref<IntTable<Int>>     ;Will not be needed after indices are dense
  consts:ref<Buffer>
  new-consts:ptr<long>
  consts-data:ptr<byte>

  ;Data
  data-positions:ref<IntTable<Int>>      ;Will not be needed after indices are dense
  data:ref<Buffer>

  ;Functions
  function-addresses:ref<IntArray>
  instructions:ref<Vector<LinkedIns>>

  ;Externs
  extern-addresses:ref<IntTable<Long>>    ;Will not be needed after indices are dense

  ;FileInfos
  fileinfos:ref<IntTable<FileInfo>>           

;============================================================
;======================= Initialization =====================
;============================================================

public lostanza defn VMTable (class-table:ref<ClassTable>, branch-table:ref<BranchTable>) -> ref<VMTable> :
  return new VMTable{
    ;Initializers
    HashTable<Symbol,Int|False>(),

    ;Branches
    branch-table,
    
    ;Globals
    IntTable<LoadedGlobal>(),
    Buffer(),

    ;Classes
    class-table,

    ;Constants
    IntTable<Int>(),
    Buffer(),
    0L as ptr<long>,
    0L as ptr<byte>,

    ;Data
    IntTable<Int>(),
    Buffer(),

    ;Functions
    IntArray(new Int{1024}),
    Vector<LinkedIns>(),

    ;Externs
    IntTable<Long>()
    
    ;FileInfos
    IntTable<FileInfo>()}

;============================================================
;================= Class Display Analysis ===================
;============================================================
public deftype ClassTable
public defmulti class? (this, c:Int) -> True|False
public defmulti instanceof? (t:ClassTable, child:Int, parent:TypeSet) -> True|False
public defmulti add (t:ClassTable, c:VMClass) -> False
public defmulti get (t:ClassTable, c:Int) -> VMClass

public defn ClassTable () :
  val class-table = IntTable<VMClass>()

  var parent-table:Maybe<IntTable<Tuple<Int>>> = None()
  defn calc-parent-table () :    
    ;First calculate immediate parents
    val immediate-parents = IntTable<List<Int>>(List())
    for c in values(class-table) do :
      update(immediate-parents, append{parents(c), _}, id(c))
      match(c:VMAbstractClass) :
        for child in children(c) do :
          update(immediate-parents, cons{id(c), _}, child)
    ;Next calculate parent table
    val all-parents = IntTable<Tuple<Int>>()
    defn calc-parents (c:Int) :
      if not key?(all-parents, c) :
        all-parents[c] = to-tuple $ cat(
          [c]
          seq-cat(calc-parents, immediate-parents[c]))
      all-parents[c]
    do(calc-parents, keys(class-table))
    
    ;Return computed table
    all-parents    
  defn parent-table! () :
    if empty?(parent-table) :
      parent-table = One(calc-parent-table())
    value!(parent-table)

  defn instanceof? (child:Int, t:TypeSet) :
    val parents = parent-table!()
    let loop (t:TypeSet = t) :
      match(t) :
        (t:TopType) : true
        (t:SingleType) : contains?(parents[child], type(t))
        (t:AndType) : all?(loop, types(t))
        (t:OrType) : any?(loop, types(t))
    
  new ClassTable :
    defmethod add (this, c:VMClass) :
      class-table[id(c)] = c
      parent-table = None()
    defmethod get (this, c:Int) :
      class-table[c]
    defmethod class? (this, c:Int) :
      key?(class-table, c)
    defmethod instanceof? (this, child:Int, parent:TypeSet) :
      instanceof?(child, parent)

public defn subtype? (ct:ClassTable, a:TypeSet, b:TypeSet) :
  match(a) :
    (a:TopType) :
      let loop (t:TypeSet = b) :
        match(t) :
          (t:TopType) : true
          (t:SingleType) : false
          (t:AndType) : all?(loop, types(t))
          (t:OrType) : any?(loop, types(t))
    (a:SingleType) :
      instanceof?(ct, type(a), b)
    (a:AndType) :
      any?(subtype?{ct, _, b}, types(a))
    (a:OrType) :
      all?(subtype?{ct, _, b}, types(a))

public defn dispatch-ordering<?T> (class-table:ClassTable, methods:Tuple<?T>, types:T -> Tuple<TypeSet>) :
  defn submethod? (a:Int, b:Int) :
    for (ta in types(methods[a]), tb in types(methods[b])) all? :
      subtype?(class-table, ta, tb)
  to-tuple $ for item in ambiguity-ordering(length(methods), submethod?) seq :
    match(item) :
      (item:Int) :
        methods[item]
      (item:List<Int>) :
        to-tuple(seq({methods[_]}, item))

;============================================================
;=================== Global Loading =========================
;============================================================

defstruct LoadedGlobal :
  offset: Long
  size: Int
  roots: Tuple<Int>
  package: Symbol

public defn roots (globals:IntTable<LoadedGlobal>) -> Tuple<Int> :
  roots(globals, [])

public defn global-offset (vmt:VMTable, id:Int) -> Long :
  offset(global-table(vmt)[id])

public defn roots (globals:IntTable<LoadedGlobal>, exclude:Seqable<Symbol>) -> Tuple<Int> :
  val exset = to-hashset<Symbol>(exclude)
  to-tuple $
    for g in values(globals) seq-cat :
      if exset[package(g)] :
        []
      else :
        for r in roots(g) seq :
          to-int(offset(g) / 8L) + r  

public defn load-globals (vmt:VMTable, load-globals:Seqable<VMGlobal>, package:Symbol,
                          keep-existing-globals?:True|False) :
  val gt = global-table(vmt)
  for g in load-globals do :
    val size* = (size(g) + 7) & -8
    check-existing-entry() where :    
      defn* check-existing-entry () :
        match(get?(gt, id(g))) :
          (l:LoadedGlobal) :
            if keep-existing-globals? :
              fatal("New global size does not match existing global.") when size(l) != size*
              false ;Do nothing
            else :
              if size(l) <= size* : overwrite-entry(l)
              else : make-new-entry()
          (_:False) :
            make-new-entry()
      defn* overwrite-entry (l:LoadedGlobal) :
        val entry = LoadedGlobal(offset(l), size*, roots(g), package)
        gt[id(g)] = entry
        void-roots(offset(l))
      defn* make-new-entry () :
        val offset = alloc-global(vmt, size*)
        val entry = LoadedGlobal(offset, size*, roots(g), package)
        gt[id(g)] = entry
        void-roots(offset)
      defn* void-roots (offset:Long) :
        for r in roots(g) do :
          make-void(globals(vmt), to-int(offset / 8L) + r)

lostanza defn global-table (vmt:ref<VMTable>) -> ref<IntTable<LoadedGlobal>> :
  return vmt.global-table
lostanza defn globals (vmt:ref<VMTable>) -> ref<Buffer> :
  return vmt.globals
lostanza defn alloc-global (vmt:ref<VMTable>, size:ref<Int>) -> ref<Long> :
  return new Long{alloc(vmt.globals, size.value)}

lostanza val VOID-MARKER:long = void-marker()
lostanza defn make-void (buffer:ref<Buffer>, i:ref<Int>) -> ref<False> :
  val mem:ptr<long> = buffer.mem
  mem[i.value] = VOID-MARKER
  return false

;============================================================
;===================== Class Loading ========================
;============================================================

public lostanza defn load-classes (vmt:ref<VMTable>, classes:ref<Seqable<VMClass>>) -> ref<False> :
  val class-seq = to-seq(classes)
  while empty?(class-seq) == false :
    add(vmt.class-table, next(class-seq))
  return false

;============================================================
;===================== Const Loading ========================
;============================================================

public lostanza defn load-consts (vmt:ref<VMTable>, consts:ref<Tuple<VMConst>>) -> ref<False> :
  ;Put into const-positions table
  val nconsts = length(consts).value
  val const-space = nconsts * 8L
  val pos = alloc(vmt.consts, const-space) / 8
  for (var i:int = 0, i < nconsts, i = i + 1) :
    val id = id(consts.items[i])
    if key?(vmt.const-positions, id) == true : fatal("Const already defined.")
    val pos* = new Int{(pos + i) as int}
    set(vmt.const-positions, id, pos*)
    make-void(vmt.consts, pos*)

  ;Compile data
  vmt.consts-data = compile-const-data(consts)

  ;Point to new constants
  vmt.new-consts = addr!(vmt.consts.mem[pos])

  return false

;============================================================
;=================== Const Compilation ======================
;============================================================

lostanza defn compile-const-data (consts:ref<Tuple<VMConst>>) -> ptr<byte> :
  return to-byte-ptr(to-byte-buffer(consts))

val BYTE-CONST-TAG = 0
val CHAR-CONST-TAG = 1
val INT-CONST-TAG = 2
val LONG-CONST-TAG = 3
val FLOAT-CONST-TAG = 4
val DOUBLE-CONST-TAG = 5
val TRUE-CONST-TAG = 6
val FALSE-CONST-TAG = 7
val LIST-CONST-TAG = 8
val STRING-CONST-TAG = 9
val SYMBOL-CONST-TAG = 10
val TYPE-CONST-TAG = 11
val FN-CONST-TAG = 12
val INTERNED-CONST-TAG = 13

defn to-byte-buffer (consts:Tuple<VMConst>) :
  ;Discover indices
  val const-indices = to-inttable<Int> $
    for (c in consts, i in 0 to false) seq :
      id(c) => i
      
  val buffer = ByteBuffer()
  put(buffer, length(consts))
  defn emit (v:VMValue) :
    match(v) :
      (v:Char) :
        put(buffer, CHAR-CONST-TAG)
        put(buffer, v)
      (v:Byte) :
        put(buffer, BYTE-CONST-TAG)
        put(buffer, v)
      (v:Int) :
        put(buffer, INT-CONST-TAG)
        put(buffer, v)
      (v:Long) :
        put(buffer, LONG-CONST-TAG)
        put(buffer, v)
      (v:Float) :
        put(buffer, FLOAT-CONST-TAG)
        put(buffer, v)
      (v:Double) :
        put(buffer, DOUBLE-CONST-TAG)
        put(buffer, v)
      (v:String) :
        put(buffer, STRING-CONST-TAG)
        emit-chars(buffer, v)
      (v:Symbol) :
        put(buffer, SYMBOL-CONST-TAG)
        emit-chars(buffer, to-string(v))
      (v:List) :
        put(buffer, LIST-CONST-TAG)
        put(buffer, length(v))
        do(emit, v)
      (v:True) :
        put(buffer, TRUE-CONST-TAG)
      (v:False) :
        put(buffer, FALSE-CONST-TAG)
      (v:VMTypeObject) :
        put(buffer, TYPE-CONST-TAG)
        put(buffer, to-long(id(id(v))))
      (v:VMClosure) :
        put(buffer, FN-CONST-TAG)
        put(buffer, to-long(id(id(v))))
      (v:VMInternedConst) :
        put(buffer, INTERNED-CONST-TAG)
        put(buffer, const-indices[id(id(v))])
      (v) :
        fatal("Unrecognized constant: %~" % [v])
  do(emit{value(_)}, consts)
  buffer

defn emit-chars (buffer:ByteBuffer, s:String) :
  val n = length(s)
  put(buffer, n)
  for c in s do :
    put(buffer, c)
  val endn = (n + 3) & -4
  for i in n to endn do :
    put(buffer, 0Y)
  
lostanza defn to-byte-ptr (b:ref<ByteBuffer>) -> ptr<byte> :
  val n = length(b).value
  val x = call-c clib/malloc(n)
  call-c memcpy(x, data(b), n)
  return x

;============================================================
;=================== Build Fileinfo Table ===================
;============================================================
defn load-fileinfos (vmt:VMTable, infos:Tuple<FileInfoEntry>, offset:Int) :
  val infot = fileinfos(vmt)
  for e in infos do :
    val address = pc(e) + offset
    infot[address] = fileinfo(e)

lostanza defn fileinfos (vmt:ref<VMTable>) -> ref<IntTable<FileInfo>> :
  return vmt.fileinfos

;============================================================
;====================== Data Loading ========================
;============================================================

public lostanza defn load-data (vmt:ref<VMTable>, d:ref<VMData>) -> ref<False> :
  ;Put into data buffer
  val size = length(data(d)).value
  val size* = (size + 7L) & -8L
  val pos = alloc(vmt.data, size*) / 8
  call-c memcpy(addr!(vmt.data.mem[pos]), addr!(data(d).data), size)
  if key?(vmt.data-positions, id(d)) == true : fatal("Data already defined.")
  set(vmt.data-positions, id(d), new Int{pos as int})
  return false

public defn load-datas (vmt:VMTable, ds:Tuple<VMData>) :
  do(load-data{vmt, _}, ds)

;============================================================
;====================== Extern Loading ======================
;============================================================

public lostanza defn load-extern (vmt:ref<VMTable>, e:ref<VMExtern>) -> ref<False> :
  val address = get(EXTERN-TABLE, name(e))
  set(vmt.extern-addresses, id(e), address)
  return false

public defn load-externs (vmt:VMTable, es:Tuple<VMExtern>) :
  do(load-extern{vmt, _}, es)

;============================================================
;===================== Function Loading =====================
;============================================================

public lostanza defn load-function (vmt:ref<VMTable>, id:ref<Int>, lf:ref<LinkedFunction>) -> ref<False> :
  ;Load instructions into instruction vector
  val address = length(vmt.instructions)
  add-all(vmt.instructions, instructions(lf))
  set-function-address(vmt, id, address)

  ;Load fileinfos into fileinfo table
  load-fileinfos(vmt, fileinfos(lf), address)
  
  return false

lostanza defn set-function-address (vmt:ref<VMTable>, f:ref<Int>, address:ref<Int>) -> ref<False> :
  val size = length(vmt.function-addresses).value
  if f.value >= size :
    vmt.function-addresses = enlarge(vmt.function-addresses, new Int{f.value + 1}, new Int{-1})
  set(vmt.function-addresses, f, address)
  return false
    
defn enlarge (xs:IntArray, min-size:Int, default:Int) -> IntArray :
  var new-size:Int = length(xs)
  while new-size < min-size : new-size = new-size * 2
  val ys = IntArray(new-size)
  block-copy(length(xs), ys, 0, xs, 0)
  for i in length(xs) to length(ys) do :
    ys[i] = default
  ys

;============================================================
;====================== Initializers ========================
;============================================================

public lostanza defn set-init (vmt:ref<VMTable>, package:ref<Symbol>, init:ref<Int|False>) -> ref<False> :
  set(vmt.package-inits, package, init)
  return false

public lostanza defn init (vmt:ref<VMTable>, package:ref<Symbol>) -> ref<Int|False> :
  return get(vmt.package-inits, package)