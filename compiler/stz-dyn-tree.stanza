defpackage stz/dyn-tree :
  import core
  import collections
  import stz/utils

public deftype DynTree
public defmulti all-children (t:DynTree, n:Int) -> Tuple<Int>
public defmulti add-parent (t:DynTree, x:Int, p:Int) -> False
public defmulti remove-parent (t:DynTree, x:Int, p:Int) -> False
public defmulti add-node (t:DynTree, x:Int, leaf?:True|False) -> False

public defn DynTree (notify-children-changed:Int -> ?) :
  val nodes = IntTable<TreeNode>()  
  defn children-changed (p:Int) :
    notify-children-changed(p)
    set-all-children(nodes[p], false)
    do(children-changed, parents(nodes[p]))
  defn add-parent (x:Int, p:Int) :
    if leaf?(nodes[p]) :
      fatal("Cannot add child to leaf node %_." % [p])
    children-changed(p)
    /add-parent(nodes[x], p)
    add-child(nodes[p], x)
  defn remove-parent (x:Int, p:Int) :
    children-changed(p)
    /remove-parent(nodes[x], p)
    remove-child(nodes[p], x)
  defn add-node (x:Int, leaf?:True|False) :
    if key?(nodes,x) :
      fatal("Node %_ already exists." % [x])
    nodes[x] = TreeNode(leaf?)
  defn compute-children (x:Int) -> Tuple<Int> :
    val nx = nodes[x]
    defn compute () :
      if leaf?(nx) :
        [x]
      else :
        val cs = Vector<Int>()
        for c in children(nx) do :
          add-all(cs,compute-children(c))
        qsort!(cs)
        remove-duplicates!(cs)
        to-tuple(cs)
    if all-children(nx) is False :
      set-all-children(nx, compute())
    all-children(nx) as Tuple<Int>

  new DynTree :
    defmethod all-children (this, n:Int) : compute-children(n)
    defmethod add-parent (this, x:Int, p:Int) : add-parent(x,p)
    defmethod remove-parent (this, x:Int, p:Int) : remove-parent(x, p)
    defmethod add-node (this, x:Int, leaf?:True|False) : add-node(x, leaf?)

defstruct TreeNode :
  parents: List<Int> with: (init => List(), setter => set-parents)
  children: List<Int> with: (init => List(), setter => set-children)
  all-children: False|Tuple<Int> with: (init => false, setter => set-all-children)
  leaf?: True|False
defn add-parent (n:TreeNode, p:Int) :
  set-parents(n, cons(p, parents(n)))
defn remove-parent (n:TreeNode, p:Int) :
  set-parents(n, remove(parents(n), p))
defn add-child (n:TreeNode, p:Int) :
  set-children(n, cons(p, children(n)))
defn remove-child (n:TreeNode, p:Int) :
  set-children(n, remove(children(n), p))
defn remove (xs:List<Int>, x:Int) :
  if empty?(xs) : xs
  else if head(xs) == x : tail(xs)
  else : cons(head(xs), remove(tail(xs), x))

defn add-child (t:DynTree, x:Int, c:Int) :
  add-parent(t, c, x)
defn remove-child (t:DynTree, x:Int, c:Int) :
  remove-parent(t, c, x)
defn add-children (t:DynTree, x:Int, cs:Seqable<Int>) :
  do(add-child{t, x, _}, cs)
defn add-parents (t:DynTree, x:Int, ps:Seqable<Int>) :
  do(add-parent{t, x, _}, ps)