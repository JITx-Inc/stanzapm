defpackage stz/dyn-tree :
  import core
  import collections
  import stz/utils

public deftype DynTree
public defmulti all-children (t:DynTree, n:Int) -> Tuple<Int>
public defmulti all-parents (t:DynTree, n:Int) -> Tuple<Int>
public defmulti add-parent (t:DynTree, x:Int, p:Int) -> False
public defmulti remove-parent (t:DynTree, x:Int, p:Int) -> False
public defmulti add-node (t:DynTree, x:Int, leaf?:True|False) -> False

public deftype TreeListener
public defmulti children-changed (t:TreeListener, n:Int) -> False
public defmulti parents-changed (t:TreeListener, n:Int) -> False

public defn DynTree (l:TreeListener) :
  val nodes = IntTable<TreeNode>()  
  defn children-changed (p:Int) :
    /children-changed(l, p)
    set-all-children(nodes[p], false)
    do(children-changed, parents(nodes[p]))
  defn parents-changed (c:Int) :
    /parents-changed(l, c)
    set-all-parents(nodes[c], false)
    do(parents-changed, children(nodes[c]))
  defn add-parent (x:Int, p:Int) :
    if leaf?(nodes[p]) :
      fatal("Cannot add child to leaf node %_." % [p])      
    children-changed(p)
    parents-changed(x)
    /add-parent(nodes[x], p)
    add-child(nodes[p], x)
  defn remove-parent (x:Int, p:Int) :
    children-changed(p)
    parents-changed(x)
    /remove-parent(nodes[x], p)
    remove-child(nodes[p], x)
  defn add-node (x:Int, leaf?:True|False) :
    if key?(nodes,x) :
      fatal("Node %_ already exists." % [x])
    nodes[x] = TreeNode(leaf?)
  defn compute-children (x:Int) -> Tuple<Int> :
    val nx = nodes[x]
    defn compute () :
      if leaf?(nx) : [x]
      else : merge-all(seq(compute-children, children(nx)))
    if all-children(nx) is False :
      set-all-children(nx, compute())
    all-children(nx) as Tuple<Int>
  defn compute-parents (x:Int) -> Tuple<Int> :
    val nx = nodes[x]
    defn compute () :
      merge-all $ cat(
        [[x]],
        seq(compute-parents, parents(nx)))
    if all-parents(nx) is False :
      set-all-parents(nx, compute())
    all-parents(nx) as Tuple<Int>

  new DynTree :
    defmethod all-children (this, n:Int) : compute-children(n)
    defmethod all-parents (this, n:Int) : compute-parents(n)
    defmethod add-parent (this, x:Int, p:Int) : add-parent(x,p)
    defmethod remove-parent (this, x:Int, p:Int) : remove-parent(x, p)
    defmethod add-node (this, x:Int, leaf?:True|False) : add-node(x, leaf?)

defstruct TreeNode :
  parents: List<Int> with: (init => List(), setter => set-parents)
  children: List<Int> with: (init => List(), setter => set-children)
  all-children: False|Tuple<Int> with: (init => false, setter => set-all-children)
  all-parents: False|Tuple<Int> with: (init => false, setter => set-all-parents)
  leaf?: True|False
defn add-parent (n:TreeNode, p:Int) :
  set-parents(n, cons(p, parents(n)))
defn remove-parent (n:TreeNode, p:Int) :
  set-parents(n, remove(parents(n), p))
defn add-child (n:TreeNode, p:Int) :
  set-children(n, cons(p, children(n)))
defn remove-child (n:TreeNode, p:Int) :
  set-children(n, remove(children(n), p))
defn remove (xs:List<Int>, x:Int) :
  if empty?(xs) : xs
  else if head(xs) == x : tail(xs)
  else : cons(head(xs), remove(tail(xs), x))

public defn add-child (t:DynTree, x:Int, c:Int) :
  add-parent(t, c, x)
public defn remove-child (t:DynTree, x:Int, c:Int) :
  remove-parent(t, c, x)
public defn add-children (t:DynTree, x:Int, cs:Seqable<Int>) :
  do(add-child{t, x, _}, cs)
public defn add-parents (t:DynTree, x:Int, ps:Seqable<Int>) :
  do(add-parent{t, x, _}, ps)
public defn parent? (t:DynTree, x:Int, p:Int) :
  bsearch(all-parents(t,x), p) is Int

defmethod children-changed (t:TreeListener, n:Int) : false
defmethod parents-changed (t:TreeListener, n:Int) : false

defn bsearch (xs:Tuple<Int>, x:Int) -> Int|False :
  let loop (start:Int = 0, end:Int = length(xs)) :
    if end > start :
      val center = (start + end) / 2
      val y = xs[center]
      if x == y : center
      else if x < y : loop(start, center)
      else : loop(center + 1, end)

defn merge (xs0:Seqable<Int>, ys0:Seqable<Int>) :
  val xs = to-seq(xs0)
  val ys = to-seq(ys0)
  defn get-next () -> Maybe<Int> :
    match(empty?(xs), empty?(ys)) :
      (ex:True, ey:True) :
        None()
      (ex:True, ey:False) :
        One(next(ys))        
      (ex:False, ey:True) :
        One(next(xs))
      (ex:False, ey:False) :
        switch(compare(peek(xs), peek(ys))) :
          0 :
            next(ys)
            One(next(xs))
          -1 : One(next(xs))
          1 : One(next(ys))
  repeat-while(get-next)

defn merge-all (xxs0:Seqable<Tuple<Int>>) :
  val xxs = to-seq(xxs0)
  if empty?(xxs) : []
  else :
    val xs0 = next(xxs)
    to-tuple(reduce(merge, xs0, xxs))
    
;defn main () :
;  val listen = new TreeListener :
;    defmethod children-changed (this, n:Int) :
;      println("Children of %_ changed." % [n])
;    defmethod parents-changed (this, n:Int) :
;      println("Parents of %_ changed." % [n])
;  val t = DynTree(listen)
;  for i in 1 through 7 do :
;    add-node(t, i, contains?([2, 7], i))
;  add-children(t, 1, [2 3 4])
;  add-children(t, 3, [5 6])
;  add-parents(t, 7, [5 6])
;
;  for i in 1 through 7 do :
;    println("Node %_ has children %_" % [i, all-children(t,i)])
;    println("Node %_ has parents %_" % [i, all-parents(t,i)])
;
;  remove-parent(t, 7, 6)
;
;main()