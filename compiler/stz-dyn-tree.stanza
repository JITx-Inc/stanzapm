defpackage stz/dyn-tree :
  import core
  import collections
  import stz/utils

public deftype DynTree
public defmulti add (t:DynTree, nodes:Seqable<NodeState>) -> False
public defmulti all-children (t:DynTree, n:Int) -> Tuple<Int>
public defmulti all-parents (t:DynTree, n:Int) -> Tuple<Int>
public defmulti add (t:DynTree, listener:TreeListener) -> False

public deftype TreeListener
public defmulti children-changed (t:TreeListener, n:Int) -> False
public defmulti parents-changed (t:TreeListener, n:Int) -> False
public defmulti node-added (t:TreeListener, n:Int) -> False

public defstruct NodeState :
  id: Int
  parents: Tuple<Int> with: (ensure => sorted!)
  children: Tuple<Int> with: (ensure => sorted!)
  leaf?: True|False

public defn SortedNodeState (id:Int, parents:Seqable<Int>, children:Seqable<Int>, leaf?:True|False) :
  NodeState(id, qsort(parents), qsort(children), leaf?)  

defn sorted! (description:String, xs:False|Tuple<Int>) :
  match(xs:Tuple<Int>) :
    for i in 0 to length(xs) - 1 do :
      if not xs[i] < xs[i + 1] :
        fatal("Value %_ given to %_ is not sorted." % [xs, description])

public defn DynTree () :
  val nodes = IntTable<TreeNode>()
  val node-states = IntTable<NodeState>()
  
  val listeners = Vector<TreeListener>()
  defn notify-listeners (f:(TreeListener, Int) -> False, n:Int) :
    for l in listeners do : f(l, n)

  ;Track changed nodes for updating purposes
  val update-children = Vector<Int>()
  val update-parents = Vector<Int>()
  defn children-changed (p:Int) :
    val node = nodes[p]
    if all-children(node) is-not False :
      set-all-children(node, false)
      notify-listeners(/children-changed, p)
      add(update-children, p)
      do(children-changed, parents(node))
  defn parents-changed (c:Int) :
    val node = nodes[c]
    if all-parents(node) is-not False :
      set-all-parents(node, false)
      notify-listeners(/parents-changed, c)
      add(update-parents, c)
      do(parents-changed, children(node))

  ;Guard conditions
  defn ensure-not-leaf! (x:Int) :
    #if-not-defined(OPTIMIZE) :
      if leaf?(nodes[x]) :
        fatal("Node %_ is a leaf node." % [x])
  defn ensure-no-children! (x:Int) :
    #if-not-defined(OPTIMIZE) :
      if not empty?(children(nodes[x])) :
        fatal("Node %_ has children." % [x])
  defn ensure-not-exists! (x:Int) :
    if key?(nodes,x) :
      fatal("Node %_ already exists." % [x])

  ;Functions for changing the state of existing nodes
  defn add-parent (x:Int, p:Int) :
    ensure-not-leaf!(p)
    children-changed(p)
    parents-changed(x)
    /add-parent(nodes[x], p)
    add-child(nodes[p], x)
  defn remove-parent (x:Int, p:Int) :
    children-changed(p)
    parents-changed(x)
    /remove-parent(nodes[x], p)
    remove-child(nodes[p], x)
  defn set-leaf? (x:Int, leaf?:True|False) :
    ensure-no-children!(x) when leaf?
    val node = nodes[x]
    if leaf? != /leaf?(node) :
      /set-leaf?(node, leaf?)
      children-changed(x)

  ;Add a new node to the tree
  defn add-node (x:Int, leaf?:True|False) :
    ensure-not-exists!(x)
    notify-listeners(node-added, x)
    val node = TreeNode(leaf?)
    set-all-children(node, [x] when leaf? else [])
    set-all-parents(node, [x])
    nodes[x] = node
      
  ;Functions for computing the children and parents of each node
  defn compute-children (x:Int) -> Tuple<Int> :
    val nx = nodes[x]
    defn compute () :
      if leaf?(nx) : [x]
      else : merge-all(seq(compute-children, children(nx)))
    if all-children(nx) is False :
      set-all-children(nx, compute())
    all-children(nx) as Tuple<Int>
  defn compute-parents (x:Int) -> Tuple<Int> :
    val nx = nodes[x]
    defn compute () :
      merge-all $ cat(
        [[x]],
        seq(compute-parents, parents(nx)))
    if all-parents(nx) is False :
      set-all-parents(nx, compute())
    all-parents(nx) as Tuple<Int>

  defn add-nodes (new-nodes:Seqable<NodeState>) :
    ;Steps:
    ;1. Remove existing connections from existing nodes.
    ;2. Create new nodes.
    ;3. Create new connections for nodes.
    ;4. Set the leaf state for nodes.

    ;Action buffers
    val connect-buffer = Vector<(() -> ?)>()
    val new-node-buffer = Vector<(() -> ?)>()
    val change-leaf-buffer = Vector<(() -> ?)>()
    defn add-to-buffer (f:() -> ?, buffer:Vector<(() -> ?)>) : add(buffer, f)
    defn exec-buffer (buffer:Vector<(() -> ?)>) : for f in buffer do : f()

    ;Prepare actions
    val exists-buffer = Vector<True|False>()
    defn init-exists-buffer (n:Int) :
      clear(exists-buffer)
      lengthen(exists-buffer, n, false)
    
    for ns in new-nodes do :
      if key?(node-states,id(ns)) :
        val node = node-states[id(ns)]
        ;Scan through parents and adjust if necessary
        init-exists-buffer(length(parents(ns)))
        for p in parents(node) do :
          match(bsearch(parents(ns), p)) :
            (i:Int) : exists-buffer[i] = true
            (_:False) : remove-parent(id(ns), p)
        for (p in parents(ns), old? in exists-buffer) do :
          if not old? :
            within add-to-buffer(connect-buffer) :
              add-parent(id(ns), p)
        ;Scan through children and adjust if necessary
        init-exists-buffer(length(children(ns)))
        for c in children(node) do :
          match(bsearch(children(ns), c)) :
            (i:Int) : exists-buffer[i] = true
            (_:False) : remove-parent(c, id(ns))
        for (c in children(ns), old? in exists-buffer) do :
          if not old? :
            within add-to-buffer(connect-buffer) :
              add-parent(c, id(ns))
        ;Set the leaf state for node
        if leaf?(node) != leaf?(ns) :
          within add-to-buffer(change-leaf-buffer) :
            set-leaf?(id(ns), leaf?(ns))
      else :
        within add-to-buffer(new-node-buffer) :
          add-node(id(ns), leaf?(ns))
        within add-to-buffer(connect-buffer) :          
          do(add-parent{id(ns), _}, parents(ns))
        within add-to-buffer(connect-buffer) :          
          do(add-parent{_, id(ns)}, children(ns))
      ;Record new node state      
      node-states[id(ns)] = ns

    ;Execute actions
    exec-buffer(new-node-buffer)
    exec-buffer(connect-buffer)
    exec-buffer(change-leaf-buffer)

    ;Recompute children and parents
    do(compute-children, update-children)
    do(compute-parents, update-parents)
    clear(update-children)
    clear(update-parents)

  new DynTree :
    defmethod add (this, nodes:Seqable<NodeState>) : add-nodes(nodes)
    defmethod add (this, listen:TreeListener) : add(listeners, listen)
    defmethod all-children (this, n:Int) : all-children(nodes[n]) as Tuple<Int>
    defmethod all-parents (this, n:Int) : all-parents(nodes[n]) as Tuple<Int>
    defmethod print (o:OutputStream, this) :
      print(o, "DynTree :")
      if empty?(nodes) :
        print(o, " ()")
      else :
        val o2 = IndentedStream(o)
        for (entry in nodes, i in 0 to false) do :
          val n = value(entry)
          val nodestr = "Leaf" when leaf?(n) else "Node"
          print(o2, "\n%_ %_ :" % [nodestr, key(entry)])
          print(o2, "\n  children = %," % [children(n)])
          print(o2, "\n  parents = %," % [parents(n)])

defstruct TreeNode :
  parents: List<Int> with: (init => List(), setter => set-parents)
  children: List<Int> with: (init => List(), setter => set-children)
  all-children: False|Tuple<Int> with: (init => false, setter => set-all-children)
  all-parents: False|Tuple<Int> with: (init => false, setter => set-all-parents)
  leaf?: True|False with: (setter => set-leaf?)
defn add-parent (n:TreeNode, p:Int) :
  set-parents(n, cons(p, parents(n)))
defn remove-parent (n:TreeNode, p:Int) :
  set-parents(n, remove(parents(n), p))
defn add-child (n:TreeNode, p:Int) :
  set-children(n, cons(p, children(n)))
defn remove-child (n:TreeNode, p:Int) :
  set-children(n, remove(children(n), p))
defn remove (xs:List<Int>, x:Int) :
  if empty?(xs) : xs
  else if head(xs) == x : tail(xs)
  else : cons(head(xs), remove(tail(xs), x))

public defn parent? (t:DynTree, x:Int, p:Int) :
  bsearch(all-parents(t,x), p) is Int

defmethod children-changed (t:TreeListener, n:Int) : false
defmethod parents-changed (t:TreeListener, n:Int) : false
defmethod node-added (t:TreeListener, n:Int) : false

defn bsearch (xs:Tuple<Int>, x:Int) -> Int|False :
  let loop (start:Int = 0, end:Int = length(xs)) :
    if end > start :
      val center = (start + end) / 2
      val y = xs[center]
      if x == y : center
      else if x < y : loop(start, center)
      else : loop(center + 1, end)

defn merge (xs0:Seqable<Int>, ys0:Seqable<Int>) :
  val xs = to-seq(xs0)
  val ys = to-seq(ys0)
  defn get-next () -> Maybe<Int> :
    match(empty?(xs), empty?(ys)) :
      (ex:True, ey:True) :
        None()
      (ex:True, ey:False) :
        One(next(ys))        
      (ex:False, ey:True) :
        One(next(xs))
      (ex:False, ey:False) :
        switch(compare(peek(xs), peek(ys))) :
          0 :
            next(ys)
            One(next(xs))
          -1 : One(next(xs))
          1 : One(next(ys))
  repeat-while(get-next)

defn merge-all (xxs0:Seqable<Tuple<Int>>) :
  val xxs = to-seq(xxs0)
  if empty?(xxs) : []
  else :
    val xs0 = next(xxs)
    to-tuple(reduce(merge, xs0, xxs))
    
;defn main () :
;  val listen = new TreeListener :
;    defmethod children-changed (this, n:Int) :
;      println("Children of %_ changed." % [n])
;    defmethod parents-changed (this, n:Int) :
;      println("Parents of %_ changed." % [n])
;
;  val t = DynTree(listen)
;  defn print-state (name) :
;    println(name)
;    println(t)
;    for i in 1 through 7 do :
;      println("All leaves of %_ = %," % [i, all-children(t,i)])
;      println("All parents of %_ = %," % [i, all-parents(t,i)])
;
;  add(t, [
;    NodeState(1, [], [2, 3, 4], false)
;    NodeState(2, [], [], true)
;    NodeState(3, [], [5,6], false)
;    NodeState(4, [], [], false)
;    NodeState(5, [], [], false)
;    NodeState(6, [], [], false)
;    NodeState(7, [5,6], [], true)
;  ])
;  print-state("Initial Tree")
;
;  add(t, [
;    NodeState(7, [4,5], [], true)
;    NodeState(1, [], [3,4], false)
;    NodeState(2, [3], [], true)
;  ])
;  print-state("After Moving")
;
;  add(t, [
;    NodeState(3, [], [2,5,6], false)
;    NodeState(2, [], [], true)])
;  print-state("Done")   
;
;main()