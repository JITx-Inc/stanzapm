defpackage stz/dyn-tree :
  import core
  import collections
  import stz/utils

public deftype DynTree
public defmulti all-children (t:DynTree, n:Int) -> Tuple<Int>
public defmulti all-parents (t:DynTree, n:Int) -> Tuple<Int>
public defmulti add-parent (t:DynTree, x:Int, p:Int) -> False
public defmulti remove-parent (t:DynTree, x:Int, p:Int) -> False
public defmulti add-node (t:DynTree, x:Int, leaf?:True|False) -> False

public deftype TreeListener
public defmulti children-changed (t:TreeListener, n:Int) -> False
public defmulti parents-changed (t:TreeListener, n:Int) -> False

public defn DynTree (l:TreeListener) :
  val nodes = IntTable<TreeNode>()  
  defn children-changed (p:Int) :
    /children-changed(l, p)
    set-all-children(nodes[p], false)
    do(children-changed, parents(nodes[p]))
  defn parents-changed (c:Int) :
    /parents-changed(l, c)
    set-all-parents(nodes[c], false)
    do(parents-changed, children(nodes[c]))
  defn add-parent (x:Int, p:Int) :
    if leaf?(nodes[p]) :
      fatal("Cannot add child to leaf node %_." % [p])      
    children-changed(p)
    parents-changed(x)
    /add-parent(nodes[x], p)
    add-child(nodes[p], x)
  defn remove-parent (x:Int, p:Int) :
    children-changed(p)
    parents-changed(x)
    /remove-parent(nodes[x], p)
    remove-child(nodes[p], x)
  defn add-node (x:Int, leaf?:True|False) :
    if key?(nodes,x) :
      fatal("Node %_ already exists." % [x])
    nodes[x] = TreeNode(leaf?)
  defn compute-children (x:Int) -> Tuple<Int> :
    val nx = nodes[x]
    defn compute () :
      if leaf?(nx) :
        [x]
      else :
        val cs = Vector<Int>()
        for c in children(nx) do :
          add-all(cs,compute-children(c))
        qsort!(cs)
        remove-duplicates!(cs)
        to-tuple(cs)
    if all-children(nx) is False :
      set-all-children(nx, compute())
    all-children(nx) as Tuple<Int>
  defn compute-parents (x:Int) -> Tuple<Int> :
    val nx = nodes[x]
    defn compute () :
      val ps = Vector<Int>()
      add(ps, x)
      for p in parents(nx) do :
        add-all(ps, compute-parents(p))
      qsort!(ps)
      remove-duplicates!(ps)
      to-tuple(ps)
    if all-parents(nx) is False :
      set-all-parents(nx, compute())
    all-parents(nx) as Tuple<Int>

  new DynTree :
    defmethod all-children (this, n:Int) : compute-children(n)
    defmethod all-parents (this, n:Int) : compute-parents(n)
    defmethod add-parent (this, x:Int, p:Int) : add-parent(x,p)
    defmethod remove-parent (this, x:Int, p:Int) : remove-parent(x, p)
    defmethod add-node (this, x:Int, leaf?:True|False) : add-node(x, leaf?)

defstruct TreeNode :
  parents: List<Int> with: (init => List(), setter => set-parents)
  children: List<Int> with: (init => List(), setter => set-children)
  all-children: False|Tuple<Int> with: (init => false, setter => set-all-children)
  all-parents: False|Tuple<Int> with: (init => false, setter => set-all-parents)
  leaf?: True|False
defn add-parent (n:TreeNode, p:Int) :
  set-parents(n, cons(p, parents(n)))
defn remove-parent (n:TreeNode, p:Int) :
  set-parents(n, remove(parents(n), p))
defn add-child (n:TreeNode, p:Int) :
  set-children(n, cons(p, children(n)))
defn remove-child (n:TreeNode, p:Int) :
  set-children(n, remove(children(n), p))
defn remove (xs:List<Int>, x:Int) :
  if empty?(xs) : xs
  else if head(xs) == x : tail(xs)
  else : cons(head(xs), remove(tail(xs), x))

public defn add-child (t:DynTree, x:Int, c:Int) :
  add-parent(t, c, x)
public defn remove-child (t:DynTree, x:Int, c:Int) :
  remove-parent(t, c, x)
public defn add-children (t:DynTree, x:Int, cs:Seqable<Int>) :
  do(add-child{t, x, _}, cs)
public defn add-parents (t:DynTree, x:Int, ps:Seqable<Int>) :
  do(add-parent{t, x, _}, ps)
public defn parent? (t:DynTree, x:Int, p:Int) :
  bsearch(all-parents(t,x), p) is Int

defmethod children-changed (t:TreeListener, n:Int) : false
defmethod parents-changed (t:TreeListener, n:Int) : false

defn bsearch (xs:Tuple<Int>, x:Int) -> Int|False :
  let loop (start:Int = 0, end:Int = length(xs)) :
    if end > start :
      val center = (start + end) / 2
      val y = xs[center]
      if x == y : center
      else if x < y : loop(start, center)
      else : loop(center + 1, end)

;defn main () :
;  val listen = new TreeListener :
;    defmethod children-changed (this, n:Int) :
;      println("Children of %_ changed." % [n])
;    defmethod parents-changed (this, n:Int) :
;      println("Parents of %_ changed." % [n])
;  val t = DynTree(listen)
;  for i in 1 through 7 do :
;    add-node(t, i, contains?([2, 7], i))
;  add-children(t, 1, [2 3 4])
;  add-children(t, 3, [5 6])
;  add-parents(t, 7, [5 6])
;
;  for i in 1 through 7 do :
;    println("Node %_" % [i])
;    for j in 1 through 7 do :
;      if parent?(t, i, j) :
;        println("%_ is a parent of %_" % [j, i])
;
;  remove-parent(t, 7, 6)
;
;main()