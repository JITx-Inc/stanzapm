defpackage test-el-infer :
  import core
  import collections
  import parser
  import reader
  import stz/el-infer
  import stz/el-ir

;============================================================
;==================== Read Blocks ===========================
;============================================================

defsyntax test-el-infer :
  public defproduction input : Input
  defrule input = (input : (?ds:#def ...) ?bs:#block ...) : TInput(ds, bs)

  defproduction block : TBlock
  defrule block = (block ?n:#int : (?ins:#ins ...)) : TBlock(n, to-tuple(ins))

  defproduction ins : Ins
  defrule ins = (?d:#def) : d
  defrule ins = (?c:#cast) : c
  defrule ins = (use ?x:#int) : TUse(x)
  defrule ins = (match : (?bs:#branch ...)) : TMatch(to-tuple(bs))
  defrule ins = (goto ?n:#int) : TMatch([TBranch(n, [])])
  defrule ins = (here ?x:#string) : THere(x)

  defproduction def : TDef
  defrule def = (def ?x:#int : ?t:#int) : TDef(x, EOf(t))

  defproduction cast : Cast
  defrule cast = (cast ?x:#int : ?t:#int) : TCast(x, EOf(t))

  defproduction branch : Branch
  defrule branch = (branch ?n:#int : (?cs:#cast ...)) : TBranch(n, to-tuple(cs))
 
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)
  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)

defn read-input (filename:String) :
  parse-syntax[test-el-infer / #input](read-file(filename))

;============================================================
;===================== Datastructures =======================
;============================================================

defstruct TBlock <: Block :
  n: Int with: (as-method => true)
  instructions: Tuple<Ins> with: (as-method => true)
  preds: List<Int> with: (init => List(), setter => set-preds)

defstruct TDef <: Def :
  n: Int with: (as-method => true)
  type: EType with: (as-method => true)
defstruct TCast <: Cast :
  n: Int with: (as-method => true)
  type: EType with: (as-method => true)
defstruct TMatch <: Match :
  branches: Tuple<Branch> with: (as-method => true)
defstruct TBranch <: Branch :
  n: Int with: (as-method => true)
  casts: Tuple<Cast> with: (as-method => true)
defstruct TUse <: Use :
  n: Int with: (as-method => true)
defstruct THere <: Ins :
  msg: String

defmethod print (o:OutputStream, e:TDef) :
  print(o, "def %_ : %_" % [n(e), type(e)])

defmethod print (o:OutputStream, e:TCast) :
  print(o, "cast %_ : %_" % [n(e), type(e)])

defmethod print (o:OutputStream, e:TUse) :
  print(o, "use %_" % [n(e)])

defmethod print (o:OutputStream, e:TBranch) :
  print(o, "branch %_ : (%,)" % [n(e), casts(e)])
  
defmethod print (o:OutputStream, e:TMatch) :
  print(o, "match :")
  for o in o do-indented :
    for b in branches(e) do :
      print(o, "\n%_" % [b])

defmethod print (o:OutputStream, e:THere) :
  print(o, "here %~" % [msg(e)])

defmethod print (o:OutputStream, b:TBlock) :
  print(o, "block %_ :" % [n(b)])
  for o in o do-indented :
    for i in instructions(b) do :
      print(o, "\n%_" % [i])

defmethod predecessors (b:TBlock) :
  to-tuple(preds(b))

defn TInput (defs:Collection<Def>, blocks:Collection<TBlock>) :
  val input-table = IntTable<EType>()
  val block-table = IntTable<TBlock>()
  defn add-pred (s:Int, p:Int) :
    val b = block-table[s]
    set-preds(b, cons(p, preds(b)))
  for d in defs do : input-table[n(d)] = type(d)
  for b in blocks do : block-table[n(b)] = b
  for b in blocks do :
    val ins = instructions(b) as Tuple<Ins>
    if not empty?(ins) :
      val lasti = ins[length(ins) - 1]
      match(lasti:Match) :
        for s in branches(lasti) do :
          add-pred(n(s), n(b))
    
  new Input :
    defmethod blocks (this) : to-tuple(blocks)
    defmethod entry-state (this, n:Int) : input-table[n]
    defmethod print (o:OutputStream, this) :
      print(o, "input :")
      for o in o do-indented :
        for d in defs do :
          print(o, "\n%_" % [d])
      for b in blocks do :
        print(o, "\n%_" % [b])

;============================================================
;============================================================
;============================================================

defn main () :
  val input = read-input(command-line-arguments()[1])
  println(input)

  val annotated = Vector<Ins>()
  val output = new Output :
    defmethod emit (this, i:Ins) :
      add(annotated, i)
  infer(input, output)
  do(println, annotated)

main()