;See License.txt for details about licensing.

defpackage stz/namemap :
  import core
  import collections
  import stz/dl-ir
  ;import stz/ids
  ;import stz/params
  ;import stz/pl-ir with:
  ;  prefix(Private Protected Public) => PL
  ;import stz/tl-ir

public deftype NameMap <: Collection<VEntry>
public defmulti add (n:NameMap, e:VEntry) -> False
public defmulti get (nm:NameMap, n:Int) -> VEntry
public defmulti key? (n:NameMap, n:Int) -> True|False
public defmulti exported (n:NameMap) -> Collection<VEntry>

;public defmulti pkg-ids (nm:NameMap, name:Symbol) -> Collection<Int>
;public defmulti type-id (nm:NameMap, pkg:Symbol, name:Symbol) -> False|Int

public defn NameMap () :
  val table = IntTable<VEntry>()
  val exported = Vector<VEntry>()
  ;val pkg-tables = HashTable-init<Symbol,Vector<Int>>(Vector<Int>{})
  ;val type-table = HashTable<[Symbol,Symbol],Int>()
  
  ;defn add-entry (e:VEntry) :
  ;  ;Add to table
  ;  table[n(e)] = e
  ;  ;Add to pkg tables
  ;  add(pkg-tables[package(e)], n(e))
  ;  ;Record type id
  ;  match(type(e):TypeE|LTypeE) :
  ;    type-table[[package(e), name(e)]] = n(e)

  new NameMap :
    defmethod add (this, e:VEntry) -> False :
      table[n(e)] = e
      match(visibility(e):Public|Protected) :
        add(exported, e)
    defmethod exported (this) :
      exported
    defmethod get (this, n:Int) -> VEntry :
      table[n]
    defmethod key? (this, n:Int) :
      key?(table,n)
    defmethod to-seq (this) :
      values(table)
  ;  defmethod pkg-ids (this, name:Symbol) :
  ;    get?(pkg-tables, name, [])
  ;  defmethod key? (this, i:Int) :
  ;    key?(table, i)
  ;  defmethod type-id (this, pkg:Symbol, name:Symbol) :
  ;    get?(type-table, [pkg, name])
    defmethod print (o:OutputStream, this) :
      print(o, "NameMap:")
      for io in o do-indented :
        for entry in values(table) do :
          print(io, "\n%_" % [entry])

public defstruct VEntry :
  n: Int
  package: Symbol
  name: Symbol
  visibility: Vis
  type: EType
  info: FileInfo|False
with:
  printer => true

public defstruct Local <: Visibility
defmethod print (o:OutputStream, l:Local) :
  print(o, "local")

public deftype EType <: Equalable
public defstruct ValE <: EType
public defstruct VarE <: EType
public defstruct TVarE <: EType
public defstruct CapVarE <: EType
public defstruct TypeE <: EType
public defstruct MultiE <: EType
public defstruct FnE <: EType
public defstruct LValE <: EType
public defstruct LVarE <: EType
public defstruct LFnE <: EType
public defstruct LTypeE <: EType
public defstruct FieldE <: EType
public defstruct LabelE <: EType

defmethod equal? (a:EType, b:EType) :
  ($prim identical? a b)

defmethod print (o:OutputStream, t:EType) :
  print{o, _} $ match(t) :
    (t:ValE) : "ValE"
    (t:VarE) : "VarE"
    (t:TVarE) : "TVarE"
    (t:CapVarE) : "CapVarE"
    (t:TypeE) : "TypeE"
    (t:MultiE) : "MultiE"
    (t:FnE) : "FnE"
    (t:LValE) : "LValE"
    (t:LVarE) : "LVarE"
    (t:LFnE) : "LFnE"
    (t:LTypeE) : "LTypeE"
    (t:FieldE) : "FieldE"
    (t:LabelE) : "LabelE"

