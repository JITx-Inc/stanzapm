;See License.txt for details about licensing.

defpackage stz/namemap :
  import core
  import collections
  import stz/dl-ir
  ;import stz/ids
  ;import stz/params
  ;import stz/pl-ir with:
  ;  prefix(Private Protected Public) => PL
  ;import stz/tl-ir

public deftype NameMap <: Collection<VEntry>
public defmulti add (n:NameMap, e:VEntry) -> False
public defmulti get (nm:NameMap, n:Int) -> VEntry
public defmulti key? (n:NameMap, n:Int) -> True|False
public defmulti exported (n:NameMap) -> Seqable<VEntry>
public defmulti toplevel (n:NameMap) -> Seqable<VEntry>

;public defmulti pkg-ids (nm:NameMap, name:Symbol) -> Collection<Int>
;public defmulti type-id (nm:NameMap, pkg:Symbol, name:Symbol) -> False|Int

public defn NameMap () :
  val table = IntTable<VEntry>()
  val toplevel = Vector<VEntry>()
  ;val pkg-tables = HashTable-init<Symbol,Vector<Int>>(Vector<Int>{})
  ;val type-table = HashTable<[Symbol,Symbol],Int>()
  
  ;defn add-entry (e:VEntry) :
  ;  ;Add to table
  ;  table[n(e)] = e
  ;  ;Add to pkg tables
  ;  add(pkg-tables[package(e)], n(e))
  ;  ;Record type id
  ;  match(type(e):TypeE|LTypeE) :
  ;    type-table[[package(e), name(e)]] = n(e)

  new NameMap :
    defmethod add (this, e:VEntry) -> False :
      table[n(e)] = e
      add(toplevel,e) when visibility(e) is-not Local
    defmethod exported (this) :
      filter({visibility(_) is-not Private}, toplevel)
    defmethod toplevel (this) :
      toplevel
    defmethod get (this, n:Int) -> VEntry :
      table[n]
    defmethod key? (this, n:Int) :
      key?(table,n)
    defmethod to-seq (this) :
      to-seq(values(table))
  ;  defmethod pkg-ids (this, name:Symbol) :
  ;    get?(pkg-tables, name, [])
  ;  defmethod key? (this, i:Int) :
  ;    key?(table, i)
  ;  defmethod type-id (this, pkg:Symbol, name:Symbol) :
  ;    get?(type-table, [pkg, name])
    defmethod print (o:OutputStream, this) :
      print(o, "NameMap:")
      for io in o do-indented :
        for entry in values(table) do :
          print(io, "\n%_" % [entry])

public defstruct VEntry :
  n: Int
  package: Symbol
  name: Symbol
  visibility: Visibility
  type: EType
  info: FileInfo|False
with:
  printer => true

public defstruct Local <: Visibility
defmethod print (o:OutputStream, l:Local) :
  print(o, "local")

public deftype EType <: Equalable
public defstruct ValE <: EType
public defstruct VarE <: EType
public defstruct TVarE <: EType
public defstruct CapVarE <: EType
public defstruct TypeE <: EType
public defstruct MultiE <: EType
public defstruct FnE <: EType
public defstruct LValE <: EType
public defstruct LVarE <: EType
public defstruct LFnE <: EType
public defstruct LTypeE <: EType
public defstruct FieldE <: EType
public defstruct LabelE <: EType

defmethod equal? (a:EType, b:EType) :
  ($prim identical? a b)

defmethod print (o:OutputStream, t:EType) :
  print{o, _} $ match(t) :
    (t:ValE) : "ValE"
    (t:VarE) : "VarE"
    (t:TVarE) : "TVarE"
    (t:CapVarE) : "CapVarE"
    (t:TypeE) : "TypeE"
    (t:MultiE) : "MultiE"
    (t:FnE) : "FnE"
    (t:LValE) : "LValE"
    (t:LVarE) : "LVarE"
    (t:LFnE) : "LFnE"
    (t:LTypeE) : "LTypeE"
    (t:FieldE) : "FieldE"
    (t:LabelE) : "LabelE"

defn etype (r:Rec) :
  match(r) :
    (r:ValRec) :
      match(mutable?(r), lostanza?(r)) :
        (m:False, ls:False) : ValE()
        (m:True, ls:False) : VarE()
        (m:False, ls:True) : LValE()
        (m:True, ls:True) : LVarE()
    (r:FnRec) :
      if lostanza?(r) : LFnE()
      else : FnE()
    (r:MultiRec) : MultiE()
    (r:ExternFnRec) : LFnE()
    (r:ExternRec) :
      match(type(r)) :
        (t:DFnT) : LFnE()
        (t) : LVarE()
    (r:StructRec) : LTypeE()
    (r:TypeRec) : TypeE()

public defn VEntry (e:Export) :
  val rid = id(rec(e))
  VEntry(n(e), package(rid), name(rid), visibility(e), etype(rec(e)), false)

;public defn VEntry (n:Int, vis:Visibility, r:Rec) :
;  val rid = id(r)
;  VEntry(n, package(rid), name(rid), vis, etype(r), false)
;
;public defn VEntry (e:Export) :
;  VEntry(n(e), visibility(e), rec(e))
;
;public defn VEntry (i:Import) :
;  VEntry(n(i), Private(), rec(i))