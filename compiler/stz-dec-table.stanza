defpackage stz/dec-table :
  import core
  import collections
  import stz/kl-ir

;============================================================
;==================== Interface =============================
;============================================================
public deftype DecTable
defmulti get (this, n:Int) -> DecEntry
defmulti set (this, n:Int, e:DecEntry) -> False
defmulti structs (this) -> Seqable<Int>

;============================================================
;==================== Construction ==========================
;============================================================
public defn DecTable () :
  val entries = HashTable<Int,DecEntry>()
  new DecTable :
    defmethod get (this, n:Int) : entries[n]
    defmethod set (this, n:Int, e:DecEntry) : entries[n] = e
    defmethod structs (this) :
      seq(key, filter({value(_) is StructEntry}, entries))

;============================================================
;=================== Public Queries =========================
;============================================================

public defn global? (t:DecTable, n:Int) :
  global?(t[n])

public defn function? (t:DecTable, n:Int) :
  t[n] is FnEntry|LSFnEntry

public defn lostanza-function? (t:DecTable, n:Int) :
  t[n] is LSFnEntry

public defn global-function? (t:DecTable, n:Int) :
  global?(t, n) and function?(t, n)

public defn arity (t:DecTable, n:Int) :
  arity(t[n] as FnEntry|LSFnEntry)

public defn tail? (t:DecTable, n:Int) :
  tail?(t[n] as FnEntry|LSFnEntry)

public defn fn-types (t:DecTable, n:Int, type-args:List<KTag>) ->
                      [List<KTag>, KTag] :  
  val [tvars, a1, a2] = match(t[n]) :
    (e:LSFnEntry) : [targs(e), tags!(a1(e)), tag!(a2(e))]
    (e:FnEntry) : [targs(e), a1(e), a2(e)]
  val sub-table = to-hashtable<Int,KTag>(tvars, type-args)
  val a1* = map(replace-tvars{_, sub-table}, a1)
  val a2* = replace-tvars(a2, sub-table)
  [a1*, a2*]

public defn ls-fn-types (t:DecTable, n:Int, type-args:List<KTag>) ->
                         [List<KLSType>, KLSType] :
  val [tvars, a1, a2] = match(t[n]) :
    (e:LSFnEntry) : [targs(e), a1(e), a2(e)]
    (e:FnEntry) : [targs(e), KRefTs(a1(e)), KRefT(a2(e))]
  val sub-table = to-hashtable<Int,KTag>(tvars, type-args)
  val a1* = map(replace-tvars{_, sub-table}, a1)
  val a2* = replace-tvars(a2, sub-table)
  [a1*, a2*]

public defn ls-var-type (t:DecTable, n:Int) -> KLSType :
  match(t[n]) :
    (e:LSVarEntry) : type(e)
    (e:VarEntry) : KRefT(type(e))

public defn voidable? (t:DecTable, n:Int) -> True|False :
  val e = t[n] as LSVarEntry|VarEntry
  global?(e) or (mutable?(e) and not initialized?(e))

public defn mutable? (t:DecTable, n:Int) -> True|False :
  mutable?(t[n] as LSVarEntry|VarEntry)

public defn extern-label (t:DecTable) -> False|Symbol :
  match(t[n]) :
    (e:LSFnEntry|LSVarEntry) : lbl(e)
    (e:FnEntry|VarEntry) : false

defn analyzed-fentry (t:DecTable, n:Int) -> FieldEntry :
  val e = t[n] as FieldEntry
  match(index(e)) :
    (i:Int) :
      e
    (i:False) :
      analyze(t)
      t[n] as FieldEntry

public defn field-type (t:DecTable, n:Int) -> KLSType :
  type(analyzed-fentry(t,n))

public defn field-index (t:DecTable, n:Int) -> Int :
  index(analyzed-fentry(t,n)) as Int

public defn field-offset (t:DecTable, n:Int) -> Int :
  offset(analyzed-fentry(t,n)) as Int

;============================================================
;===================== Entries ==============================
;============================================================

deftype DecEntry
defstruct LSFnEntry <: DecEntry :
  lbl: False|Symbol
  arity: Int
  tail?: True|False
  targs: List<Int>
  a1: List<KLSType>
  a2: KLSType

defstruct FnEntry <: DecEntry :
  global?: True|False with: (as-method => true)
  arity: Int
  tail?: True|False
  targs: List<Int>
  a1: List<KTag>
  a2: KTag

defstruct LSVarEntry <: DecEntry :
  lbl: False|Symbol
  global?: True|False with: (as-method => true)
  mutable?: True|False
  initialized?: True|False
  type: KLSType

defstruct VarEntry <: DecEntry :
  global?: True|False with: (as-method => true)
  mutable?: True|False
  initialized?: True|False
  type: Type

defstruct StructEntry <: DecEntry :
  fields: List<Int>
  rfield: False|Int
  size: Int|False
  alignment: Int|False
  length: Int|False

defstruct FieldEntry <: DecEntry :
  type: KLSType
  index: Int|False
  offset: Int|False

defmulti global? (e:DecEntry) -> True|False
defmethod global? (e:StructEntry) : true
defmethod global? (e:LSFnEntry) : true
defmethod global? (e:FieldEntry) : false

;============================================================
;===================== KForm Registration ===================
;============================================================

public defn register (t:DecTable, c:KComm) :
  register(t, c, true)

public defn register (t:DecTable, c:KComm, global?:True|False) :
  defn assert-global () :
    fatal("Command must be registered as global.") when not global?
  match(c) :
    (c:KDef) :
      t[n(c)] = VarEntry(global?, false, true, type(c))
    (c:KDefConst) :
      assert-global()
      t[n(c)] = VarEntry(global?, false, true, KTop())
    (c:KDefVar) :
      t[n(c)] = VarEntry(global?, true, value(c) is-not False, type(c))
    (c:KLSDef) :
      assert-global()
      t[n(c)] = LSVarEntry(false, global?, false, true, type(c))      
    (c:KLSDefVar) :
      assert-global()
      t[n(c)] = LSVarEntry(false, global?, true, value(c) is-not False, type(c))      
    (c:KLSExtern) :
      assert-global()
      t[n(c)] = LSVarEntry(lbl(c), global?, true, false, type(c))
    (c:KDefn) :
      val f = value(c) as KFn
      t[n(c)] = FnEntry(global?, length(a1(f)), tail?(f), targs(f), a1(f), a2(f))
    (c:KDefmulti) :
      assert-global()
      t[n(c)] = FnEntry(global?, length(a1(c)), tail?(c), targs(c), a1(c), a2(c))
    (c:KLSDefn) :
      assert-global()
      val f = value(c) as KLSFn
      t[n(c)] = LSFnEntry(false, length(a1(f)), tail?(f), targs(f), a1(f), a2(f))
    (c:KLSExternFn) :
      assert-global()
      val f = value(c) as KLSFn
      t[n(c)] = LSFnEntry(lbl(c), length(a1(f)), tail?(f), targs(f), a1(f), a2(f))
    (c:KLSDefStruct) :
      assert-global()

      defn field-entry (f:KStructField) :
        val e = FieldEntry(type(c), false, false)
        t[n(c)] = e
        n(c)
      defn field-entry (f:False) :        
        false        
      t[n(c)] = StructEntry(map(field-entry,fields(c)),
                            field-entry(rfield(c)),
                            false,
                            false,
                            false)      
    (c) : false

;============================================================
;===================== Analysis =============================
;============================================================

defn analyze (t:DecTable) :
  ;Cached records
  defn type-record (n:Int) :
    val e = t[n] as StructEntry
    match(size(e):False) :
      val e* = analyze(e)
      t[n] = e*
      e*
    else : e
  defn type-alignment (t:KLSType) :
    match(t:KStructT) : alignment(type-record(n(t)))
    else : prim-size(t)
  defn type-length (t:KLSType) :
    match(t:KStructT) : length(type-record(n(t)))
    else : 1
  defn type-size (t:KLSType) :
    match(t:KStructT) : size(type-record(n(t)))
    else : prim-size(t)  

  ;Analyzed records
  defn analyze (e:StructEntry) :
    val offset-counter = Counter(0)
    val index-counter = Counter(0)
    defn fentry (n:Int) :
      t[n] as FieldEntry
    defn annotate (n:Int) :
      val f = fentry(n)
      val o = next(offset-counter, type-size(type(f)))
      val i = next(index-counter, type-length(type(f)))
      t[n] = FieldEntry(type(f), i, o)      
    defn annotate (e:Padding) :
      next(offset-counter, size(e))
    
    match(rfield(e)) :
      (rf:False) :
        val [fs, aln] = pad(
          type-alignment{type(fentry(_))}
          type-size{type(fentry(_))}
          fields(e)
          1)
        do(annotate, fs)
        val size = value(offset-counter)
        val length = value(index-counter)
        StructEntry(fields(e), false, size, aln, length)
      (rf:Int) :
        defn not-rest? (e:Padding|Int) :
          match(e:Int) : n(e) != rf
          else : true
        val [fs, aln] = pad(
          type-alignment{type(fentry(_))}
          type-size{type(fentry(_))}
          append(fields(e), List(rf))
          1)
        do(annotate, take-while(not-rest?, fs))
        val size = value(offset-counter)
        val length = value(index-counter)
        annotate(next(fs))
        StructEntry(fields(e), rf, size, aln, length)        

  ;Analyze all
  do(type-record, structs(t))
