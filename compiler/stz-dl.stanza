defpackage stz/dl :
  import core
  import collections
  import stz/dl-ir

;============================================================
;======================= Interface ==========================
;============================================================

public :
  deftype DEnv
  defmulti packageio (e:DEnv, name:Symbol) -> PackageIO|False
  defmulti packageios (e:DEnv) -> Seqable<PackageIO>
  defmulti load (e:DEnv, ps:Tuple<PackageIO>, live-recs:Tuple<Rec>) -> LoadResult
  defmulti existing-exports (e:DEnv, p:PackageIO) -> Tuple<Int>

  deftype LoadResult
  defstruct LoadErrors <: LoadResult : (errors: Tuple<LoadError>)
  with: (printer => true)
  defstruct LoadSuccess <: LoadResult
  with: (printer => true)

  deftype LoadError
  defstruct MissingDependency <: LoadError : (source:DependencySource, expected:Rec)
  with: (printer => true)
  defstruct MismatchedDependency <: LoadError : (source:DependencySource, expected:Rec, actual:Rec)
  with: (printer => true)

  deftype DependencySource
  defstruct LoadedPackage <: DependencySource : (package:Symbol)
  with: (printer => true)
  defstruct LiveObject <: DependencySource
  with: (printer => true)

;============================================================
;=============== Descriptor Environment =====================
;============================================================

public defn DEnv () :
  ;Initialize package table and live set
  val packages = HashTable<Symbol,PackageIO>()

  ;Sanity consistency check
  defn ensure-consistency () :
    #if-not-defined(OPTIMIZE) :
      ;Ensure that all imported records match the exported records exactly.
      val rec-table = to-hashtable<RecId,Rec> $
        seq-cat(exported-entries, values(packages))      
      for import in seq-cat(imports,values(packages)) do :
        val r = rec(import)
        match(get?(rec-table, id(r))) :
          (r2:Rec) : fatal("Mismatched dependency: %_ != %_" % [r, r2]) when not match?(r, r2)
          (r2:False) : fatal("Missing dependency: %_" % [id(r)])
    #else :
      false

  ;Given the package, which exports correspond to existing exports?
  defn existing-exports (p:PackageIO) :
    val p0 = get?(packages, package(p))
    match(p0:PackageIO) :
      val old-exports = to-hashtable<RecId,Rec>(exported-entries(p0))
      to-tuple $ for e in exports(p) seq? :
        val rec = rec(e)
        match(get?(old-exports, id(rec))) :
          (rec0:Rec) :
            if match?(rec,rec0) : One(n(e))
            else : None()
          (_:False) :
            None()
    else :
      []

  ;Load packages into environment. Either load in the packages, or return
  ;an error report indicating what has failed. 
  ;We assume that the packages to load have successfully passed the typechecker.
  ;This indicates two things:
  ;1. The packages are internally consistent. All imports/exports
  ;   from/to packages to be reloaded are guaranteed to be consistent by
  ;   the typechecker.
  ;2. The package imports are consistent. The typechecker imports the existing
  ;   definitions from the environment and ensures that the code is consistent
  ;   with these definitions.
  ;Therefore there is only one thing to check. Whether the new exports
  ;from the reloaded packages are consistent with the context.
  defn load (ps:Tuple<PackageIO>, live-recs:Tuple<Rec>) :
    ;These are the packages to be reloaded
    val reloaded-packages = to-hashset<Symbol>(seq(package, ps))

    ;Here are the new exported entries from the reloaded packages
    val export-table = to-hashtable<RecId,Rec> $
      seq-cat(exported-entries, ps)

    ;Check whether the imported record, imported, from 'src-package'
    ;is satisfied by the reloaded-packages.
    val errors = Vector<LoadError>()
    defn check-dependency (src:DependencySource, imported:Rec) :
      val rid = id(imported)
      if reloaded-packages[package(rid)] :
        match(get?(export-table, rid)) :
          (exported:Rec) :
            if not match?(imported, exported) :
              add(errors, MismatchedDependency(src, imported, exported))
          (_:False) :
            add(errors, MissingDependency(src, imported))

    ;Check all the dependencies from existing packages
    for p in values(packages) do :
      val src = LoadedPackage(package(p))
      do(check-dependency{src, rec(_)}, imports(p))
    ;Check all the dependencies from the live objects
    let :
      val src = LiveObject()
      do(check-dependency{src, _}, live-recs)

    ;Load the new packages if no errors
    if empty?(errors) :
      for p in ps do : packages[package(p)] = p
      ensure-consistency()
      LoadSuccess()

    ;Otherwise return the error report
    else :
      LoadErrors(to-tuple(errors))

  ;Return new environment
  new DEnv :
    defmethod packageios (this) :
      values(packages)
    defmethod packageio (this, name:Symbol) :
      get?(packages, name)
    defmethod load (this, packages:Tuple<PackageIO>, live-recs:Tuple<Rec>) :
      load(packages, live-recs)
    defmethod existing-exports (this, p:PackageIO) :
      existing-exports(p)

;============================================================
;======================= Utilities ==========================
;============================================================

;Utilities
defn exported-entries (p:PackageIO) :
  for e in exports(p) seq :
    val r = rec(e)
    id(r) => r