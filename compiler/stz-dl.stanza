defpackage stz/dl :
  import core
  import collections
  import stz/dl-ir

;============================================================
;======================= Interface ==========================
;============================================================

public :
  deftype DEnv
  defmulti set-live (e:DEnv, live:Seqable<Rec>) -> False
  defmulti load (e:DEnv, ps:Tuple<PackageIO>) -> LoadResult

  deftype LoadResult
  defstruct LoadErrors <: LoadResult : (errors: Tuple<LoadError>)
  with: (printer => true)
  defstruct LoadSuccess <: LoadResult
  with: (printer => true)

  deftype LoadError
  defstruct MissingDependency <: LoadError : (source:DependencySource)
  with: (printer => true)
  defstruct MismatchedDependency <: LoadError : (source:DependencySource, expected:Rec, actual:Rec)
  with: (printer => true)

  defstruct Dependency : (source:DependencySource, rec:Rec)
  deftype DependencySource
  defstruct PackageDependency <: DependencySource : (package:Symbol)
  with: (printer => true)
  defstruct LiveDependency <: DependencySource
  with: (printer => true)

;============================================================
;=============== Descriptor Environment =====================
;============================================================

public defn DEnv () :
  ;Initialize package table and live set
  val packages = HashTable<Symbol,PackageIO>()
  var live:Tuple<Rec> = []

  ;Utilities
  defn exported-entries (p:PackageIO) :
    for e in exports(p) seq :
      val r = rec(e)
      id(r) => r

  ;Sanity consistency check
  defn ensure-consistency () :
    #if-not-defined(OPTIMIZE) :
      val rec-set = to-hashtable<RecId,Rec> $
        seq-cat(exported-entries, values(packages))
      for p in values(packages) do :
        for import in imports(p) do :
          val r = rec(import)
          match(get?(rec-set, id(r))) :
            (r2:Rec) : fatal("Mismatched dependency: %_ != %_" % [r, r2]) when not match?(r, r2)
            (r2:False) : fatal("Missing dependency: %_" % [id(r)])
    #else : (false)

  ;Load packages into environment
  defn load (ps:Tuple<PackageIO>) :
    ;Figure out dependencies
    val reload-set = to-hashset<Symbol>(seq(package, ps))
    val dependencies = cat(package-dependencies, live-dependencies) where :
      val package-dependencies = for p in values(packages) seq-cat :
        if not reload-set[package(p)] :
          for import in imports(p) seq? :
            val r = rec(import)
            if reload-set[package(id(r))] :
              val src = PackageDependency(package(p))
              One(Dependency(src, r))
            else : None()
        else : []
      val live-dependencies = for r in live seq :
        Dependency(LiveDependency(), r)

    ;Check dependencies
    val errors = Vector<LoadError>()
    val new-recs = to-hashtable<RecId,Rec> $
      seq-cat(exported-entries, ps)
    for d in dependencies do :
      match(get?(new-recs, id(rec(d)))) :
        (r:Rec) : check-dependency(d, r)
        (r:False) : missing-dependency(d)
    where :
      defn check-dependency (d:Dependency, r:Rec) :
        if not match?(rec(d), r) :
          add(errors, MismatchedDependency(source(d), rec(d), r))
      defn missing-dependency (d:Dependency) :
        add(errors, MissingDependency(source(d)))

    ;If successful, put packages in table
    if empty?(errors) :
      ;Put new packages in table
      for p in ps do : packages[package(p)] = p
      ;Sanity check
      ensure-consistency()
      ;Return success
      LoadSuccess()
    else :
      ;If not successful, return errors
      LoadErrors(to-tuple(errors))

  ;Return new environment
  new DEnv :
    defmethod set-live (this, recs:Seqable<Rec>) :
      val ids = HashSet<RecId>()
      live = to-tuple $ for r in recs seq? :
        if add(ids, id(r)) : One(r)
        else : None()
    defmethod load (this, pkgs:Tuple<PackageIO>) :
      load(pkgs)

