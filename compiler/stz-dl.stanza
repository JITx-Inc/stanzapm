defpackage stz/dl :
  import core
  import collections
  import stz/dl-ir

;============================================================
;======================= Interface ==========================
;============================================================

public :
  deftype DEnv
  defmulti packageios (e:DEnv) -> Seqable<PackageIO>
  defmulti packageio (e:DEnv, name:Symbol) -> PackageIO|False
  defmulti check-exports (e:DEnv, ps:Tuple<PackageIO>, live-recs:Tuple<Rec>) -> LoadResult
  defmulti check-export-types (e:DEnv, packages:Set<Symbol>, types:Set<TypeId>, live-recs:Tuple<Rec>) -> LoadResult
  defmulti load (e:DEnv, ps:Seqable<PackageIO>) -> False
  defmulti existing-exports (e:DEnv, p:PackageIO) -> Tuple<Int>

  deftype LoadResult
  defstruct LoadErrors <: LoadResult : (errors: Tuple<LoadError>)
  with: (printer => true)
  defstruct LoadSuccess <: LoadResult
  with: (printer => true)

  deftype LoadError
  defstruct MissingDependency <: LoadError : (source:DependencySource, expected:Rec)
  with: (printer => true)
  defstruct MismatchedDependency <: LoadError : (source:DependencySource, expected:Rec, actual:Rec)
  with: (printer => true)

  deftype DependencySource
  defstruct LoadedPackage <: DependencySource : (package:Symbol)
  with: (printer => true)
  defstruct LiveObject <: DependencySource
  with: (printer => true)

;============================================================
;=============== Descriptor Environment =====================
;============================================================

public defn DEnv () :
  ;Initialize package table and live set
  val packages = HashTable<Symbol,PackageIO>()

  ;Sanity consistency check
  defn ensure-consistency () :
    #if-not-defined(OPTIMIZE) :
      ;Ensure that all imported records match the exported records exactly.
      val rec-table = to-hashtable<RecId,Rec> $
        seq-cat(exported-entries, values(packages))      
      for import in seq-cat(imports,values(packages)) do :
        if not transient?(import) :
          val r = rec(import)
          match(get?(rec-table, id(r))) :
            (r2:Rec) : fatal("Mismatched dependency: %_ != %_" % [r, r2]) when not match?(r, r2)
            (r2:False) : fatal("Missing dependency: %_" % [id(r)])
    #else :
      false

  ;Given the package, which exports correspond to existing exports?
  defn existing-exports (p:PackageIO) :
    val p0 = get?(packages, package(p))
    match(p0:PackageIO) :
      val old-exports = to-hashtable<RecId,Rec>(exported-entries(p0))
      to-tuple $ for e in exports(p) seq? :
        val rec = rec(e)
        match(get?(old-exports, id(rec))) :
          (rec0:Rec) :
            if match?(rec,rec0) : One(n(e))
            else : None()
          (_:False) :
            None()
    else :
      []

  ;Return true if the given package p may possible by affected the
  ;given reload set.
  defn affected? (p:PackageIO, reloaded:Set<Symbol>) :
    (not reloaded[package(p)]) and
    any?({reloaded[_]}, imported-packages(p))

  ;Consider loading the given packages and types into the environment.
  ;Return an error if the environment depends upon types that are missing. 
  defn check-export-types (reload-set:Set<Symbol>, types:Set<TypeId>, live-recs:Tuple<Rec>) :
    val errors = Vector<LoadError>()
    defn check-dependency (src:DependencySource, imported:Rec) :
      val rid = id(imported)
      match(rid:TypeId) :
        if reload-set[package(rid)] :
          if not types[rid] :
            add(errors, MissingDependency(src, imported))
    ;Check dependencies from existing packages
    for p in values(packages) do :
      val src = LoadedPackage(package(p))
      if affected?(p,reload-set) :
        for import in imports(p) do :
          check-dependency(src, rec(import)) when not transient?(import)
    ;Check all the dependencies from the live objects
    do(check-dependency{LiveObject(), _}, live-recs)
    ;Return result
    if empty?(errors) : LoadSuccess()
    else : LoadErrors(to-tuple(errors))      

  ;Check loading packages into environment. Return an error report
  ;indicating what will fail, or success otherwise.
  ;We assume that the packages to load have successfully passed the typechecker.
  ;This indicates two things:
  ;1. The packages are internally consistent. All imports/exports
  ;   from/to packages to be reloaded are guaranteed to be consistent by
  ;   the typechecker.
  ;2. The package imports are consistent. The typechecker imports the existing
  ;   definitions from the environment and ensures that the code is consistent
  ;   with these definitions.
  ;Therefore there is only one thing to check. Whether the new exports
  ;from the reloaded packages are consistent with the context.
  defn check-exports (ps:Tuple<PackageIO>, live-recs:Tuple<Rec>) :
    ;These are the packages to be reloaded
    val reloaded-packages = to-hashset<Symbol>(seq(package, ps))

    ;Here are the new exported entries from the reloaded packages
    val export-table = to-hashtable<RecId,Rec> $
      seq-cat(exported-entries, ps)

    ;Check whether the imported record, imported, from 'src-package'
    ;is satisfied by the reloaded-packages.
    val errors = Vector<LoadError>()
    defn check-dependency (src:DependencySource, imported:Rec) :
      val rid = id(imported)
      if reloaded-packages[package(rid)] :
        match(get?(export-table, rid)) :
          (exported:Rec) :
            if not match?(imported, exported) :
              add(errors, MismatchedDependency(src, imported, exported))
          (_:False) :
            add(errors, MissingDependency(src, imported))

    ;Check all the dependencies from existing packages
    for p in values(packages) do :
      val src = LoadedPackage(package(p))
      if affected?(p, reloaded-packages) :
        for import in imports(p) do :
          check-dependency(src, rec(import)) when not transient?(import)
    ;Check all the dependencies from the live objects
    do(check-dependency{LiveObject(), _}, live-recs)

    ;Return result
    if empty?(errors) : LoadSuccess()
    else : LoadErrors(to-tuple(errors))      

  ;Return new environment
  new DEnv :
    defmethod packageios (this) :
      values(packages)
    defmethod packageio (this, name:Symbol) :
      get?(packages, name)
    defmethod check-exports (this, packages:Tuple<PackageIO>, live-recs:Tuple<Rec>) :
      check-exports(packages, live-recs)
    defmethod check-export-types (this, packages:Set<Symbol>, types:Set<TypeId>, live-recs:Tuple<Rec>) :
      check-export-types(packages, types, live-recs)
    defmethod load (this, pkgs:Seqable<PackageIO>) :
      for p in pkgs do : packages[package(p)] = p
      ensure-consistency()
    defmethod existing-exports (this, p:PackageIO) :
      existing-exports(p)

;============================================================
;======================= Utilities ==========================
;============================================================

;Utilities
defn exported-entries (p:PackageIO) :
  for e in exports(p) seq :
    val r = rec(e)
    id(r) => r