defpackage stz/vm-ir :
  import core
  import collections
  import reader

;============================================================
;================== Design of Instructions ==================
;============================================================

public defstruct VMProg :
  classes: Tuple<VMClass>
  funcs: Tuple<VMFunc>
  externs: Tuple<VMExtern>

public deftype VMImm
public defstruct Local <: VMImm :
  index: Int
public defstruct NumConst <: VMImm :
  value: Byte|Int|Long|Float|Double
public defstruct CodeId <: VMImm :
  fid: Int

public deftype VMType
public defstruct VMByte <: VMType
public defstruct VMInt <: VMType
public defstruct VMLong <: VMType
public defstruct VMFloat <: VMType
public defstruct VMDouble <: VMType
public defstruct VMRef <: VMType
public defstruct VMPointer <: VMType

public defstruct VMFunc :
  id: Int
  args: Tuple<Local|False>
  defs: Tuple<VMDef>
  ins: Tuple<VMIns>

public destruct VMExtern :
  id: Int
  name: String

public defstruct VMDef :
  id: Int
  type: VMType
  local: Int

public deftype VMClass
public defmulti id (c:VMClass) -> Int
public defmulti parents (c:VMClass) -> Tuple<Int>

public defstruct VMArrayClass <: VMClass :
  id: Int with: (as-method => true)
  parents: Tuple<Int> with: (as-method => true)
  base-size: Int
  item-size: Int
public defstruct VMLeafClass <: VMClass :
  id: Int with: (as-method => true)
  parents: Tuple<Int> with: (as-method => true)
  size: Int
public defstruct VMAbstractClass <: VMClass :
  id: Int with: (as-method => true)
  parents: Tuple<Int> with: (as-method => true)

public deftype VMIns
public defstruct CallIns <: VMIns :
  xs: Tuple<Local|False>
  f: VMImm
  ys: Tuple<VMImm>
public defstruct CallClosureIns <: VMIns :
  xs: Tuple<Local|False>
  f: VMImm
  ys: Tuple<VMImm>
public defstruct CallCIns <: VMIns :
  xs: Tuple<Local|False>
  f: VMImm
  ys: Tuple<VMImm>
public defstruct YieldIns <: VMIns :
  xs: Tuple<Local|False>
  f: VMImm
  ys: Tuple<VMImm>
public defstruct NewStackIns <: VMIns :
  x: Local
  fid: VMImm
public defstruct SetIns <: VMIns :
  x: Local
  y: VMImm
public defstruct Op0Ins <: VMIns :
  x: Local
  op: VMOp
public defstruct Op1Ins <: VMIns :
  x: Local
  op: VMOp
  y: VMImm
public defstruct Op2Ins <: VMIns :
  x: Local
  op: VMOp
  y: VMImm
  z: VMImm
public defstruct LabelIns <: VMIns :
  n: Int
public defstruct GotoIns <: VMIns :
  n: Int with: (updater => sub-n)
public defstruct Branch1Ins <: VMIns :
  n: Int with: (updater => sub-n)
  op: VMOp
  x: VMImm
public defstruct Branch2Ins <: VMIns :
  n: Int with: (updater => sub-n)
  op: VMOp
  x: VMImm
  y: VMImm
public defstruct ReserveIns <: VMIns :
  num-objects: Int
  size: VMImm
public defstruct AllocIns <: VMIns :
  x: Local
  type: Int
  size: VMImm
public defstruct RefSetIns <: VMIns :
  x: VMImm
  y: VMImm
  z: VMImm
public defstruct RefGetIns <: VMIns :
  x: Local
  y: VMImm
  z: VMImm
public defstruct ReturnIns <: VMIns :
  xs: Tuple<VMImm>
public defstruct DumpIns <: VMIns :
  xs: Tuple<Local>

public deftype VMOp
public defstruct AddOp <: VMOp
public defstruct SubOp <: VMOp
public defstruct MulOp <: VMOp
public defstruct DivOp <: VMOp
public defstruct ModOp <: VMOp
public defstruct AndOp <: VMOp
public defstruct OrOp <: VMOp
public defstruct XorOp <: VMOp
public defstruct NotOp <: VMOp
public defstruct ShlOp <: VMOp
public defstruct ShrOp <: VMOp
public defstruct AshrOp <: VMOp
public defstruct EqOp <: VMOp
public defstruct NeOp <: VMOp
public defstruct LtOp <: VMOp
public defstruct GtOp <: VMOp
public defstruct LeOp <: VMOp
public defstruct GeOp <: VMOp
public defstruct UleOp <: VMOp
public defstruct UltOp <: VMOp
public defstruct UgtOp <: VMOp
public defstruct UgeOp <: VMOp
public defstruct NegOp <: VMOp
public defstruct InstanceofOp <: VMOp : (type:Int)
public defstruct CurrentStackOp <: VMOp

;============================================================
;==================== Printer ===============================
;============================================================

defn arg-string (xs:Tuple<Local|False>) :
  val xs* = for x in xs seq :
    match(x:False) : "_"
    else : x
  "(%,)" % [xs*]

defmethod print (o:OutputStream, p:VMProg) :
  for (x in cat(classes(p), funcs(p)), i in 0 to false) do :
    if i == 0 : print(o, x)
    else : lnprint(o, x)

defmethod print (o:OutputStream, d:VMDef) :
  print(o, "def L%_ : %_ (local %_)" % [id(d), type(d), local(d)])

defmethod print (o:OutputStream, d:VMExtern) :
  print(o, "extern %_ %~" % [id(d), name(d)])

defmethod print (o:OutputStream, f:VMFunc) :
  print(o, "func %_ %_ :" % [id(f), arg-string(args(f))])
  val o2 = IndentedStream(o)
  do(lnprint{o2, _}, defs(f))
  do(lnprint{o2, _}, ins(f))
  
defmethod print (o:OutputStream, c:VMAbstractClass) :
  print(o, "class %_ (%,)" % [id(c), parents(c)])

defmethod print (o:OutputStream, c:VMLeafClass) :
  print(o, "class %_ (%,) (size = %_)" % [id(c), parents(c), size(c)])

defmethod print (o:OutputStream, c:VMArrayClass) :
  print(o, "class %_ (%,) (base-size = %_, item-size = %_)" % [id(c), parents(c), base-size(c), item-size(c)])

defmethod print (o:OutputStream, x:VMImm) :
  print{o, _} $ match(x) :
    (x:Local) : "L%_" % [index(x)]
    (x:NumConst) : "%~" % [value(x)]
    (x:CodeId) : "F%_" % [fid(x)]
  
defmethod print (o:OutputStream, i:VMIns) :
  print{o, _} $ match(i) :
    (i:CallIns) : "%_ = call %_ (%,)" % [arg-string(xs(i)), f(i), ys(i)]
    (i:CallCIns) : "%_ = call-c %_ (%,)" % [arg-string(xs(i)), f(i), ys(i)]
    (i:CallClosureIns): "%_ = call-closure %_ (%,)" % [arg-string(xs(i)), f(i), ys(i)]
    (i:YieldIns) : "%_ = yield %_ (%,)" % [arg-string(xs(i)), f(i), ys(i)]
    (i:NewStackIns) : "%_ = new-stack %_" % [x(i), fid(i)]
    (i:SetIns) : "%_ = %_" % [x(i), y(i)]
    (i:Op0Ins) : "%_ = %_" % [x(i), op(i)]
    (i:Op1Ins) : "%_ = %_ %_" % [x(i), op(i), y(i)]
    (i:Op2Ins) : "%_ = %_ %_ %_" % [x(i), op(i), y(i), z(i)]
    (i:LabelIns) : "label %_" % [n(i)]
    (i:GotoIns) : "goto %_" % [n(i)]
    (i:Branch1Ins) : "goto %_ when %_ %_" % [n(i), op(i), x(i)]
    (i:Branch2Ins) : "goto %_ when %_ %_ %_" % [n(i), op(i), x(i), y(i)]
    (i:ReserveIns) : "reserve %_ %_" % [num-objects(i), size(i)]
    (i:AllocIns) : "%_ = alloc<%_> %_" % [x(i), type(i), size(i)]
    (i:RefSetIns) : "%_[%_] = %_" % [x(i), y(i), z(i)]
    (i:RefGetIns) : "%_ = %_[%_]" % [x(i), y(i), z(i)]
    (i:ReturnIns) : "return (%,)" % [xs(i)]
    (i:DumpIns) : "dump (%,)" % [xs(i)]

defmethod print (o:OutputStream, op:VMOp) :
  print{o, _} $ match(op) :
    (op:InstanceofOp) : "instanceof<%_>" % [type(op)]
    (op:CurrentStackOp) : "current-stack"
    (op:AddOp) : "add"
    (op:SubOp) : "sub"
    (op:MulOp) : "mul"
    (op:DivOp) : "div"
    (op:ModOp) : "mod"
    (op:AndOp) : "and"
    (op:OrOp) : "or"
    (op:XorOp) : "xor"
    (op:NotOp) : "not"
    (op:ShlOp) : "shl"
    (op:ShrOp) : "shr"
    (op:AshrOp) : "ashr"
    (op:EqOp) : "eq"
    (op:NeOp) : "ne"
    (op:LtOp) : "lt"
    (op:GtOp) : "gt"
    (op:LeOp) : "le"
    (op:GeOp) : "ge"
    (op:UleOp) : "ule"
    (op:UltOp) : "ult"
    (op:UgtOp) : "ugt"
    (op:UgeOp) : "uge"
    (op:NegOp) : "neg"

defmethod print (o:OutputStream, t:VMType) :
  print{o, _} $ match(t) :
    (t:VMByte) : "byte"
    (t:VMInt) : "int"
    (t:VMLong) : "long"
    (t:VMFloat) : "float"
    (t:VMDouble) : "double"
    (t:VMRef) : "ref"
    (t:VMPointer) : "ptr"

defn lnprint (o:OutputStream, x) :
  print(o, '\n')
  print(o, x)

;============================================================
;======================= Reader =============================
;============================================================

defsyntax vmcode :
  defproduction op0 : VMOp
  defrule op0 = (current-stack) : CurrentStackOp()
  
  defproduction op1 : VMOp
  defrule op1 = (instanceof<?t:#int!>) : InstanceofOp(t)
  defrule op1 = (not) : NotOp()
  defrule op1 = (neg) : NegOp()

  defproduction op2 : VMOp
  defrule op2 = (add) : AddOp()
  defrule op2 = (sub) : SubOp()
  defrule op2 = (mul) : MulOp()
  defrule op2 = (div) : DivOp()
  defrule op2 = (mod) : ModOp()
  defrule op2 = (and) : AndOp()
  defrule op2 = (or) : OrOp()
  defrule op2 = (xor) : XorOp()
  defrule op2 = (shl) : ShlOp()
  defrule op2 = (shr) : ShrOp()
  defrule op2 = (ashr) : AshrOp()
  defrule op2 = (eq) : EqOp()
  defrule op2 = (ne) : NeOp()
  defrule op2 = (lt) : LtOp()
  defrule op2 = (gt) : GtOp()
  defrule op2 = (le) : LeOp()
  defrule op2 = (ge) : GeOp()
  defrule op2 = (ule) : UleOp()
  defrule op2 = (ult) : UltOp()
  defrule op2 = (ugt) : UgtOp()
  defrule op2 = (uge) : UgeOp()

  defproduction type : VMType
  defrule type = (byte) : VMByte()
  defrule type = (int) : VMInt()
  defrule type = (long) : VMLong()
  defrule type = (float) : VMFloat()
  defrule type = (double) : VMDouble()
  defrule type = (ref) : VMRef()
  defrule type = (ptr) : VMPointer()

  defn char-prefix? (x, c:Char) :
    unwrap-token(x) is Symbol and to-string(x)[0] == c
  defn char-index! (info:FileInfo|False, x:Symbol|Token) :
    val i = to-int(to-string(x)[1 to false])
    match(i:Int) : i
    else : throw(VME(info, "Invalid name: %~" % [x]))
  defproduction local : Local
  defrule local = (?r) when char-prefix?(r, 'L') : Local(char-index!(closest-info(), r))

  defproduction imm : VMImm
  defrule imm = (?x) when unwrap-token(x) is Byte|Int|Long|Float|Double : NumConst(unwrap-token(x))
  defrule imm = (?x) when char-prefix?(x, 'F') : CodeId(char-index!(closest-info(), x))
  defrule imm = (?x:#local) : x

  defproduction ins : VMIns
  defrule ins = (?xs:#args = call ?f:#imm! (?ys:#imm! ...)) : CallIns(xs, f, to-tuple(ys))
  defrule ins = (?xs:#args = call-c ?f:#imm! (?ys:#imm! ...)) : CallCIns(xs, f, to-tuple(ys))
  defrule ins = (?xs:#args = call-closure ?f:#imm! (?ys:#imm! ...)) : CallClosureIns(xs, f, to-tuple(ys))
  defrule ins = (?xs:#args = yield ?f:#imm! (?ys:#imm! ...)) : YieldIns(xs, f, to-tuple(ys))
  defrule ins = (?x:#local = new-stack ?fid:#imm!) : NewStackIns(x, fid)
  defrule ins = (?x:#local = alloc<?t:#int!> ?size:#imm!) : AllocIns(x, t, size)
  defrule ins = (?x:#local = ?y:#imm[?z:#imm!]) : RefGetIns(x, y, z)
  defrule ins = (?x:#imm[?y:#imm] = ?z:#imm!) : RefSetIns(x, y, z)
  defrule ins = (?x:#local = ?o:#op0) : Op0Ins(x, o)
  defrule ins = (?x:#local = ?o:#op1 ?y:#imm!) : Op1Ins(x, o, y)
  defrule ins = (?x:#local = ?o:#op2 ?y:#imm! ?z:#imm!) : Op2Ins(x, o, y, z)
  defrule ins = (?x:#local = ?y:#imm!) : SetIns(x,y)
  defrule ins = (label ?n:#int!) : LabelIns(n)
  defrule ins = (goto ?n:#int! when ?o:#op2 ?x:#imm! ?y:#imm!) : Branch2Ins(n, o, x, y)
  defrule ins = (goto ?n:#int! when ?o:#op1 ?x:#imm!) : Branch1Ins(n, o, x)
  defrule ins = (goto ?n:#int!) : GotoIns(n)
  defrule ins = (reserve ?num-objects:#int! ?sz:#imm!) : ReserveIns(num-objects, sz)
  defrule ins = (return (?xs:#imm! ...)) : ReturnIns(to-tuple(xs))
  defrule ins = (dump (?xs:#local ...)) : DumpIns(to-tuple(xs))

  defproduction args : Tuple<Local|False>
  defrule args = ((?xs:#arg ...)) : to-tuple(xs)  
  defproduction arg : Local|False
  defrule arg = (?x:#local) : x
  defrule arg = (_) : false

  defproduction def : VMDef
  defrule def = (def ?n:#local : ?t:#type! (local ?l:#int!)) : VMDef(index(n), t, l)

  defproduction extern : VMExtern
  defrule extern = (extern ?n:#int! ?name:#string!) : VMExtern(n, name)

  defproduction func : VMFunc
  defrule func = (func ?id:#int! ?args:#args :  
                    ?defs:#def ...
                    ?ins:#ins! ...) :
    VMFunc(id, args, to-tuple(defs), to-tuple(ins))

  defproduction class : VMClass
  defrule class = (class ?id:#int! (?parents:#int! ...) (base-size = ?base:#int!, item-size = ?item:#int!)) :
    VMArrayClass(id, to-tuple(parents), base, item)
  defrule class = (class ?id:#int! (?parents:#int! ...) (size = ?size:#int!)) :
    VMLeafClass(id, to-tuple(parents), size)
  defrule class = (class ?id:#int! (?parents:#int! ...)) :
    VMAbstractClass(id, to-tuple(parents))

  public defproduction prog : VMProg
  defrule prog = (?es:#extern ... ?classes:#class ... ?funcs:#func! ...) :
    VMProg(to-tuple(classes), to-tuple(funcs), to-tuple(es))

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)

  ;===== Failure =====
  defproduction imm! : VMImm
  defrule imm! = (?x:#imm) : x
  fail-if imm! = () : VME(closest-info(), "Expected an immediate here.")

  defproduction int! : Int
  defrule int! = (?x:#int) : x
  fail-if int! = () : VME(closest-info(), "Expected an integer here.")

  defproduction ins! : VMIns
  defrule ins! = (?x:#ins) : x
  fail-if ins! = () : VME(closest-info(), "Expected an instruction here.")

  defproduction func! : VMFunc
  defrule func! = (?x:#func) : x
  fail-if func! = () : VME(closest-info(), "Expected a function here.")

  defproduction type! : VMType
  defrule type! = (?x:#type) : x
  fail-if type! = () : VME(closest-info(), "Expected a type here.")

  defproduction string! : String
  defrule string! = (?x:#string) : x
  fail-if string! = () : VME(closest-info(), "Expected a string here.")


;============================================================
;====================== Errors ==============================
;============================================================

public defstruct VMError <: Exception :
  info: FileInfo|False
  msg

public defn VME (info:FileInfo|False, msg) :
  VMError(info, msg)

defmethod print (o:OutputStream, e:VMError) :
  val info-str = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [info-str, msg(e)])

;============================================================
;============================================================
;============================================================

public defn read-vm-prog (filename:String) :
  val forms = read-file(filename)
  parse-syntax[vmcode / #prog](forms)