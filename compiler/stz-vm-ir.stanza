defpackage stz/vm-ir :
  import core
  import collections
  import reader

;============================================================
;================== Design of Instructions ==================
;============================================================

public defstruct VMProg :
  globals: Tuple<VMGlobal>
  classes: Tuple<VMClass>
  funcs: Tuple<VMFunction>
  externs: Tuple<VMExtern>

public deftype VMImm
public defstruct Local <: VMImm :
  index: Int
public defstruct NumConst <: VMImm :
  value: Byte|Int|Long|Float|Double
public defstruct CodeId <: VMImm :
  fid: Int
public defstruct ExternId <: VMImm :
  eid: Int
public defstruct GlobalId <: VMImm :
  gid: Int

public deftype VMType <: Hashable&Equalable
public defstruct VMByte <: VMType
public defstruct VMInt <: VMType
public defstruct VMLong <: VMType
public defstruct VMFloat <: VMType
public defstruct VMDouble <: VMType
public defstruct VMRef <: VMType
public defstruct VMPointer <: VMType

public deftype VMFunction
public defmulti id (f:VMFunction) -> Int

public defstruct VMMulti <: VMFunction :
  id: Int with: (as-method => true)
  arg: Int
  funcs: Tuple<KeyValue<Int, VMFunc>>
  default: VMFunc|False

public defstruct VMFunc <: VMFunction :
  id: Int with: (as-method => true)
  args: Tuple<Local|False>
  defs: Tuple<VMDef>
  ins: Tuple<VMIns>

public defstruct VMExtern :
  id: Int
  name: Symbol

public defstruct VMGlobal :
  id: Int
  size: Int
  position: Int
  roots: Tuple<Int>

public defstruct VMDef :
  id: Int
  type: VMType
  local: Int

public deftype VMClass
public defmulti id (c:VMClass) -> Int
public defmulti parents (c:VMClass) -> Tuple<Int>

public defstruct VMArrayClass <: VMClass :
  id: Int with: (as-method => true)
  parents: Tuple<Int> with: (as-method => true)
  base-size: Int
  item-size: Int
  base-roots: Tuple<Int>
  item-roots: Tuple<Int>
public defstruct VMLeafClass <: VMClass :
  id: Int with: (as-method => true)
  parents: Tuple<Int> with: (as-method => true)
  size: Int
  roots: Tuple<Int>
public defstruct VMAbstractClass <: VMClass :
  id: Int with: (as-method => true)
  parents: Tuple<Int> with: (as-method => true)

public deftype VMIns
public defstruct CallIns <: VMIns :
  xs: Tuple<Local|False>
  f: VMImm
  ys: Tuple<VMImm>
public defstruct CallClosureIns <: VMIns :
  xs: Tuple<Local|False>
  f: VMImm
  ys: Tuple<VMImm>
public defstruct CallCIns <: VMIns :
  xs: Tuple<Local|False>
  f: VMImm
  ys: Tuple<VMImm>
public defstruct YieldIns <: VMIns :
  xs: Tuple<Local|False>
  f: VMImm
  ys: Tuple<VMImm>
public defstruct NewStackIns <: VMIns :
  x: Local
  fid: VMImm
public defstruct SetIns <: VMIns :
  x: Local
  y: VMImm
public defstruct Op0Ins <: VMIns :
  x: Local
  op: VMOp
public defstruct Op1Ins <: VMIns :
  x: Local
  op: VMOp
  y: VMImm
public defstruct Op2Ins <: VMIns :
  x: Local
  op: VMOp
  y: VMImm
  z: VMImm
public defstruct LabelIns <: VMIns :
  n: Int
public defstruct GotoIns <: VMIns :
  n: Int with: (updater => sub-n)
public defstruct Branch1Ins <: VMIns :
  n: Int with: (updater => sub-n)
  op: VMOp
  x: VMImm
public defstruct Branch2Ins <: VMIns :
  n: Int with: (updater => sub-n)
  op: VMOp
  x: VMImm
  y: VMImm
public defstruct AllocIns <: VMIns :
  xs: Tuple<Local>
  types: Tuple<Int>
  sizes: Tuple<VMImm>
public defstruct StoreIns <: VMIns :
  x: VMImm
  y: VMImm
  z: VMImm
public defstruct LoadIns <: VMIns :
  x: Local
  y: VMImm
  z: VMImm
public defstruct ReturnIns <: VMIns :
  xs: Tuple<VMImm>
public defstruct DumpIns <: VMIns :
  xs: Tuple<Local>
public defstruct RecordLiveIns <: VMIns :
  live: Tuple<Local>

public deftype VMOp
public defstruct AddOp <: VMOp
public defstruct SubOp <: VMOp
public defstruct MulOp <: VMOp
public defstruct DivOp <: VMOp
public defstruct ModOp <: VMOp
public defstruct AndOp <: VMOp
public defstruct OrOp <: VMOp
public defstruct XorOp <: VMOp
public defstruct NotOp <: VMOp
public defstruct ShlOp <: VMOp
public defstruct ShrOp <: VMOp
public defstruct AshrOp <: VMOp
public defstruct EqOp <: VMOp
public defstruct NeOp <: VMOp
public defstruct LtOp <: VMOp
public defstruct GtOp <: VMOp
public defstruct LeOp <: VMOp
public defstruct GeOp <: VMOp
public defstruct UleOp <: VMOp
public defstruct UltOp <: VMOp
public defstruct UgtOp <: VMOp
public defstruct UgeOp <: VMOp
public defstruct NegOp <: VMOp
public defstruct InstanceofOp <: VMOp : (type:Int)
public defstruct CurrentStackOp <: VMOp

;============================================================
;====================== Hashes ==============================
;============================================================

defmethod hash (x:VMType) :
  match(x) :
    (x:VMByte) : 0
    (x:VMInt) : 1
    (x:VMLong) : 2
    (x:VMFloat) : 3
    (x:VMDouble) : 4
    (x:VMRef) : 5
    (x:VMPointer) : 6

defmethod equal? (a:VMType, b:VMType) :
  hash(a) == hash(b)

;============================================================
;=================== Size Calculations ======================
;============================================================

public defn size (x:VMImm) :
  match(x) :
    (x:NumConst) :
      match(value(x)) :
        (v:Byte) : 1
        (v:Int) : 4
        (v:Long) : 8
        (v:Float) : 4
        (v:Double) : 8
    (x:CodeId) : 8
    (x:ExternId) : 8
    (x:GlobalId) : 8

public defn type (x:VMImm) :
  match(x) :
    (x:NumConst) :
      match(value(x)) :
        (v:Byte) : VMByte()
        (v:Int) : VMInt()
        (v:Long) : VMLong()
        (v:Float) : VMFloat()
        (v:Double) : VMDouble()
    (x:CodeId) : VMPointer()
    (x:ExternId) : VMPointer()
    (x:GlobalId) : VMPointer()

public defn size (t:VMType) :
  match(t) :
    (t:VMByte) : 1
    (t:VMInt) : 4
    (t:VMLong) : 8
    (t:VMFloat) : 4
    (t:VMDouble) : 8
    (t:VMRef) : 8
    (t:VMPointer) : 8

;============================================================
;===================== Mapper ===============================
;============================================================

public defn map (t:Int -> Int, g:Local -> Local, ins:VMIns) :
  defn h (x:VMImm) :
    match(x:Local) : g(x)
    else : x
  defn h (xs:Tuple<VMImm>) :
    map(h, xs)
  defn gs (xs:Tuple<Local|False>) :
    for x in xs map :
      match(x:Local) : g(x)
  match(ins) :
    (ins:CallIns) :
      CallIns(gs(xs(ins)), h(f(ins)), h(ys(ins)))
    (ins:CallCIns) :
      CallCIns(gs(xs(ins)), h(f(ins)), h(ys(ins)))
    (ins:CallClosureIns) :
      CallClosureIns(gs(xs(ins)), h(f(ins)), h(ys(ins)))
    (ins:YieldIns) :
      YieldIns(gs(xs(ins)), h(f(ins)), h(ys(ins)))      
    (ins:NewStackIns) :
      NewStackIns(g(x(ins)), h(fid(ins)))
    (ins:SetIns) :
      SetIns(g(x(ins)), h(y(ins)))
    (ins:Op0Ins) :
      Op0Ins(g(x(ins)), op(ins))
    (ins:Op1Ins) :
      Op1Ins(g(x(ins)), op(ins), h(y(ins)))
    (ins:Op2Ins) :
      Op2Ins(g(x(ins)), op(ins), h(y(ins)), h(z(ins)))
    (ins:LabelIns) :
      LabelIns(t(n(ins)))
    (ins:GotoIns) :
      GotoIns(t(n(ins)))
    (ins:Branch1Ins) :
      Branch1Ins(t(n(ins)), op(ins), h(x(ins)))
    (ins:Branch2Ins) :
      Branch2Ins(t(n(ins)), op(ins), h(x(ins)), h(y(ins)))
    (ins:AllocIns) :
      AllocIns(gs(xs(ins)) as Tuple<Local>, types(ins), h(sizes(ins)))
    (ins:StoreIns) :
      StoreIns(h(x(ins)), h(y(ins)), h(z(ins)))
    (ins:LoadIns) :
      LoadIns(g(x(ins)), h(y(ins)), h(z(ins)))
    (ins:ReturnIns) :
      ReturnIns(h(xs(ins)))
    (ins:DumpIns) :
      DumpIns(gs(xs(ins)) as Tuple<Local>)
    (ins:RecordLiveIns) :
      RecordLiveIns(gs(live(ins)) as Tuple<Local>)

;============================================================
;==================== Printer ===============================
;============================================================

defn arg-string (xs:Tuple<Local|False>) :
  val xs* = for x in xs seq :
    match(x:False) : "_"
    else : x
  "(%,)" % [xs*]

defmethod print (o:OutputStream, p:VMProg) :
  val xs = cat-all $ [
    globals(p)
    externs(p)
    classes(p)
    funcs(p)]
  for (x in xs, i in 0 to false) do :
    if i == 0 : print(o, x)
    else : lnprint(o, x)

defmethod print (o:OutputStream, d:VMDef) :
  print(o, "def %_ : %_ (local %_)" % [Local(id(d)), type(d), local(d)])

defmethod print (o:OutputStream, g:VMGlobal) :
  print(o, "global %_ (size = %_, position = %_, roots = (%,))" % [GlobalId(id(g)), size(g), position(g), roots(g)])

defmethod print (o:OutputStream, d:VMExtern) :
  print(o, "extern %_ %~" % [ExternId(id(d)), name(d)])

defmethod print (o:OutputStream, m:VMMulti) :
  print(o, "multi %_ (%_) :" % [CodeId(id(m)), arg(m)])
  for entry in funcs(m) do :
    lnprint(o, "  %_ => " % [key(entry)])
    print-func(o, value(entry), 4)
  match(default(m):VMFunc) :
    lnprint(o, "  else => ")
    print-func(o, default(m) as VMFunc, 4)

defmethod print (o:OutputStream, f:VMFunc) :
  print-func(o, f, 2)

defn print-func (o:OutputStream, f:VMFunc, indent:Int) :
  print(o, "func %_ %_ :" % [CodeId(id(f)), arg-string(args(f))])
  val o2 = IndentedStream(o, indent)
  do(lnprint{o2, _}, defs(f))
  do(lnprint{o2, _}, ins(f))
  
defmethod print (o:OutputStream, c:VMAbstractClass) :
  print(o, "class %_ (%,)" % [id(c), parents(c)])

defmethod print (o:OutputStream, c:VMLeafClass) :
  print(o, "class %_ (%,) (size = %_, roots = (%,))" % [id(c), parents(c), size(c), roots(c)])

defmethod print (o:OutputStream, c:VMArrayClass) :
  print(o, "class %_ (%,) (base-size = %_, item-size = %_, base-roots = (%,), item-roots = (%,))" % [
    id(c), parents(c), base-size(c), item-size(c), base-roots(c), item-roots(c)])

defmethod print (o:OutputStream, x:VMImm) :
  print{o, _} $ match(x) :
    (x:Local) : "L%_" % [index(x)]
    (x:NumConst) : "%~" % [value(x)]
    (x:CodeId) : "F%_" % [fid(x)]
    (x:ExternId) : "E%_" % [eid(x)]
    (x:GlobalId) : "G%_" % [gid(x)]
  
defmethod print (o:OutputStream, i:VMIns) :
  print{o, _} $ match(i) :
    (i:CallIns) : "%_ = call %_ (%,)" % [arg-string(xs(i)), f(i), ys(i)]
    (i:CallCIns) : "%_ = call-c %_ (%,)" % [arg-string(xs(i)), f(i), ys(i)]
    (i:CallClosureIns): "%_ = call-closure %_ (%,)" % [arg-string(xs(i)), f(i), ys(i)]
    (i:YieldIns) : "%_ = yield %_ (%,)" % [arg-string(xs(i)), f(i), ys(i)]
    (i:NewStackIns) : "%_ = new-stack %_" % [x(i), fid(i)]
    (i:SetIns) : "%_ = %_" % [x(i), y(i)]
    (i:Op0Ins) : "%_ = %_" % [x(i), op(i)]
    (i:Op1Ins) : "%_ = %_ %_" % [x(i), op(i), y(i)]
    (i:Op2Ins) : "%_ = %_ %_ %_" % [x(i), op(i), y(i), z(i)]
    (i:LabelIns) : "label %_" % [n(i)]
    (i:GotoIns) : "goto %_" % [n(i)]
    (i:Branch1Ins) : "goto %_ when %_ %_" % [n(i), op(i), x(i)]
    (i:Branch2Ins) : "goto %_ when %_ %_ %_" % [n(i), op(i), x(i), y(i)]
    (i:AllocIns) : "(%,) = alloc<%,> (%,)" % [xs(i), types(i), sizes(i)]
    (i:StoreIns) : "%_[%_] = %_" % [x(i), y(i), z(i)]
    (i:LoadIns) : "%_ = %_[%_]" % [x(i), y(i), z(i)]
    (i:ReturnIns) : "return (%,)" % [xs(i)]
    (i:DumpIns) : "dump (%,)" % [xs(i)]
    (i:RecordLiveIns) : "live (%,)" % [live(i)]

defmethod print (o:OutputStream, op:VMOp) :
  print{o, _} $ match(op) :
    (op:InstanceofOp) : "instanceof<%_>" % [type(op)]
    (op:CurrentStackOp) : "current-stack"
    (op:AddOp) : "add"
    (op:SubOp) : "sub"
    (op:MulOp) : "mul"
    (op:DivOp) : "div"
    (op:ModOp) : "mod"
    (op:AndOp) : "and"
    (op:OrOp) : "or"
    (op:XorOp) : "xor"
    (op:NotOp) : "not"
    (op:ShlOp) : "shl"
    (op:ShrOp) : "shr"
    (op:AshrOp) : "ashr"
    (op:EqOp) : "eq"
    (op:NeOp) : "ne"
    (op:LtOp) : "lt"
    (op:GtOp) : "gt"
    (op:LeOp) : "le"
    (op:GeOp) : "ge"
    (op:UleOp) : "ule"
    (op:UltOp) : "ult"
    (op:UgtOp) : "ugt"
    (op:UgeOp) : "uge"
    (op:NegOp) : "neg"

defmethod print (o:OutputStream, t:VMType) :
  print{o, _} $ match(t) :
    (t:VMByte) : "byte"
    (t:VMInt) : "int"
    (t:VMLong) : "long"
    (t:VMFloat) : "float"
    (t:VMDouble) : "double"
    (t:VMRef) : "ref"
    (t:VMPointer) : "ptr"

defn lnprint (o:OutputStream, x) :
  print(o, '\n')
  print(o, x)

;============================================================
;======================= Reader =============================
;============================================================

defsyntax vmcode :
  defproduction op0 : VMOp
  defrule op0 = (current-stack) : CurrentStackOp()
  
  defproduction op1 : VMOp
  defrule op1 = (instanceof<?t:#int!>) : InstanceofOp(t)
  defrule op1 = (not) : NotOp()
  defrule op1 = (neg) : NegOp()

  defproduction op2 : VMOp
  defrule op2 = (add) : AddOp()
  defrule op2 = (sub) : SubOp()
  defrule op2 = (mul) : MulOp()
  defrule op2 = (div) : DivOp()
  defrule op2 = (mod) : ModOp()
  defrule op2 = (and) : AndOp()
  defrule op2 = (or) : OrOp()
  defrule op2 = (xor) : XorOp()
  defrule op2 = (shl) : ShlOp()
  defrule op2 = (shr) : ShrOp()
  defrule op2 = (ashr) : AshrOp()
  defrule op2 = (eq) : EqOp()
  defrule op2 = (ne) : NeOp()
  defrule op2 = (lt) : LtOp()
  defrule op2 = (gt) : GtOp()
  defrule op2 = (le) : LeOp()
  defrule op2 = (ge) : GeOp()
  defrule op2 = (ule) : UleOp()
  defrule op2 = (ult) : UltOp()
  defrule op2 = (ugt) : UgtOp()
  defrule op2 = (uge) : UgeOp()

  defproduction type : VMType
  defrule type = (byte) : VMByte()
  defrule type = (int) : VMInt()
  defrule type = (long) : VMLong()
  defrule type = (float) : VMFloat()
  defrule type = (double) : VMDouble()
  defrule type = (ref) : VMRef()
  defrule type = (ptr) : VMPointer()

  defn char-prefix? (x, c:Char) :
    unwrap-token(x) is Symbol and to-string(x)[0] == c
  defn char-index! (info:FileInfo|False, x:Symbol|Token) :
    val i = to-int(to-string(x)[1 to false])
    match(i:Int) : i
    else : throw(VME(info, "Invalid name: %~" % [x]))
    
  defproduction local : Local
  defrule local = (?r) when char-prefix?(r, 'L') : Local(char-index!(closest-info(), r))
  defproduction externid : ExternId
  defrule externid = (?r) when char-prefix?(r, 'E') : ExternId(char-index!(closest-info(), r))
  defproduction globalid : GlobalId
  defrule globalid = (?r) when char-prefix?(r, 'G') : GlobalId(char-index!(closest-info(), r))
  defproduction codeid : CodeId
  defrule codeid = (?r) when char-prefix?(r, 'F') : CodeId(char-index!(closest-info(), r))

  defproduction imm : VMImm
  defrule imm = (?x) when unwrap-token(x) is Byte|Int|Long|Float|Double : NumConst(unwrap-token(x))
  defrule imm = (?x:#local) : x
  defrule imm = (?x:#externid) : x
  defrule imm = (?x:#globalid) : x
  defrule imm = (?x:#codeid) : x

  defproduction ins : VMIns
  defrule ins = (?xs:#args = call ?f:#imm! (?ys:#imm! ...)) : CallIns(xs, f, to-tuple(ys))
  defrule ins = (?xs:#args = call-c ?f:#imm! (?ys:#imm! ...)) : CallCIns(xs, f, to-tuple(ys))
  defrule ins = (?xs:#args = call-closure ?f:#imm! (?ys:#imm! ...)) : CallClosureIns(xs, f, to-tuple(ys))
  defrule ins = (?xs:#args = yield ?f:#imm! (?ys:#imm! ...)) : YieldIns(xs, f, to-tuple(ys))
  defrule ins = (?x:#local = new-stack ?fid:#imm!) : NewStackIns(x, fid)
  defrule ins = ((?xs:#local ...) = alloc<?ts:#int! ...> (?sizes:#imm! ...)) : AllocIns(to-tuple(xs), to-tuple(ts), to-tuple(sizes))
  defrule ins = (?x:#local = ?y:#imm[?z:#imm!]) : LoadIns(x, y, z)
  defrule ins = (?x:#imm[?y:#imm] = ?z:#imm!) : StoreIns(x, y, z)
  defrule ins = (?x:#local = ?o:#op0) : Op0Ins(x, o)
  defrule ins = (?x:#local = ?o:#op1 ?y:#imm!) : Op1Ins(x, o, y)
  defrule ins = (?x:#local = ?o:#op2 ?y:#imm! ?z:#imm!) : Op2Ins(x, o, y, z)
  defrule ins = (?x:#local = ?y:#imm!) : SetIns(x,y)
  defrule ins = (label ?n:#int!) : LabelIns(n)
  defrule ins = (goto ?n:#int! when ?o:#op2 ?x:#imm! ?y:#imm!) : Branch2Ins(n, o, x, y)
  defrule ins = (goto ?n:#int! when ?o:#op1 ?x:#imm!) : Branch1Ins(n, o, x)
  defrule ins = (goto ?n:#int!) : GotoIns(n)
  defrule ins = (return (?xs:#imm! ...)) : ReturnIns(to-tuple(xs))
  defrule ins = (dump (?xs:#local ...)) : DumpIns(to-tuple(xs))
  defrule ins = (live (?xs:#local ...)) : RecordLiveIns(to-tuple(xs))

  defproduction args : Tuple<Local|False>
  defrule args = ((?xs:#arg ...)) : to-tuple(xs)  
  defproduction arg : Local|False
  defrule arg = (?x:#local) : x
  defrule arg = (_) : false

  defproduction def : VMDef
  defrule def = (def ?n:#local : ?t:#type! (local ?l:#int!)) : VMDef(index(n), t, l)

  defproduction extern : VMExtern
  defrule extern = (extern ?id:#externid ?name:#symbol!) : VMExtern(eid(id), name)

  defproduction global : VMGlobal
  defrule global = (global ?id:#globalid (size = ?size:#int!,
                                          position = ?pos:#int!,
                                          roots = (?rs:#int! ...))) :
    VMGlobal(gid(id), size, pos, to-tuple(rs))

  defproduction func : VMFunction
  defrule func = (multi ?id:#codeid (?arg:#int!) : (?bs:#branch ... ?eb:#elsebranch?)) :
    VMMulti(fid(id), arg, to-tuple(bs), eb)  
  defrule func = (?f:#func1) :
    f

  defproduction func1 : VMFunc
  defrule func1 = (func ?id:#codeid ?args:#args :  
                     ?defs:#def ...
                     ?ins:#ins! ...) :
    VMFunc(fid(id), args, to-tuple(defs), to-tuple(ins))

  defproduction branch : KeyValue<Int, VMFunc>
  defrule branch = (?n:#int! => ?f:#func1) :
    n => f

  defproduction elsebranch? : VMFunc|False
  defrule elsebranch? = (else => ?f:#func1) : f
  defrule elsebranch? = () : false

  defproduction class : VMClass
  defrule class = (class ?id:#int! (?parents:#int! ...) (
                     base-size = ?base:#int!,
                     item-size = ?item:#int!,
                     base-roots = (?brs:#int! ...),
                     item-roots = (?irs:#int! ...))) :
    VMArrayClass(id, to-tuple(parents), base, item, to-tuple(brs), to-tuple(irs))
  defrule class = (class ?id:#int! (?parents:#int! ...) (size = ?size:#int!, roots = (?rs:#int! ...))) :
    VMLeafClass(id, to-tuple(parents), size, to-tuple(rs))
  defrule class = (class ?id:#int! (?parents:#int! ...)) :
    VMAbstractClass(id, to-tuple(parents))

  public defproduction prog : VMProg
  defrule prog = (?stmts:#tstmt ...) :
    val gs = to-tuple(filter-by<VMGlobal>(stmts))
    val cs = to-tuple(filter-by<VMClass>(stmts))
    val fs = to-tuple(filter-by<VMFunction>(stmts))
    val es = to-tuple(filter-by<VMExtern>(stmts))
    VMProg(gs, cs, fs, es)

  defproduction tstmt : VMGlobal|VMClass|VMFunction|VMExtern
  defrule tstmt = (?x:#global) : x
  defrule tstmt = (?x:#extern) : x
  defrule tstmt = (?x:#class) : x
  defrule tstmt = (?x:#func) : x
  fail-if tstmt = () : VME(closest-info(), "Expected a top-level statement here.")

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

  ;===== Failure =====
  defproduction imm! : VMImm
  defrule imm! = (?x:#imm) : x
  fail-if imm! = () : VME(closest-info(), "Expected an immediate here.")

  defproduction int! : Int
  defrule int! = (?x:#int) : x
  fail-if int! = () : VME(closest-info(), "Expected an integer here.")

  defproduction ins! : VMIns
  defrule ins! = (?x:#ins) : x
  fail-if ins! = () : VME(closest-info(), "Expected an instruction here.")

  defproduction func! : VMFunction
  defrule func! = (?x:#func) : x
  fail-if func! = () : VME(closest-info(), "Expected a function here.")

  defproduction type! : VMType
  defrule type! = (?x:#type) : x
  fail-if type! = () : VME(closest-info(), "Expected a type here.")

  defproduction string! : String
  defrule string! = (?x:#string) : x
  fail-if string! = () : VME(closest-info(), "Expected a string here.")

  defproduction symbol! : Symbol
  defrule symbol! = (?x:#symbol) : x
  fail-if symbol! = () : VME(closest-info(), "Expected a symbol here.")


;============================================================
;====================== Errors ==============================
;============================================================

public defstruct VMError <: Exception :
  info: FileInfo|False
  msg

public defn VME (info:FileInfo|False, msg) :
  VMError(info, msg)

defmethod print (o:OutputStream, e:VMError) :
  val info-str = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [info-str, msg(e)])

;============================================================
;============================================================
;============================================================

public defn read-vm-prog (filename:String) :
  val forms = read-file(filename)
  parse-syntax[vmcode / #prog](forms)