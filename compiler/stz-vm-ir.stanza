defpackage stz/vm-ir :
  import core
  import collections
  import reader

;============================================================
;=================== Special Identifiers ====================
;============================================================

public val FALSE-TYPE = 0
public val TRUE-TYPE = 1
public val BYTE-TYPE = 2
public val CHAR-TYPE = 3
public val INT-TYPE = 4
public val FLOAT-TYPE = 5
public val STACK-TYPE = 6
public val FN-TYPE = 7
public val TYPE-TYPE = 8
public val NUM-BUILTIN-TYPES = 9

;============================================================
;================== Design of Instructions ==================
;============================================================

public defstruct VMProg :
  globals: Tuple<VMGlobal>
  datas: Tuple<VMData>
  consts: Tuple<VMConst>
  classes: Tuple<VMClass>
  funcs: Tuple<VMFunction> with: (updater => sub-funcs)
  multis: Tuple<VMMulti>
  methods: Tuple<VMMethod>
  externs: Tuple<VMExtern>  

public deftype VMId <: Hashable & Equalable
public defmulti id (id:VMId) -> Int
public defstruct CodeId <: VMId :
  id: Int with: (as-method => true)
public defstruct ExternId <: VMId :
  id: Int with: (as-method => true)
public defstruct GlobalId <: VMId :
  id: Int with: (as-method => true)
public defstruct DataId <: VMId :
  id: Int with: (as-method => true)
public defstruct ConstId <: VMId :
  id: Int with: (as-method => true)
public defstruct ClassId <: VMId :
  id: Int with: (as-method => true)

public deftype VMImm :
  CodeId <: VMImm
  ExternId <: VMImm
  GlobalId <: VMImm
  DataId <: VMImm
  ConstId <: VMImm  

public defstruct Local <: VMImm :
  index: Int
public defstruct NumConst <: VMImm :
  value: Char|Byte|Int|Long|Float|Double
public defstruct Marker <: VMImm :
  typeid: Int
public defstruct Tag <: VMImm :
  typeid: Int

public deftype VMType <: Hashable&Equalable
public defstruct VMByte <: VMType
public defstruct VMInt <: VMType
public defstruct VMLong <: VMType
public defstruct VMFloat <: VMType
public defstruct VMDouble <: VMType
public defstruct VMRef <: VMType

public deftype VMFunction
public defmulti id (f:VMFunction) -> Int

public defstruct VMMultifn <: VMFunction :
  id: Int with: (as-method => true)
  arg: Int
  funcs: Tuple<KeyValue<Int, VMFunc>> with: (updater => sub-funcs)
  default: VMFunc

public defstruct VMFunc <: VMFunction :
  id: Int with: (as-method => true)
  args: Tuple<Local|False>
  defs: Tuple<VMDef> with: (updater => sub-defs)
  ins: Tuple<VMIns> with: (updater => sub-ins)

public defstruct VMExtern :
  id: Int
  name: Symbol

public defstruct VMGlobal :
  id: Int
  size: Int
  roots: Tuple<Int>

public defstruct VMData :
  id: Int
  data: ByteArray

public defstruct VMConst :
  id: Int
  value: VMValue

public defstruct VMDef :
  id: Int
  type: VMType
  local: Int with: (updater => sub-local)

public defstruct VMMulti :
  id: Int  
  types: Tuple<VMType>
  dispatch-args: Tuple<Int>
  
public defstruct VMMethod :
  multi: Int
  types: Tuple<TypeSet>
  fid: Int

public deftype VMClass
public defmulti id (c:VMClass) -> Int
public defmulti parents (c:VMClass) -> Tuple<Int>

public defstruct VMArrayClass <: VMClass :
  id: Int with: (as-method => true)
  parents: Tuple<Int> with: (as-method => true)
  base-size: Int
  item-size: Int
  base-roots: Tuple<Int>
  item-roots: Tuple<Int>
public defstruct VMLeafClass <: VMClass :
  id: Int with: (as-method => true)
  parents: Tuple<Int> with: (as-method => true)
  size: Int
  roots: Tuple<Int>
public defstruct VMAbstractClass <: VMClass :
  id: Int with: (as-method => true)
  parents: Tuple<Int> with: (as-method => true)
  children: Tuple<Int>

public deftype VMIns
public defstruct CallIns <: VMIns :
  xs: Tuple<Local|False>
  f: VMImm
  ys: Tuple<VMImm>
public defstruct CallClosureIns <: VMIns :
  xs: Tuple<Local|False>
  f: VMImm
  ys: Tuple<VMImm>
public defstruct TCallIns <: VMIns :
  f: VMImm
  ys: Tuple<VMImm>
public defstruct TCallClosureIns <: VMIns :
  f: VMImm
  ys: Tuple<VMImm>
public defstruct CallCIns <: VMIns :
  xs: Tuple<Local|False>
  f: VMImm
  ys: Tuple<VMImm>
public defstruct YieldIns <: VMIns :
  xs: Tuple<Local|False>
  f: VMImm
  ys: Tuple<VMImm>
public defstruct NewStackIns <: VMIns :
  x: Local
  fid: VMImm
public defstruct SetIns <: VMIns :
  x: Local
  y: VMImm
public defstruct Op0Ins <: VMIns :
  x: Local
  op: VMOp
public defstruct Op1Ins <: VMIns :
  x: Local
  op: VMOp
  y: VMImm
public defstruct Op2Ins <: VMIns :
  x: Local
  op: VMOp
  y: VMImm
  z: VMImm
public defstruct LabelIns <: VMIns :
  n: Int
public defstruct GotoIns <: VMIns :
  n: Int with: (updater => sub-n)
public defstruct Branch1Ins <: VMIns :
  n1: Int with: (updater => sub-n1)
  n2: Int with: (updater => sub-n2)
  op: VMOp|False
  x: VMImm
public defstruct Branch2Ins <: VMIns :
  n1: Int with: (updater => sub-n1)
  n2: Int with: (updater => sub-n2)
  op: VMOp
  x: VMImm
  y: VMImm
public defstruct DispatchIns <: VMIns :
  ys: Tuple<VMImm>
  branches: Tuple<VMBranch>
  default: Int with: (updater => sub-n)
public defstruct MatchIns <: VMIns :
  ys: Tuple<VMImm>
  branches: Tuple<VMBranch>
  default: Int with: (updater => sub-n)
public defstruct AllocIns <: VMIns :
  xs: Tuple<Local>
  types: Tuple<Int>
  sizes: Tuple<VMImm>
public defstruct StoreIns <: VMIns :
  x: VMImm
  y: VMImm|False with: (default => false)
  offset: Int
  z: VMImm
public defstruct LoadIns <: VMIns :
  x: Local
  y: VMImm
  z: VMImm|False with: (default => false)
  offset: Int
public defstruct ReturnIns <: VMIns :
  xs: Tuple<VMImm>
public defstruct DumpIns <: VMIns :
  xs: Tuple<Local>
public defstruct RecordLiveIns <: VMIns :
  live: Tuple<Local>
public defstruct CommentIns <: VMIns :
  message: String

public deftype VMValue :
  Char <: VMValue
  Byte <: VMValue
  Int <: VMValue
  Long <: VMValue
  Float <: VMValue
  Double <: VMValue
  String <: VMValue
  Symbol <: VMValue
  List<T> <: VMValue
  True <: VMValue
  False <: VMValue
  
public defstruct VMTypeObject <: VMValue :
  id: CodeId
public defstruct VMClosure <: VMValue :
  id: CodeId
public defstruct VMBranch :
  types: Tuple<TypeSet>
  n: Int with: (updater => sub-n)

public deftype VMOp

public defstruct IntAddOp <: VMOp
public defstruct IntSubOp <: VMOp
public defstruct IntMulOp <: VMOp
public defstruct IntDivOp <: VMOp
public defstruct IntModOp <: VMOp
public defstruct IntAndOp <: VMOp
public defstruct IntOrOp <: VMOp
public defstruct IntXorOp <: VMOp
public defstruct IntNotOp <: VMOp
public defstruct IntShlOp <: VMOp
public defstruct IntShrOp <: VMOp
public defstruct IntAshrOp <: VMOp
public defstruct IntLtOp <: VMOp
public defstruct IntGtOp <: VMOp
public defstruct IntLeOp <: VMOp
public defstruct IntGeOp <: VMOp
public defstruct IntNegOp <: VMOp

public defstruct RefEqOp <: VMOp
public defstruct RefNeOp <: VMOp

public defstruct AddOp <: VMOp
public defstruct SubOp <: VMOp
public defstruct MulOp <: VMOp
public defstruct DivOp <: VMOp
public defstruct ModOp <: VMOp
public defstruct AndOp <: VMOp
public defstruct OrOp <: VMOp
public defstruct XorOp <: VMOp
public defstruct NotOp <: VMOp
public defstruct ShlOp <: VMOp
public defstruct ShrOp <: VMOp
public defstruct AshrOp <: VMOp
public defstruct EqOp <: VMOp
public defstruct NeOp <: VMOp
public defstruct LtOp <: VMOp
public defstruct GtOp <: VMOp
public defstruct LeOp <: VMOp
public defstruct GeOp <: VMOp
public defstruct UleOp <: VMOp
public defstruct UltOp <: VMOp
public defstruct UgtOp <: VMOp
public defstruct UgeOp <: VMOp
public defstruct NegOp <: VMOp
public defstruct InstanceofOp <: VMOp : (type:TypeSet)
public defstruct TagOp <: VMOp : (type:Int)
public defstruct DetagOp <: VMOp : (type:Int)
public defstruct ConvOp <: VMOp
public defstruct InterpretOp <: VMOp
public defstruct DerefOp <: VMOp

public defstruct CurrentStackOp <: VMOp
public defstruct GlobalsOp <: VMOp
public defstruct ConstsOp <: VMOp
public defstruct ConstsDataOp <: VMOp

public deftype TypeSet
public defstruct AndType <: TypeSet :
  types: Tuple<TypeSet>
public defstruct OrType <: TypeSet :
  types: Tuple<TypeSet>
public defstruct TopType <: TypeSet
public defstruct SingleType <: TypeSet :
  type: Int

;============================================================
;================== Hashes and Equality =====================
;============================================================

defmethod hash (x:VMId) :
  match(x) :
    (x:CodeId) : 7 * id(x)
    (x:ExternId) : 8 * id(x)
    (x:GlobalId) : 9 * id(x)
    (x:DataId) : 10 * id(x)
    (x:ConstId) : 11  * id(x)
    (x:ClassId) : 12 * id(x)

defmethod equal? (x:VMId, y:VMId) :
  match(x, y) :
    (x:CodeId, y:CodeId) : id(x) == id(y)
    (x:ExternId, y:ExternId) : id(x) == id(y)
    (x:GlobalId, y:GlobalId) : id(x) == id(y)
    (x:DataId, y:DataId) : id(x) == id(y)
    (x:ConstId, y:ConstId) : id(x) == id(y)
    (x:ClassId, y:ClassId) : id(x) == id(y)
    (x, y) : false

defmethod hash (x:VMType) :
  match(x) :
    (x:VMByte) : 0
    (x:VMInt) : 1
    (x:VMLong) : 2
    (x:VMFloat) : 3
    (x:VMDouble) : 4
    (x:VMRef) : 5

defmethod equal? (a:VMType, b:VMType) :
  hash(a) == hash(b)

;============================================================
;=================== Size Calculations ======================
;============================================================

public defn size (x:VMImm) :
  match(x) :
    (x:NumConst) :
      match(value(x)) :
        (v:Char) : 1
        (v:Byte) : 1
        (v:Int) : 4
        (v:Long) : 8
        (v:Float) : 4
        (v:Double) : 8
    (x:CodeId) : 8
    (x:ExternId) : 8
    (x:GlobalId) : 8
    (x:DataId) : 8
    (x:ConstId) : 8
    (x:Marker) : 8
    (x:Tag) : 8

public defn type (x:VMImm) :
  match(x) :
    (x:NumConst) :
      match(value(x)) :
        (v:Char) : VMByte()
        (v:Byte) : VMByte()
        (v:Int) : VMInt()
        (v:Long) : VMLong()
        (v:Float) : VMFloat()
        (v:Double) : VMDouble()
    (x:CodeId) : VMLong()
    (x:ExternId) : VMLong()
    (x:GlobalId) : VMLong()
    (x:DataId) : VMLong()
    (x:ConstId) : VMLong()
    (x:Marker) : VMRef()
    (x:Tag) : VMLong()

public defn size (t:VMType) :
  match(t) :
    (t:VMByte) : 1
    (t:VMInt) : 4
    (t:VMLong) : 8
    (t:VMFloat) : 4
    (t:VMDouble) : 8
    (t:VMRef) : 8

;============================================================
;===================== Mapper ===============================
;============================================================

public defn map (t:Int -> Int, g:Local -> Local, ins:VMIns) :
  defn h (x:False) :
    x
  defn h (x:VMImm) :
    match(x:Local) : g(x)
    else : x
  defn h (xs:Tuple<VMImm>) :
    map(h, xs)
  defn h (b:VMBranch) :
    VMBranch(types(b), t(n(b)))
  defn gs (xs:Tuple<Local|False>) :
    for x in xs map :
      match(x:Local) : g(x)
  match(ins) :
    (ins:TCallIns) :
      TCallIns(h(f(ins)), h(ys(ins)))
    (ins:TCallClosureIns) :
      TCallClosureIns(h(f(ins)), h(ys(ins)))
    (ins:CallIns) :
      CallIns(gs(xs(ins)), h(f(ins)), h(ys(ins)))
    (ins:CallCIns) :
      CallCIns(gs(xs(ins)), h(f(ins)), h(ys(ins)))
    (ins:CallClosureIns) :
      CallClosureIns(gs(xs(ins)), h(f(ins)), h(ys(ins)))
    (ins:YieldIns) :
      YieldIns(gs(xs(ins)), h(f(ins)), h(ys(ins)))      
    (ins:NewStackIns) :
      NewStackIns(g(x(ins)), h(fid(ins)))
    (ins:SetIns) :
      SetIns(g(x(ins)), h(y(ins)))
    (ins:Op0Ins) :
      Op0Ins(g(x(ins)), op(ins))
    (ins:Op1Ins) :
      Op1Ins(g(x(ins)), op(ins), h(y(ins)))
    (ins:Op2Ins) :
      Op2Ins(g(x(ins)), op(ins), h(y(ins)), h(z(ins)))
    (ins:LabelIns) :
      LabelIns(t(n(ins)))
    (ins:GotoIns) :
      GotoIns(t(n(ins)))
    (ins:Branch1Ins) :
      Branch1Ins(t(n1(ins)), t(n2(ins)), op(ins), h(x(ins)))
    (ins:Branch2Ins) :
      Branch2Ins(t(n1(ins)), t(n2(ins)), op(ins), h(x(ins)), h(y(ins)))
    (ins:AllocIns) :
      AllocIns(gs(xs(ins)) as Tuple<Local>, types(ins), h(sizes(ins)))
    (ins:StoreIns) :
      StoreIns(h(x(ins)), h(y(ins)), offset(ins), h(z(ins)))
    (ins:LoadIns) :
      LoadIns(g(x(ins)), h(y(ins)), h(z(ins)), offset(ins))
    (ins:ReturnIns) :
      ReturnIns(h(xs(ins)))
    (ins:DumpIns) :
      DumpIns(gs(xs(ins)) as Tuple<Local>)
    (ins:RecordLiveIns) :
      RecordLiveIns(gs(live(ins)) as Tuple<Local>)
    (ins:CommentIns) :
      ins
    (ins:MatchIns) :
      MatchIns(h(ys(ins)), map(h,branches(ins)), t(default(ins)))
    (ins:DispatchIns) :
      DispatchIns(h(ys(ins)), map(h,branches(ins)), t(default(ins)))

;============================================================
;==================== Printer ===============================
;============================================================

defn arg-string (xs:Tuple<Local|False>) :
  val xs* = for x in xs seq :
    match(x:False) : "_"
    else : x
  "(%,)" % [xs*]

defmethod print (o:OutputStream, p:VMProg) :
  val xs = cat-all $ [
    globals(p)
    datas(p)
    consts(p)
    externs(p)
    classes(p)
    funcs(p)
    multis(p)
    methods(p)]
  for (x in xs, i in 0 to false) do :
    if i == 0 : print(o, x)
    else : lnprint(o, x)

defmethod print (o:OutputStream, d:VMDef) :
  print(o, "def %_ : %_ (local %_)" % [Local(id(d)), type(d), local(d)])

defmethod print (o:OutputStream, g:VMGlobal) :
  print(o, "global %_ (size = %_, roots = (%,))" % [GlobalId(id(g)), size(g), roots(g)])

defmethod print (o:OutputStream, d:VMData) :
  print(o, "data %_ %~" % [DataId(id(d)), data(d)])

defmethod print (o:OutputStream, d:VMConst) :
  print(o, "const %_ %~" % [ConstId(id(d)), value(d)])

defmethod print (o:OutputStream, d:VMExtern) :
  print(o, "extern %_ %~" % [ExternId(id(d)), name(d)])

defmethod print (o:OutputStream, m:VMMulti) :
  print(o, "multi %_ (%,) (dispatch-on %,)" % [id(m), types(m), dispatch-args(m)])

defmethod print (o:OutputStream, m:VMMethod) :
  print(o, "method %_ (%,) : goto %_" % [multi(m), types(m), fid(m)])

defmethod print (o:OutputStream, m:VMMultifn) :
  print(o, "multifn %_ (%_) :" % [CodeId(id(m)), arg(m)])
  for entry in funcs(m) do :
    lnprint(o, "  %_ => " % [key(entry)])
    print-func(o, value(entry), 4)
  lnprint(o, "  else => ")
  print-func(o, default(m), 4)

defmethod print (o:OutputStream, f:VMFunc) :
  print-func(o, f, 2)

defn print-func (o:OutputStream, f:VMFunc, indent:Int) :
  print(o, "func %_ %_ :" % [CodeId(id(f)), arg-string(args(f))])
  val o2 = IndentedStream(o, indent)
  do(lnprint{o2, _}, defs(f))
  do(lnprint{o2, _}, ins(f))
  
defmethod print (o:OutputStream, c:VMAbstractClass) :
  print(o, "class %_ (%,)" % [id(c), parents(c)])

defmethod print (o:OutputStream, c:VMLeafClass) :
  print(o, "class %_ (%,) (size = %_, roots = (%,))" % [id(c), parents(c), size(c), roots(c)])

defmethod print (o:OutputStream, c:VMArrayClass) :
  print(o, "class %_ (%,) (base-size = %_, item-size = %_, base-roots = (%,), item-roots = (%,))" % [
    id(c), parents(c), base-size(c), item-size(c), base-roots(c), item-roots(c)])

defmethod print (o:OutputStream, x:VMId&VMImm) :
  print{o, _} $ match(x) :
    (x:CodeId) : "F%_" % [id(x)]
    (x:ExternId) : "E%_" % [id(x)]
    (x:GlobalId) : "G%_" % [id(x)]
    (x:DataId) : "D%_" % [id(x)]
    (x:ConstId) : "C%_" % [id(x)]

defmethod print (o:OutputStream, x:VMId) :
  print{o, _} $ match(x) :
    (x:ClassId) : "K%_" % [id(x)]

defmethod print (o:OutputStream, x:VMImm) :
  print{o, _} $ match(x) :
    (x:Local) : "L%_" % [index(x)]
    (x:NumConst) : "%~" % [value(x)]
    (x:Marker) : "M%_" % [typeid(x)]
    (x:Tag) : "T%_" % [typeid(x)]
  
defmethod print (o:OutputStream, i:VMIns) :
  defn P (x) : print(o, x)
  match(i) :
    (i:TCallIns) : P $ "return call %_ (%,)" % [f(i), ys(i)]
    (i:TCallClosureIns) : P $ "return call-closure %_ (%,)" % [f(i), ys(i)]
    (i:CallIns) : P $ "%_ = call %_ (%,)" % [arg-string(xs(i)), f(i), ys(i)]
    (i:CallCIns) : P $ "%_ = call-c %_ (%,)" % [arg-string(xs(i)), f(i), ys(i)]
    (i:CallClosureIns): P $ "%_ = call-closure %_ (%,)" % [arg-string(xs(i)), f(i), ys(i)]
    (i:YieldIns) : P $ "%_ = yield %_ (%,)" % [arg-string(xs(i)), f(i), ys(i)]
    (i:NewStackIns) : P $ "%_ = new-stack %_" % [x(i), fid(i)]
    (i:SetIns) : P $ "%_ = %_" % [x(i), y(i)]
    (i:Op0Ins) : P $ "%_ = %_" % [x(i), op(i)]
    (i:Op1Ins) : P $ "%_ = %_ %_" % [x(i), op(i), y(i)]
    (i:Op2Ins) : P $ "%_ = %_ %_ %_" % [x(i), op(i), y(i), z(i)]
    (i:LabelIns) : P $ "label %_" % [n(i)]
    (i:GotoIns) : P $ "goto %_" % [n(i)]
    (i:Branch1Ins) :
      val op-str = match(op(i)) :
        (op:VMOp) : " %_" % [op]
        (op:False) : ""
      P $ "goto %_ when%_ %_ else %_" % [n1(i), op-str, x(i), n2(i)]
    (i:Branch2Ins) : P $ "goto %_ when %_ %_ %_ else %_" % [n1(i), op(i), x(i), y(i), n2(i)]
    (i:AllocIns) : P $ "(%,) = alloc<%,> (%,)" % [xs(i), types(i), sizes(i)]
    (i:StoreIns) :
      val ystr = "" when y(i) is False
            else "%_ + " % [y(i)]        
      P $ "%_[%_%_] = %_" % [x(i), ystr, offset(i), z(i)]
    (i:LoadIns) :
      val zstr = "" when z(i) is False
            else "%_ + " % [z(i)]        
      P $ "%_ = %_[%_%_]" % [x(i), y(i), zstr, offset(i)]
    (i:ReturnIns) : P $ "return (%,)" % [xs(i)]
    (i:DumpIns) : P $ "dump (%,)" % [xs(i)]
    (i:RecordLiveIns) : P $ "live (%,)" % [live(i)]
    (i:CommentIns) : P $ "comment: %~" % [message(i)]
    (i:MatchIns|DispatchIns) :
      val opstr = "match" when i is MatchIns else "dispatch"
      print(o, "%_(%,)" % [opstr, ys(i)])
      val o2 = IndentedStream(o)
      do(lnprint{o2, _}, branches(i))
      lnprint(o2, "else : goto %_" % [default(i)])      

defmethod print (o:OutputStream, op:VMOp) :
  print{o, _} $ match(op) :
    (op:InstanceofOp) : "instanceof<%_>" % [type(op)]
    (op:TagOp) : "tag<%_>" % [type(op)]
    (op:DetagOp) : "detag<%_>" % [type(op)]
    (op:CurrentStackOp) : "current-stack"
    (op:GlobalsOp) : "globals"
    (op:ConstsOp) : "consts"
    (op:ConstsDataOp) : "consts-data"
    (op:AddOp) : "add"
    (op:SubOp) : "sub"
    (op:MulOp) : "mul"
    (op:DivOp) : "div"
    (op:ModOp) : "mod"
    (op:AndOp) : "and"
    (op:OrOp) : "or"
    (op:XorOp) : "xor"
    (op:NotOp) : "not"
    (op:ShlOp) : "shl"
    (op:ShrOp) : "shr"
    (op:AshrOp) : "ashr"
    (op:EqOp) : "eq"
    (op:NeOp) : "ne"
    (op:LtOp) : "lt"
    (op:GtOp) : "gt"
    (op:LeOp) : "le"
    (op:GeOp) : "ge"
    (op:UleOp) : "ule"
    (op:UltOp) : "ult"
    (op:UgtOp) : "ugt"
    (op:UgeOp) : "uge"
    (op:NegOp) : "neg"
    (op:IntAddOp) : "int-add"
    (op:IntSubOp) : "int-sub"
    (op:IntMulOp) : "int-mul"
    (op:IntDivOp) : "int-div"
    (op:IntModOp) : "int-mod"
    (op:IntAndOp) : "int-and"
    (op:IntOrOp) : "int-or"
    (op:IntXorOp) : "int-xor"
    (op:IntNotOp) : "int-not"
    (op:IntShlOp) : "int-shl"
    (op:IntShrOp) : "int-shr"
    (op:IntAshrOp) : "int-ashr"
    (op:IntLtOp) : "int-lt"
    (op:IntGtOp) : "int-gt"
    (op:IntLeOp) : "int-le"
    (op:IntGeOp) : "int-ge"
    (op:IntNegOp) : "int-neg"
    (op:RefEqOp) : "ref-eq"
    (op:RefNeOp) : "ref-ne"
    (op:ConvOp) : "conv"
    (op:InterpretOp) : "interpret"
    (op:DerefOp) : "deref"

defmethod print (o:OutputStream, t:VMType) :
  print{o, _} $ match(t) :
    (t:VMByte) : "byte"
    (t:VMInt) : "int"
    (t:VMLong) : "long"
    (t:VMFloat) : "float"
    (t:VMDouble) : "double"
    (t:VMRef) : "ref"

defmethod print (o:OutputStream, v:VMTypeObject) :
  print(o, "type(%_)" % [id(v)])

defmethod print (o:OutputStream, v:VMClosure) :
  print(o, "closure(%_)" % [id(v)])

defmethod print (o:OutputStream, b:VMBranch) :
  print(o, "(%,) : goto %_" % [types(b), n(b)])

defmethod print (o:OutputStream, t:TypeSet) :
  print{o, _} $ match(t) :
    (t:SingleType) : type(t)
    (t:TopType) : "?"
    (t:AndType) : "and(%,)" % [types(t)]
    (t:OrType) : "or(%,)" % [types(t)] 

defn lnprint (o:OutputStream, x) :
  print(o, '\n')
  print(o, x)

;============================================================
;======================= Reader =============================
;============================================================

defsyntax vmcode :
  defproduction op0 : VMOp
  defrule op0 = (current-stack) : CurrentStackOp()
  defrule op0 = (globals) : GlobalsOp()
  defrule op0 = (consts) : ConstsOp()
  defrule op0 = (consts-data) : ConstsDataOp()
  
  defproduction op1 : VMOp
  defrule op1 = (instanceof<?t:#typeset>) : InstanceofOp(t)
  defrule op1 = (tag<?t:#int!>) : TagOp(t)
  defrule op1 = (detag<?t:#int!>) : DetagOp(t)
  defrule op1 = (not) : NotOp()
  defrule op1 = (neg) : NegOp()
  defrule op1 = (int-not) : IntNotOp()
  defrule op1 = (int-neg) : IntNegOp()
  defrule op1 = (conv) : ConvOp()
  defrule op1 = (interpret) : InterpretOp()
  defrule op1 = (deref) : DerefOp()

  defproduction op2 : VMOp
  defrule op2 = (add) : AddOp()
  defrule op2 = (sub) : SubOp()
  defrule op2 = (mul) : MulOp()
  defrule op2 = (div) : DivOp()
  defrule op2 = (mod) : ModOp()
  defrule op2 = (and) : AndOp()
  defrule op2 = (or) : OrOp()
  defrule op2 = (xor) : XorOp()
  defrule op2 = (shl) : ShlOp()
  defrule op2 = (shr) : ShrOp()
  defrule op2 = (ashr) : AshrOp()
  defrule op2 = (eq) : EqOp()
  defrule op2 = (ne) : NeOp()
  defrule op2 = (lt) : LtOp()
  defrule op2 = (gt) : GtOp()
  defrule op2 = (le) : LeOp()
  defrule op2 = (ge) : GeOp()
  defrule op2 = (ule) : UleOp()
  defrule op2 = (ult) : UltOp()
  defrule op2 = (ugt) : UgtOp()
  defrule op2 = (uge) : UgeOp()
  defrule op2 = (int-add) : IntAddOp()
  defrule op2 = (int-sub) : IntSubOp()
  defrule op2 = (int-mul) : IntMulOp()
  defrule op2 = (int-div) : IntDivOp()
  defrule op2 = (int-mod) : IntModOp()
  defrule op2 = (int-and) : IntAndOp()
  defrule op2 = (int-or) : IntOrOp()
  defrule op2 = (int-xor) : IntXorOp()
  defrule op2 = (int-shl) : IntShlOp()
  defrule op2 = (int-shr) : IntShrOp()
  defrule op2 = (int-ashr) : IntAshrOp()
  defrule op2 = (int-lt) : IntLtOp()
  defrule op2 = (int-gt) : IntGtOp()
  defrule op2 = (int-le) : IntLeOp()
  defrule op2 = (int-ge) : IntGeOp()
  defrule op2 = (ref-eq) : RefEqOp()
  defrule op2 = (ref-ne) : RefNeOp()

  defproduction type : VMType
  defrule type = (byte) : VMByte()
  defrule type = (int) : VMInt()
  defrule type = (long) : VMLong()
  defrule type = (float) : VMFloat()
  defrule type = (double) : VMDouble()
  defrule type = (ref) : VMRef()

  defproduction typeset : TypeSet
  defrule typeset = (?n:#int) : SingleType(n)
  defrule typeset = (?) : TopType()
  defrule typeset = (and(?ts:#typeset ...)) : AndType(to-tuple(ts))
  defrule typeset = (or(?ts:#typeset ...)) : OrType(to-tuple(ts))

  defn char-prefix? (x, c:Char) :
    unwrap-token(x) is Symbol and to-string(x)[0] == c
  defn char-index! (info:FileInfo|False, x:Symbol|Token) :
    val i = to-int(to-string(x)[1 to false])
    match(i:Int) : i
    else : throw(VME(info, "Invalid name: %~" % [x]))
    
  defproduction local : Local
  defrule local = (?r) when char-prefix?(r, 'L') : Local(char-index!(closest-info(), r))
  defproduction externid : ExternId
  defrule externid = (?r) when char-prefix?(r, 'E') : ExternId(char-index!(closest-info(), r))
  defproduction globalid : GlobalId
  defrule globalid = (?r) when char-prefix?(r, 'G') : GlobalId(char-index!(closest-info(), r))
  defproduction dataid : DataId
  defrule dataid = (?r) when char-prefix?(r, 'D') : DataId(char-index!(closest-info(), r))
  defproduction constid : ConstId
  defrule constid = (?r) when char-prefix?(r, 'C') : ConstId(char-index!(closest-info(), r))
  defproduction marker : Marker
  defrule marker = (?r) when char-prefix?(r, 'M') : Marker(char-index!(closest-info(), r))
  defproduction tag : Tag
  defrule tag = (?r) when char-prefix?(r, 'T') : Tag(char-index!(closest-info(), r))
  defproduction codeid : CodeId
  defrule codeid = (?r) when char-prefix?(r, 'F') : CodeId(char-index!(closest-info(), r))

  defproduction imm : VMImm
  defrule imm = (?x) when unwrap-token(x) is Char|Byte|Int|Long|Float|Double : NumConst(unwrap-token(x))
  defrule imm = (?x:#local) : x
  defrule imm = (?x:#externid) : x
  defrule imm = (?x:#globalid) : x
  defrule imm = (?x:#dataid) : x
  defrule imm = (?x:#constid) : x
  defrule imm = (?x:#marker) : x
  defrule imm = (?x:#tag) : x
  defrule imm = (?x:#codeid) : x

  defproduction ins : VMIns
  defrule ins = (?xs:#args = call ?f:#imm! (?ys:#imm! ...)) : CallIns(xs, f, to-tuple(ys))
  defrule ins = (?xs:#args = call-c ?f:#imm! (?ys:#imm! ...)) : CallCIns(xs, f, to-tuple(ys))
  defrule ins = (?xs:#args = call-closure ?f:#imm! (?ys:#imm! ...)) : CallClosureIns(xs, f, to-tuple(ys))
  defrule ins = (?xs:#args = yield ?f:#imm! (?ys:#imm! ...)) : YieldIns(xs, f, to-tuple(ys))
  defrule ins = (?x:#local = new-stack ?fid:#imm!) : NewStackIns(x, fid)
  defrule ins = ((?xs:#local ...) = alloc<?ts:#int! ...> (?sizes:#imm! ...)) : AllocIns(to-tuple(xs), to-tuple(ts), to-tuple(sizes))
  defrule ins = (?x:#local = ?y:#imm[?z:#offset? ?o:#int!]) : LoadIns(x, y, z, o)
  defrule ins = (?x:#imm[?y:#offset? ?o:#int!] = ?z:#imm!) : StoreIns(x, y, o, z)
  defrule ins = (?x:#local = ?o:#op0) : Op0Ins(x, o)
  defrule ins = (?x:#local = ?o:#op1 ?y:#imm!) : Op1Ins(x, o, y)
  defrule ins = (?x:#local = ?o:#op2 ?y:#imm! ?z:#imm!) : Op2Ins(x, o, y, z)
  defrule ins = (?x:#local = ?y:#imm!) : SetIns(x,y)
  defrule ins = (label ?n:#int!) : LabelIns(n)
  defrule ins = (goto ?n1:#int! when ?o:#op2 ?x:#imm! ?y:#imm! else ?n2:#int!) : Branch2Ins(n1, n2, o, x, y)
  defrule ins = (goto ?n1:#int! when ?o:#op1 ?x:#imm! else ?n2:#int!) : Branch1Ins(n1, n2, o, x)
  defrule ins = (goto ?n1:#int! when ?x:#imm! else ?n2:#int!) : Branch1Ins(n1, n2, false, x)
  defrule ins = (goto ?n:#int!) : GotoIns(n)
  defrule ins = (return call ?f:#imm! (?ys:#imm! ...)) : TCallIns(f, to-tuple(ys))
  defrule ins = (return call-closure ?f:#imm! (?ys:#imm! ...)) : TCallClosureIns(f, to-tuple(ys))
  defrule ins = (return (?xs:#imm! ...)) : ReturnIns(to-tuple(xs))
  defrule ins = (dump (?xs:#local ...)) : DumpIns(to-tuple(xs))
  defrule ins = (live (?xs:#local ...)) : RecordLiveIns(to-tuple(xs))
  defrule ins = (comment: ?x:#string!) : CommentIns(x)
  defrule ins = (match(?ys:#imm! ...) : (?bs:#vmbranch ... ?d:#defaultbranch)) : MatchIns(to-tuple(ys), to-tuple(bs), d)
  defrule ins = (dispatch(?ys:#imm! ...) : (?bs:#vmbranch ... ?d:#defaultbranch)) : DispatchIns(to-tuple(ys), to-tuple(bs), d)

  defproduction offset? : VMImm|False
  defrule offset? = (?x:#imm +) : x
  defrule offset? = () : false

  defproduction args : Tuple<Local|False>
  defrule args = ((?xs:#arg ...)) : to-tuple(xs)  
  defproduction arg : Local|False
  defrule arg = (?x:#local) : x
  defrule arg = (_) : false

  defproduction def : VMDef
  defrule def = (def ?n:#local : ?t:#type! (local ?l:#int!)) : VMDef(index(n), t, l)

  defproduction extern : VMExtern
  defrule extern = (extern ?x:#externid ?name:#symbol!) : VMExtern(id(x), name)

  defproduction global : VMGlobal
  defrule global = (global ?x:#globalid (size = ?size:#int!,
                                         roots = (?rs:#int! ...))) :
    VMGlobal(id(x), size, to-tuple(rs))

  defn to-byte-array (bs:List<Byte>) :
    val b = ByteArray(length(bs))
    b[0 to false] = bs
    b

  defproduction data : VMData
  defrule data = (data ?x:#dataid [?bytes:#byte! ...]) :
    VMData(id(x), to-byte-array(bytes))

  defproduction const : VMConst
  defrule const = (const ?x:#constid ?v:#vmvalue) :
    VMConst(id(x), v)

  defproduction vmbranch : VMBranch
  defrule vmbranch = ((?ts:#typeset ...) : goto ?n:#int) : VMBranch(to-tuple(ts), n)  
  defproduction defaultbranch : Int
  defrule defaultbranch = (else : goto ?n:#int) : n

  defproduction func : VMFunction
  defrule func = (multifn ?x:#codeid (?arg:#int!) : (?bs:#branch ... ?eb:#elsebranch)) :
    VMMultifn(id(x), arg, to-tuple(bs), eb)  
  defrule func = (?f:#func1) :
    f

  defproduction branch : KeyValue<Int, VMFunc>
  defrule branch = (?n:#int => ?f:#func1) :
    n => f

  defproduction elsebranch : VMFunc
  defrule elsebranch = (else => ?f:#func1) : f

  defproduction func1 : VMFunc
  defrule func1 = (func ?x:#codeid ?args:#args :  
                     ?defs:#def ...
                     ?ins:#ins! ...) :
    VMFunc(id(x), args, to-tuple(defs), to-tuple(ins))

  defproduction vmvalue : VMValue
  defrule vmvalue = (type(?id:#codeid)) : VMTypeObject(id)
  defrule vmvalue = (closure(?id:#codeid)) : VMClosure(id)
  defrule vmvalue = (?x) when unwrap-token(x) is VMValue : unwrap-all(x)

  defproduction class : VMClass
  defrule class = (class ?id:#int! (?parents:#int! ...) (
                     base-size = ?base:#int!,
                     item-size = ?item:#int!,
                     base-roots = (?brs:#int! ...),
                     item-roots = (?irs:#int! ...))) :
    VMArrayClass(id, to-tuple(parents), base, item, to-tuple(brs), to-tuple(irs))
  defrule class = (class ?id:#int! (?parents:#int! ...) (size = ?size:#int!, roots = (?rs:#int! ...))) :
    VMLeafClass(id, to-tuple(parents), size, to-tuple(rs))
  defrule class = (class ?id:#int! (?parents:#int! ...) (children = (?cs:#int! ...))) :
    VMAbstractClass(id, to-tuple(parents), to-tuple(cs))

  defproduction vmmulti : VMMulti
  defrule vmmulti = (multi ?id:#int (?ts:#type ...) (dispatch-on ?args:#int ...)) :
    VMMulti(id, to-tuple(ts), to-tuple(args))

  defproduction vmmethod : VMMethod
  defrule vmmethod = (method ?multi:#int (?types:#typeset ...) : goto ?fid:#int) :
    VMMethod(multi, to-tuple(types), fid)

  public defproduction prog : VMProg
  defrule prog = (?stmts:#tstmt ...) :
    val gs = to-tuple(filter-by<VMGlobal>(stmts))
    val ds = to-tuple(filter-by<VMData>(stmts))
    val cts = to-tuple(filter-by<VMConst>(stmts))
    val cs = to-tuple(filter-by<VMClass>(stmts))
    val fs = to-tuple(filter-by<VMFunction>(stmts))
    val es = to-tuple(filter-by<VMExtern>(stmts))
    val ms = to-tuple(filter-by<VMMulti>(stmts))
    val mds = to-tuple(filter-by<VMMethod>(stmts))
    VMProg(gs, ds, cts, cs, fs, ms, mds, es)

  defproduction tstmt : VMGlobal|VMClass|VMFunction|VMExtern|VMData|VMConst|VMMulti|VMMethod
  defrule tstmt = (?x:#global) : x
  defrule tstmt = (?x:#data) : x
  defrule tstmt = (?x:#const) : x
  defrule tstmt = (?x:#extern) : x
  defrule tstmt = (?x:#class) : x
  defrule tstmt = (?x:#func) : x
  defrule tstmt = (?x:#vmmulti) : x
  defrule tstmt = (?x:#vmmethod) : x
  fail-if tstmt = () : VME(closest-info(), "Expected a top-level statement here.")

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction byte : Byte
  defrule byte = (?x) when unwrap-token(x) is Byte : unwrap-token(x)

  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

  ;===== Failure =====
  defproduction imm! : VMImm
  defrule imm! = (?x:#imm) : x
  fail-if imm! = () : VME(closest-info(), "Expected an immediate here.")

  defproduction int! : Int
  defrule int! = (?x:#int) : x
  fail-if int! = () : VME(closest-info(), "Expected an integer here.")

  defproduction byte! : Byte
  defrule byte! = (?x:#byte) : x
  fail-if byte! = () : VME(closest-info(), "Expected a byte here.")

  defproduction ins! : VMIns
  defrule ins! = (?x:#ins) : x
  fail-if ins! = () : VME(closest-info(), "Expected an instruction here.")

  defproduction func! : VMFunction
  defrule func! = (?x:#func) : x
  fail-if func! = () : VME(closest-info(), "Expected a function here.")

  defproduction type! : VMType
  defrule type! = (?x:#type) : x
  fail-if type! = () : VME(closest-info(), "Expected a type here.")

  defproduction string! : String
  defrule string! = (?x:#string) : x
  fail-if string! = () : VME(closest-info(), "Expected a string here.")

  defproduction symbol! : Symbol
  defrule symbol! = (?x:#symbol) : x
  fail-if symbol! = () : VME(closest-info(), "Expected a symbol here.")


;============================================================
;====================== Errors ==============================
;============================================================

public defstruct VMError <: Exception :
  info: FileInfo|False
  msg

public defn VME (info:FileInfo|False, msg) :
  VMError(info, msg)

defmethod print (o:OutputStream, e:VMError) :
  val info-str = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [info-str, msg(e)])

;============================================================
;============================================================
;============================================================

public defn read-vm-prog (filename:String) :
  val forms = read-file(filename)
  parse-syntax[vmcode / #prog](forms)