defpackage stz/vm-ir :
  import core
  import collections
  import reader
  import stz/dl-ir
  import stz/utils
  import stz/basic-ops

;============================================================
;================== Design of Instructions ==================
;============================================================

public defstruct VMPackage :
  packageio: PackageIO
  init: Int|False
  globals: Tuple<VMGlobal> with: (updater => sub-globals)
  datas: Tuple<VMData>
  consts: Tuple<VMConst>
  classes: Tuple<VMClass>
  funcs: Tuple<VMFunction> with: (updater => sub-funcs)
  methods: Tuple<VMMethod>
  externs: Tuple<VMExtern>

public deftype VMImm
public defstruct Local <: VMImm :
  index: Int
public defstruct NumConst <: VMImm :
  value: Char|Byte|Int|Long|Float|Double
public defstruct Marker <: VMImm :
  typeid: Int
public defstruct Tag <: VMImm :
  typeid: Int
public defstruct CodeId <: VMImm :
  id: Int
public defstruct ExternId <: VMImm :
  id: Int
public defstruct GlobalId <: VMImm :
  id: Int
public defstruct DataId <: VMImm :
  id: Int
public defstruct ConstId <: VMImm :
  id: Int
public defstruct VoidMarker <: VMImm

public deftype VMType <: Hashable&Equalable
public defstruct VMByte <: VMType
public defstruct VMInt <: VMType
public defstruct VMLong <: VMType
public defstruct VMFloat <: VMType
public defstruct VMDouble <: VMType
public defstruct VMRef <: VMType

public deftype VMFunction
public defmulti id (f:VMFunction) -> Int
public defmulti dependencies (f:VMFunction) -> Tuple<Int>
public defmulti sub-dependencies (f:VMFunction, ds:Tuple<Int>) -> VMFunction

public defstruct VMMultifn <: VMFunction :
  id: Int with: (as-method => true)
  dependencies: Tuple<Int> with: (default => [], as-method => true, updater => sub-dependencies)
  arg: Int
  funcs: Tuple<KeyValue<Int, VMFunc>> with: (updater => sub-funcs)
  default: VMFunc

public defstruct VMFunc <: VMFunction :
  id: Int with: (as-method => true)
  dependencies: Tuple<Int> with: (default => [], as-method => true, updater => sub-dependencies)
  args: Tuple<Local|False>
  defs: Tuple<VMDef> with: (updater => sub-defs)
  ins: Tuple<VMIns> with: (updater => sub-ins)

public defstruct VMExtern :
  id: Int
  name: Symbol

public defstruct VMGlobal :
  id: Int
  size: Int
  roots: Tuple<Int>

public defstruct VMData :
  id: Int
  data: ByteArray

public defstruct VMConst :
  id: Int
  value: VMValue

public defstruct VMDef :
  id: Int
  type: VMType
  local: Int with: (updater => sub-local)
  
public defstruct VMMethod :
  instance?: True|False
  multi: Int
  types: Tuple<TypeSet>
  fid: Int

public deftype VMClass
public defmulti id (c:VMClass) -> Int
public defmulti parents (c:VMClass) -> Tuple<Int>

public defstruct VMArrayClass <: VMClass :
  id: Int with: (as-method => true)
  dependencies: Tuple<Int>
  parents: Tuple<Int> with: (as-method => true)
  base-size: Int
  item-size: Int
  base-roots: Tuple<Int>
  item-roots: Tuple<Int>
public defstruct VMLeafClass <: VMClass :
  id: Int with: (as-method => true)
  dependencies: Tuple<Int>
  parents: Tuple<Int> with: (as-method => true)
  size: Int
  roots: Tuple<Int>
public defstruct VMAbstractClass <: VMClass :
  id: Int with: (as-method => true)
  parents: Tuple<Int> with: (as-method => true)
  children: Tuple<Int>

public deftype VMIns
public defmulti info (ins:VMIns) -> False|FileInfo
defmethod info (ins:VMIns) :
  fatal("Instruction %_ does not support file information." % [ins])

public defstruct CallIns <: VMIns :
  xs: Tuple<Local|False>
  f: VMImm
  ys: Tuple<VMImm>
  info: False|FileInfo with: (as-method => true)
public defstruct EndCallIns <: VMIns :
  f: VMImm
  ys: Tuple<VMImm>
  info: False|FileInfo with: (as-method => true)
public defstruct CallClosureIns <: VMIns :
  xs: Tuple<Local|False>
  f: VMImm
  ys: Tuple<VMImm>
  info: False|FileInfo with: (as-method => true)
public defstruct TCallIns <: VMIns :
  f: VMImm
  ys: Tuple<VMImm>
public defstruct TCallClosureIns <: VMIns :
  f: VMImm
  ys: Tuple<VMImm>
public defstruct CallCIns <: VMIns :
  xs: Tuple<Local|False>
  f: VMImm
  ys: Tuple<VMImm>
  info: False|FileInfo with: (as-method => true)
public defstruct YieldIns <: VMIns :
  xs: Tuple<Local|False>
  f: VMImm
  ys: Tuple<VMImm>
  info: False|FileInfo with: (as-method => true)
public defstruct NewStackIns <: VMIns :
  x: Local
  fid: VMImm
  info: False|FileInfo with: (as-method => true)
public defstruct SetIns <: VMIns :
  x: Local
  y: VMImm
public defstruct Op0Ins <: VMIns :
  x: Local
  op: VMOp
public defstruct Op1Ins <: VMIns :
  x: Local
  op: VMOp
  y: VMImm
public defstruct Op2Ins <: VMIns :
  x: Local
  op: VMOp
  y: VMImm
  z: VMImm
public defstruct LabelIns <: VMIns :
  n: Int
public defstruct GotoIns <: VMIns :
  n: Int with: (updater => sub-n)
public defstruct Branch1Ins <: VMIns :
  n1: Int with: (updater => sub-n1)
  n2: Int with: (updater => sub-n2)
  op: VMOp|False
  x: VMImm
public defstruct Branch2Ins <: VMIns :
  n1: Int with: (updater => sub-n1)
  n2: Int with: (updater => sub-n2)
  op: VMOp
  x: VMImm
  y: VMImm
public defstruct DispatchIns <: VMIns :
  ys: Tuple<VMImm>
  branches: Tuple<VMBranch>
  default: Int
  amb: Int
public defstruct MatchIns <: VMIns :
  ys: Tuple<VMImm>
  branches: Tuple<VMBranch>
  default: Int
public defstruct MethodDispatchIns <: VMIns :
  multi: Int
  ys: Tuple<VMImm>
  zs: Tuple<VMImm>
  default: Int
  amb: Int  
public defstruct AllocIns <: VMIns :
  xs: Tuple<Local>
  types: Tuple<Int>
  sizes: Tuple<VMImm>
  info: False|FileInfo with: (as-method => true)
public defstruct StoreIns <: VMIns :
  x: VMImm
  y: VMImm|False with: (default => false)
  offset: Int
  z: VMImm
  class: Int|False with: (default => false)
public defstruct LoadIns <: VMIns :
  x: Local
  y: VMImm
  z: VMImm|False with: (default => false)
  offset: Int
  class: Int|False with: (default => false)
public defstruct ReturnIns <: VMIns :
  xs: Tuple<VMImm>
public defstruct DumpIns <: VMIns :
  xs: Tuple<Local>
public defstruct RecordLiveIns <: VMIns :
  live: Tuple<Local>
public defstruct CommentIns <: VMIns :
  message: String
public defstruct UnreachableIns <: VMIns

public deftype VMValue :
  Char <: VMValue
  Byte <: VMValue
  Int <: VMValue
  Long <: VMValue
  Float <: VMValue
  Double <: VMValue
  String <: VMValue
  Symbol <: VMValue
  List<T> <: VMValue
  True <: VMValue
  False <: VMValue
  
public defstruct VMTypeObject <: VMValue :
  id: CodeId
public defstruct VMClosure <: VMValue :
  id: CodeId
public defstruct VMInternedConst <: VMValue :
  id: ConstId
public defstruct VMBranch :
  types: Tuple<TypeSet>
  n: Int with: (updater => sub-n)

public deftype VMOp :
  BasicOp <: VMOp
public defstruct InstanceofOp <: VMOp : (type:TypeSet)
public defstruct TagOp <: VMOp : (type:Int)
public defstruct DetagOp <: VMOp : (type:Int)
public defstruct ConvOp <: VMOp
public defstruct InterpretOp <: VMOp
public defstruct DerefOp <: VMOp

public deftype TypeSet <: Equalable & Comparable<TypeSet> & Hashable
public defstruct AndType <: TypeSet :
  types: Tuple<TypeSet>
public defstruct OrType <: TypeSet :
  types: Tuple<TypeSet>
public defstruct TopType <: TypeSet
public defstruct SingleType <: TypeSet :
  type: Int

;============================================================
;==================== Convenience ===========================
;============================================================

public defn StoreIns (x:VMImm, offset:Int, z:VMImm, class:Int|False) :
  StoreIns(x, false, offset, z, class)

public defn LoadIns (x:Local, y:VMImm, offset:Int, class:Int|False) :
  LoadIns(x, y, false, offset, class)

public defn package (vmp:VMPackage) :
  package(packageio(vmp))

;============================================================
;================== Hashes and Equality =====================
;============================================================

defmethod hash (x:VMType) :
  match(x) :
    (x:VMByte) : 0
    (x:VMInt) : 1
    (x:VMLong) : 2
    (x:VMFloat) : 3
    (x:VMDouble) : 4
    (x:VMRef) : 5

defmethod equal? (a:VMType, b:VMType) :
  hash(a) == hash(b)

defn rank (t:TypeSet) :
  match(t) :
    (t:AndType) : 0
    (t:OrType) : 1
    (t:SingleType) : 2
    (t:TopType) : 3

defmethod hash (t:TypeSet) :
  val base = rank(t) * 13
  defn H (y) : base + hash(y)
  match(t) :
    (t:AndType) : H $ types(t)
    (t:OrType) : H $ types(t)
    (t:SingleType) : H $ type(t)
    (t:TopType) : base

defmethod equal? (a:TypeSet, b:TypeSet) :
  match(a, b) :
    (a:AndType, b:AndType) : types(a) == types(b)
    (a:OrType, b:OrType) : types(a) == types(b)
    (a:SingleType, b:SingleType) : type(a) == type(b)
    (a:TopType, b:TopType) : true
    (a, b) : false

defmethod compare (a:TypeSet, b:TypeSet) :
  match(a, b) :
    (a:AndType, b:AndType) : compare(types(a), types(b))
    (a:OrType, b:OrType) : compare(types(a), types(b))
    (a:SingleType, b:SingleType) : compare(type(a), type(b))
    (a:TopType, b:TopType) : 0
    (a, b) : compare(rank(a), rank(b))

public defn normalize (t:TypeSet) :
  match(t) :
    (t:AndType) :
      val ts = Vector<TypeSet>()
      defn add-t (t:TypeSet) :
        match(normalize(t)) :
          (t:TopType) : false
          (t) : add(ts, t)
      for t in types(t) do :
        match(t) :
          (t:AndType) : do(add-t, types(t))
          (t) : add-t(t)
      qsort!(ts)
      remove-duplicates!(ts)
      if empty?(ts) : TopType()
      else : AndType(to-tuple(ts))
    (t:OrType) :
      label<TypeSet> return :
        val ts = Vector<TypeSet>()
        defn add-t (t:TypeSet) :
          match(normalize(t)) :
            (t:TopType) : return(t)
            (t) : add(ts,t)
        for t in types(t) do :
          match(t) :
            (t:OrType) : do(add-t, types(t))
            (t) : add-t(t)
        qsort!(ts)        
        remove-duplicates!(ts)
        fatal("Unreachable") when empty?(ts)
        OrType(to-tuple(ts))
    (t) : t
  
;============================================================
;=================== Size Calculations ======================
;============================================================

public defn size (x:VMImm) :
  match(x) :
    (x:NumConst) :
      match(value(x)) :
        (v:Char) : 1
        (v:Byte) : 1
        (v:Int) : 4
        (v:Long) : 8
        (v:Float) : 4
        (v:Double) : 8
    (x:CodeId) : 8
    (x:ExternId) : 8
    (x:GlobalId) : 8
    (x:DataId) : 8
    (x:ConstId) : 8
    (x:Marker) : 8
    (x:VoidMarker) : 8
    (x:Tag) : 8

public defn type (x:VMImm) :
  match(x) :
    (x:NumConst) :
      match(value(x)) :
        (v:Char) : VMByte()
        (v:Byte) : VMByte()
        (v:Int) : VMInt()
        (v:Long) : VMLong()
        (v:Float) : VMFloat()
        (v:Double) : VMDouble()
    (x:CodeId) : VMLong()
    (x:ExternId) : VMLong()
    (x:GlobalId) : VMLong()
    (x:DataId) : VMLong()
    (x:ConstId) : VMLong()
    (x:Marker) : VMRef()
    (x:VoidMarker) : VMRef()
    (x:Tag) : VMLong()

public defn size (t:VMType) :
  match(t) :
    (t:VMByte) : 1
    (t:VMInt) : 4
    (t:VMLong) : 8
    (t:VMFloat) : 4
    (t:VMDouble) : 8
    (t:VMRef) : 8

;============================================================
;===================== Mapper ===============================
;============================================================

public defn map<?T> (fx:Local -> Local, fid:Int -> Int, x:?T&VMImm) :
  {_ as T&VMImm} $ match(x) :
    (x:Local) : fx(x)
    (x:Marker) : Marker(fid(typeid(x)))
    (x:Tag) : Tag(fid(typeid(x)))
    (x:CodeId) : CodeId(fid(id(x)))
    (x:ExternId) : ExternId(fid(id(x)))
    (x:GlobalId) : GlobalId(fid(id(x)))
    (x:DataId) : DataId(fid(id(x)))
    (x:ConstId) : ConstId(fid(id(x)))
    (x) : x

deftype MapItem :
  False <: MapItem
  VMImm <: MapItem
  TypeSet <: MapItem
  VMBranch <: MapItem
  VMOp <: MapItem  
public defn map<?T> (fl:Int -> Int,
                     fx:Local -> Local,
                     fid:Int -> Int,
                     ins:?T&VMIns) :
  defn h<?T> (x:?T&MapItem) :
    val result = match(x) :
      (x:VMImm) : map(fx, fid, x)
      (x:SingleType) : SingleType(fid(type(x)))
      (x:AndType) : AndType(h(types(x)))
      (x:OrType) : OrType(h(types(x)))
      (x:Local) : fx(x)
      (x:Marker) : Marker(fid(typeid(x)))
      (x:Tag) : Tag(fid(typeid(x)))
      (x:CodeId) : CodeId(fid(id(x)))
      (x:ExternId) : ExternId(fid(id(x)))
      (x:GlobalId) : GlobalId(fid(id(x)))
      (x:DataId) : DataId(fid(id(x)))
      (x:ConstId) : ConstId(fid(id(x)))
      (x:VMBranch) : VMBranch(h(types(x)),fl(n(x)))
      (x:InstanceofOp) : InstanceofOp(h(type(x)))
      (x:TagOp) : TagOp(fid(type(x)))
      (x:DetagOp) : DetagOp(fid(type(x)))
      (x) : x
    result as T&MapItem
  defn h<?T> (x:Tuple<?T&MapItem>) :
    map(h,x)
  defn fid? (x:Int|False) :
    match(x:Int) : fid(x)
      
  {_ as T&VMIns} $ match(ins) :
    (ins:TCallIns) :
      TCallIns(h(f(ins)), h(ys(ins)))
    (ins:TCallClosureIns) :
      TCallClosureIns(h(f(ins)), h(ys(ins)))
    (ins:CallIns) :
      CallIns(h(xs(ins)), h(f(ins)), h(ys(ins)), info(ins))
    (ins:UnreachableIns) :
      ins
    (ins:CallCIns) :
      CallCIns(h(xs(ins)), h(f(ins)), h(ys(ins)), info(ins))
    (ins:CallClosureIns) :
      CallClosureIns(h(xs(ins)), h(f(ins)), h(ys(ins)), info(ins))
    (ins:YieldIns) :
      YieldIns(h(xs(ins)), h(f(ins)), h(ys(ins)), info(ins))      
    (ins:NewStackIns) :
      NewStackIns(h(x(ins)), h(/fid(ins)), info(ins))
    (ins:SetIns) :
      SetIns(h(x(ins)), h(y(ins)))
    (ins:Op0Ins) :
      Op0Ins(h(x(ins)), h(op(ins)))
    (ins:Op1Ins) :
      Op1Ins(h(x(ins)), h(op(ins)), h(y(ins)))
    (ins:Op2Ins) :
      Op2Ins(h(x(ins)), h(op(ins)), h(y(ins)), h(z(ins)))
    (ins:LabelIns) :
      LabelIns(fl(n(ins)))
    (ins:GotoIns) :
      GotoIns(fl(n(ins)))
    (ins:Branch1Ins) :
      Branch1Ins(fl(n1(ins)), fl(n2(ins)), h(op(ins)), h(x(ins)))
    (ins:Branch2Ins) :
      Branch2Ins(fl(n1(ins)), fl(n2(ins)), h(op(ins)), h(x(ins)), h(y(ins)))
    (ins:AllocIns) :
      AllocIns(h(xs(ins)), map(fid,types(ins)), h(sizes(ins)), info(ins))
    (ins:StoreIns) :
      StoreIns(h(x(ins)), h(y(ins)), offset(ins), h(z(ins)), fid?(class(ins)))
    (ins:LoadIns) :
      LoadIns(h(x(ins)), h(y(ins)), h(z(ins)), offset(ins), fid?(class(ins)))
    (ins:ReturnIns) :
      ReturnIns(h(xs(ins)))
    (ins:DumpIns) :
      DumpIns(h(xs(ins)))
    (ins:RecordLiveIns) :
      RecordLiveIns(h(live(ins)))
    (ins:CommentIns) :
      ins
    (ins:MatchIns) :
      MatchIns(h(ys(ins)), h(branches(ins)), fl(default(ins)))
    (ins:DispatchIns) :
      DispatchIns(h(ys(ins)), h(branches(ins)), fl(default(ins)), fl(amb(ins)))
    (ins:MethodDispatchIns) :
      MethodDispatchIns(fid(multi(ins)), h(ys(ins)), h(zs(ins)), fl(default(ins)), fl(amb(ins)))

public defn map-id (fid:Int -> Int, x:TypeSet) :
  let loop (x:TypeSet = x) :
    match(x) :
      (x:SingleType) : SingleType(fid(type(x)))
      (x:AndType) : AndType(map(loop,types(x)))
      (x:OrType) : OrType(map(loop,types(x)))
      (x:TopType) : x
public defn map-id (fid:Int -> Int, x:VMValue) -> VMValue :
  match(x) :
    (x:VMTypeObject) : VMTypeObject(CodeId(fid(id(id(x)))))
    (x:VMClosure) : VMClosure(CodeId(fid(id(id(x)))))
    (x:VMInternedConst) : VMInternedConst(ConstId(fid(id(id(x)))))
    (x:List) : for xi in x map : map-id(fid, xi)
    (x) : x
public defn map-id (fid:Int -> Int, x:VMGlobal) :
  VMGlobal(fid(id(x)), size(x), roots(x))
public defn map-id (fid:Int -> Int, x:VMData) :
  VMData(fid(id(x)), data(x))
public defn map-id (fid:Int -> Int, x:VMConst) :
  VMConst(fid(id(x)), map-id(fid, value(x)))
public defn map-id (fid:Int -> Int, x:VMClass) :
  match(x) :
    (x:VMArrayClass) :
      VMArrayClass(fid(id(x)), dependencies(x), map(fid,parents(x)),
                   base-size(x), item-size(x), base-roots(x), item-roots(x))
    (x:VMLeafClass) :
      VMLeafClass(fid(id(x)), dependencies(x), map(fid,parents(x)), size(x), roots(x))
    (x:VMAbstractClass) :
      VMAbstractClass(fid(id(x)), map(fid,parents(x)), map(fid,children(x)))
public defn map-id (fid:Int -> Int, x:VMFunction) :  
  match(x) :
    (x:VMFunc) : VMFunc(fid(id(x)), dependencies(x), args(x), defs(x), ins(x))
    (x:VMMultifn) : VMMultifn(fid(id(x)), dependencies(x), arg(x), funcs(x), default(x))    
public defn map-id (fid:Int -> Int, x:VMMethod) :
  val types* = for t in types(x) map : map-id(fid,t)
  VMMethod(instance?(x), fid(multi(x)), types*, fid(/fid(x)))
public defn map-id (fid:Int -> Int, x:VMExtern) :
  VMExtern(fid(id(x)), name(x))

;============================================================
;==================== Printer ===============================
;============================================================

defn arg-string (xs:Tuple<Local|False>) :
  val xs* = for x in xs seq :
    match(x:False) : "_"
    else : x
  "(%,)" % [xs*]

defmethod print (o:OutputStream, p:VMPackage) :
  val io = packageio(p)
  print(o, "package %~ :" % [package(io)])
  val o2 = IndentedStream(o)
  match(init(p):Int) :
    lnprint(o2, "init = %_" % [init(p)])
  val xs = cat-all $ [
    imports(io)
    exports(io)
    globals(p)
    datas(p)
    consts(p)
    externs(p)
    classes(p)
    funcs(p)
    methods(p)]
  do(lnprint{o2, _}, xs)

defmethod print (o:OutputStream, d:VMDef) :
  print(o, "def %_ : %_ (local %_)" % [Local(id(d)), type(d), local(d)])

defmethod print (o:OutputStream, g:VMGlobal) :
  print(o, "global %_ (size = %_, roots = (%,))" % [GlobalId(id(g)), size(g), roots(g)])

defmethod print (o:OutputStream, d:VMData) :
  print(o, "data %_ %~" % [DataId(id(d)), data(d)])

defmethod print (o:OutputStream, d:VMConst) :
  defn printable (v:VMValue) :
    match(v:List) : "list(%@)" % [seq(printable, v)]
    else : "%~" % [v]
  print(o, "const %_ %~" % [ConstId(id(d)), printable(value(d))])

defmethod print (o:OutputStream, d:VMExtern) :
  print(o, "extern %_ %~" % [ExternId(id(d)), name(d)])

defmethod print (o:OutputStream, m:VMMethod) :
  val istr = " instance" when instance?(m) else ""
  print(o, "method%_ %_ (%,) : goto %_" % [istr, multi(m), types(m), fid(m)])

defmethod print (o:OutputStream, m:VMMultifn) :
  print(o, "multifn %_ (%_) :" % [CodeId(id(m)), arg(m)])
  if not empty?(dependencies(m)) :
    lnprint(o, "  depends-on (%,)" % [dependencies(m)])
  for entry in funcs(m) do :
    lnprint(o, "  %_ => " % [key(entry)])
    print-func(o, value(entry), 4)
  lnprint(o, "  else => ")
  print-func(o, default(m), 4)

defmethod print (o:OutputStream, f:VMFunc) :
  print-func(o, f, 2)

defn print-func (o:OutputStream, f:VMFunc, indent:Int) :
  print(o, "func %_ %_ :" % [CodeId(id(f)), arg-string(args(f))])
  val o2 = IndentedStream(o, indent)
  if not empty?(dependencies(f)) :
    lnprint(o2, "depends-on (%,)" % [dependencies(f)])
  do(lnprint{o2, _}, defs(f))
  do(lnprint{o2, _}, ins(f))
  
defmethod print (o:OutputStream, c:VMAbstractClass) :
  print(o, "class %_ (%,) (children = (%,))" % [id(c), parents(c), children(c)])

defmethod print (o:OutputStream, c:VMLeafClass) :
  val dstr = "" when empty?(dependencies(c))
        else ", depends-on (%,)" % [dependencies(c)]
  print(o, "class %_ (%,) (size = %_, roots = (%,)%_)" % [id(c), parents(c), size(c), roots(c), dstr])

defmethod print (o:OutputStream, c:VMArrayClass) :
  val dstr = "" when empty?(dependencies(c))
        else ", depends-on (%,)" % [dependencies(c)]
  print(o, "class %_ (%,) (base-size = %_, item-size = %_, base-roots = (%,), item-roots = (%,)%_)" % [
    id(c), parents(c), base-size(c), item-size(c), base-roots(c), item-roots(c), dstr])

defmethod print (o:OutputStream, x:VMImm) :
  print{o, _} $ match(x) :
    (x:Local) : "L%_" % [index(x)]
    (x:NumConst) : "%~" % [value(x)]
    (x:Marker) : "M%_" % [typeid(x)]
    (x:VoidMarker) : "void"
    (x:Tag) : "T%_" % [typeid(x)]
    (x:CodeId) : "F%_" % [id(x)]
    (x:ExternId) : "E%_" % [id(x)]
    (x:GlobalId) : "G%_" % [id(x)]
    (x:DataId) : "D%_" % [id(x)]
    (x:ConstId) : "C%_" % [id(x)]
  
defmethod print (o:OutputStream, i:VMIns) :
  defn P (x) : print(o, x)
  defn class? (x:Int|False) :
    "" when x is False else " (class = %_)" % [x]
  match(i) :
    (i:TCallIns) : P $ "return call %_ (%,)" % [f(i), ys(i)]
    (i:TCallClosureIns) : P $ "return call-closure %_ (%,)" % [f(i), ys(i)]
    (i:CallIns) : P $ "%_ = call %_ (%,)" % [arg-string(xs(i)), f(i), ys(i)]
    (i:CallCIns) : P $ "%_ = call-c %_ (%,)" % [arg-string(xs(i)), f(i), ys(i)]
    (i:CallClosureIns): P $ "%_ = call-closure %_ (%,)" % [arg-string(xs(i)), f(i), ys(i)]
    (i:UnreachableIns) : P $ "unreachable"
    (i:YieldIns) : P $ "%_ = yield %_ (%,)" % [arg-string(xs(i)), f(i), ys(i)]
    (i:NewStackIns) : P $ "%_ = new-stack %_" % [x(i), fid(i)]
    (i:SetIns) : P $ "%_ = %_" % [x(i), y(i)]
    (i:Op0Ins) : P $ "%_ = %_" % [x(i), op(i)]
    (i:Op1Ins) : P $ "%_ = %_ %_" % [x(i), op(i), y(i)]
    (i:Op2Ins) : P $ "%_ = %_ %_ %_" % [x(i), op(i), y(i), z(i)]
    (i:LabelIns) : P $ "label %_" % [n(i)]
    (i:GotoIns) : P $ "goto %_" % [n(i)]
    (i:Branch1Ins) :
      val op-str = match(op(i)) :
        (op:VMOp) : " %_" % [op]
        (op:False) : ""
      P $ "goto %_ when%_ %_ else %_" % [n1(i), op-str, x(i), n2(i)]
    (i:Branch2Ins) : P $ "goto %_ when %_ %_ %_ else %_" % [n1(i), op(i), x(i), y(i), n2(i)]
    (i:AllocIns) : P $ "(%,) = alloc<%,> (%,)" % [xs(i), types(i), sizes(i)]
    (i:StoreIns) :
      val ystr = "" when y(i) is False
            else "%_ + " % [y(i)]        
      P $ "%_[%_%_] = %_%_" % [x(i), ystr, offset(i), z(i), class?(class(i))]
    (i:LoadIns) :
      val zstr = "" when z(i) is False
            else "%_ + " % [z(i)]        
      P $ "%_ = %_[%_%_]%_" % [x(i), y(i), zstr, offset(i), class?(class(i))]
    (i:ReturnIns) : P $ "return (%,)" % [xs(i)]
    (i:DumpIns) : P $ "dump (%,)" % [xs(i)]
    (i:RecordLiveIns) : P $ "live (%,)" % [live(i)]
    (i:CommentIns) : P $ "comment: %~" % [message(i)]
    (i:MatchIns) :
      print(o, "match(%,) :" % [ys(i)])
      val o2 = IndentedStream(o)
      do(lnprint{o2, _}, branches(i))
      lnprint(o2, "else : goto %_" % [default(i)])
    (i:DispatchIns) :
      print(o, "dispatch(%,) :" % [ys(i)])
      val o2 = IndentedStream(o)
      do(lnprint{o2, _}, branches(i))
      lnprint(o2, "else : goto %_" % [default(i)])
      lnprint(o2, "amb : goto %_" % [amb(i)])
    (i:MethodDispatchIns) :
      print(o, "method-dispatch[%_](%,)(%,) :" % [multi(i), ys(i), zs(i)])
      val o2 = IndentedStream(o)
      lnprint(o2, "else : goto %_" % [default(i)])
      lnprint(o2, "amb : goto %_" % [amb(i)])

defmethod print (o:OutputStream, op:VMOp) :
  print{o, _} $ match(op) :
    (op:InstanceofOp) : "instanceof<%_>" % [type(op)]
    (op:TagOp) : "tag<%_>" % [type(op)]
    (op:DetagOp) : "detag<%_>" % [type(op)]
    (op:ConvOp) : "conv"
    (op:InterpretOp) : "interpret"
    (op:DerefOp) : "deref"

defmethod print (o:OutputStream, t:VMType) :
  print{o, _} $ match(t) :
    (t:VMByte) : "byte"
    (t:VMInt) : "int"
    (t:VMLong) : "long"
    (t:VMFloat) : "float"
    (t:VMDouble) : "double"
    (t:VMRef) : "ref"

defmethod print (o:OutputStream, v:VMTypeObject) :
  print(o, "type(%_)" % [id(v)])

defmethod print (o:OutputStream, v:VMClosure) :
  print(o, "closure(%_)" % [id(v)])

defmethod print (o:OutputStream, v:VMInternedConst) :
  print(o, "interned-const(%_)" % [id(v)])

defmethod print (o:OutputStream, b:VMBranch) :
  print(o, "(%,) : goto %_" % [types(b), n(b)])

defmethod print (o:OutputStream, t:TypeSet) :
  print{o, _} $ match(t) :
    (t:SingleType) : type(t)
    (t:TopType) : "?"
    (t:AndType) : "and(%,)" % [types(t)]
    (t:OrType) : "or(%,)" % [types(t)] 

;============================================================
;======================= Reader =============================
;============================================================

defsyntax vmcode :
  import (basic-op0, basic-op1, basic-op2) from basic-ops
  
  defproduction op0 : VMOp
  defrule op0 = (?x:#basic-op0) : x
  
  defproduction op1 : VMOp
  defrule op1 = (?x:#basic-op1) : x
  defrule op1 = (instanceof<?t:#typeset>) : InstanceofOp(t)
  defrule op1 = (tag<?t:#int!>) : TagOp(t)
  defrule op1 = (detag<?t:#int!>) : DetagOp(t)
  defrule op1 = (conv) : ConvOp()
  defrule op1 = (interpret) : InterpretOp()
  defrule op1 = (deref) : DerefOp()

  defproduction op2 : VMOp
  defrule op2 = (?x:#basic-op2) : x

  defproduction type : VMType
  defrule type = (byte) : VMByte()
  defrule type = (int) : VMInt()
  defrule type = (long) : VMLong()
  defrule type = (float) : VMFloat()
  defrule type = (double) : VMDouble()
  defrule type = (ref) : VMRef()

  defproduction typeset : TypeSet
  defrule typeset = (?n:#int) : SingleType(n)
  defrule typeset = (?) : TopType()
  defrule typeset = (and(?ts:#typeset ...)) : AndType(to-tuple(ts))
  defrule typeset = (or(?ts:#typeset ...)) : OrType(to-tuple(ts))

  defn char-prefix? (x, c:Char) :
    unwrap-token(x) is Symbol and to-string(x)[0] == c
  defn char-index! (info:FileInfo|False, x:Symbol|Token) :
    val i = to-int(to-string(x)[1 to false])
    match(i:Int) : i
    else : throw(VME(info, "Invalid name: %~" % [x]))
    
  defproduction local : Local
  defrule local = (?r) when char-prefix?(r, 'L') : Local(char-index!(closest-info(), r))
  defproduction externid : ExternId
  defrule externid = (?r) when char-prefix?(r, 'E') : ExternId(char-index!(closest-info(), r))
  defproduction globalid : GlobalId
  defrule globalid = (?r) when char-prefix?(r, 'G') : GlobalId(char-index!(closest-info(), r))
  defproduction dataid : DataId
  defrule dataid = (?r) when char-prefix?(r, 'D') : DataId(char-index!(closest-info(), r))
  defproduction constid : ConstId
  defrule constid = (?r) when char-prefix?(r, 'C') : ConstId(char-index!(closest-info(), r))
  defproduction marker : Marker
  defrule marker = (?r) when char-prefix?(r, 'M') : Marker(char-index!(closest-info(), r))
  defproduction tag : Tag
  defrule tag = (?r) when char-prefix?(r, 'T') : Tag(char-index!(closest-info(), r))
  defproduction codeid : CodeId
  defrule codeid = (?r) when char-prefix?(r, 'F') : CodeId(char-index!(closest-info(), r))

  defproduction imm : VMImm
  defrule imm = (?x) when unwrap-token(x) is Char|Byte|Int|Long|Float|Double : NumConst(unwrap-token(x))
  defrule imm = (void) : VoidMarker()
  defrule imm = (?x:#local) : x
  defrule imm = (?x:#externid) : x
  defrule imm = (?x:#globalid) : x
  defrule imm = (?x:#dataid) : x
  defrule imm = (?x:#constid) : x
  defrule imm = (?x:#marker) : x
  defrule imm = (?x:#tag) : x
  defrule imm = (?x:#codeid) : x

  defproduction ins : VMIns
  defrule ins = (?xs:#args = call ?f:#imm! (?ys:#imm! ...)) : CallIns(xs, f, to-tuple(ys), closest-info())
  defrule ins = (?xs:#args = call-c ?f:#imm! (?ys:#imm! ...)) : CallCIns(xs, f, to-tuple(ys), closest-info())
  defrule ins = (?xs:#args = call-closure ?f:#imm! (?ys:#imm! ...)) : CallClosureIns(xs, f, to-tuple(ys), closest-info())
  defrule ins = (?xs:#args = yield ?f:#imm! (?ys:#imm! ...)) : YieldIns(xs, f, to-tuple(ys), closest-info())
  defrule ins = (?x:#local = new-stack ?fid:#imm!) : NewStackIns(x, fid, closest-info())
  defrule ins = ((?xs:#local ...) = alloc<?ts:#int! ...> (?sizes:#imm! ...)) : AllocIns(to-tuple(xs), to-tuple(ts), to-tuple(sizes), closest-info())
  defrule ins = (?x:#local = ?y:#imm[?z:#offset? ?o:#int!] ?c:#class?) : LoadIns(x, y, z, o, c)
  defrule ins = (?x:#imm[?y:#offset? ?o:#int!] = ?z:#imm! ?c:#class?) : StoreIns(x, y, o, z, c)
  defrule ins = (?x:#local = ?o:#op0) : Op0Ins(x, o)
  defrule ins = (?x:#local = ?o:#op1 ?y:#imm!) : Op1Ins(x, o, y)
  defrule ins = (?x:#local = ?o:#op2 ?y:#imm! ?z:#imm!) : Op2Ins(x, o, y, z)
  defrule ins = (?x:#local = ?y:#imm!) : SetIns(x,y)
  defrule ins = (label ?n:#int!) : LabelIns(n)
  defrule ins = (goto ?n1:#int! when ?o:#op2 ?x:#imm! ?y:#imm! else ?n2:#int!) : Branch2Ins(n1, n2, o, x, y)
  defrule ins = (goto ?n1:#int! when ?o:#op1 ?x:#imm! else ?n2:#int!) : Branch1Ins(n1, n2, o, x)
  defrule ins = (goto ?n1:#int! when ?x:#imm! else ?n2:#int!) : Branch1Ins(n1, n2, false, x)
  defrule ins = (goto ?n:#int!) : GotoIns(n)
  defrule ins = (return call ?f:#imm! (?ys:#imm! ...)) : TCallIns(f, to-tuple(ys))
  defrule ins = (unreachable) : UnreachableIns()
  defrule ins = (return call-closure ?f:#imm! (?ys:#imm! ...)) : TCallClosureIns(f, to-tuple(ys))
  defrule ins = (return (?xs:#imm! ...)) : ReturnIns(to-tuple(xs))
  defrule ins = (dump (?xs:#local ...)) : DumpIns(to-tuple(xs))
  defrule ins = (live (?xs:#local ...)) : RecordLiveIns(to-tuple(xs))
  defrule ins = (comment: ?x:#string!) : CommentIns(x)
  defrule ins = (match(?ys:#imm! ...) : (?bs:#vmbranch ... ?d:#defaultbranch)) : MatchIns(to-tuple(ys), to-tuple(bs), d)
  defrule ins = (dispatch(?ys:#imm! ...) : (?bs:#vmbranch ... ?d:#defaultbranch ?a:#ambbranch)) :
    DispatchIns(to-tuple(ys), to-tuple(bs), d, a)
  defrule ins = (method-dispatch[?m:#int!](?ys:#imm! ...)(?zs:#imm! ...) : (?d:#defaultbranch ?a:#ambbranch)) :
    MethodDispatchIns(m, to-tuple(ys), to-tuple(zs), d, a)

  defproduction class? : Int|False
  defrule class? = ((class = ?n:#int)) : n
  defrule class? = () : false

  defproduction offset? : VMImm|False
  defrule offset? = (?x:#imm +) : x
  defrule offset? = () : false

  defproduction args : Tuple<Local|False>
  defrule args = ((?xs:#arg ...)) : to-tuple(xs)  
  defproduction arg : Local|False
  defrule arg = (?x:#local) : x
  defrule arg = (_) : false

  defproduction def : VMDef
  defrule def = (def ?n:#local : ?t:#type! (local ?l:#int!)) : VMDef(index(n), t, l)

  defproduction extern : VMExtern
  defrule extern = (extern ?x:#externid ?name:#symbol!) : VMExtern(id(x), name)

  defproduction global : VMGlobal
  defrule global = (global ?x:#globalid (size = ?size:#int!,
                                         roots = (?rs:#int! ...))) :
    VMGlobal(id(x), size, to-tuple(rs))

  defn to-byte-array (bs:List<Byte>) :
    val b = ByteArray(length(bs))
    b[0 to false] = bs
    b

  defproduction data : VMData
  defrule data = (data ?x:#dataid [?bytes:#byte! ...]) :
    VMData(id(x), to-byte-array(bytes))

  defproduction const : VMConst
  defrule const = (const ?x:#constid ?v:#vmvalue) :
    VMConst(id(x), v)

  defproduction vmbranch : VMBranch
  defrule vmbranch = ((?ts:#typeset ...) : goto ?n:#int) : VMBranch(to-tuple(ts), n)  
  defproduction defaultbranch : Int
  defrule defaultbranch = (else : goto ?n:#int) : n
  defproduction ambbranch : Int
  defrule ambbranch = (amb : goto ?n:#int) : n

  defproduction func : VMFunction
  defrule func = (multifn ?x:#codeid (?arg:#int!) : (?deps:#dependencies ?bs:#branch ... ?eb:#elsebranch)) :
    VMMultifn(id(x), deps, arg, to-tuple(bs), eb)  
  defrule func = (?f:#func1) :
    f

  defproduction branch : KeyValue<Int, VMFunc>
  defrule branch = (?n:#int => ?f:#func1) :
    n => f

  defproduction elsebranch : VMFunc
  defrule elsebranch = (else => ?f:#func1) : f

  defproduction func1 : VMFunc
  defrule func1 = (func ?x:#codeid ?args:#args :
                     ?deps:#dependencies
                     ?defs:#def ...
                     ?ins:#ins! ...) :
    VMFunc(id(x), deps, args, to-tuple(defs), to-tuple(ins))

  defproduction dependencies : Tuple<Int>
  defrule dependencies = (depends-on (?ns:#int ...)) : to-tuple(ns)
  defrule dependencies = () : []

  defproduction vmvalue : VMValue
  defrule vmvalue = (type(?id:#codeid)) : VMTypeObject(id)
  defrule vmvalue = (closure(?id:#codeid)) : VMClosure(id)
  defrule vmvalue = (interned-const(?id:#constid)) : VMInternedConst(id)
  defrule vmvalue = (?x) when unwrap-token(x) is VMValue : unwrap-all(x)

  defproduction class : VMClass
  defrule class = (class ?id:#int! (?parents:#int! ...) (
                     base-size = ?base:#int!,
                     item-size = ?item:#int!,
                     base-roots = (?brs:#int! ...),
                     item-roots = (?irs:#int! ...),
                     ?deps:#dependencies)) :
    VMArrayClass(id, deps, to-tuple(parents), base, item, to-tuple(brs), to-tuple(irs))
  defrule class = (class ?id:#int! (?parents:#int! ...) (size = ?size:#int!, roots = (?rs:#int! ...), ?deps:#dependencies)) :
    VMLeafClass(id, deps, to-tuple(parents), size, to-tuple(rs))
  defrule class = (class ?id:#int! (?parents:#int! ...) (children = (?cs:#int! ...))) :
    VMAbstractClass(id, to-tuple(parents), to-tuple(cs))

  defproduction vmmethod : VMMethod
  defrule vmmethod = (method instance ?multi:#int (?types:#typeset ...) : goto ?fid:#int) :
    VMMethod(true, multi, to-tuple(types), fid)
  defrule vmmethod = (method ?multi:#int (?types:#typeset ...) : goto ?fid:#int) :
    VMMethod(false, multi, to-tuple(types), fid)

  import (import export) from dl-ir
  public defproduction vmpackage : VMPackage
  defrule vmpackage = (package ?name:#symbol :
                         ?init:#init?
                         ?stmts:#tstmt ...) :
    val ins = to-tuple(filter-by<Import>(stmts))
    val exs = to-tuple(filter-by<Export>(stmts))
    val io = PackageIO(name, [], ins, exs)                
    val gs = to-tuple(filter-by<VMGlobal>(stmts))
    val ds = to-tuple(filter-by<VMData>(stmts))
    val cts = to-tuple(filter-by<VMConst>(stmts))
    val cs = to-tuple(filter-by<VMClass>(stmts))
    val fs = to-tuple(filter-by<VMFunction>(stmts))
    val es = to-tuple(filter-by<VMExtern>(stmts))
    val ms = to-tuple(filter-by<VMMethod>(stmts))
    VMPackage(io, init, gs, ds, cts, cs, fs, ms, es)

  defproduction init? : Int|False
  defrule init? = (init = ?n:#int) : n
  defrule init? = () : false

  defproduction tstmt : VMGlobal|VMClass|VMFunction|VMExtern|VMData|VMConst|VMMethod|Import|Export
  defrule tstmt = (?x:#global) : x
  defrule tstmt = (?x:#data) : x
  defrule tstmt = (?x:#const) : x
  defrule tstmt = (?x:#extern) : x
  defrule tstmt = (?x:#class) : x
  defrule tstmt = (?x:#func) : x
  defrule tstmt = (?x:#vmmethod) : x
  defrule tstmt = (?x:#import) : x
  defrule tstmt = (?x:#export) : x
  fail-if tstmt = () : VME(closest-info(), "Expected a top-level statement here.")

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction byte : Byte
  defrule byte = (?x) when unwrap-token(x) is Byte : unwrap-token(x)

  defproduction string : String
  defrule string = (?x) when unwrap-token(x) is String : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

  ;===== Failure =====
  defproduction imm! : VMImm
  defrule imm! = (?x:#imm) : x
  fail-if imm! = () : VME(closest-info(), "Expected an immediate here.")

  defproduction int! : Int
  defrule int! = (?x:#int) : x
  fail-if int! = () : VME(closest-info(), "Expected an integer here.")

  defproduction byte! : Byte
  defrule byte! = (?x:#byte) : x
  fail-if byte! = () : VME(closest-info(), "Expected a byte here.")

  defproduction ins! : VMIns
  defrule ins! = (?x:#ins) : x
  fail-if ins! = () : VME(closest-info(), "Expected an instruction here.")

  defproduction func! : VMFunction
  defrule func! = (?x:#func) : x
  fail-if func! = () : VME(closest-info(), "Expected a function here.")

  defproduction type! : VMType
  defrule type! = (?x:#type) : x
  fail-if type! = () : VME(closest-info(), "Expected a type here.")

  defproduction string! : String
  defrule string! = (?x:#string) : x
  fail-if string! = () : VME(closest-info(), "Expected a string here.")

  defproduction symbol! : Symbol
  defrule symbol! = (?x:#symbol) : x
  fail-if symbol! = () : VME(closest-info(), "Expected a symbol here.")


;============================================================
;====================== Errors ==============================
;============================================================

public defstruct VMError <: Exception :
  info: FileInfo|False
  msg

public defn VME (info:FileInfo|False, msg) :
  VMError(info, msg)

defmethod print (o:OutputStream, e:VMError) :
  val info-str = "" when info(e) is False else "%_: " % [info(e)]
  print-all(o, [info-str, msg(e)])

;============================================================
;============================================================
;============================================================

public defn read-vm-package (filename:String) :
  val forms = read-file(filename)
  parse-syntax[vmcode / #vmpackage](forms)

public defn read-vm-packages (filename:String) :
  val forms = read-file(filename)
  to-tuple(parse-syntax[vmcode / #vmpackage ...](forms))