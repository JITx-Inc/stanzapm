defpackage stz/dl-ir :
  import core
  import collections

;============================================================
;======================== EPackage ==========================
;============================================================

public defstruct PackageIO :
  package: Symbol
  imports: Tuple<Import>
  exports: Tuple<Export> 

;============================================================
;===================== Import/Export ========================
;============================================================

public defstruct Export :
  n: Int
  rec: Rec

public defstruct Import :
  n: Int
  rec: Rec

;============================================================
;======================= Records ============================
;============================================================

public deftype Rec
public defmulti id (r:Rec) -> RecId

public defstruct FnRec <: Rec :
  id: FnId with: (as-method => true)
  a2: DType
  
public defstruct TypeRec <: Rec :
  id: TypeId with: (as-method => true)
  parent: False|DType

;============================================================
;========================= Ids ==============================
;============================================================

public deftype DType <: Hashable & Equalable & Comparable<DType>

;LoStanza Types
public defstruct DByte <: DType
public defstruct DInt <: DType
public defstruct DLong <: DType
public defstruct DFloat <: DType
public defstruct DDouble <: DType
public defstruct DUnknown <: DType
public defstruct DPtrT <: DType : (type:DType)
public defstruct DFnT <: DType : (a:Tuple<DType>, r:False|DType, b:DType)
public defstruct DStructT <: DType : (id:TypeId)

;HiStanza Types
public defstruct DOf <: DType: (id:TypeId)
public defstruct DTVar <: DType: (index:Int)
public defstruct DAnd <: DType: (types:Tuple<DType> with: (ensure => ordered!))
public defstruct DOr <: DType: (types:Tuple<DType> with: (ensure => ordered!))
public defstruct DTop <: DType
public defstruct DBot <: DType

public deftype RecId <: Hashable & Equalable
public defmulti package (r:RecId) -> Symbol

public defstruct TypeId <: RecId :
  package: Symbol with: (as-method => true)
  name: Symbol

public defstruct FnId <: RecId :
  package: Symbol with: (as-method => true)
  name: Symbol
  a1: Tuple<DType>

;============================================================
;================== DType Consistency =======================
;============================================================

defn ordered! (description:String, ts:Tuple<DType>) :
  if length(ts) < 2 :
    fatal("Field %_ with value %_ has length less than 2." % [description, ts])
  else :
    val n = length(ts)
    for i in 0 to n - 1 do :
      if ts[i] >= ts[i + 1] :
        fatal("Field %_ wth value %_ is not strictly ordered." % [description, ts])

;============================================================
;==================== DType Comparisons =====================
;============================================================

defn rank (t:DType) :
  match(t) :
    (t:DByte) : 0
    (t:DInt) : 1
    (t:DLong) : 2
    (t:DFloat) : 3
    (t:DDouble) : 4
    (t:DUnknown) : 5
    (t:DPtrT) : 6
    (t:DFnT) : 7
    (t:DStructT) : 8
    (t:DOf) : 9
    (t:DTVar) : 10
    (t:DAnd) : 11
    (t:DOr) : 12
    (t:DTop) : 13
    (t:DBot) : 14

defmethod compare (x:DType, y:DType) :
  defn compare? (x:Comparable|False, y:Comparable|False) :
    match(x, y) :
      (x:Comparable, y:Comparable) : compare(x,y)
      (x:False, y:False) : 0
      (x:Comparable, y:False) : 1
      (x:False, y:Comparable) : -1
  defn compare-id (x:TypeId, y:TypeId) :
    compare([package(x), name(x)], [package(y), name(y)])
      
  val c = compare(rank(x), rank(y))
  if c == 0 :
    match(x, y) :
      (x:DPtrT, y:DPtrT) :
        compare(type(x), type(y))
      (x:DFnT, y:DFnT) :
        val c = compare?(r(x), r(y))
        if c == 0 : compare([a(x), b(x)], [a(y), b(y)])
        else : c          
      (x:DStructT, y:DStructT) :
        compare-id(id(x), id(y))
      (x:DOf, y:DOf) :
        compare-id(id(x), id(y))
      (x:DTVar, y:DTVar) :
        compare(index(x), index(y))
      (x:DAnd, y:DAnd) :
        compare(types(x), types(y))
      (x:DOr, y:DOr) :
        compare(types(x), types(y))
      (x, y) : c
  else : c

defmethod equal? (x:DType, y:DType) :
  match(x, y) :
    (x:DByte, y:DByte) : true
    (x:DInt, y:DInt) : true
    (x:DLong, y:DLong) : true
    (x:DFloat, y:DFloat) : true
    (x:DDouble, y:DDouble) : true
    (x:DUnknown, y:DUnknown) : true
    (x:DPtrT, y:DPtrT) : type(x) == type(y)
    (x:DFnT, y:DFnT) : a(x) == a(y) and b(x) == b(y) and r(x) == r(y)
    (x:DStructT, y:DStructT) : id(x) == id(y)
    (x:DOf, y:DOf) : id(x) == id(y)
    (x:DTVar, y:DTVar) : index(x) == index(y)
    (x:DAnd, y:DAnd) : types(x) == types(y)
    (x:DOr, y:DOr) : types(x) == types(y)
    (x:DTop, y:DTop) : true
    (x:DBot, y:DBot) : true
    (x, y) : false

defmethod hash (x:DType) :
  val base = rank(x) * 13
  defn H (y) : base + hash(y) 
  match(x) :
    (x:DPtrT) : H $ type(x)
    (x:DFnT) : H $ [a(x), r(x), b(x)]
    (x:DStructT) : H $ id(x)
    (x:DOf) : H $ id(x)
    (x:DTVar) : H $ index(x)
    (x:DAnd) : H $ types(x)
    (x:DOr) : H $ types(x)
    (x) : base

;============================================================
;======================= Matching ===========================
;============================================================

defmethod equal? (x:TypeId, y:TypeId) :
  package(x) == package(y) and
  name(x) == name(y)

defmethod equal? (x:FnId, y:FnId) :
  package(x) == package(y) and
  name(x) == name(y) and
  a1(x) == a1(y)

defmethod hash (x:TypeId) :
  hash $ [7, package(x), name(x)]

defmethod hash (x:FnId) :
  hash $ [11, package(x), name(x), a1(x)]

public defn match? (x:Rec, y:Rec) :
  match(x, y) :
    (x:FnRec, y:FnRec) :
      a2(x) == a2(y)
    (x:TypeRec, y:TypeRec) :
      parent(x) == parent(y)

;============================================================
;========================= Printer ==========================
;============================================================

defmethod print (o:OutputStream, x:TypeId) :
  print(o, "T(%~, %~)" % [package(x), name(x)])

defmethod print (o:OutputStream, x:FnId) :
  print(o, "F(%~, %~, %~)" % [package(x), name(x), a1(x)])

defmethod print (o:OutputStream, x:DType) :
  print{o, _} $ match(x) :
    (x:DByte) : "byte"
    (x:DInt) : "int"
    (x:DLong) : "long"
    (x:DFloat) : "float"
    (x:DDouble) : "double"
    (x:DOf) : "ref<%~>" % [id(x)]

defmethod print (o:OutputStream, r:TypeRec) :
  val pstr = match(parent(r)) :
    (p:DType) : " <: %~" % [p]
    (p:False) : ""
  print(o, "type(%~%_)" % [id(r), pstr])

defmethod print (o:OutputStream, r:FnRec) :
  print(o, "fn(%~ -> %~)" % [id(r), a2(r)])

defmethod print (o:OutputStream, x:Import) :
  print(o, "import %_ %~" % [n(x), rec(x)])

defmethod print (o:OutputStream, x:Export) :
  print(o, "export %_ %~" % [n(x), rec(x)])

defmethod print (o:OutputStream, x:PackageIO) :
  print(o, "package %~ :" % [package(x)])
  val o2 = IndentedStream(o)
  for e in cat(imports(x), exports(x)) do :
    print(o2, '\n')
    print(o2, e)

;============================================================
;======================= Reader =============================
;============================================================

defsyntax dl-ir :
  public defproduction packageio : PackageIO
  defrule packageio = (package ?name:#symbol :
                         ?imports:#import ...
                         ?exports:#export ...) :
    PackageIO(name, to-tuple(imports), to-tuple(exports))

  defproduction dtype : DType
  defrule dtype = (byte) : DByte()
  defrule dtype = (int) : DInt()
  defrule dtype = (long) : DLong()
  defrule dtype = (float) : DFloat()
  defrule dtype = (double) : DDouble()
  defrule dtype = (ref<?id:#id>) : DOf(id as TypeId)

  defproduction id : RecId
  defrule id = (T(?p:#symbol,?n:#symbol)) : TypeId(p,n)
  defrule id = (F(?p:#symbol,?n:#symbol,[?a1:#dtype ...])) : FnId(p,n,to-tuple(a1))

  defproduction rec : Rec
  defrule rec = (type(?id:#id)) : TypeRec(id as TypeId,false)
  defrule rec = (type(?id:#id <: ?p:#dtype)) : TypeRec(id as TypeId,p)
  defrule rec = (fn(?id:#id -> ?a2:#dtype)) : FnRec(id as FnId,a2)

  defproduction import : Import
  defrule import = (import ?n:#int ?r:#rec) : Import(n,r)
  fail-if import = (import) : DLE(closest-info(), "Invalid import statement.")

  defproduction export : Export
  defrule export = (export ?n:#int ?r:#rec) : Export(n,r)
  fail-if export = (export) : DLE(closest-info(), "Invalid export statement.")

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

;============================================================
;======================== Errors ============================
;============================================================

public defstruct DLError <: Exception :
  info: FileInfo|False
  msg: String

defn DLE (info:FileInfo|False, msg) :
  DLError(info, to-string(msg))