defpackage stz/dl-ir :
  import core
  import collections
  import reader

;============================================================
;======================== EPackage ==========================
;============================================================

defstruct PackageIO :
  package: Symbol
  imports: Tuple<Import>
  exports: Tuple<Export>

;============================================================
;===================== Import/Export ========================
;============================================================

defstruct Export :
  n: Int
  rec: Rec

defstruct Import :
  n: Int
  rec: Rec

;============================================================
;======================= Records ============================
;============================================================

deftype Rec
defmulti id (r:Rec) -> RecId

defstruct FnRec <: Rec :
  id: FnId with: (as-method => true)
  a2: DType
  
defstruct TypeRec <: Rec :
  id: TypeId with: (as-method => true)
  parent: False|DType

;============================================================
;========================= Ids ==============================
;============================================================

deftype DType
defstruct DByte <: DType
defstruct DInt <: DType
defstruct DLong <: DType
defstruct DFloat <: DType
defstruct DDouble <: DType
defstruct DOf <: DType : (id:TypeId)

deftype RecId

defstruct TypeId <: RecId :
  package: Symbol
  name: Symbol

defstruct FnId <: RecId :
  package: Symbol
  name: Symbol
  a1: Tuple<DType>

;============================================================
;========================= Printer ==========================
;============================================================

defmethod print (o:OutputStream, x:TypeId) :
  print(o, "T(%~, %~)" % [package(x), name(x)])

defmethod print (o:OutputStream, x:FnId) :
  print(o, "F(%~, %~, %~)" % [package(x), name(x), a1(x)])

defmethod print (o:OutputStream, x:DType) :
  print{o, _} $ match(x) :
    (x:DByte) : "byte"
    (x:DInt) : "int"
    (x:DLong) : "long"
    (x:DFloat) : "float"
    (x:DDouble) : "double"
    (x:DOf) : "ref<%~>" % [id(x)]

defmethod print (o:OutputStream, r:TypeRec) :
  val pstr = match(parent(r)) :
    (p:DType) : " <: %~" % [p]
    (p:False) : ""
  print(o, "type(%~%_)" % [id(r), pstr])

defmethod print (o:OutputStream, r:FnRec) :
  print(o, "fn(%~ -> %~)" % [id(r), a2(r)])

defmethod print (o:OutputStream, x:Import) :
  print(o, "import %_ %~" % [n(x), rec(x)])

defmethod print (o:OutputStream, x:Export) :
  print(o, "export %_ %~" % [n(x), rec(x)])

defmethod print (o:OutputStream, x:PackageIO) :
  print(o, "package %~ :" % [package(x)])
  val o2 = IndentedStream(o)
  for e in cat(imports(x), exports(x)) do :
    print(o2, '\n')
    print(o2, e)

;============================================================
;======================= Reader =============================
;============================================================

defsyntax dl-ir :
  public defproduction packageio : PackageIO
  defrule packageio = (package ?name:#symbol :
                         ?imports:#import ...
                         ?exports:#export ...) :
    PackageIO(name, to-tuple(imports), to-tuple(exports))

  defproduction dtype : DType
  defrule dtype = (byte) : DByte()
  defrule dtype = (int) : DInt()
  defrule dtype = (long) : DLong()
  defrule dtype = (float) : DFloat()
  defrule dtype = (double) : DDouble()
  defrule dtype = (ref<?id:#id>) : DOf(id as TypeId)

  defproduction id : RecId
  defrule id = (T(?p:#symbol,?n:#symbol)) : TypeId(p,n)
  defrule id = (F(?p:#symbol,?n:#symbol,[?a1:#dtype ...])) : FnId(p,n,to-tuple(a1))

  defproduction rec : Rec
  defrule rec = (type(?id:#id)) : TypeRec(id as TypeId,false)
  defrule rec = (type(?id:#id <: ?p:#dtype)) : TypeRec(id as TypeId,p)
  defrule rec = (fn(?id:#id -> ?a2:#dtype)) : FnRec(id as FnId,a2)

  defproduction import : Import
  defrule import = (import ?n:#int ?r:#rec) : Import(n,r)
  fail-if import = (import) : DLE(closest-info(), "Invalid import statement.")

  defproduction export : Export
  defrule export = (export ?n:#int ?r:#rec) : Export(n,r)
  fail-if export = (export) : DLE(closest-info(), "Invalid export statement.")

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

public defstruct DLError <: Exception :
  info: FileInfo|False
  msg: String

public defn DLE (info:FileInfo|False, msg) :
  DLError(info, to-string(msg))

;============================================================
;==================== Driver ================================
;============================================================

defn read-dl-ir (filename:String) :
  val forms = read-file(filename)
  parse-syntax[dl-ir / #packageio](forms)

defn main () :
  val ir = read-dl-ir(command-line-arguments()[1])
  println(ir)

main()