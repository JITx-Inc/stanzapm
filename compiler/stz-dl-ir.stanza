defpackage stz/dl-ir :
  import core
  import collections
  import stz/utils

;============================================================
;======================== EPackage ==========================
;============================================================

public defstruct PackageIO :
  package: Symbol
  imports: Tuple<Import> with: (updater => sub-imports)
  exports: Tuple<Export> with: (updater => sub-exports)

;============================================================
;===================== Import/Export ========================
;============================================================

public defstruct Export :
  n: Int
  rec: Rec

public defstruct Import :
  n: Int
  rec: Rec

;============================================================
;=================== Record Ids =============================
;============================================================

public deftype RecId <: Hashable & Equalable
public defmulti package (r:RecId) -> Symbol
public defmulti name (r:RecId) -> Symbol

public defstruct ValId <: RecId :
  package: Symbol with: (as-method => true)
  name: Symbol with: (as-method => true)

public defstruct TypeId <: RecId :
  package: Symbol with: (as-method => true)
  name: Symbol with: (as-method => true)

public defstruct FnId <: RecId :
  package: Symbol with: (as-method => true)
  name: Symbol with: (as-method => true)
  ntargs: Int
  a1: Tuple<DType>

;============================================================
;======================= Records ============================
;============================================================

public deftype Rec
public defmulti id (r:Rec) -> RecId

public defstruct ValRec <: Rec :
  id: ValId with: (as-method => true)
  type: DType
  mutable?: True|False
  lostanza?: True|False

public defstruct FnRec <: Rec :
  id: FnId with: (as-method => true)
  a2: DType
  lostanza?: True|False

public defstruct MultiRec <: Rec :
  id: FnId with: (as-method => true)
  a2: DType

public defstruct ExternFnRec <: Rec :
  id: FnId with: (as-method => true)
  a2: DType
  lbl: Symbol

public defstruct ExternRec <: Rec :
  id: ValId with: (as-method => true)
  type: DType
  lbl: Symbol

public defstruct StructRec <: Rec :
  id: TypeId with: (as-method => true)
  ntargs: Int
  parent: False|DType
  base: Tuple<DType>
  items: False|DType

public defstruct TypeRec <: Rec :
  id: TypeId with: (as-method => true)
  ntargs: Int
  parent: False|DType
  children: Tuple<TypeId>

;============================================================
;========================= DTypes ===========================
;============================================================
;TODO:
; - DTypes need to be reflect TL more accurately.
; - So that if we change a dependency, the downstream code
;   is aware of the changes.

public deftype DType <: Hashable & Equalable & Comparable<DType>

;LoStanza Types
public defstruct DByte <: DType
public defstruct DInt <: DType
public defstruct DLong <: DType
public defstruct DFloat <: DType
public defstruct DDouble <: DType
public defstruct DUnknown <: DType
public defstruct DPtrT <: DType : (type:DType)
public defstruct DFnT <: DType : (a:Tuple<DType>, r:False|DType, b:DType)
public defstruct DStructT <: DType : (id:TypeId)

;HiStanza Types
public defstruct DOf <: DType: (id:TypeId)
public defstruct DTVar <: DType: (index:Int)
public defstruct DAnd <: DType:
  types:Tuple<DType> with:
    ensure => and!<Tuple<DType>>(ordered!, no-ands!)
public defstruct DOr <: DType:
  types:Tuple<DType> with:
    ensure => and!<Tuple<DType>>(ordered!, no-ors!)
public defstruct DTop <: DType
public defstruct DBot <: DType

defn rank (t:DType) :
  match(t) :
    (t:DByte) : 0
    (t:DInt) : 1
    (t:DLong) : 2
    (t:DFloat) : 3
    (t:DDouble) : 4
    (t:DUnknown) : 5
    (t:DPtrT) : 6
    (t:DFnT) : 7
    (t:DStructT) : 8
    (t:DOf) : 9
    (t:DTVar) : 10
    (t:DAnd) : 11
    (t:DOr) : 12
    (t:DTop) : 13
    (t:DBot) : 14

defn and!<T> (a: (String, T) -> True|False, b: (String, T) -> True|False) :
  fn (s:String, x:T) :
    a(s,x)
    b(s,x)

defn ordered! (description:String, ts:Tuple<DType>) :
  if length(ts) < 2 :
    fatal("The %_ with value %_ has length less than 2." % [description, ts])
  else :
    val n = length(ts)
    for i in 0 to n - 1 do :
      if ts[i] >= ts[i + 1] :
        fatal("The %_ with value %_ is not strictly ordered." % [description, ts])

defn no-ands! (description:String, ts:Tuple<DType>) :
  for t in ts do :
    if t is DAnd :
      fatal("The %_ cannot accept 'and' type %_." % [description, t])

defn no-ors! (description:String, ts:Tuple<DType>) :
  for t in ts do :
    if t is DOr :
      fatal("The %_ cannot accept 'or' type %_." % [description, t])

defmethod compare (x:DType, y:DType) :
  defn compare? (x:Comparable|False, y:Comparable|False) :
    match(x, y) :
      (x:Comparable, y:Comparable) : compare(x,y)
      (x:False, y:False) : 0
      (x:Comparable, y:False) : 1
      (x:False, y:Comparable) : -1
  defn compare-id (x:TypeId, y:TypeId) :
    compare([package(x), name(x)], [package(y), name(y)])

  val c = compare(rank(x), rank(y))
  if c == 0 :
    match(x, y) :
      (x:DPtrT, y:DPtrT) :
        compare(type(x), type(y))
      (x:DFnT, y:DFnT) :
        val c = compare?(r(x), r(y))
        if c == 0 : compare([a(x), b(x)], [a(y), b(y)])
        else : c
      (x:DStructT, y:DStructT) :
        compare-id(id(x), id(y))
      (x:DOf, y:DOf) :
        compare-id(id(x), id(y))
      (x:DTVar, y:DTVar) :
        compare(index(x), index(y))
      (x:DAnd, y:DAnd) :
        compare(types(x), types(y))
      (x:DOr, y:DOr) :
        compare(types(x), types(y))
      (x, y) : c
  else : c

defmethod equal? (x:DType, y:DType) :
  match(x, y) :
    (x:DByte, y:DByte) : true
    (x:DInt, y:DInt) : true
    (x:DLong, y:DLong) : true
    (x:DFloat, y:DFloat) : true
    (x:DDouble, y:DDouble) : true
    (x:DUnknown, y:DUnknown) : true
    (x:DPtrT, y:DPtrT) : type(x) == type(y)
    (x:DFnT, y:DFnT) : a(x) == a(y) and b(x) == b(y) and r(x) == r(y)
    (x:DStructT, y:DStructT) : id(x) == id(y)
    (x:DOf, y:DOf) : id(x) == id(y)
    (x:DTVar, y:DTVar) : index(x) == index(y)
    (x:DAnd, y:DAnd) : types(x) == types(y)
    (x:DOr, y:DOr) : types(x) == types(y)
    (x:DTop, y:DTop) : true
    (x:DBot, y:DBot) : true
    (x, y) : false

defmethod hash (x:DType) :
  val base = rank(x) * 13
  defn H (y) : base + hash(y)
  match(x) :
    (x:DPtrT) : H $ type(x)
    (x:DFnT) : H $ [a(x), r(x), b(x)]
    (x:DStructT) : H $ id(x)
    (x:DOf) : H $ id(x)
    (x:DTVar) : H $ index(x)
    (x:DAnd) : H $ types(x)
    (x:DOr) : H $ types(x)
    (x) : base

public defn DOr? (ts:Seqable<DType>) :
  label<DType> return :
    val types = Vector<DType>()
    for t in ts do :
      match(t) :
        (t:DTop) : return(t)
        (t:DBot) : false
        (t:DOr) : add-all(types, /types(t))
        (t) : add(types,t)
    qsort!(types)
    remove-duplicates!(types)
    switch(length(types)) :
      0 : DBot()
      1 : types[0]
      else : DOr(to-tuple(types))

public defn DAnd? (ts:Seqable<DType>) :
  label<DType> return :
    val types = Vector<DType>()
    for t in ts do :
      match(t) :
        (t:DTop) : false
        (t:DBot) : return(t)
        (t:DAnd) : add-all(types, /types(t))
        (t) : add(types,t)
    qsort!(types)
    remove-duplicates!(types)
    switch(length(types)) :
      0 : DTop()
      1 : types[0]
      else : DAnd(to-tuple(types))

;============================================================
;======================= Matching ===========================
;============================================================

defmethod equal? (x:TypeId, y:TypeId) :
  package(x) == package(y) and
  name(x) == name(y)

defmethod equal? (x:ValId, y:ValId) :
  package(x) == package(y) and
  name(x) == name(y)

defmethod equal? (x:FnId, y:FnId) :
  package(x) == package(y) and
  name(x) == name(y) and
  ntargs(x) == ntargs(y) and
  a1(x) == a1(y)

defmethod hash (x:ValId) :
  hash $ [1, package(x), name(x)]

defmethod hash (x:TypeId) :
  hash $ [2, package(x), name(x)]

defmethod hash (x:FnId) :
  hash $ [3, package(x), name(x), ntargs(x), a1(x)]

public defn match? (x:Rec, y:Rec) :
  match(x, y) :
    (x:ValRec, y:ValRec) :
      type(x) == type(y) and
      mutable?(x) == mutable?(y) and
      lostanza?(x) == lostanza?(y)
    (x:FnRec, y:FnRec) :
      a2(x) == a2(y) and
      lostanza?(x) == lostanza?(y)
    (x:MultiRec, y:MultiRec) :
      a2(x) == a2(y)
    (x:ExternFnRec, y:ExternFnRec) :
      a2(x) == a2(y) and
      lbl(x) == lbl(y)
    (x:ExternRec, y:ExternRec) :
      type(x) == type(y) and
      lbl(x) == lbl(y)
    (x:StructRec, y:StructRec) :
      ntargs(x) == ntargs(y) and
      parent(x) == parent(y) and
      base(x) == base(y) and
      items(x) == items(y)
    (x:TypeRec, y:TypeRec) :
      ntargs(x) == ntargs(y) and
      parent(x) == parent(y) and
      children(x) == children(y)

;============================================================
;===================== IOTable ==============================
;============================================================

public deftype IOTable
public defmulti package (t:IOTable) -> Symbol
public defmulti import (t:IOTable, n:Int) -> Rec
public defmulti export (t:IOTable, n:Int) -> Rec
public defmulti get (t:IOTable, n:Int) -> Rec
public defmulti get (t:IOTable, id:RecId) -> Import|Export

public defn IOTable (io:PackageIO) :
  val idtable = to-hashtable<RecId,Import|Export> $
    for e in cat(imports(io), exports(io)) seq :
      id(rec(e)) => e
  val ntable = to-inttable<Import|Export> $
    for e in cat(imports(io), exports(io)) seq :
      n(e) => e
  
  new IOTable :
    defmethod package (this) : package(io)
    defmethod import (this, n:Int) : rec(ntable[n] as Import)
    defmethod export (this, n:Int) : rec(ntable[n] as Export)
    defmethod get (this, n:Int) : rec(ntable[n])
    defmethod get (this, id:RecId) : idtable[id]

public defn n (iotable:IOTable, id:RecId) :
  n(iotable[id])

;============================================================
;========================= Printer ==========================
;============================================================

defmethod print (o:OutputStream, t:DType) :
  print{o, _} $ match(t) :
    (t:DByte) : "byte"
    (t:DInt) : "int"
    (t:DLong) : "long"
    (t:DFloat) : "float"
    (t:DDouble) : "double"
    (t:DUnknown) : "?"
    (t:DPtrT) : "ptr<%_>" % [type(t)]
    (t:DFnT) :
      match(r(t)) :
        (r:DType) : "fn<(%,), %_, %_>" % [a(t), r, b(t)]
        (r:False) : "fn<(%,), %_>" % [a(t), b(t)]
    (t:DStructT) : "struct<%_>" % [id(t)]
    (t:DOf) : "ref<%_>" % [id(t)]
    (t:DTVar) : "TV%_" % [index(t)]
    (t:DAnd) : "and(%,)" % [types(t)]
    (t:DOr) : "or(%,)" % [types(t)]
    (t:DTop) : "top"
    (t:DBot) : "bot"

defmethod print (o:OutputStream, x:ValId) :
  print(o, "V(%~, %~)" % [package(x), name(x)])

defmethod print (o:OutputStream, x:TypeId) :
  print(o, "T(%~, %~)" % [package(x), name(x)])

defmethod print (o:OutputStream, x:FnId) :
  print(o, "F<%_>(%~, %~, %~)" % [ntargs(x), package(x), name(x), a1(x)])

defmethod print (o:OutputStream, r:ValRec) :
  val lsstr = "ls" when lostanza?(r) else ""
  val vstr = "var" when mutable?(r) else "val"
  print(o, "%_%_(%_ : %_)" % [
    lsstr, vstr, id(r), type(r)])

defmethod print (o:OutputStream, r:FnRec) :
  val lsstr = "ls" when lostanza?(r) else ""
  print(o, "%_fn(%~ -> %~)" % [lsstr, id(r), a2(r)])

defmethod print (o:OutputStream, r:MultiRec) :
  print(o, "multi(%~ -> %~)" % [id(r), a2(r)])

defmethod print (o:OutputStream, r:ExternFnRec) :
  print(o, "externfn(%~ -> %~, %~)" % [id(r), a2(r), lbl(r)])

defmethod print (o:OutputStream, r:ExternRec) :
  print(o, "extern(%_ : %_, %~)" % [id(r), type(r), lbl(r)])

defmethod print (o:OutputStream, r:StructRec) :
  val pstr = "" when parent(r) is False else " <: %_" % [parent(r)]
  print(o, "struct %_<%_>%_ :" % [id(r), ntargs(r), pstr])
  match(items(r)) :
    (items:DType) :
      val item-str = "%_ ..." % [items]
      bprint(o, cat(base(r), [item-str]))
    (items:False) :
      bprint(o, base(r))

defmethod print (o:OutputStream, r:TypeRec) :
  val pstr = "" when parent(r) is False else " <: %_" % [parent(r)]
  print(o, "type %_<%_>%_ :" % [id(r), ntargs(r), pstr])
  bprint(o, children(r))

defmethod print (o:OutputStream, x:Import) :
  print(o, "import %_ %~" % [n(x), rec(x)])

defmethod print (o:OutputStream, x:Export) :
  print(o, "export %_ %~" % [n(x), rec(x)])

defmethod print (o:OutputStream, x:PackageIO) :
  print(o, "package %~ :" % [package(x)])
  bprint(o, cat(imports(x), exports(x)))

defn lnprint (o:OutputStream, x) :
  print(o, '\n')
  print(o, x)

defn lnprints (o:OutputStream, xs:Seqable) :
  do(lnprint{o, _}, xs)

defn bprint (o:OutputStream, xs:Seqable) :
  val xs-seq = to-seq(xs)
  if empty?(xs-seq) : print(o, " ()")
  else : lnprints(IndentedStream(o), xs-seq)

;============================================================
;======================= Reader =============================
;============================================================

defsyntax dl-ir :
  defn prefix-id? (x, s:String) :
    match(unwrap-token(x)) :
      (x:Symbol) : prefix?(x, s)
      (x) : false
  defn id-prefix (info:FileInfo|False, x:Symbol|Token, len:Int) :
    match(to-int(to-string(unwrap-token(x))[len to false])) :
      (i:Int) : i
      (i) : throw(DLE(info, "Invalid name: %~" % [x]))

  public defproduction packageio : PackageIO
  defrule packageio = (package ?name:#symbol :
                         ?imports:#import ...
                         ?exports:#export ...) :
    PackageIO(name, to-tuple(imports), to-tuple(exports))

  defproduction dtype : DType
  defrule dtype = (byte) : DByte()
  defrule dtype = (int) : DInt()
  defrule dtype = (long) : DLong()
  defrule dtype = (float) : DFloat()
  defrule dtype = (double) : DDouble()
  defrule dtype = (?) : DUnknown()
  defrule dtype = (ptr<?t:#dtype>) : DPtrT(t)
  defrule dtype = (fn<(?a:#dtype ...), ?r:#dtype, ?b:#dtype>) : DFnT(to-tuple(a), r, b)
  defrule dtype = (fn<(?a:#dtype ...), ?b:#dtype>) : DFnT(to-tuple(a), false, b)
  defrule dtype = (struct<?t:#tid>) : DStructT(t)
  defrule dtype = (ref<?t:#tid>) : DOf(t)
  defrule dtype = (?x) when prefix-id?(x,"TV") : DTVar(id-prefix(closest-info(), x, 2))
  defrule dtype = (and(?ts:#dtype ...)) : DAnd(qsort(ts))
  defrule dtype = (or(?ts:#dtype ...)) : DOr(qsort(ts))
  defrule dtype = (top) : DTop()
  defrule dtype = (bot) : DBot()

  defproduction vid : ValId
  defrule vid = (V(?p:#symbol,?n:#symbol)) : ValId(p,n)
  defproduction fid : FnId
  defrule fid = (F<?ntargs:#int>(?p:#symbol,?n:#symbol, [?a1:#dtype ...])) :
    FnId(p,n,ntargs,to-tuple(a1))
  defproduction tid : TypeId
  defrule tid = (T(?p:#symbol,?n:#symbol)) : TypeId(p,n)

  defproduction id : RecId
  defrule id = (?x:#vid) : x
  defrule id = (?x:#tid) : x
  defrule id = (?x:#fid) : x

  defproduction rec : Rec
  defrule rec = (val(?id:#vid : ?t:#dtype)) : ValRec(id, t, false, false)
  defrule rec = (var(?id:#vid : ?t:#dtype)) : ValRec(id, t, true, false)
  defrule rec = (lsval(?id:#vid : ?t:#dtype)) : ValRec(id, t, false, true)
  defrule rec = (lsvar(?id:#vid : ?t:#dtype)) : ValRec(id, t, true, true)
  defrule rec = (fn(?id:#fid -> ?a2:#dtype)) : FnRec(id, a2, false)
  defrule rec = (lsfn(?id:#fid -> ?a2:#dtype)) : FnRec(id, a2, true)
  defrule rec = (multi(?id:#fid -> ?a2:#dtype)) : MultiRec(id, a2)
  defrule rec = (externfn(?id:#fid -> ?a2:#dtype, ?lbl:#symbol)) : ExternFnRec(id, a2, lbl)
  defrule rec = (extern(?id:#vid : ?t:#dtype, ?lbl:#symbol)) : ExternRec(id, t, lbl)
  defrule rec = (struct ?id:#tid<?ntargs:#int> ?p:#parent? : (?ts:#dtype ... ~ ...)) :
    StructRec(id, ntargs, p, to-tuple(but-last(ts)), last(ts))
  defrule rec = (struct ?id:#tid<?ntargs:#int> ?p:#parent? : (?ts:#dtype ...)) :
    StructRec(id, ntargs, p, to-tuple(ts), false)
  defrule rec = (type ?id:#tid<?ntargs:#int> ?p:#parent? : (?cs:#tid ...)) :
    TypeRec(id, ntargs, p, to-tuple(cs))

  defproduction parent? : False|DType
  defrule parent? = (<: ?p:#dtype) : p
  defrule parent? = () : false

  public defproduction import : Import
  defrule import = (import ?n:#int ?r:#rec) : Import(n,r)
  fail-if import = (import) : DLE(closest-info(), "Invalid import statement.")

  public defproduction export : Export
  defrule export = (export ?n:#int ?r:#rec) : Export(n,r)
  fail-if export = (export) : DLE(closest-info(), "Invalid export statement.")

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

;============================================================
;======================== Errors ============================
;============================================================

public defstruct DLError <: Exception :
  info: FileInfo|False
  msg: String

defn DLE (info:FileInfo|False, msg) :
  DLError(info, to-string(msg))

;============================================================
;=================== Built-in Descriptors ===================
;============================================================

defn core-typeid (name:Symbol) :
  TypeId(`core, name)
defn core-type (name:Symbol) :
  switch(name) :
    `byte : DByte()
    `int : DInt()
    `long : DLong()
    `float : DFloat()
    `double : DDouble()
    else : DOf(core-typeid(name))
defn core-fnid (name:Symbol, args:Tuple<Symbol>) :
  DFnT(`core, name, 0, map(core-type, args))
defn core-fnid (name:Symbol) :
  core-fnid(name, [])

val CORE-IDS = Vector<RecId>()
public defn core-ids () :
  CORE-IDS
  
defn register (id:RecId) :
  add(CORE-IDS,id)
  id

public val CORE-TYPE-ID = register $ core-typeid(`Type)
public val CORE-TUPLE-ID = register $ core-typeid(`Tuple)
public val CORE-BOX-ID = register $ core-typeid(`Box)
public val CORE-FN-ID = register $ core-typeid(`Fn)
public val CORE-STACK-ID = register $ core-typeid(`Stack)
public val CORE-CHAR-ID = register $ core-typeid(`Char)
public val CORE-BYTE-ID = register $ core-typeid(`Byte)
public val CORE-INT-ID = register $ core-typeid(`Int)
public val CORE-LONG-ID = register $ core-typeid(`Long)
public val CORE-FLOAT-ID = register $ core-typeid(`Float)
public val CORE-DOUBLE-ID = register $ core-typeid(`Double)
public val CORE-FALSE-ID = register $ core-typeid(`False)
public val CORE-TRUE-ID = register $ core-typeid(`True)
public val CORE-ARITY-ERROR-ID = register $ core-fnid(`arity-error)
public val CORE-NO-METHOD-ERROR-ID = register $ core-fnid(`no-method-error)
public val CORE-AMB-METHOD-ERROR-ID = register $ core-fnid(`amb-method-error)
public val CORE-TUPLE-LENGTH-ERROR-ID = register $ core-fnid(`tuple-length-error)
public val CORE-NO-BRANCH-ERROR-ID = register $ core-fnid(`no-branch-error)
public val CORE-AMB-BRANCH-ERROR-ID = register $ core-fnid(`amb-branch-error)
public val CORE-CAST-ERROR-ID = register $ core-fnid(`cast-error)
public val CORE-VARIABLE-UNINITIALIZED-ERROR-ID = register $ core-fnid(`variable-uninitialized-error)
public val CORE-VOID-TUPLE-ID = register $ core-fnid(`void-tuple)