defpackage stz/dl-ir :
  import core
  import collections

;============================================================
;======================== EPackage ==========================
;============================================================

public defstruct PackageIO :
  package: Symbol
  imports: Tuple<Import>
  exports: Tuple<Export>

;============================================================
;===================== Import/Export ========================
;============================================================

public defstruct Export :
  n: Int
  rec: Rec

public defstruct Import :
  n: Int
  rec: Rec

;============================================================
;======================= Records ============================
;============================================================

public deftype Rec
public defmulti id (r:Rec) -> RecId

public defstruct FnRec <: Rec :
  id: FnId with: (as-method => true)
  a2: DType
  
public defstruct TypeRec <: Rec :
  id: TypeId with: (as-method => true)
  parent: False|DType

;============================================================
;========================= Ids ==============================
;============================================================

public deftype DType <: Hashable & Equalable
public defstruct DByte <: DType
public defstruct DInt <: DType
public defstruct DLong <: DType
public defstruct DFloat <: DType
public defstruct DDouble <: DType
public defstruct DOf <: DType : (id:TypeId)

public deftype RecId <: Hashable & Equalable
public defmulti package (r:RecId) -> Symbol

public defstruct TypeId <: RecId :
  package: Symbol with: (as-method => true)
  name: Symbol

public defstruct FnId <: RecId :
  package: Symbol with: (as-method => true)
  name: Symbol
  a1: Tuple<DType>

;============================================================
;======================= Matching ===========================
;============================================================

defmethod equal? (x:TypeId, y:TypeId) :
  package(x) == package(y) and
  name(x) == name(y)

defmethod equal? (x:FnId, y:FnId) :
  package(x) == package(y) and
  name(x) == name(y) and
  a1(x) == a1(y)

defmethod equal? (x:DType, y:DType) :
  match(x, y) :
    (x:DByte, y:DByte) : true
    (x:DInt, y:DInt) : true
    (x:DLong, y:DLong) : true
    (x:DFloat, y:DFloat) : true
    (x:DDouble, y:DDouble) : true
    (x:DOf, y:DOf) : id(x) == id(y)
    (x, y) : false

defmethod hash (x:TypeId) :
  hash $ [7, package(x), name(x)]

defmethod hash (x:FnId) :
  hash $ [11, package(x), name(x), a1(x)]

defmethod hash (x:DType) :
  match(x) :
    (x:DByte) : 1
    (x:DInt) : 2
    (x:DLong) : 3
    (x:DFloat) : 4
    (x:DDouble) : 5
    (x:DOf) : hash(id(x))

public defn match? (x:Rec, y:Rec) :
  match(x, y) :
    (x:FnRec, y:FnRec) :
      a2(x) == a2(y)
    (x:TypeRec, y:TypeRec) :
      parent(x) == parent(y)

;============================================================
;========================= Printer ==========================
;============================================================

defmethod print (o:OutputStream, x:TypeId) :
  print(o, "T(%~, %~)" % [package(x), name(x)])

defmethod print (o:OutputStream, x:FnId) :
  print(o, "F(%~, %~, %~)" % [package(x), name(x), a1(x)])

defmethod print (o:OutputStream, x:DType) :
  print{o, _} $ match(x) :
    (x:DByte) : "byte"
    (x:DInt) : "int"
    (x:DLong) : "long"
    (x:DFloat) : "float"
    (x:DDouble) : "double"
    (x:DOf) : "ref<%~>" % [id(x)]

defmethod print (o:OutputStream, r:TypeRec) :
  val pstr = match(parent(r)) :
    (p:DType) : " <: %~" % [p]
    (p:False) : ""
  print(o, "type(%~%_)" % [id(r), pstr])

defmethod print (o:OutputStream, r:FnRec) :
  print(o, "fn(%~ -> %~)" % [id(r), a2(r)])

defmethod print (o:OutputStream, x:Import) :
  print(o, "import %_ %~" % [n(x), rec(x)])

defmethod print (o:OutputStream, x:Export) :
  print(o, "export %_ %~" % [n(x), rec(x)])

defmethod print (o:OutputStream, x:PackageIO) :
  print(o, "package %~ :" % [package(x)])
  val o2 = IndentedStream(o)
  for e in cat(imports(x), exports(x)) do :
    print(o2, '\n')
    print(o2, e)

;============================================================
;======================= Reader =============================
;============================================================

defsyntax dl-ir :
  public defproduction packageio : PackageIO
  defrule packageio = (package ?name:#symbol :
                         ?imports:#import ...
                         ?exports:#export ...) :
    PackageIO(name, to-tuple(imports), to-tuple(exports))

  defproduction dtype : DType
  defrule dtype = (byte) : DByte()
  defrule dtype = (int) : DInt()
  defrule dtype = (long) : DLong()
  defrule dtype = (float) : DFloat()
  defrule dtype = (double) : DDouble()
  defrule dtype = (ref<?id:#id>) : DOf(id as TypeId)

  defproduction id : RecId
  defrule id = (T(?p:#symbol,?n:#symbol)) : TypeId(p,n)
  defrule id = (F(?p:#symbol,?n:#symbol,[?a1:#dtype ...])) : FnId(p,n,to-tuple(a1))

  defproduction rec : Rec
  defrule rec = (type(?id:#id)) : TypeRec(id as TypeId,false)
  defrule rec = (type(?id:#id <: ?p:#dtype)) : TypeRec(id as TypeId,p)
  defrule rec = (fn(?id:#id -> ?a2:#dtype)) : FnRec(id as FnId,a2)

  defproduction import : Import
  defrule import = (import ?n:#int ?r:#rec) : Import(n,r)
  fail-if import = (import) : DLE(closest-info(), "Invalid import statement.")

  defproduction export : Export
  defrule export = (export ?n:#int ?r:#rec) : Export(n,r)
  fail-if export = (export) : DLE(closest-info(), "Invalid export statement.")

  ;===== Primitives =====
  defproduction int : Int
  defrule int = (?x) when unwrap-token(x) is Int : unwrap-token(x)

  defproduction symbol : Symbol
  defrule symbol = (?x) when unwrap-token(x) is Symbol : unwrap-token(x)

;============================================================
;======================== Errors ============================
;============================================================

public defstruct DLError <: Exception :
  info: FileInfo|False
  msg: String

defn DLE (info:FileInfo|False, msg) :
  DLError(info, to-string(msg))