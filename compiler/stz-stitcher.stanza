;See License.txt for details about licensing.

defpackage stz/stitcher :
  import core
  import collections
  import stz/asm-ir
  import stz/kl-ir
  import stz/khier
  import stz/algorithms
  import stz/codegen
  
;============================================================
;===================== Stitcher =============================
;============================================================

public deftype Stitcher
public defmulti stitch (s:Stitcher, ins:Seqable<Ins>) -> False

public defn Stitcher (khier:KHierarchy) :
  new Stitcher :
    defmethod stitch (this, ins:Seqable<Ins>) :
      for e in ins do :
        match(e) :
          (e:Match) :
            println("Stitch: %_" % [e])
            val branches =
              for branch in branches(e) map :
                val bits = map(kbits{khier, _}, tags(branch))
                bits => n(branch)
            val trie = to-trie(branches)
            println(trie)
          (e:Dispatch) :
            println("Stitch: %_" % [e])
            val branches =
              for branch in branches(e) map :
                tags(branch) => n(branch)
            val dbranches = dispatch-branches(khier, branches, -1)
            println(dbranches)
            val trie = to-trie(dbranches)
            println(trie)            
          (e) :
            false

;============================================================
;==================== Tag Assignment ========================
;============================================================

deftype TagTable
defmulti tag (t:TagTable, n:Int) -> Int

public defn assign-tags (h:KHierarchy) :
  val tag-counter = to-seq(0 to false)
  val table = HashTable<Int,False|Int>()
  
  ;Call f on all roots of n
  defn do-roots (f:Int -> ?, n:Int) :
    val ps = parents(h, n)
    if empty?(ps) : f(n)
    else : do(do-roots{f, _}, ps)

  ;Assign tags to all children
  defn assign-tags (n:Int) :
    if not key?(table, n) :
      table[n] = next(tag-counter) when leaf?(h,n)
      do(assign-tags, children(h,n))
      
  ;Assigns tags
  for n in types(h) do :
    do-roots(assign-tags, n)
  val num-tags = next(tag-counter)

  ;Return tag table
  new TagTable :
    defmethod tag (this, n:Int) : table[n] as Int

;============================================================
;===================== Match Tries ==========================
;============================================================

deftype MTrie
defstruct IfTrie <: MTrie :
  branches: List<KeyValue<KBits, MTrie>>
defstruct EndTrie <: MTrie :
  lbl: Int

defmethod print (o:OutputStream, t:MTrie) :
  print{o, _} $ match(t) :
    (t:IfTrie) : "(%*)" % [join(branches(t), " or ")]
    (t:EndTrie) : lbl(t)

;============================================================
;===================== Trie Conversion ======================
;============================================================

defn to-trie (bs:List<KeyValue<List<KBits>, Int>>) -> MTrie :
  ;Utilities
  defn less? (a:KBits, b:KBits) : subset?(a, b)
  defn minus (a:KBits, b:KBits) : subtract(a, b)
  defn bit-and (a:KBits, b:KBits) : intersect(a, b)

  ;Initial starting place
  defn init (ts:List<KBits>, lbl:Int) -> MTrie :
    if empty?(ts) :
      EndTrie(lbl)
    else : 
      val [X, YZ] = [head(ts), tail(ts)]
      IfTrie(List(X => init(YZ, lbl)))
    
  ;Add a branch to a trie
  defn add (t:MTrie, ts:List<KBits>, lbl:Int) -> MTrie :
    match(t) :
      (t:IfTrie) : IfTrie(add(branches(t), ts, lbl))
      (t:EndTrie) : t

  ;Add X => Y => Z ... to (A => B => C, rest ...)
  defn add (brs:List<KeyValue<KBits, MTrie>>,
            ts:List<KBits>,
            lbl:Int) ->
            List<KeyValue<KBits, MTrie>> :
    val [X, YZ] = [head(ts), tail(ts)]
    if bottom?(X) :
      brs    
    else if empty?(brs) :
      List(X => init(YZ, lbl))
    else :
      val [A, BC] = [key(head(brs)), value(head(brs))]
      val rest = tail(brs)
      if A < X :
        val b1 = A => add(BC, YZ, lbl)
        val b2 = add(rest, cons(X - A, YZ), lbl)
        cons(b1, b2)     
      else if X < A :
        val b1 = X => add(BC, YZ, lbl)
        val b2 = (A - X) => BC
        cons(b1, b2, rest)
      else if disjoint?(A, X) :
        cons(
          head(brs)
          add(rest, ts, lbl))      
      else :
        val W = A & X
        val ts1 = cons(W, tail(ts))
        val ts2 = cons(X - W, tail(ts))
        add(add(brs, ts1, lbl), ts2, lbl)

  ;Driver
  val b0 = head(bs)
  reduce{_, init(key(b0), value(b0)), tail(bs)} $
    fn (trie:MTrie, branch:KeyValue<List<KBits>,Int>) :
      add(trie, key(branch), value(branch))

;============================================================
;================== Dispatch Conversion =====================
;============================================================

defn union-taglists (hier:KHierarchy, tag-lists:List<List<KBits>>) -> List<List<KBits>> :
  defn compatible? (xs:List<KBits>, ys:List<KBits>) :
    val n = for [x, y] in zip(xs, ys) count : x != y
    n <= 1
  val lists = Vector<List<KBits>>()
  defn add-list (ts:List<KBits>) :
    match(index-when(compatible?{ts, _}, lists)) :
      (i:Int) : lists[i] = map(union, ts, lists[i])
      (i:False) : add(lists, ts)
  for [xs, ys] in all-pairs(tag-lists) do :
    val ts = map(intersect, xs, ys)
    add-list(ts) when none?(bottom?, ts)
  to-list(lists)

defn dispatch-branches (hier:KHierarchy,
                        branches:List<KeyValue<List<KTag>, Int>>,
                        amb-lbl:Int) ->
                        List<KeyValue<List<KBits>, Int>> :
  val lists = to-vector<List<KTag>>(seq(key,branches))
  val lbls = to-vector<Int>(seq(value,branches))
  defn more-applicable? (a:Int, b:Int) :
    all?(subtype?{hier, _, _}, lists[a], lists[b])
    
  defn kbits (xs:List<KTag>) : map(/kbits{hier,_}, xs)    
  val ordering = ambiguity-ordering(length(lists), more-applicable?)
  to-list $ for entry in ordering seq-cat :
    match(entry) :
      (i:Int) :
        List(kbits(lists[i]) => lbls[i])
      (idx:List<Int>) :
        val lists = union-taglists(hier, map(kbits{lists[_]}, idx))
        seq({_ => amb-lbl}, lists)
        