;See License.txt for details about licensing.

defpackage stz/stitcher :
  import core
  import collections
  import stz/asm-ir

;============================================================
;==================== Tag Assignment ========================
;============================================================

deftype TagTable
defmulti tag (t:TagTable, n:Int) -> Int

public defn assign-tags (h:KHierarchy) :
  val tag-counter = to-seq(0 to false)
  val table = HashTable<Int,False|Int>()
  
  ;Call f on all roots of n
  defn do-roots (f:Int -> ?, n:Int) :
    val ps = parents(h, n)
    if empty?(ps) : f(n)
    else : do(do-roots{f, _}, ps)

  ;Assign tags to all children
  defn assign-tags (n:Int) :
    if not key?(table, n) :
      table[n] = next(tag-counter) when leaf?(h,n)
      do(assign-tags, children(h,n))
      
  ;Assigns tags
  for n in types(h) do :
    do-roots(assign-tags, n)
  val num-tags = next(tag-counter)

  ;Return tag table
  new TagTable :
    defmethod tag (this, n:Int) : table[n] as Int

;============================================================
;===================== OLD Match Trie =======================
;============================================================

deftype MTrieBak
defmulti bits (t:MTrieBak) -> KBits

defstruct TrieArgBak <: MTrieBak :
   bits: KBits with: (as-method => true)
   children: List<MTrieBak>
defstruct TrieEndBak <: MTrieBak :
   bits: KBits with: (as-method => true)
   lbl: Int

defmethod print (o:OutputStream, tr:MTrieBak) :
   print{o,_} $
   match(tr) :
      (tr:TrieArgBak) : "(%~ => %*)" % [bits(tr), join(children(tr), " or ")]
      (tr:TrieEndBak) : "(%~ => %~)" % [bits(tr), lbl(tr)]

;============================================================
;==================== OLD Trie Conversion ===================
;============================================================

defn to-trie-bak (branches:List<List<KBits>>, lbls:List<Int>) -> List<MTrieBak> :
  ;Add a list of types ending with a branch to the given list of tries
  defn add (trs:List<MTrieBak>, types:List<KBits>, lbl:Int) -> List<MTrieBak> :
    val [t, rest] = [head(types), tail(types)]
    ;Case 1: Path is unreachable
    if bottom?(t) :
      trs
    ;Case 2: No tries in list
    else if empty?(trs) :
      ;Make a Trie
      if empty?(rest) : List(TrieEndBak(t, lbl))
      else : List(TrieArgBak(t, add(trs, rest, lbl)))
    else :
      val [tr, tr-rest] = [head(trs), tail(trs)]
      ;Case 3: Trie is more specialized than path
      if subset?(bits(tr), t) :
        val tr* = match(tr) :
          (tr:TrieArgBak) : TrieArgBak(bits(tr), add(children(tr), rest, lbl))
          (tr:TrieEndBak) : tr
        val types* = cons(subtract(t, bits(tr)), rest)
        cons(tr*, add(tr-rest, types*, lbl))
      ;Case 4: Trie is less specialized than path
      else if subset?(t, bits(tr)) :
        match(tr) :
          (tr:TrieArgBak) :
            cons(TrieArgBak(t, add(children(tr), rest, lbl))
            cons(TrieArgBak(subtract(bits(tr), t), children(tr))
                 tr-rest))
          (tr:TrieEndBak) :
            trs
      ;Case 5: Trie is partially covered by path
      else :
        val t1 = intersect(bits(tr), t)
        if bottom?(t1) :
          cons(tr, add(tr-rest, types, lbl))
        else :
          val t2 = subtract(t, t1)
          val types1 = cons(t1, rest)
          val types2 = cons(t2, rest)
          val trs* = add(trs, types1, lbl)
          add(trs*, types2, lbl)

  ;Driver
  reduce{_, List(), zip(branches, lbls)} $
    fn (accum, [b lbl]) :
      add(accum, b, lbl)

;============================================================
;===================== Match Tries ==========================
;============================================================

deftype MTrie
defstruct IfTrie <: MTrie :
  branches: List<KeyValue<KBits, MTrie>>
defstruct EndTrie <: MTrie :
  lbl: Int

defmethod print (o:OutputStream, t:MTrie) :
  print{o, _} $ match(t) :
    (t:IfTrie) : "(%*)" % [join(branches(t), " or ")]
    (t:EndTrie) : value(t)

;============================================================
;===================== Trie Conversion ======================
;============================================================

defn to-trie (branches:List<KeyValue<List<KBits>, Int>>) -> MTrie :
  ;Utilities
  defn less? (a:KBits, b:KBits) : subset?(a, b)
  defn minus (a:KBits, b:KBits) : subtract(a, b)
  defn bit-and (a:KBits, b:KBits) : intersect(a, b)

  ;Initial starting place
  defn init (ts:List<KBits>, lbl:Int) -> MTrie :
    if empty?(ts) : EndTrie(lbl)
    else : IfTrie(List(head(ts) => init(tail(ts), lbl)))
    
  ;Add a branch to a trie
  defn add (t:MTrie, ts:List<KBits>, lbl:Int) -> MTrie :
    match(t) :
      (t:IfTrie) : IfTrie(add(branches(t), ts, lbl))
      (t:EndTrie) : t

  ;Add X => Y => Z ... to (A => B => C, rest ...)
  defn add (brs:List<KeyValue<KBits, MTrie>>,
            ts:List<KBits>,
            lbl:Int) ->
            List<KeyValue<KBits, MTrie>> :              
    val [X, YZ] = [head(ts), tail(ts)]
    val [A, BC] = [key(head(brs)), value(head(brs))]
    val rest = tail(brs)
    if bottom?(X) :
      brs
    else if A < X :
      cons(
        A => add(BC, YZ, lbl)
        add(rest, cons(X - A, YZ), lbl))      
    else if X < A :
      cons(
        X => add(BC, YZ, lbl)
        A - X => BC
        rest)
    else if disjoint?(A, X) :
      cons(
        head(brs)
        add(rest, ts, lbl))      
    else :
      val W = A & X      
      val ts1 = cons(W, tail(ts))
      val ts2 = cons(X - W, tail(ts))
      add(add(brs, ts1, lbl), ts2, lbl)

  ;Driver
  val b0 = head(branches)
  reduce{_, init(key(b0), value(b0)), tail(branches)} $
    fn (trie, branch) :
      add(trie, key(branch), value(branch))