;See License.txt for details about licensing.

defpackage stz/stitcher :
  import core
  import collections
  import stz/asm-ir
  import stz/khier

;============================================================
;===================== Driver ===============================
;============================================================

public defn stitch (khier:KHierarchy, f: Stitcher -> ?) :
  f(Stitcher(khier))

;============================================================
;===================== Stitcher =============================
;============================================================

public deftype Stitcher
public defmulti stitch (s:Stitcher, ins:Seqable<Ins>) -> False

defn Stitcher (khier:KHierarchy) :
  new Stitcher :
    defmethod stitch (this, ins:Seqable<Ins>) :
      for e in ins do :
        match(e) :
          (e:Match) :
            println("Stitch: %_" % [e])
            let :
              val branches =
                for branch in branches(e) map :
                  val bits = map(kbits{khier, _}, tags(branch))
                  bits => n(branch)
              val trie = to-trie(branches)
              println(trie)
            let :
              val tag-lists =
                for branch in branches(e) map :
                  map(kbits{khier, _}, tags(branch))
              val lbls = map(n, branches(e))
              val bak = to-trie-bak(tag-lists, lbls)
              println("Backup Algorithm:")
              println(bak)
          (e) :
            false

;============================================================
;==================== Tag Assignment ========================
;============================================================

deftype TagTable
defmulti tag (t:TagTable, n:Int) -> Int

public defn assign-tags (h:KHierarchy) :
  val tag-counter = to-seq(0 to false)
  val table = HashTable<Int,False|Int>()
  
  ;Call f on all roots of n
  defn do-roots (f:Int -> ?, n:Int) :
    val ps = parents(h, n)
    if empty?(ps) : f(n)
    else : do(do-roots{f, _}, ps)

  ;Assign tags to all children
  defn assign-tags (n:Int) :
    if not key?(table, n) :
      table[n] = next(tag-counter) when leaf?(h,n)
      do(assign-tags, children(h,n))
      
  ;Assigns tags
  for n in types(h) do :
    do-roots(assign-tags, n)
  val num-tags = next(tag-counter)

  ;Return tag table
  new TagTable :
    defmethod tag (this, n:Int) : table[n] as Int

;============================================================
;===================== Match Tries ==========================
;============================================================

deftype MTrie
defstruct IfTrie <: MTrie :
  branches: List<KeyValue<KBits, MTrie>>
defstruct EndTrie <: MTrie :
  lbl: Int

defmethod print (o:OutputStream, t:MTrie) :
  print{o, _} $ match(t) :
    (t:IfTrie) : "(%*)" % [join(branches(t), " or ")]
    (t:EndTrie) : lbl(t)

;============================================================
;===================== Trie Conversion ======================
;============================================================

defn to-trie (bs:List<KeyValue<List<KBits>, Int>>) -> MTrie :
  ;Utilities
  defn less? (a:KBits, b:KBits) : subset?(a, b)
  defn minus (a:KBits, b:KBits) : subtract(a, b)
  defn bit-and (a:KBits, b:KBits) : intersect(a, b)

  ;Initial starting place
  defn init (ts:List<KBits>, lbl:Int) -> MTrie :
    if empty?(ts) :
      EndTrie(lbl)
    else : 
      val [X, YZ] = [head(ts), tail(ts)]
      IfTrie(List(X => init(YZ, lbl)))
    
  ;Add a branch to a trie
  defn add (t:MTrie, ts:List<KBits>, lbl:Int) -> MTrie :
    match(t) :
      (t:IfTrie) : IfTrie(add(branches(t), ts, lbl))
      (t:EndTrie) : t

  ;Add X => Y => Z ... to (A => B => C, rest ...)
  defn add (brs:List<KeyValue<KBits, MTrie>>,
            ts:List<KBits>,
            lbl:Int) ->
            List<KeyValue<KBits, MTrie>> :
    val [X, YZ] = [head(ts), tail(ts)]
    if bottom?(X) :
      brs    
    else if empty?(brs) :
      List(X => init(YZ, lbl))
    else :
      val [A, BC] = [key(head(brs)), value(head(brs))]
      val rest = tail(brs)
      if A < X :
        val b1 = A => add(BC, YZ, lbl)
        val b2 = add(rest, cons(X - A, YZ), lbl)
        cons(b1, b2)     
      else if X < A :
        val b1 = X => add(BC, YZ, lbl)
        val b2 = (A - X) => BC
        cons(b1, b2, rest)
      else if disjoint?(A, X) :
        cons(
          head(brs)
          add(rest, ts, lbl))      
      else :
        val W = A & X
        val ts1 = cons(W, tail(ts))
        val ts2 = cons(X - W, tail(ts))
        add(add(brs, ts1, lbl), ts2, lbl)

  ;Driver
  val b0 = head(bs)
  reduce{_, init(key(b0), value(b0)), tail(bs)} $
    fn (trie:MTrie, branch:KeyValue<List<KBits>,Int>) :
      add(trie, key(branch), value(branch))