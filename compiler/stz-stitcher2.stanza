defpackage stz/stitcher :
  import core
  import collections
  import stz/asm-ir
  import stz/codegen
  import stz/dl-ir
  import stz/vm-ir
  import stz/utils
  import stz/padder
  import stz/const-pool
  import stz/dyn-tree

;<DOC>=======================================================
;===================== Documentation ========================
;============================================================

Input:
  Functions compiled into ASM IR.  
Output:
  Pure ASM IR

Constructs that are removed:
  TagImm
  StackMap
  LinkId
  Match
  Dispatch
  MethodDispatch

Removal strategies for each construct:
  TagImm:
    Becomes integer immediates.
    Requires each class to have an integer tag assigned to it.
    If it is a marker, then becomes (tag << 3) + marker-ref-bits.
    If it is not a marker, then becomes tag.
  StackMap:
    Becomes an integer immediate.
    Requires every unique stackmap to have an integer id assigned to it.
    Output the id.
  LinkId:
    The linkids can refer to one of the following:
      CodeId:
        Becomes a Mem immediate referencing the starting label of the function.
        Requires all functions to have a unique label assigned to it.
      ExternId:
        Becomes an ExMem immediate referencing the external label of the variable.
      ExternDefnId:
        Becomes an ExMem immediate referencing the external label of the function.
      DataId:
        Becomes a Mem immediate referencing the label of the data packet.
      GlobalId:
        Becomes a Mem immediate referencing the global constant pool table, with
        the appropriate offset. 
      ConstId:
        Becomes a Mem immediate referencing the global constant pool table, with
        the appropriate offset.
        Requires constants to be interned and assigned indices. 
  Match, Dispatch:
    Requires the class hierarchy to be indexed.
    Convert the branches into a trie and then emit the instructions
    for performing the branching.
  MethodDispatch:
    Requires the class hierarchy to be indexed.
    Requires the method branches for each multi to be collected.
    Convert the branches into a trie and then emit the instructions
    for performing the branching.

Implementation of Global Table:
  Input:
    Sequence of VMGlobals:
      defstruct VMGlobal :
        id: Int
        size: Int
        roots: Tuple<Int>
  Output:
    For each global:
      Compute an offset.
    Compute the reference mask.
    Compute the number of words in the mask.

Implementation of Constant Table:
  Input:
    Sequence of VMConst:
      defstruct VMConst :
        id: Int
        value: VMValue
  Output:
    The index of each interned VMConst.
    The Consts corresponding to each index, ready to be
    encoded as a table.

Implementation of Class Table:
  Goal:
    The objective of the class table is to help compile the
    match/dispatch statements. The key feature needed is the ability
    to convert a TypeSet into an ISet to perform the trie conversion.
  Therefore:
    Given a single typeid, within a package. Convert it to an ISet.
  Therefore:
    Given a single typeid, we need to resolve it to a global typeid.
  Therefore:
    Each global typeid needs a node in the class dynamic tree.
  Implementation:
    Sweep through every vmclass definition in each package, and if it
    is a concrete class, then assign its ClassProp property with its
    assigned tag.
    At the same time, for each vmclass definition, add a definition in
    the class dynamic tree using its global id (not its tag).
  Output:
    For each TypeSet, its ISet mapping to its global tags, because we
    need to distinguish marker objects from non-marker objects.

Implementation of Match/Dispatch instructions:
  Input:
    Match :
      xs: List<Imm>
      branches: List<Branch>
      no-branch: Int
    Branch :
      tags: List<TypeSet>
      n: Int
  Output:
    Emitted code for performing the dispatch.
  Assumptions:
    We can assume that the arguments have been placed in the appropriate
    registers and argument slots for the platform.
  Implementation:
    Requires conversion of a typeset to an ISet.
    This can be done using the DynTree implementation, once we
    have finished assigning class tags to all concrete classes.

;============================================================
;=======================================================<DOC>

;============================================================
;=================== StitcherEmitter ========================
;============================================================

public deftype Stitcher
public defmulti emit-tables (s:Stitcher, emitter:CodeEmitter) -> False
public defmulti emitter (s:Stitcher, package:Symbol, emitter:CodeEmitter) -> CodeEmitter

;============================================================
;=============== Create the Stitcher Tables =================
;============================================================

deftype PackageIds
defmulti resolve (ids:PackageIds, x:LinkId) -> Imm
defmulti global-id (ids:PackageIds, lid:Int) -> Int

public defn Stitcher (vmpackages:Seqable<VMPackage>, stubs:AsmStubs) :
  ;Records
  val global-records = Vector<Rec>()
  val global-props = Vector<GProps|False>()
  val id-indices = HashTable<RecId,Int>()
  val package-ids = HashTable<Symbol,PackageIds>()

  ;Add a new global record
  defn add-global-record (r:Rec) -> Int :
    val global-id = length(global-records)
    add(global-records, r)
    add(global-props, false)
    id-indices[id(r)] = global-id
    global-id

  ;Retrieve the global id for a given RecId
  defn get-global-id (id:RecId) :
    id-indices[id]

  ;Create a PackageIds struct
  defn PackageIds (local-ids:IntTable<Int>) :
    new PackageIds :
      defmethod global-id (this, lid:Int) :
        local-ids[lid]
      defmethod resolve (this, x:LinkId) :
        val props = global-props[local-ids[id(x)]]
        match(props) :
          (p:CodeProps) :
            Mem(lbl(p), 0)
          (p:ExternProps) :
            ExMem(exlbl(p), 0)
          (p:ExternDefnProps) :
            ExMem(exlbl(p), 0)
          (p:DataProps) :
            Mem(lbl(p), 0)
          (p:ConstProps) :
            Mem(const-table(stubs), index(p) * 8)
          (p:GlobalProps) :
            Mem(globals(stubs), offset(p))

  ;Initialize record tables
  defn initialize-record-tables () :
    ;Accumulate initializers to run after we populate
    ;exported records.
    val initializers = Vector<(() -> ?)>()
    defn initialize (f:() -> ?) :
      add(initializers, f)      

    ;Initialize package ids
    for packageio in seq(packageio, vmpackages) do :
      val local-ids = IntTable<Int>()
      for e in exports(packageio) do :
        local-ids[n(e)] = add-global-record(rec(e))
      within initialize() :
        for i in imports(packageio) do :
          local-ids[n(i)] = get-global-id(id(rec(i)))
      package-ids[package(packageio)] = PackageIds(local-ids)
        
    ;Run initializers
    for init in initializers do :
      init()

  ;Simple properties
  defn initialize-simple-props () :    
    for p in vmpackages do :
      val pkgids = package-ids[package(p)]
      defn set-props (local-id:Int, props:GProps) :
        val gid = global-id(pkgids, local-id)
        global-props[gid] = props
      for f in funcs(p) do :
        set-props(id(f), CodeProps(unique-id(stubs)))
      for e in extern-defns(p) do :
        set-props(fid(e), ExternDefnProps(lbl(e)))
      for e in externs(p) do :
        set-props(id(e), ExternProps(name(e)))
      for d in datas(p) do :
        set-props(id(d), DataProps(unique-id(stubs)))

  ;Global table
  var total-global-size:Int = 0
  val global-roots = Vector<Int>()
  defn initialize-global-table () :
    val offset-counter = Counter(0)
    for p in vmpackages do :
      val pkgids = package-ids[package(p)]
      defn global-alignment (g:VMGlobal) :
        if size(g) >= 8 : 8
        else : size(g)
      val [padded-globals, _] = pad(global-alignment, size, globals(p), 8)      
      for g in padded-globals do :
        match(g) :
          (g:Padding) :
            next(offset-counter, size(g))
          (g:VMGlobal) :
            val offset = next(offset-counter, size(g))
            val gid = global-id(pkgids, id(g))
            global-props[gid] = GlobalProps(offset)
            for r in roots(g) do :
              fatal("Unaligned global reference") when offset % 8 != 0
              add(global-roots, offset / 8 + r)
      total-global-size = total-global-size + value(offset-counter)

  ;Constant pool
  val const-pool = ConstantPool()
  defn initialize-const-table () :    
    for p in vmpackages do :
      val pkgids = package-ids[package(p)]
      defn resolve-code-ids (v:VMValue) -> VMValue :
        defn to-global (x:CodeId) : CodeId(global-id(pkgids, id(x)))
        match(v) :
          (v:List) : map(resolve-code-ids, v)
          (v:VMTypeObject) : VMTypeObject(to-global(id(v)))
          (v:VMClosure) : VMClosure(to-global(id(v)))
          (v) : v              
      for c in consts(p) do :
        val v* = resolve-code-ids(value(c))
        val c* = intern(const-pool, value(c))
        val gid = global-id(pkgids, id(c))
        global-props[gid] = ConstProps(id(id(c*)))

  ;Class properties
  val class-tree = DynTree()
  defn initialize-class-props () :
    ;First compute tags for all core classes   
    defn assign-core-tag (id:TypeId, tag:Int) :
      val gid = id-indices[id]
      global-props[gid] = ClassProps(tag)
    assign-core-tag(CORE-FALSE-ID, FALSE-TYPE)
    assign-core-tag(CORE-TRUE-ID, TRUE-TYPE)
    assign-core-tag(CORE-BYTE-ID, BYTE-TYPE)
    assign-core-tag(CORE-CHAR-ID, CHAR-TYPE)
    assign-core-tag(CORE-INT-ID, INT-TYPE)
    assign-core-tag(CORE-FLOAT-ID, FLOAT-TYPE)
    assign-core-tag(CORE-STACK-ID, STACK-TYPE)
    assign-core-tag(CORE-FN-ID, FN-TYPE)
    assign-core-tag(CORE-TYPE-ID, TYPE-TYPE)
    assign-core-tag(CORE-LIVENESS-TRACKER-ID, LIVENESS-TRACKER-TYPE)
    
    ;Next compute tags and node states for all classes
    val tag-counter = to-seq(NUM-BUILTIN-TYPES to false)
    val node-states = Vector<NodeState>()
    for p in vmpackages do :
      val pkgids = package-ids[package(p)]
      defn gid (n:Int) : global-id(pkgids, n)
      for c in classes(p) do :
        ;Compute a tag if it doesn't already have one
        val cid = gid(id(c))
        if global-props[cid] is False :
          global-props[cid] = ClassProps(next(tag-counter))
        ;Compute a node state for the class tree
        match(c) :
          (c:VMArrayClass|VMLeafClass) :
            val parents* = map(gid,parents(c))
            add(node-states, SortedNodeState(cid, parents*, [], true))
          (c:VMAbstractClass) :
            val parents* = map(gid,parents(c))
            val children* = map(gid,children(c))
            add(node-states, SortedNodeState(cid, parents*, children*, false))

    ;Populate the class tree
    add(class-tree, node-states)        

  ;Initialize record tables
  initialize-record-tables()
  initialize-simple-props()
  initialize-global-table()
  initialize-const-table()
  initialize-class-props()

  ;Return new Stitcher
  new Stitcher
  
deftype GProps
defstruct CodeProps <: GProps :
  lbl:Int
defstruct ExternProps <: GProps :
  exlbl:Symbol
defstruct ExternDefnProps <: GProps :
  exlbl:Symbol
defstruct GlobalProps <: GProps :
  offset: Int
defstruct DataProps <: GProps :
  lbl:Int
defstruct ConstProps <: GProps :
  index:Int
defstruct ClassProps <: GProps :
  tag: Int