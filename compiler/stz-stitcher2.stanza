defpackage stz/stitcher :
  import core
  import collections
  import stz/asm-ir
  import stz/codegen
  import stz/dl-ir
  import stz/vm-ir
  import stz/utils
  import stz/padder
  import stz/const-pool
  import stz/dyn-tree
  import stz/trie
  import stz/typeset
  import stz/backend

;<DOC>=======================================================
;===================== Documentation ========================
;============================================================

Input:
  Functions compiled into ASM IR.  
Output:
  Pure ASM IR

Constructs that are removed:
  LocalMem
  TagImm
  StackMap
  LinkId
  Match
  Dispatch
  MethodDispatch
  TypeofOp

Labels are unique-ified so that we can compile multiple packages into
the same assembly file.

Removal strategies for each construct:
  TagImm:
    Becomes integer immediates.
    Requires each class to have an integer tag assigned to it.
    If it is a marker, then becomes (tag << 3) + marker-ref-bits.
    If it is not a marker, then becomes tag.
  StackMap:
    Becomes an integer immediate.
    Requires every unique stackmap to have an integer id assigned to it.
    Output the id.
  LinkId:
    The linkids can refer to one of the following:
      CodeId:
        Becomes a Mem immediate referencing the starting label of the function.
        Requires all functions to have a unique label assigned to it.
      ExternId:
        Becomes an ExMem immediate referencing the external label of the variable.
      ExternDefnId:
        Becomes an ExMem immediate referencing the external label of the function.
      DataId:
        Becomes a Mem immediate referencing the label of the data packet.
      GlobalId:
        Becomes a Mem immediate referencing the global constant pool table, with
        the appropriate offset. 
      ConstId:
        Becomes a Mem immediate referencing the global constant pool table, with
        the appropriate offset.
        Requires constants to be interned and assigned indices. 
  Match, Dispatch:
    Requires the class hierarchy to be indexed.
    Convert the branches into a trie and then emit the instructions
    for performing the branching.
  MethodDispatch:
    Requires the class hierarchy to be indexed.
    Requires the method branches for each multi to be collected.
    Convert the branches into a trie and then emit the instructions
    for performing the branching.
  TypeofOp :
    Requires the class hierarchy to be indexed.
    No trie is needed, just the list of concrete tags.

Implementation of Global Table:
  Input:
    Sequence of VMGlobals:
      defstruct VMGlobal :
        id: Int
        size: Int
        roots: Tuple<Int>
  Output:
    For each global:
      Compute an offset.
    Compute the reference mask.
    Compute the number of words in the mask.

Implementation of Constant Table:
  Input:
    Sequence of VMConst:
      defstruct VMConst :
        id: Int
        value: VMValue
  Output:
    The index of each interned VMConst.
    The Consts corresponding to each index, ready to be
    encoded as a table.

Implementation of Class Table:
  Goal:
    The objective of the class table is to help compile the
    match/dispatch statements. The key feature needed is the ability
    to convert a TypeSet into an ISet to perform the trie conversion.
  Therefore:
    Given a single typeid, within a package. Convert it to an ISet.
  Therefore:
    Given a single typeid, we need to resolve it to a global typeid.
  Therefore:
    Each global typeid needs a node in the class dynamic tree.
  Implementation:
    Sweep through every vmclass definition in each package, and if it
    is a concrete class, then assign its ClassProp property with its
    assigned tag.
    At the same time, for each vmclass definition, add a definition in
    the class dynamic tree using its global id (not its tag).
  Output:
    For each TypeSet, its ISet mapping to its global tags, because we
    need to distinguish marker objects from non-marker objects.

Implementation of Match/Dispatch instructions:
  Input:
    Match :
      xs: List<Imm>
      branches: List<Branch>
      no-branch: Int
    Branch :
      tags: List<TypeSet>
      n: Int
  Output:
    Emitted code for performing the dispatch.
  Assumptions:
    We can assume that the arguments have been placed in the appropriate
    registers and argument slots for the platform.
  Implementation:
    Requires conversion of a typeset to an ISet.
    This can be done using the DynTree implementation, once we
    have finished assigning class tags to all concrete classes.

;============================================================
;=======================================================<DOC>

;============================================================
;=================== StitcherEmitter ========================
;============================================================

public deftype Stitcher
public defmulti emit-tables (s:Stitcher, emitter:CodeEmitter) -> False
public defmulti emitter (s:Stitcher, package:Symbol, emitter:CodeEmitter) -> StitchEmitter

public deftype StitchEmitter <: CodeEmitter
public defmulti emit-label (e:StitchEmitter, id:Int) -> False

;============================================================
;=============== Create the Stitcher Tables =================
;============================================================

deftype PackageIds
defmulti global-id (ids:PackageIds, lid:Int) -> Int|False
defmulti set-global-id (ids:PackageIds, lid:Int, gid:Int) -> False

defn global-id! (ids:PackageIds, lid:Int) :
  match(global-id(ids,lid)) :
    (id:Int) : id
    (id:False) : fatal("No global id registered for local id: %_" % [lid])

public defn Stitcher (vmpackages:Seqable<VMPackage>, stubs:AsmStubs) :
  ;Records
  val global-props = Vector<GProps|False>()
  val id-indices = HashTable<RecId,Int>()
  val package-ids = HashTable<Symbol,PackageIds>()

  ;Add a new global record
  defn add-global-record (r:Rec) -> Int :
    val global-id = length(global-props)
    add(global-props, false)
    id-indices[id(r)] = global-id
    global-id

  ;Set the property of a given local id
  defn set-global-prop (pkgids:PackageIds, lid:Int, p:GProps) :
    match(global-id(pkgids, lid)) :
      (gid:Int) :
        global-props[gid] = p
      (_:False) :
        val gid = length(global-props)
        add(global-props, p)
        set-global-id(pkgids, lid, gid)

  ;Initialize record tables
  defn initialize-record-tables () :
    ;Accumulate initializers to run after we populate
    ;exported records.
    val initializers = Vector<(() -> ?)>()
    defn initialize (f:() -> ?) :
      add(initializers, f)      

    ;Initialize package ids
    for packageio in seq(packageio, vmpackages) do :
      val local-ids = IntTable<Int>()
      for e in exports(packageio) do :
        local-ids[n(e)] = add-global-record(rec(e))
      within initialize() :
        for i in imports(packageio) do :
          local-ids[n(i)] = id-indices[id(rec(i))]
      package-ids[package(packageio)] = new PackageIds :
        defmethod global-id (this, lid:Int) :
          get?(local-ids, lid)
        defmethod set-global-id (this, lid:Int, gid:Int) :
          local-ids[lid] = gid
        
    ;Run initializers
    for init in initializers do :
      init()

  ;Simple properties
  defn initialize-simple-props () :    
    for p in vmpackages do :
      val pkgids = package-ids[package(p)]
      for f in funcs(p) do :
        set-global-prop(pkgids, id(f), CodeProps(unique-id(stubs)))
      for e in extern-defns(p) do :
        set-global-prop(pkgids, fid(e), ExternDefnProps(lbl(e)))
      for e in externs(p) do :
        set-global-prop(pkgids, id(e), ExternProps(name(e)))
      for d in datas(p) do :
        set-global-prop(pkgids, id(d), DataProps(unique-id(stubs)))

  ;Global table
  var total-global-size:Int = 0
  val global-roots = Vector<Int>()
  defn initialize-global-table () :
    val offset-counter = Counter(0)
    for p in vmpackages do :
      val pkgids = package-ids[package(p)]
      defn global-alignment (g:VMGlobal) :
        if size(g) >= 8 : 8
        else : size(g)
      val [padded-globals, _] = pad(global-alignment, size, globals(p), 8)      
      for g in padded-globals do :
        match(g) :
          (g:Padding) :
            next(offset-counter, size(g))
          (g:VMGlobal) :
            val offset = next(offset-counter, size(g))
            set-global-prop(pkgids, id(g), GlobalProps(offset))
            for r in roots(g) do :
              fatal("Unaligned global reference") when offset % 8 != 0
              add(global-roots, offset / 8 + r)
      total-global-size = total-global-size + value(offset-counter)

  ;Constant pool
  val const-pool = ConstantPool()
  defn initialize-const-table () :    
    for p in vmpackages do :
      val pkgids = package-ids[package(p)]
      defn resolve-code-ids (v:VMValue) -> VMValue :
        defn to-global (x:CodeId) : CodeId(global-id!(pkgids, id(x)))
        match(v) :
          (v:List) : map(resolve-code-ids, v)
          (v:VMTypeObject) : VMTypeObject(to-global(id(v)))
          (v:VMClosure) : VMClosure(to-global(id(v)))
          (v) : v              
      for c in consts(p) do :
        val v* = resolve-code-ids(value(c))
        val c* = intern(const-pool, value(c))
        set-global-prop(pkgids, id(c), ConstProps(id(id(c*))))

  ;Class properties
  val class-tree = DynTree()
  val unique-children = IntSet()
  defn initialize-class-props () :
    ;First compute tags for all core classes   
    defn assign-core-tag (id:TypeId, tag:Int, has-fields?:True|False) :
      val gid = id-indices[id]
      global-props[gid] = ClassProps(tag, has-fields?)
    assign-core-tag(CORE-FALSE-ID, FALSE-TYPE, false)
    assign-core-tag(CORE-TRUE-ID, TRUE-TYPE, false)
    assign-core-tag(CORE-BYTE-ID, BYTE-TYPE, true)
    assign-core-tag(CORE-CHAR-ID, CHAR-TYPE, true)
    assign-core-tag(CORE-INT-ID, INT-TYPE, true)
    assign-core-tag(CORE-FLOAT-ID, FLOAT-TYPE, true)
    assign-core-tag(CORE-STACK-ID, STACK-TYPE, true)
    assign-core-tag(CORE-FN-ID, FN-TYPE, true)
    assign-core-tag(CORE-TYPE-ID, TYPE-TYPE, true)
    assign-core-tag(CORE-LIVENESS-TRACKER-ID, LIVENESS-TRACKER-TYPE, true)
    
    ;Next compute tags and node states for all classes
    val tag-counter = to-seq(NUM-BUILTIN-TYPES to false)
    val node-states = Vector<NodeState>()
    for p in vmpackages do :
      val pkgids = package-ids[package(p)]
      for c in classes(p) do :
        ;Compute a tag if it doesn't already have one
        val has-tag? = 
          match(global-id(pkgids,id(c))) :
            (gid:Int) : global-props[gid] is-not False
            (gid:False) : false
        if not has-tag? :
          val has-fields? = match(c) :
            (c:VMArrayClass) : true
            (c:VMLeafClass) : size(c) > 0
            (c:VMAbstractClass) : false
          set-global-prop(pkgids, id(c), ClassProps(next(tag-counter), has-fields?))
        ;Compute a node state for the class tree
        defn gid (n:Int) : global-id!(pkgids,n)
        match(c) :
          (c:VMArrayClass|VMLeafClass) :
            val parents* = map(gid,parents(c))
            add(node-states, SortedNodeState(gid(id(c)), parents*, [], true))
          (c:VMAbstractClass) :
            val parents* = map(gid,parents(c))
            val children* = map(gid,children(c))
            add(node-states, SortedNodeState(gid(id(c)), parents*, children*, false))

    ;Populate the class tree
    add(class-tree, node-states)
    
    ;Compute all the children of Unique
    val unique-id = id-indices[CORE-UNIQUE-ID]
    add-all(unique-children, all-children(class-tree, unique-id))

  ;Create stackmap table
  val stackmap-table = HashTable<?,Int>()
  defn stackmap-index (m:StackMap) :
    0

  ;Accumulate info table
  defn add-info-table (n:Int, info:FileInfo) :
    false

  ;Create a function-local emitter
  defn emitter (package:Symbol, code-emitter:CodeEmitter) :
    val pkgids = package-ids[package]
    val label-table = IntTable-init<Int>(unique-id{stubs})

    ;Link an immediate, remove all non-handled items.
    defn link (x:Imm) :
      match(x) :
        (x:LocalMem) :
          Mem(label-table[n(x)],0)
        (x:TagImm) : 
          tag-imm(global-id!(pkgids, n(x)), marker?(x))
        (x:StackMap) :
          IntImm(stackmap-index(x))
        (x:LinkId) :
          val gid = global-id!(pkgids, id(x))
          match(global-props[gid]) :
            (p:CodeProps) :
              Mem(lbl(p), 0)
            (p:ExternProps) :
              ExMem(exlbl(p), 0)
            (p:ExternDefnProps) :
              ExMem(exlbl(p), 0)
            (p:DataProps) :
              Mem(lbl(p), 0)
            (p:ConstProps) :
              Mem(const-table(stubs), index(p) * 8)
            (p:GlobalProps) :
              Mem(globals(stubs), offset(p))
        (x) :
          x

    ;Return the numerical tag for the given global id
    defn tag-imm (gid:Int, marker?:True|False) :
      val props = global-props[gid] as ClassProps
      if marker? : INT(tag(props) << 3 + 2)
      else : INT(tag(props))

    ;Resolve a typeset from package ids to global ids
    defn resolve (t:TypeSet) :
      let loop (t:TypeSet = t) :
        match(t) :
          (t:TopType) : t
          (t:AndType) : AndType?(seq(loop,types(t)))
          (t:OrType) : OrType?(seq(loop,types(t)))
          (t:SingleType) : SingleType(global-id!(pkgids,type(t)))

    ;Convert a typeset into an ISet for the trie
    defn to-iset (t:TypeSet) :
      defn union (a:ISet, b:ISet) :
        a-or-b(compare(a,b))
      defn intersection (a:ISet, b:ISet) :
        a-and-b(compare(a,b))
      match(t) :
        (t:TopType) :
          IAll()
        (t:AndType) :
          reduce(intersection, seq(to-iset, types(t)))
        (t:OrType) :
          reduce(union, seq(to-iset, types(t)))
        (t:SingleType) :
          ISubset(all-children(class-tree, type(t)))

    ;Convert an asm branch into an ibranch
    defn to-ibranch (b:Branch) :
      val sets = for t in tags(b) map :
        to-iset(resolve(t))
      IBranch(sets, dst(b))      

    ;Emit code for producing trie (args is a helper)
    defn emit-trie (t:IfTrie, default:Imm, args:List<Imm>) :
      ;Is the given type a marker?
      ;Is it both empty, and not a subtype of Unique?
      defn marker? (x:Int) :
        val props = global-props[x] as ClassProps
        if has-fields?(props) : false
        else : not unique-children[x]

      ;Calculate targets of all branches
      val targets = for entry in branches(t) map :
        match(value(entry)) :
          (v:IfTrie) : M(unique-id(stubs))
          (v:EndTrie) : target(v) as Imm

      ;Categorize branches
      val prim-targets = Vector<KeyValue<Int,Imm>>()
      val marker-targets = Vector<KeyValue<Int,Imm>>()
      val ref-targets = Vector<KeyValue<Int,Imm>>()
      var default-target = default
      for (entry in branches(t), target in targets) do :
        match(key(entry)) :
          (iset:ISubset) :
            for x in xs(iset) do :
              if x == id-indices[CORE-BYTE-ID] : add(prim-targets, x => target)
              else if x == id-indices[CORE-CHAR-ID] : add(prim-targets, x => target)
              else if x == id-indices[CORE-INT-ID] : add(prim-targets, x => target)
              else if x == id-indices[CORE-FLOAT-ID] : add(prim-targets, x => target)
              else if marker?(x) : add(marker-targets, x => target)
              else : add(ref-targets, x => target)              
          (iset:IAll) :
            default-target = target

      ;Registers
      val OBJ = R0
      val BITS = R1
      val TAG = R1

      ;Load object
      val object = match(head(args)) :
        (a:Reg) :
          a
        (a:Mem) :
          E $ LoadL(OBJ, a)
          OBJ

      ;Test bits
      val marker-branches = unique-id(stubs)
      val ref-branches = unique-id(stubs)
      E $ AndL(BITS, object, INT(7))      
      for entry in prim-targets do :
        val x = key(entry)
        val target = value(entry)
        val tagbits =
          if x == id-indices[CORE-BYTE-ID] : INT(3)
          else if x == id-indices[CORE-CHAR-ID] : INT(4)
          else if x == id-indices[CORE-INT-ID] : INT(0)
          else if x == id-indices[CORE-FLOAT-ID] : INT(5)
          else : fatal("Not a primitive type")
        E $ BreakL(target, EqOp(), BITS, tagbits)
      E $ BreakL(M(marker-branches), EqOp(), BITS, INT(2))
      E $ BreakL(M(ref-branches), EqOp(), BITS, INT(1))
      E $ Goto(default-target)

      ;Marker branches
      E $ Label(marker-branches)
      for entry in marker-targets do :
        val x = key(entry)
        val target = value(entry)
        E $ BreakL(target, EqOp(), object, tag-imm(x,true))
      E $ Goto(default-target)

      ;Ref branches
      E $ Label(ref-branches)
      E $ LoadL(TAG, object, -1)
      for entry in ref-targets do :
        val x = key(entry)
        val target = value(entry)
        E $ BreakL(target, EqOp(), TAG, tag-imm(x, false))
      E $ Goto(default-target)

      ;Further tries
      for (entry in branches(t), target in targets) do :
        val trie = value(entry)
        match(trie:IfTrie) :
          E $ Label(n(target as LocalMem))
          emit-trie(trie, default, tail(args))

    ;Retrieve the arguments to a trie for a match/dispatch statement
    defn trie-args (t:MTrie, xs:List<Imm>) :
      val reg-args = xs as List<Reg>
      val mem-args = seq(Mem{registers(stubs), _}, 0 to false by 8)
      val all-args = cat(reg-args, mem-args)
      to-list(take-n(depth(t), all-args))      

    ;Retrieve the arguments to a trie from a method-dispatch statement
    defn trie-method-args (t:MTrie, num-header-args:Int) :
      val reg-args = seq(R, tailn(call-regs(backend(stubs)), num-header-args))
      val mem-args = seq(Mem{registers(stubs), _}, 0 to false by 8)
      val all-args = cat(reg-args, mem-args)
      to-list(take-n(depth(t), all-args))      

    ;Emit code for producing typeof
    defn emit-typeof (x:Loc, y:Imm, type:TypeSet) :
      false

    ;Return new code emitter
    defn E (i:Ins) : emit(code-emitter, i)      
    new StitchEmitter :
      defmethod emit-label (this, id:Int) :
        val gid = global-id!(pkgids, id)
        match(global-props[gid]) :
          (p:CodeProps) : E $ Label(lbl(p))
          (p:ExternDefnProps) : E $ ExLabel(exlbl(p))
      defmethod emit (this, i:Ins) :
        match(map(link,i)) :
          (i:Label) :
            val n* = label-table[n(i)]
            E $ Label(n*)
            match(info(i)) :
              (info:FileInfo) : add-info-table(n*, info)
              (info:False) : false
          (i:Match) :
            val trie = to-trie(seq(to-ibranch, branches(i)))
            emit-trie(trie, no-branch(i), trie-args(trie,xs(i)))
          (i:Dispatch) :
            false
          (i:MethodDispatch) :
            false
          (i:UnaOp) :
            match(op(i)) :
              (op:TypeofOp) : emit-typeof(x(i), y(i), tag(op))
              (op) : E(i)
          (i) : E(i)    

  ;Initialization function
  defn emit-initialization-function (code-emitter:CodeEmitter) :
    defn E (i:Ins) : emit(code-emitter, i)
    val frame-size = 16
    val stackmap = stackmap-index(StackMap(frame-size, []))
    E $ Label(init-function(stubs))
    E $ StoreL(RSP, INT(stackmap), 8)    
    for p in vmpackages do :
      val pkgids = package-ids[package(p)]
      val init = init(p)
      match(init:Int) :
        E $ AddL(RSP, RSP, INT(frame-size + 8))
        val gid = global-id!(pkgids, init)
        val code-id = lbl(global-props[gid] as CodeProps)
        E $ Call(M(code-id))
        E $ SubL(RSP, RSP, INT(frame-size + 8))
    E $ SetL(R0, INT(0))
    E $ Return()

  ;Emit global table
  defn emit-global-table (code-emitter:CodeEmitter) :
    defn E (i:Ins) : emit(code-emitter, i)
    E $ DefData()
    E $ Label(globals(stubs))
    E $ DefLong(0L)
    E $ DefText()

  ;Emit constant table
  defn emit-const-table (code-emitter:CodeEmitter) :
    defn E (i:Ins) : emit(code-emitter, i)
    E $ DefData()
    E $ Label(const-table(stubs))
    E $ DefLong(0L)
    E $ DefText()    

  ;Emit data table
  defn emit-data-table (code-emitter:CodeEmitter) :
    defn E (i:Ins) : emit(code-emitter, i)      
    for p in vmpackages do :
      val pkgids = package-ids[package(p)]
      for d in datas(p) do :
        val props = global-props[global-id!(pkgids, id(d))] as DataProps
        E $ DefData()
        E $ Label(lbl(props))
        E $ DefBytes(data(d))
        E $ DefText()

  ;Initialize record tables
  initialize-record-tables()
  initialize-simple-props()
  initialize-global-table()
  initialize-const-table()
  initialize-class-props()

  ;Return new Stitcher
  new Stitcher :
    defmethod emitter (this, package:Symbol, code-emitter:CodeEmitter) :
      emitter(package, code-emitter)
    defmethod emit-tables (this, code-emitter:CodeEmitter) :
      emit-initialization-function(code-emitter)
      emit-global-table(code-emitter)
      emit-const-table(code-emitter)
      emit-data-table(code-emitter)
  
deftype GProps
defstruct CodeProps <: GProps :
  lbl:Int
defstruct ExternProps <: GProps :
  exlbl:Symbol
defstruct ExternDefnProps <: GProps :
  exlbl:Symbol
defstruct GlobalProps <: GProps :
  offset: Int
defstruct DataProps <: GProps :
  lbl:Int
defstruct ConstProps <: GProps :
  index:Int
defstruct ClassProps <: GProps :
  tag: Int
  has-fields?: True|False