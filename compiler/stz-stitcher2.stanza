defpackage stz/stitcher :
  import core
  import collections
  import stz/asm-ir
  import stz/codegen
  import stz/dl-ir

;<DOC>=======================================================
;===================== Documentation ========================
;============================================================

Input:
  Functions compiled into ASM IR.  
Output:
  Pure ASM IR

Constructs that are removed:
  TagImm
  StackMap
  LinkId
  Match
  Dispatch
  MethodDispatch

Removal strategies for each construct:
  TagImm:
    Becomes integer immediates.
    Requires each class to have an integer tag assigned to it.
    If it is a marker, then becomes (tag << 3) + marker-ref-bits.
    If it is not a marker, then becomes tag.
  StackMap:
    Becomes an integer immediate.
    Requires every unique stackmap to have an integer id assigned to it.
    Output the id.
  LinkId:
    The linkids can refer to one of the following:
      CodeId:
        Becomes a Mem immediate referencing the starting label of the function.
        Requires all functions to have a unique label assigned to it.
      ExternId:
        Becomes an ExMem immediate referencing the external label of the variable.
      ExternDefnId:
        Becomes an ExMem immediate referencing the external label of the function.
      DataId:
        Becomes a Mem immediate referencing the label of the data packet.
      GlobalId:
        Becomes a Mem immediate referencing the global constant pool table, with
        the appropriate offset. 
      ConstId:
        Becomes a Mem immediate referencing the global constant pool table, with
        the appropriate offset.
        Requires constants to be interned and assigned indices. 
  Match, Dispatch:
    Requires the class hierarchy to be indexed.
    Convert the branches into a trie and then emit the instructions
    for performing the branching.
  MethodDispatch:
    Requires the class hierarchy to be indexed.
    Requires the method branches for each multi to be collected.
    Convert the branches into a trie and then emit the instructions
    for performing the branching.

;============================================================
;=======================================================<DOC>

;============================================================
;=================== StitcherEmitter ========================
;============================================================

public deftype Stitcher
public defmulti emit-tables (s:Stitcher, emitter:CodeEmitter) -> False
public defmulti emitter (s:Stitcher, package:Symbol, emitter:CodeEmitter) -> CodeEmitter

;============================================================
;=============== Create the Stitcher Tables =================
;============================================================

deftype PackageIds
defmulti resolve (ids:PackageIds) -> Imm

public defn Stitcher (packageios:Seqable<PackageIO>, stubs:AsmStubs) :
  ;Global records
  val global-records = Vector<Rec>()
  val id-indices = HashTable<RecId,Int>()
  val package-ids = HashTable<Symbol,PackageIds>()

  ;Add a new global record
  defn add-global-record (r:Rec) -> Int :
    add(global-records, r)
    val global-id = length(global-records)
    id-indices[id(r)] = global-id
    global-id

  ;Retrieve the global id for a given RecId
  defn get-global-id (id:RecId) :
    id-indices[id]

  ;Initialize record tables
  defn initialize-record-tables () :
    ;Accumulate initializers to run after we populate
    ;exported records.
    val initializers = Vector<(() -> ?)>()
    defn initialize (f:() -> ?) :
      add(initializers, f)      

    ;Initialize package ids
    for packageio in packageios do :
      val local-ids = IntTable<Int>()
      for e in exports(packageio) do :
        local-ids[n(e)] = add-global-record(rec(e))
      within initialize() :
        for i in imports(packageio) do :
          local-ids[n(i)] = get-global-id(id(rec(i)))    
      package-ids[package(packageio)] = new PackageIds
        
    ;Run initializers
    for init in initializers do :
      init()

  defn initialize-global-table () :
    println("Compute global indices and offsets")

  defn initialize-const-table () :
    println("Intern and compute const indices")

  ;Initialize record tables
  initialize-record-tables()
  initialize-global-table()
  initialize-const-table()

  ;Return new Stitcher
  new Stitcher
  
