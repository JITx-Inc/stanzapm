;See License.txt for details about licensing.

defpackage stz/codegen :
  import core
  import collections
  import stz/asm-ir
  import stz/backend

;============================================================
;===================== Code Emitter =========================
;============================================================

public deftype CodeEmitter
public defmulti emit (e:CodeEmitter, i:Ins) -> False

;============================================================
;======================= Stubs ==============================
;============================================================

public defstruct AsmStubs :
  backend: Backend
  vmstate:Int
  const-table:Int
  globals:Int
  stack-pointer:Int
  stack-limit:Int
  registers:Int
  sys-registers:Int
  heap:Int
  heap-top:Int
  heap-limit:Int
  free:Int
  free-limit:Int
  current-stack:Int
  saved-c-rsp:Int
  swap-lbl:Int
  extend-stack:Int
  extend-heap:Int
  saved-c-regs:Tuple<Int>
  id-counter:Seq<Int>

public defn AsmStubs (backend:Backend) :
  val id-counter = to-seq(0 to false)
  val c-preserved = to-tuple $
    for i in c-preserved-regs(backend) seq :
      next(id-counter)
  AsmStubs(
    backend
    next(id-counter)  ;vmstate:Int
    next(id-counter)  ;const-table:Int
    next(id-counter)  ;globals:Int
    next(id-counter)  ;stack-pointer:Int
    next(id-counter)  ;stack-limit:Int
    next(id-counter)  ;registers:Int
    next(id-counter)  ;sys-registers:Int
    next(id-counter)  ;heap:Int
    next(id-counter)  ;heap-top:Int
    next(id-counter)  ;heap-limit:Int
    next(id-counter)  ;free:Int
    next(id-counter)  ;free-limit:Int
    next(id-counter)  ;current-stack:Int
    next(id-counter)  ;saved-c-rsp:Int
    next(id-counter)  ;swap-lbl:Int
    next(id-counter)  ;extend-stack:Int
    next(id-counter)  ;extend-heap:Int
    c-preserved
    id-counter)

public defn unique-id (s:AsmStubs) :
  next(id-counter(s))

;============================================================
;=================== Assembly Stubs =========================
;============================================================

public defn compile-entry-function (emitter:CodeEmitter, stubs:AsmStubs) :
  val backend = backend(stubs)
  val aregs = callc-regs(backend)
  val A0 = R(aregs[0])
  val TMP = R(aregs[1])
  defn E (i:Ins) : emit(emitter, i)

  ;Save the C context
  ;Save the VMInit packet to the machine state
  ;Set the new stack
  ;Run the initialization function
  ;Restore the C context
  val initialization-function = unique-id(stubs)
  
  ;Emit labels for holding the C state
  defn make-long-storage (n:Int) :
    E $ Label(n)
    E $ DefLong(0L)
  E $ DefData()
  make-long-storage(saved-c-rsp(stubs))
  do(make-long-storage, saved-c-regs(stubs))
  E $ DefText()

  ;Temporary storage locations
  E $ DefData()
  make-long-storage(swap-lbl(stubs))
  make-long-storage(stack-limit(stubs))
  make-long-storage(stack-pointer(stubs))
  E $ DefText()

  ;Emit labels for holding the VM state
  let :
    defn #long () :
      E $ DefLong(0L)
    defn #long (n:Int) :
      E $ Label(n)
      E $ DefLong(0L)
    defn #int () :
      E $ DefInt(0)
    defn #label (n:Int) :
      E $ DefLabel(n)
    defn #space (n:Int, sz:Int) :
      E $ Label(n)
      E $ DefSpace(sz)
      
    E $ DefData()
    #label(vmstate(stubs))
    #long()                       ;instructions: ptr<byte>
    #label(registers(stubs))      ;registers: ptr<long>
    #long()                       ;global-offsets: ptr<long>
    #long()                       ;global-mem: ptr<byte>
    #long()                       ;const-table: ptr<long>
    #long()                       ;const-mem: ptr<byte>
    #long()                       ;data-offsets: ptr<int>
    #long()                       ;data-mem: ptr<byte>
    #long()                       ;extern-addresses: ptr<long>
    #long()                       ;extern-defn-addresses: ptr<long>
    #long()                       ;code-offsets: ptr<int>
    #int()                        ;extend-heap-id: int
    #int()                        ;extend-stack-id: int
    #long(heap(stubs))            ;heap: ptr<long>      
    #long(heap-top(stubs))        ;heap-top: ptr<long>  
    #long(heap-limit(stubs))      ;heap-limit: ptr<long>
    #long(free(stubs))            ;free: ptr<long>      
    #long(free-limit(stubs))      ;free-limit: ptr<long>
    #long(current-stack(stubs))   ;current-stack: long
    #long()                       ;system-stack: long
    #label(sys-registers(stubs))  ;system-registers: ptr<long>
    #space(registers(stubs), 8 * 256)     ;space for registers
    #space(sys-registers(stubs), 8 * 256) ;space for system registers
    E $ DefText()

  ;Start of entry function
  E $ ExLabel(`stanza_entry)

  ;Save the C Context
  E $ StoreL(M(saved-c-rsp(stubs)), RSP)
  for (i in c-preserved-regs(backend),
       n in saved-c-regs(stubs)) do :
    E $ StoreL(M(n), R(i))

  ;Save the entry packet to the machine state
  let :
    defn save (i:Int, n:AsmStubs -> Int) :
      E $ LoadL(TMP, A0, i * 8)
      E $ StoreL(M(n(stubs)), TMP)
    save(0, heap)
    save(1, heap-top)
    save(2, heap-limit)
    save(3, free)
    save(4, free-limit)
    save(5, current-stack)

  ;Load the stack pointer
  val frames-offset = 8 + 8 - 1
  val stanza-return = unique-id(stubs)
  E $ LoadL(TMP, A0, 5 * 8)
  E $ LoadL(RSP, TMP, frames-offset)
  E $ SetL(TMP, M(stanza-return))
  E $ StoreL(RSP, TMP)
  E $ Goto(M(initialization-function))
  E $ Label(stanza-return)

  ;Restore the C Context
  E $ LoadL(RSP, M(saved-c-rsp(stubs)))
  for (i in c-preserved-regs(backend),
       n in saved-c-regs(stubs)) do :
    E $ LoadL(R(i), M(n))

  ;Return 0 for successful completion
  E $ SetL(R0, INT(0))
  E $ Return()

  ;Dummy initialization-function
  E $ Label(initialization-function)
  E $ Return()  

;============================================================
;==================== Assembly Shorthands ===================
;============================================================

;==============================
;==== Assembly Equivalents ====
;==============================
public defn R (n:Int) : Reg(n)
public defn F (n:Int) : FReg(n)
public defn M (n:Int) : Mem(n,0)
public defn LM (n:Int) : LocalMem(n)
public defn INT (v:Byte|Int|Long) : IntImm(v)
public val BT = ByteT()
public val IT = IntT()
public val LT = LongT()
public val FT = FloatT()
public val DT = DoubleT()

public val R0 = R(0)
public val R1 = R(1)
public val R2 = R(2)
public val R3 = R(3)
public val R4 = R(4)
public val R5 = R(5)
public val R6 = R(6)
public val RSP = RegSP()

public defn SetL (x:Loc, y:Imm) : SetIns(LT, x, y)
public defn SetD (x:Loc, y:Imm) : SetIns(DT, x, y)
public defn StoreL (x:Imm, y:Imm) : Store(LT, x, y, 0)
public defn LoadL (x:Loc, y:Imm) : Load(LT, x, y, 0)
public defn StoreL (x:Imm, y:Imm, o:Int) : Store(LT, x, y, o)
public defn LoadL (x:Loc, y:Imm, o:Int) : Load(LT, x, y, o)
public defn AddL (x:Loc, y:Imm, z:Imm) : BinOp(LT, x, AddOp(), y, z)
public defn SubL (x:Loc, y:Imm, z:Imm) : BinOp(LT, x, SubOp(), y, z)
public defn BreakL (x:Imm, op:Op, y:Imm, z:Imm) : Break(LT, x, op, y, z)