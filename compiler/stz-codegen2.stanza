;See License.txt for details about licensing.

;<doc>=======================================================
;==================== Documentation =========================
;============================================================

Extend Heap Stub:
  Input:
    R0 is return address.
    R2 is size to extend by.
    RSP still points to caller's stack frame.
  Responsibilities:
    Save the current stack, with return address.
    Switch to using the system stack.
    Set the arguments.
    Call extend-heap.
    Null the system stack pointer.
    Restore the program stack.
    Restore the stack state.
    Continue from stack.pc.

;============================================================
;=======================================================<doc>


defpackage stz/codegen :
  import core
  import collections
  import stz/asm-ir
  import stz/backend
  import stz/utils

;============================================================
;===================== Code Emitter =========================
;============================================================

public deftype CodeEmitter
public defmulti emit (e:CodeEmitter, i:Ins) -> False

;============================================================
;======================= Stubs ==============================
;============================================================

public defstruct AsmStubs :
  backend: Backend
  vmstate:Int
  current-registers:Int
  system-registers:Int  
  init-function:Int
  const-table:Int
  globals:Int
  stack-pointer:Int
  stack-limit:Int
  registers:Int
  system-registers-space:Int
  heap:Int
  heap-top:Int
  heap-limit:Int
  free:Int
  free-limit:Int
  current-stack:Int
  system-stack:Int
  saved-c-rsp:Int
  swap-lbl:Int
  extend-stack:Int
  extend-heap:Int
  saved-c-regs:Tuple<Int>
  saved-regs:Tuple<Int>
  saved-fregs:Tuple<Int>
  id-counter:Seq<Int>

public defn AsmStubs (backend:Backend) :
  val id-counter = to-seq(0 to false)
  val c-preserved = to-tuple $
    for i in c-preserved-regs(backend) seq :
      next(id-counter)
  val saved-regs = to-tuple $
    for i in call-regs(backend) seq :
      next(id-counter)
  val saved-fregs = to-tuple $
    for i in call-fregs(backend) seq :
      next(id-counter)
  AsmStubs(
    backend
    next(id-counter)  ;vmstate:Int
    next(id-counter)  ;current-registers:Int
    next(id-counter)  ;system-registers:Int  
    next(id-counter)  ;init-function:Int
    next(id-counter)  ;const-table:Int
    next(id-counter)  ;globals:Int
    next(id-counter)  ;stack-pointer:Int
    next(id-counter)  ;stack-limit:Int
    next(id-counter)  ;registers:Int  
    next(id-counter)  ;system-registers-space:Int
    next(id-counter)  ;heap:Int
    next(id-counter)  ;heap-top:Int
    next(id-counter)  ;heap-limit:Int
    next(id-counter)  ;free:Int
    next(id-counter)  ;free-limit:Int
    next(id-counter)  ;current-stack:Int
    next(id-counter)  ;system-stack:Int
    next(id-counter)  ;saved-c-rsp:Int
    next(id-counter)  ;swap-lbl:Int
    next(id-counter)  ;extend-stack:Int
    next(id-counter)  ;extend-heap:Int
    c-preserved       ;saved-c-regs:Tuple<Int>
    saved-regs        ;saved-regs:Tuple<Int>
    saved-fregs       ;saved-fregs:Tuple<Int>
    id-counter)

public defn unique-id (s:AsmStubs) :
  next(id-counter(s))

;============================================================
;=================== Assembly Stubs =========================
;============================================================

public defn compile-runtime-stubs (emitter:CodeEmitter, stubs:AsmStubs) :
  println("//Stubs:")
  println("//vmstate = %_" % [vmstate(stubs)])
  println("//const-table = %_" % [const-table(stubs)])
  println("//globals = %_" % [globals(stubs)])
  println("//stack-pointer = %_" % [stack-pointer(stubs)])
  println("//stack-limit = %_" % [stack-limit(stubs)])
  println("//registers = %_" % [registers(stubs)])
  println("//system-registers-space = %_" % [system-registers-space(stubs)])
  println("//heap = %_" % [heap(stubs)])
  println("//heap-top = %_" % [heap-top(stubs)])
  println("//heap-limit = %_" % [heap-limit(stubs)])
  println("//free = %_" % [free(stubs)])
  println("//free-limit = %_" % [free-limit(stubs)])
  println("//current-stack = %_" % [current-stack(stubs)])
  println("//saved-c-rsp = %_" % [saved-c-rsp(stubs)])
  println("//swap-lbl = %_" % [swap-lbl(stubs)])
  println("//extend-stack = %_" % [extend-stack(stubs)])
  println("//extend-heap = %_" % [extend-heap(stubs)])
  println("//saved-c-regs = %_" % [saved-c-regs(stubs)])

  compile-entry-function(emitter, stubs)
  compile-extend-heap-stub(emitter, stubs)
  compile-extend-stack-stub(emitter, stubs)

public defn compile-entry-function (emitter:CodeEmitter, stubs:AsmStubs) :
  val backend = backend(stubs)
  val aregs = callc-regs(backend)
  val A0 = R(aregs[0])
  val TMP = R(aregs[1])
  defn E (i:Ins) : emit(emitter, i)

  ;Save the C context
  ;Save the VMInit packet to the machine state
  ;Set the new stack
  ;Run the initialization function
  ;Restore the C context
  
  ;Emit labels for holding the register state
  defn make-long-storage (n:Int) :
    E $ Label(n)
    E $ DefLong(0L)
  E $ DefData()
  make-long-storage(saved-c-rsp(stubs))
  do(make-long-storage, saved-c-regs(stubs))
  do(make-long-storage, saved-regs(stubs))
  do(make-long-storage, saved-fregs(stubs))
  E $ DefText()

  ;Temporary storage locations
  E $ DefData()
  make-long-storage(swap-lbl(stubs))
  make-long-storage(stack-limit(stubs))
  make-long-storage(stack-pointer(stubs))
  E $ DefText()

  ;Emit labels for holding the VM state
  let :
    defn #label (n:Int) :
      E $ Label(n)
    defn #long () :
      E $ DefLong(0L)
    defn #long (n:Int) :
      E $ Label(n)
      E $ DefLong(0L)
    defn #int () :
      E $ DefInt(0)
    defn #deflabel (n:Int) :
      E $ DefLabel(n)
    defn #space (n:Int, sz:Int) :
      E $ Label(n)
      E $ DefSpace(sz)
      
    E $ DefData()
    #label(vmstate(stubs))
      #long()                                         ;instructions: ptr<byte>
    #label(current-registers(stubs))
      #deflabel(registers(stubs))                     ;registers: ptr<long>
      #long()                                         ;global-offsets: ptr<long>
      #long()                                         ;global-mem: ptr<byte>
      #long()                                         ;const-table: ptr<long>
      #long()                                         ;const-mem: ptr<byte>
      #long()                                         ;data-offsets: ptr<int>
      #long()                                         ;data-mem: ptr<byte>
      #long()                                         ;extern-addresses: ptr<long>
      #long()                                         ;extern-defn-addresses: ptr<long>
      #long()                                         ;code-offsets: ptr<int>
      #int()                                          ;extend-heap-id: int
      #int()                                          ;extend-stack-id: int
      #long(heap(stubs))                              ;heap: ptr<long>      
      #long(heap-top(stubs))                          ;heap-top: ptr<long>  
      #long(heap-limit(stubs))                        ;heap-limit: ptr<long>
      #long(free(stubs))                              ;free: ptr<long>      
      #long(free-limit(stubs))                        ;free-limit: ptr<long>
      #long(current-stack(stubs))                     ;current-stack: long
      #long(system-stack(stubs))                      ;system-stack: long
    #label(system-registers(stubs))
      #deflabel(system-registers-space(stubs))        ;system-registers: ptr<long>
      #space(registers(stubs), 8 * 256)               ;space for registers
      #space(system-registers-space(stubs), 8 * 256)  ;space for system registers
    E $ DefText()

  ;Start of entry function
  E $ ExLabel(`stanza_entry)

  ;Save the C Context
  E $ StoreL(M(saved-c-rsp(stubs)), RSP)
  for (i in c-preserved-regs(backend),
       n in saved-c-regs(stubs)) do :
    E $ StoreL(M(n), R(i))

  ;Save the entry packet to the machine state
  let :
    defn save (i:Int, n:AsmStubs -> Int) :
      E $ LoadL(TMP, A0, i * 8)
      E $ StoreL(M(n(stubs)), TMP)
    save(0, heap)
    save(1, heap-top)
    save(2, heap-limit)
    save(3, free)
    save(4, free-limit)
    save(5, current-stack)

  ;Load the stack pointer
  val frames-offset = 8 + 8 - 1
  val stanza-return = unique-id(stubs)
  E $ LoadL(TMP, A0, 5 * 8)
  E $ LoadL(RSP, TMP, frames-offset)

  ;Set stack limit
  val size-offset = 0 + 8 - 1
  E $ LoadL(TMP, TMP, size-offset)
  E $ AddL(TMP, TMP, RSP)
  E $ StoreL(M(stack-limit(stubs)), TMP)

  ;Call the initialization function
  E $ AddL(RSP, RSP, INT(8))
  E $ Call(M(init-function(stubs)))
  E $ SubL(RSP, RSP, INT(8))

  ;Restore the C Context
  E $ LoadL(RSP, M(saved-c-rsp(stubs)))
  for (i in c-preserved-regs(backend),
       n in saved-c-regs(stubs)) do :
    E $ LoadL(R(i), M(n))

  ;Return
  E $ Return()

public defn compile-extend-heap-stub (emitter:CodeEmitter, stubs:AsmStubs) :
  val backend = backend(stubs)
  defn E (i:Ins) : emit(emitter, i)

  E $ Label(extend-heap(stubs))
  E $ Return()

;<doc>=======================================================
;==================== Stack Extension =======================
;============================================================

Extend Stack Stub:
  Input:
    R0 is return address.
    R1 is required stack size: (must satisfy: RSP + R1 <= stack-limit)
    RSP still points to caller's stack frame.
  Responsibilities:
    Save the current registers.
    Save the current stack parameters.
      (Save RSP)
      (Save return address)
    Compute the desired size
      (size = RSP + R1 - stack-limit)
    Switch to using the system stack.
      (Swap current stack with system stack)
      (Swap registers with system registers)
    Load the system stack parameters
      (Load RSP)
      (Load stack-limit)
    Call extend-stack:
      (argument 0 (unused) = ---)
      (argument 1 (arity) = 1)
      (argument 2 (size) = size)
      (call)
    Switch back to using the program stack.
      (Null the system stack pointer)
      (Swap current stack with system stack)
      (Swap registers with system registers)
    Restore current registers.
    Continue from stack.pc.

  Pseudocode:
    save R2 ... Rn
    
    current-stack.pc = return address (R0)
    current-stack.sp = RSP
      (use TMP:R2 for current-stack)
      TMP = [current-stack]
      TMP.pc = R0
      TMP.sp = RSP

    size = RSP + R1 - stack-limit
      (use TMP:R2 for stack-limit)
      (use size:R4)
      R4 = RSP + R1
      TMP = [stack-limit]
      R4 -= TMP

    swap [current-stack] with [system-stack]
      (use TMP:R2)
      (use TMP2:R3)
      TMP = [current-stack]
      TMP2 = [system-stack]
      [current-stack] = TMP2
      [system-stack] = TMP

    swap [registers] with [system_registers]
      (use TMP:R2)
      (use TMP2:R3)
      TMP = [registers]
      TMP2 = [system-registers]
      [registers] = TMP
      [system-registers] = TMP2

    RSP = current-stack.frames
    stack-limit = current-stack.frames + current-stack.size
      (use TMP:R2)
      (use TMP2:R3)
      TMP = [current-stack]
      RSP = TMP.frames
      TMP2 = TMP.size
      TMP2 += RSP
      [stack-limit] = TMP2
    
    R3 = 1
    R4 = size (Elided: Already set)
    
    RSP += 8
    call extend-stack
    (RSP -= 8) (Elided: Not used again)
    
    current-stack.stack-pointer = null
      (use TMP:R2)
      TMP = [current-stack]
      TMP.stack-pointer = null

    swap [current-stack] with [system-stack]
      (use TMP:R2)
      (use TMP2:R3)
      TMP = [current-stack]
      TMP2 = [system-stack]
      [current-stack] = TMP2
      [system-stack] = TMP

    swap [registers] with [system_registers]
      (use TMP:R2)
      (use TMP2:R3)
      TMP = [registers]
      TMP2 = [system-registers]
      [registers] = TMP
      [system-registers] = TMP2

    restore R2 ... Rn
    
    goto current-stack.pc
      (use TMP:R2)
      TMP = [current-stack]
      TMP = TMP.pc
      goto TMP

;============================================================
;=======================================================<doc>

public defn compile-extend-stack-stub (emitter:CodeEmitter, stubs:AsmStubs) :
  val backend = backend(stubs)
  defn E (i:Ins) : emit(emitter, i)
  
  defn swap (r1:Reg, m1:Mem, r2:Reg, m2:Mem) :
    E $ LoadL(r1, m1)
    E $ LoadL(r2, m2)
    E $ StoreL(m1, r2)
    E $ StoreL(m2, r1)

  ;Compute stack offsets
  val stack-offset-counter = Counter(-1 + 8)
  val size-offset = next(stack-offset-counter, 8)
  val frames-offset = next(stack-offset-counter, 8)
  val sp-offset = next(stack-offset-counter, 8)
  val pc-offset = next(stack-offset-counter, 8)

  E $ Label(extend-stack(stubs))

  ;save R2 ... Rn
  for (r in call-regs(backend), loc in saved-regs(stubs)) do :
    E $ StoreL(M(loc), R(r))
  for (r in call-fregs(backend), loc in saved-fregs(stubs)) do :
    E $ StoreD(M(loc), F(r))

  ;current-stack.pc = return address (R0)
  ;current-stack.sp = RSP
  let :
    val TMP = R2
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ StoreL(TMP, R0, pc-offset)
    E $ StoreL(TMP, RSP, sp-offset)

  ;size = RSP + R1 - stack-limit
  let :
    val TMP = R2
    E $ AddL(R4, RSP, R1)
    E $ LoadL(TMP, M(stack-limit(stubs)))
    E $ SubL(R4, R4, TMP)

  ;swap [current-stack] with [system-stack]
  ;swap [registers] with [system_registers]
  swap(R2, M(current-stack(stubs)), R3, M(system-stack(stubs)))  
  swap(R2, M(registers(stubs)), R3, M(system-registers(stubs)))

  ;RSP = current-stack.frames
  ;stack-limit = current-stack.frames + current-stack.size
  let :
    val TMP = R2
    val TMP2 = R3
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ LoadL(RSP, TMP, frames-offset)
    E $ LoadL(TMP2, TMP, size-offset)
    E $ AddL(TMP2, TMP2, RSP)
    E $ StoreL(M(stack-limit(stubs)), TMP2)

  ;Call extend stack
  E $ SetL(R3, INT(1))
  E $ AddL(RSP, RSP, INT(8))
  E $ Call(M(extend-stack(stubs)))

  ;current-stack.stack-pointer = null
  let :
    val TMP = R2
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ StoreL(TMP, INT(0), sp-offset)

  ;swap [current-stack] with [system-stack]
  ;swap [registers] with [system_registers]
  swap(R2, M(current-stack(stubs)), R3, M(system-stack(stubs)))  
  swap(R2, M(registers(stubs)), R3, M(system-registers(stubs)))  

  ;restore R2 ... Rn
  for (r in call-regs(backend), loc in saved-regs(stubs)) do :
    E $ LoadL(R(r), M(loc))
  for (r in call-fregs(backend), loc in saved-fregs(stubs)) do :
    E $ LoadD(F(r), M(loc))

  ;goto current-stack.pc
  let :
    val TMP = R2
    E $ LoadL(TMP, M(current-stack(stubs)))
    E $ LoadL(TMP, TMP, pc-offset)
    E $ Goto(TMP)

;============================================================
;==================== Assembly Shorthands ===================
;============================================================

;==============================
;==== Assembly Equivalents ====
;==============================
public defn R (n:Int) : Reg(n)
public defn F (n:Int) : FReg(n)
public defn M (n:Int) : Mem(n,0)
public defn LM (n:Int) : LocalMem(n)
public defn INT (v:Byte|Int|Long) : IntImm(v)
public val BT = ByteT()
public val IT = IntT()
public val LT = LongT()
public val FT = FloatT()
public val DT = DoubleT()

public val R0 = R(0)
public val R1 = R(1)
public val R2 = R(2)
public val R3 = R(3)
public val R4 = R(4)
public val R5 = R(5)
public val R6 = R(6)
public val RSP = RegSP()

public defn SetL (x:Loc, y:Imm) : SetIns(LT, x, y)
public defn SetD (x:Loc, y:Imm) : SetIns(DT, x, y)
public defn StoreL (x:Imm, y:Imm) : Store(LT, x, y, 0)
public defn StoreD (x:Imm, y:Imm) : Store(DT, x, y, 0)
public defn LoadL (x:Loc, y:Imm) : Load(LT, x, y, 0)
public defn LoadD (x:Loc, y:Imm) : Load(DT, x, y, 0)
public defn StoreL (x:Imm, y:Imm, o:Int) : Store(LT, x, y, o)
public defn StoreD (x:Imm, y:Imm, o:Int) : Store(DT, x, y, o)
public defn LoadL (x:Loc, y:Imm, o:Int) : Load(LT, x, y, o)
public defn AddL (x:Loc, y:Imm, z:Imm) : BinOp(LT, x, AddOp(), y, z)
public defn SubL (x:Loc, y:Imm, z:Imm) : BinOp(LT, x, SubOp(), y, z)
public defn AndL (x:Loc, y:Imm, z:Imm) : BinOp(LT, x, AndOp(), y, z)
public defn BreakL (x:Imm, op:Op, y:Imm, z:Imm) : Break(LT, x, op, y, z)