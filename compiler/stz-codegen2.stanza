;See License.txt for details about licensing.

defpackage stz/codegen :
  import core
  import collections
  import stz/asm-ir
  import stz/backend

;============================================================
;===================== Code Emitter =========================
;============================================================

public deftype CodeEmitter
public defmulti emit (e:CodeEmitter, i:Ins) -> False

;============================================================
;======================= Stubs ==============================
;============================================================

public defstruct AsmStubs :
  backend: Backend
  stack-limit:Int
  registers:Int
  sys-registers:Int
  heap:Int
  heap-top:Int
  heap-limit:Int
  free:Int
  free-limit:Int
  current-stack:Int
  saved-c-rsp:Int
  swap-lbl:Int
  extend-stack:Int
  saved-c-regs:Tuple<Int>
  id-counter:Seq<Int>

public defn AsmStubs (backend:Backend) :
  val id-counter = to-seq(0 to false)
  val c-preserved = to-tuple $
    for i in c-preserved-regs(backend) seq :
      next(id-counter)
  AsmStubs(
    backend
    next(id-counter)  ;stack-limit:Int
    next(id-counter)  ;registers:Int
    next(id-counter)  ;sys-registers:Int
    next(id-counter)  ;heap:Int
    next(id-counter)  ;heap-top:Int
    next(id-counter)  ;heap-limit:Int
    next(id-counter)  ;free:Int
    next(id-counter)  ;free-limit:Int
    next(id-counter)  ;current-stack:Int
    next(id-counter)  ;saved-c-rsp:Int
    next(id-counter)  ;swap-lbl:Int
    next(id-counter)  ;extend-stack:Int
    c-preserved
    id-counter)

public defn unique-id (s:AsmStubs) :
  next(id-counter(s))

;============================================================
;=================== Assembly Stubs =========================
;============================================================

public defn compile-entry-function (emitter:CodeEmitter, stubs:AsmStubs) :
  val backend = backend(stubs)
  val aregs = callc-regs(backend)
  val A0 = R(aregs[0])
  val TMP = R(aregs[1])
  defn E (i:Ins) : emit(emitter, i)

  ;Save the C context
  ;Save the VMInit packet to the machine state
  ;Set the new stack
  ;Run the initialization function
  ;Restore the C context
  val initialization-function = unique-id(stubs)
  
  ;Emit labels for holding the C state
  defn make-long-storage (n:Int) :
    E $ Label(n)
    E $ DefLong(0L)
  E $ DefData()
  make-long-storage(saved-c-rsp(stubs))
  do(make-long-storage, saved-c-regs(stubs))
  E $ DefText()

  ;Temporary storage locations
  E $ DefData()
  make-long-storage(swap-lbl(stubs))
  make-long-storage(stack-limit(stubs))
  E $ DefText()

  ;Emit labels for holding the VM state
  let :
    defn #long () :
      E $ DefLong(0L)
    defn #long (n:Int) :
      E $ Label(n)
      E $ DefLong(0L)
    defn #int () :
      E $ DefInt(0)
    defn #label (n:Int) :
      E $ DefLabel(n)
    defn #space (n:Int, sz:Int) :
      E $ Label(n)
      E $ DefSpace(sz)
      
    E $ DefData()    
    #long()                       ;instructions: ptr<byte>
    #label(registers(stubs))      ;registers: ptr<long>
    #long()                       ;global-offsets: ptr<long>
    #long()                       ;global-mem: ptr<byte>
    #long()                       ;const-table: ptr<long>
    #long()                       ;const-mem: ptr<byte>
    #long()                       ;data-offsets: ptr<int>
    #long()                       ;data-mem: ptr<byte>
    #long()                       ;extern-addresses: ptr<long>
    #long()                       ;extern-defn-addresses: ptr<long>
    #long()                       ;code-offsets: ptr<int>
    #int()                        ;extend-heap-id: int
    #int()                        ;extend-stack-id: int
    #long(heap(stubs))            ;heap: ptr<long>      
    #long(heap-top(stubs))        ;heap-top: ptr<long>  
    #long(heap-limit(stubs))      ;heap-limit: ptr<long>
    #long(free(stubs))            ;free: ptr<long>      
    #long(free-limit(stubs))      ;free-limit: ptr<long>
    #long(current-stack(stubs))   ;current-stack: long
    #long()                       ;system-stack: long
    #label(sys-registers(stubs))  ;system-registers: ptr<long>
    #space(registers(stubs), 8 * 256)     ;space for registers
    #space(sys-registers(stubs), 8 * 256) ;space for system registers
    E $ DefText()

  ;Start of entry function
  E $ ExLabel(`stanza_entry)

  ;Save the C Context
  E $ StoreL(M(saved-c-rsp(stubs)), RSP)
  for (i in c-preserved-regs(backend),
       n in saved-c-regs(stubs)) do :
    E $ StoreL(M(n), R(i))

  ;Save the entry packet to the machine state
  let :
    defn save (i:Int, n:AsmStubs -> Int) :
      E $ LoadL(TMP, A0, i * 8)
      E $ StoreL(M(n(stubs)), TMP)
    save(0, heap)
    save(1, heap-top)
    save(2, heap-limit)
    save(3, free)
    save(4, free-limit)
    save(5, current-stack)

  ;Load the stack pointer
  val frames-offset = 8 + 8 - 1
  val stanza-return = unique-id(stubs)
  E $ LoadL(TMP, A0, 5 * 8)
  E $ LoadL(RSP, TMP, frames-offset)
  E $ SetL(TMP, M(stanza-return))
  E $ StoreL(RSP, TMP)
  E $ Goto(M(initialization-function))
  E $ Label(stanza-return)

  ;Restore the C Context
  E $ LoadL(RSP, M(saved-c-rsp(stubs)))
  for (i in c-preserved-regs(backend),
       n in saved-c-regs(stubs)) do :
    E $ LoadL(R(i), M(n))

  ;Return 0 for successful completion
  E $ SetL(R0, INT(0))
  E $ Return()

  ;Dummy initialization-function
  E $ Label(initialization-function)
  E $ Return()  

;============================================================
;==================== Assembly Shorthands ===================
;============================================================

;==============================
;==== Assembly Equivalents ====
;==============================
public defn R (n:Int) : Reg(n)
public defn F (n:Int) : FReg(n)
public defn M (n:Int) : Mem(n,0)
public defn INT (v:Byte|Int|Long) : IntImm(v)
public val BT = ByteT()
public val IT = IntT()
public val LT = LongT()
public val FT = FloatT()
public val DT = DoubleT()

public val R0 = R(0)
public val R1 = R(1)
public val R2 = R(2)
public val R3 = R(3)
public val R4 = R(4)
public val R5 = R(5)
public val R6 = R(6)
public val RSP = RegSP()

public defn SetL (x:Loc, y:Imm) : SetIns(LT, x, y)
public defn StoreL (x:Imm, y:Imm) : Store(LT, x, y, 0)
public defn LoadL (x:Loc, y:Imm) : Load(LT, x, y, 0)
public defn StoreL (x:Imm, y:Imm, o:Int) : Store(LT, x, y, o)
public defn LoadL (x:Loc, y:Imm, o:Int) : Load(LT, x, y, o)
public defn AddL (x:Loc, y:Imm, z:Imm) : BinOp(LT, x, AddOp(), y, z)
public defn BreakL (x:Imm, op:Op, y:Imm, z:Imm) : Break(LT, x, op, y, z)

;
;public defn #data () : DefData()
;public defn #text () : DefText()
;public defn #defbyte (v:Byte) : DefByte(v)
;public defn #defint (v:Int) : DefInt(v)
;public defn #deflong (v:Long) : DefLong(v)
;public defn #deffloat (v:Float) : DefFloat(v)
;public defn #defdouble (v:Double) : DefDouble(v)
;public defn #defstring (v:String) : DefString(v)
;public defn #defspace (size:Int) : DefSpace(size)
;public defn #deflabel (n:Int) : DefLabel(n)
;
;public defn #label (n:Int) : Label(n, false)
;public defn #exlabel (n:Symbol) : ExLabel(n)
;public defn #goto (x:Imm) : Goto(x)
;public defn #call (x:Imm, i:False|FileInfo) :
;  E(Call(x))
;  match(i:FileInfo) : E(Label(fresh-id(), i))
;    
;public defn #return () : Return()
;public defn #xchg (x:Loc, y:Loc) : XchgIns(x, y)
;public defn #dispatch (xs:List<Imm>, 
;                       bs:List<Branch>, 
;                       no-branch:Int,
;                       amb-branch:Int) : 
;  Dispatch(xs, bs, no-branch, amb-branch)
;public defn #match (xs:List<Imm>,
;                    bs:List<Branch>,
;                    no-branch:Int) :
;  Match(xs, bs, no-branch)
;
;public defn #mov (t:ASMType, x:Loc, y:Imm) : SetIns(t, x, y)
;public defn #movl (x:Loc, y:Imm) : #mov(LT, x, y)
;public defn #movi (x:Loc, y:Imm) : #mov(IT, x, y)
;public defn #movd (x:Loc, y:Imm) : #mov(DT, x, y)
;
;public defn #load (t:ASMType, x:Loc, y:Imm, off:Int) : Load(t, x, y, off)
;public defn #loadl (x:Loc, y:Imm, off:Int) : #load(LT, x, y, off)
;public defn #loadi (x:Loc, y:Imm, off:Int) : #load(LT, x, y, off)
;public defn #loadl (x:Loc, y:Imm) : #load(LT, x, y, 0)
;public defn #loadi (x:Loc, y:Imm) : #load(LT, x, y, 0)
;
;public defn #store (t:ASMType, x:Imm, y:Imm, off:Int) : Store(t, x, y, off)
;public defn #storel (x:Imm, y:Imm, off:Int) : #store(LT, x, y, off)
;public defn #storei (x:Imm, y:Imm, off:Int) : #store(IT, x, y, off)
;public defn #storel (x:Imm, y:Imm) : #store(LT, x, y, 0)
;public defn #storei (x:Imm, y:Imm) : #store(IT, x, y, 0)
;
;public defn #bin (t:ASMType, x:Loc, op:Op, y:Imm, z:Imm) : BinOp(t, x, op, y, z)
;public defn #binl (x:Loc, op:Op, y:Imm, z:Imm) : #bin(LT, x, op, y, z)
;public defn #addl (x:Loc, y:Imm, z:Imm) : #bin(LT, x, AddOp(), y, z)
;public defn #subl (x:Loc, y:Imm, z:Imm) : #bin(LT, x, SubOp(), y, z)
;public defn #andl (x:Loc, y:Imm, z:Imm) : #bin(LT, x, AndOp(), y, z)
;public defn #shrl (x:Loc, y:Imm, z:Imm) : #bin(LT, x, ShrOp(), y, z)
;
;public defn #una (t:ASMType, x:Loc, op:Op, y:Imm) : UnaOp(t, x, op, y)
;
;public defn #dual (t:ASMType, x1:Loc, x2:Loc, op:Op, y:Imm, z:Imm) : DualOp(t, x1, x2, op, y, z)
;
;public defn #break (t:ASMType, x:Imm, op:Op, y:Imm, z:Imm) : Break(t, x, op, y, z)
;public defn #breakl (x:Imm, op:Op, y:Imm, z:Imm) : #break(LT, x, op, y, z)
;public defn #jeql (x:Imm, y:Imm, z:Imm) : #break(LT, x, EqOp(), y, z)
;public defn #jnel (x:Imm, y:Imm, z:Imm) : #break(LT, x, NeOp(), y, z)
;public defn #jugel (x:Imm, y:Imm, z:Imm) : #break(LT, x, UgeOp(), y, z)
;public defn #jbsl (x:Imm, y:Imm, z:Imm) : #break(LT, x, BitSetOp(), y, z)
;
;public defn #conv (xt:ASMType, x:Loc, yt:ASMType, y:Imm) : ConvertIns(xt, x, yt, y)
;public defn #convi2l (x:Loc, y:Imm) : #conv(LT, x, IT, y)
;
;public defn #interpret (xt:ASMType, x:Loc, yt:ASMType, y:Imm) : InterpretIns(xt, x, yt, y)
;
;
;
;
;
