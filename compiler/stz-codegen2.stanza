;See License.txt for details about licensing.

defpackage stz/codegen :
  import core
  import collections
  import stz/asm-ir

;============================================================
;===================== Code Emitter =========================
;============================================================

public deftype CodeEmitter
public defmulti emit (e:CodeEmitter, i:Ins) -> False

;============================================================
;=================== Assembly Stubs =========================
;============================================================

public defn compile-entry-function (emitter:CodeEmitter) :
  defn E (i:Ins) : emit(emitter, i)
  E $ ExLabel(`stanza_entry)
  E $ SetL(R0, INT(42))
  E $ Return()

;============================================================
;==================== Assembly Shorthands ===================
;============================================================

;==============================
;==== Assembly Equivalents ====
;==============================
public defn R (n:Int) : Reg(n)
public defn F (n:Int) : FReg(n)
public defn M (n:Int) : Mem(n,0)
public defn INT (v:Byte|Int|Long) : IntImm(v)
public val BT = ByteT()
public val IT = IntT()
public val LT = LongT()
public val FT = FloatT()
public val DT = DoubleT()

public val R0 = R(0)
public val R1 = R(1)
public val R2 = R(2)
public val R3 = R(3)
public val R4 = R(4)
public val R5 = R(5)
public val R6 = R(6)
public val RSP = RegSP()

public defn SetL (x:Loc, y:Imm) : SetIns(LT, x, y)
;
;public defn #data () : DefData()
;public defn #text () : DefText()
;public defn #defbyte (v:Byte) : DefByte(v)
;public defn #defint (v:Int) : DefInt(v)
;public defn #deflong (v:Long) : DefLong(v)
;public defn #deffloat (v:Float) : DefFloat(v)
;public defn #defdouble (v:Double) : DefDouble(v)
;public defn #defstring (v:String) : DefString(v)
;public defn #defspace (size:Int) : DefSpace(size)
;public defn #deflabel (n:Int) : DefLabel(n)
;
;public defn #label (n:Int) : Label(n, false)
;public defn #exlabel (n:Symbol) : ExLabel(n)
;public defn #goto (x:Imm) : Goto(x)
;public defn #call (x:Imm, i:False|FileInfo) :
;  E(Call(x))
;  match(i:FileInfo) : E(Label(fresh-id(), i))
;    
;public defn #return () : Return()
;public defn #xchg (x:Loc, y:Loc) : XchgIns(x, y)
;public defn #dispatch (xs:List<Imm>, 
;                       bs:List<Branch>, 
;                       no-branch:Int,
;                       amb-branch:Int) : 
;  Dispatch(xs, bs, no-branch, amb-branch)
;public defn #match (xs:List<Imm>,
;                    bs:List<Branch>,
;                    no-branch:Int) :
;  Match(xs, bs, no-branch)
;
;public defn #mov (t:ASMType, x:Loc, y:Imm) : SetIns(t, x, y)
;public defn #movl (x:Loc, y:Imm) : #mov(LT, x, y)
;public defn #movi (x:Loc, y:Imm) : #mov(IT, x, y)
;public defn #movd (x:Loc, y:Imm) : #mov(DT, x, y)
;
;public defn #load (t:ASMType, x:Loc, y:Imm, off:Int) : Load(t, x, y, off)
;public defn #loadl (x:Loc, y:Imm, off:Int) : #load(LT, x, y, off)
;public defn #loadi (x:Loc, y:Imm, off:Int) : #load(LT, x, y, off)
;public defn #loadl (x:Loc, y:Imm) : #load(LT, x, y, 0)
;public defn #loadi (x:Loc, y:Imm) : #load(LT, x, y, 0)
;
;public defn #store (t:ASMType, x:Imm, y:Imm, off:Int) : Store(t, x, y, off)
;public defn #storel (x:Imm, y:Imm, off:Int) : #store(LT, x, y, off)
;public defn #storei (x:Imm, y:Imm, off:Int) : #store(IT, x, y, off)
;public defn #storel (x:Imm, y:Imm) : #store(LT, x, y, 0)
;public defn #storei (x:Imm, y:Imm) : #store(IT, x, y, 0)
;
;public defn #bin (t:ASMType, x:Loc, op:Op, y:Imm, z:Imm) : BinOp(t, x, op, y, z)
;public defn #binl (x:Loc, op:Op, y:Imm, z:Imm) : #bin(LT, x, op, y, z)
;public defn #addl (x:Loc, y:Imm, z:Imm) : #bin(LT, x, AddOp(), y, z)
;public defn #subl (x:Loc, y:Imm, z:Imm) : #bin(LT, x, SubOp(), y, z)
;public defn #andl (x:Loc, y:Imm, z:Imm) : #bin(LT, x, AndOp(), y, z)
;public defn #shrl (x:Loc, y:Imm, z:Imm) : #bin(LT, x, ShrOp(), y, z)
;
;public defn #una (t:ASMType, x:Loc, op:Op, y:Imm) : UnaOp(t, x, op, y)
;
;public defn #dual (t:ASMType, x1:Loc, x2:Loc, op:Op, y:Imm, z:Imm) : DualOp(t, x1, x2, op, y, z)
;
;public defn #break (t:ASMType, x:Imm, op:Op, y:Imm, z:Imm) : Break(t, x, op, y, z)
;public defn #breakl (x:Imm, op:Op, y:Imm, z:Imm) : #break(LT, x, op, y, z)
;public defn #jeql (x:Imm, y:Imm, z:Imm) : #break(LT, x, EqOp(), y, z)
;public defn #jnel (x:Imm, y:Imm, z:Imm) : #break(LT, x, NeOp(), y, z)
;public defn #jugel (x:Imm, y:Imm, z:Imm) : #break(LT, x, UgeOp(), y, z)
;public defn #jbsl (x:Imm, y:Imm, z:Imm) : #break(LT, x, BitSetOp(), y, z)
;
;public defn #conv (xt:ASMType, x:Loc, yt:ASMType, y:Imm) : ConvertIns(xt, x, yt, y)
;public defn #convi2l (x:Loc, y:Imm) : #conv(LT, x, IT, y)
;
;public defn #interpret (xt:ASMType, x:Loc, yt:ASMType, y:Imm) : InterpretIns(xt, x, yt, y)
;
;
;
;
;
