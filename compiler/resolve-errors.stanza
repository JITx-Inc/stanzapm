defpackage stz/resolve-errors :
  import core
  import collections
  import stz/absolute-info
  import stz/namemap
  import stz/dl-ir

;============================================================
;===================== Exceptions ===========================
;============================================================

public deftype ResolveError <: Exception
public defmulti info (e:ResolveError) -> AbsoluteFileInfo|False

public defstruct NoResolve <: ResolveError :
  name:Symbol
  info:AbsoluteFileInfo|False with: (as-method => true)
public defstruct BadQualifyPackage <: ResolveError :
  name:Symbol
  info:AbsoluteFileInfo|False with: (as-method => true)
public defstruct NoPackage <: ResolveError :
  name:Symbol
  source-package:Symbol
  info:AbsoluteFileInfo|False with: (as-method => true)
public defstruct NoConditionalPackage <: ResolveError :
  name:Symbol
public defstruct AmbResolve <: ResolveError :
  name:Symbol
  info:AbsoluteFileInfo|False with: (as-method => true)
  entries:List<VEntry>
public defstruct NotMutable <: ResolveError :
  name:Symbol
  info:AbsoluteFileInfo|False with: (as-method => true)
  entry:VEntry
public defstruct NotFn <: ResolveError :
  name:Symbol
  info:AbsoluteFileInfo|False with: (as-method => true)
  entry:VEntry
public defstruct NotClass <: ResolveError :
  name:Symbol
  info:AbsoluteFileInfo|False with: (as-method => true)
  entry:VEntry
public defstruct NotHSClass <: ResolveError :
  name:Symbol
  info:AbsoluteFileInfo|False with: (as-method => true)
  entry:VEntry
public defstruct NotLSClass <: ResolveError :
  name:Symbol
  info:AbsoluteFileInfo|False with: (as-method => true)
  entry:VEntry
public defstruct NotPrim <: ResolveError :
  name:Symbol
  info:AbsoluteFileInfo|False with: (as-method => true)
public defstruct NotLSPrim <: ResolveError :
  name:Symbol
  info:AbsoluteFileInfo|False with: (as-method => true)
public defstruct NotCapVar <: ResolveError :
  name:Symbol
  info:AbsoluteFileInfo|False with: (as-method => true)
  entry:VEntry
public defstruct MissingType <: ResolveError :
  src-package:Symbol
  typeid:TypeId

;Indicates that a package expected to be imported via forwarding
;is missing.
;- src-package: The package that is being analyzed by the resolver.
;- imported-package: The package that is being imported (via
;  forwarding) that is missing.
public defstruct MissingForwardedPackage <: ResolveError :
  src-package:Symbol
  imported-package:Symbol
public defstruct ForwardingCycle <: ResolveError :
  src-packages:Seq<Symbol>

defmethod print (o:OutputStream, ps:ForwardingCycle) :
  print(o, "Packages form a cycle via forwarding: ")
  print-all(o, join(src-packages(ps), ", "))

defmethod print (o:OutputStream, e:MissingType) :
  val FMT = "Missing type: The %~ package requires the %_/%_ type to be defined."
  print(o, FMT % [src-package(e), package(typeid(e)), name(typeid(e))])

defmethod print (o:OutputStream, e:MissingForwardedPackage) :
  val FMT = "Missing forwarded package: The %~ package needs the %~ package."
  print(o, FMT % [src-package(e), imported-package(e)])

defmethod print (o:OutputStream, e:NoResolve) :
  val FMT = "%_Could not resolve %~."
  print(o, FMT % [infostr(e), name(e)])

defmethod print (o:OutputStream, e:BadQualifyPackage) :
  val [package,n] = qualifier(name(e))
  val FMT = "%_Could not resolve %~. The package %~ could not be found."
  print(o, FMT % [infostr(e), name(e), package])

defmethod print (o:OutputStream, e:NoPackage) :
  val FMT = "%_Could not find package %~, which is imported by package %~."
  print(o, FMT % [infostr(e), name(e), source-package(e)])

defmethod print (o:OutputStream, e:NoConditionalPackage) :
  val FMT = "Conditionally-imported package %_ could not be found."
  print(o, FMT % [name(e)])

defmethod print (o:OutputStream, e:AmbResolve) :
  val FMT = "%_Ambiguous reference to %~. Possibilities include:"
  print(o, FMT % [infostr(e), name(e)])
  val o2 = IndentedStream(o)
  for v in entries(e) do :
    val FMT = "%_%~ defined in package %~"
    lnprint(o2, FMT % [infostr(v), name(v), package(v)])

defmethod print (o:OutputStream, e:NotMutable) :
  val FMT = "%_Expected %~ to be a mutable variable, but %_"
  print(o, FMT % [infostr(e), name(e), descriptor(entry(e))])

defmethod print (o:OutputStream, e:NotFn) :
  val FMT = "%_Expected %~ to be a function, but %_"
  print(o, FMT % [infostr(e), name(e), descriptor(entry(e))])

defmethod print (o:OutputStream, e:NotClass) :
  val FMT = "%_Expected %~ to be a type, but %_"
  print(o, FMT % [infostr(e), name(e), descriptor(entry(e))])

defmethod print (o:OutputStream, e:NotHSClass) :
  val FMT = "%_Expected %~ to be a HiStanza type, but %_"
  print(o, FMT % [infostr(e), name(e), descriptor(entry(e))])

defmethod print (o:OutputStream, e:NotLSClass) :
  val FMT = "%_Expected %~ to be a LoStanza type, but %_"
  print(o, FMT % [infostr(e), name(e), descriptor(entry(e))])

defmethod print (o:OutputStream, e:NotCapVar) :
  val FMT = "%_Expected %~ to be a captured type variable, but %_"
  print(o, FMT % [infostr(e), name(e), descriptor(entry(e))])

defmethod print (o:OutputStream, e:NotPrim) :
  val FMT = "%_%~ is not a recognized HiStanza primitive."
  print(o, FMT % [infostr(e), name(e)])

defmethod print (o:OutputStream, e:NotLSPrim) :
  val FMT = "%_%~ is not a recognized LoStanza primitive."
  print(o, FMT % [infostr(e), name(e)])

defn descriptor (e:VEntry) :
  val typestr = match(type(e)) :
    (t:ValE) : "HiStanza value"
    (t:VarE) : "HiStanza variable"
    (t:TVarE) : "type variable"
    (t:CapVarE) : "captured type variable"
    (t:TypeE) : "HiStanza type"
    (t:MultiE) : "multi"
    (t:FnE) : "HiStanza function"
    (t:LValE) : "LoStanza value"
    (t:LVarE) : "LoStanza variable"
    (t:LFnE) : "LoStanza function"
    (t:LTypeE) : "LoStanza type"
    (t:FieldE) : "field"
    (t:LabelE) : "label"
  val defstr = match(info(e)) :
    (info:AbsoluteFileInfo) : " at %_" % [/info(info)]
    (info:False) : ""
  "%~ defined%_ in package %~ is a %_." % [name(e), defstr, package(e), typestr]

defn infostr (info:AbsoluteFileInfo|False) :
  match(info) :
    (info:AbsoluteFileInfo) : "%_: " % [/info(info)]
    (info:False) : ""
defn infostr (e:ResolveError) :
  infostr(info(e))
defn infostr (e:VEntry) :
  infostr(info(e))

public defstruct ResolveErrors <: Exception :
  errors: Tuple<ResolveError>
defmethod print (o:OutputStream, e:ResolveErrors) :
  print(o, "%n" % [errors(e)])
