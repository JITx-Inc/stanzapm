defpackage stz/renamer :
  import core
  import collections
  import reader

deftype RenameExp
defstruct PushScope <: RenameExp
with: (printer => true)
defstruct PopScope <: RenameExp
with: (printer => true)
defstruct PushGroup <: RenameExp
with: (printer => true)
defstruct PopGroup <: RenameExp
with: (printer => true)
defstruct Register <: RenameExp : (type:Symbol, name:Symbol)
with: (printer => true)
defstruct PushVis <: RenameExp : (vis:Symbol)
with: (printer => true)
defstruct PopVis <: RenameExp
with: (printer => true)

defsyntax rename :
  defn sym (v) : unwrap-token(v) as Symbol

  public defproduction pkg : Tuple<RenameExp>
  defrule pkg = (renaming package: (?es:#exp ...)) : to-tuple(es)

  defproduction exp : RenameExp
  defrule exp = (push scope) : PushScope()
  defrule exp = (pop scope) : PopScope()
  defrule exp = (push group) : PushGroup()
  defrule exp = (pop group) : PopGroup()
  defrule exp = (push visibility ?v) : PushVis(sym(v))
  defrule exp = (pop visibility) : PopVis()
  defrule exp = (register ?t ?n) : Register(sym(t), sym(n))

defn read-exps (filename:String) :
  val forms = read-file(filename)
  parse-syntax[rename / #pkg ...](forms)

;============================================================
;===================== Engine ===============================
;============================================================

defn rename (es:Tuple<RenameExp>) :
  val vardefs = MultilevelTable<Symbol,True>()
  val tvardefs = MultilevelTable<Symbol,True>()
  val classdefs = MultilevelTable<Symbol,True>()
  val labeldefs = MultilevelTable<Symbol,True>()
  val fielddefs = MultilevelTable<Symbol,True>()
  val groupdefs = MultilevelStack<Register>()
  val scope-stack = Vector<Symbol>()
  val vis-stack = Vector<Symbol>()
  add(scope-stack, `group)
  add(vis-stack, `Private)

  defn add-unique (s:MultilevelTable<Symbol,True>, name:Symbol) :
    if key?(s, name) :
      println("%_ already defined" % [name])
    else :
      s[name] = true

  for e in es do :
    match(e) :
      (e:PushScope) :
        push-level(vardefs)
        push-level(tvardefs)
        push-level(classdefs)
        push-level(labeldefs)
        push-level(fielddefs)
        add(scope-stack, `scope)
        add(vis-stack, `Local)
      (e:PopScope) :
        pop-level(vardefs)
        pop-level(tvardefs)
        pop-level(classdefs)
        pop-level(labeldefs)
        pop-level(fielddefs)
        pop(scope-stack)
        pop(vis-stack)
      (e:PushGroup) :
        push-level(groupdefs)
        add(scope-stack, `group)
      (e:PopGroup) :
        for e in groupdefs peek-level :
          if key?(vardefs, name(e)) :
            println("%_ already defined" % [name(e)])
        for e in groupdefs pop-level :
          vardefs[name(e)] = true
        pop(scope-stack)
      (e:PushVis) :
        add(vis-stack, vis(e))
      (e:PopVis) :
        pop(vis-stack)
      (e:Register) :
        switch(peek(scope-stack)) :
          `group :
            switch(type(e)) :
              `var : add-unique(vardefs, name(e))
              `mutable-var : add-unique(vardefs, name(e))
              `tvar : add-unique(tvardefs, name(e))
              `capvar : add-unique(tvardefs, name(e))
              `class : add-unique(classdefs, name(e))
              `ls-var : add-unique(vardefs, name(e))
              `ls-mutable-var : add-unique(vardefs, name(e))
              `ls-class : add-unique(classdefs, name(e))
              `ls-field : add-unique(fielddefs, name(e))
              `ls-label : add-unique(labeldefs, name(e))
              `multi : add(groupdefs, e)
              `fn : add(groupdefs, e)
              `ls-fn : add(groupdefs, e)
          `scope :
            switch(type(e)) :
              `var : add-unique(vardefs, name(e))
              `mutable-var : add-unique(vardefs, name(e))
              `tvar : add-unique(tvardefs, name(e))
              `capvar : add-unique(tvardefs, name(e))
              `class : add-unique(classdefs, name(e))
              `ls-var : add-unique(vardefs, name(e))
              `ls-mutable-var : add-unique(vardefs, name(e))
              `ls-class : add-unique(classdefs, name(e))
              `ls-field : add-unique(fielddefs, name(e))
              `ls-label : add-unique(labeldefs, name(e))
              `multi : add-unique(vardefs, name(e))
              `fn : add-unique(vardefs, name(e))
              `ls-fn : add-unique(vardefs, name(e))

;============================================================
;==================== Utilities =============================
;============================================================

deftype MultilevelStack<T>
defmulti push-level (s:MultilevelStack) -> False
defmulti pop-level<?T> (return:T -> ?, s:MultilevelStack<?T>) -> False
defmulti peek-level<?T> (return:T -> ?, s:MultilevelStack<?T>) -> False
defmulti add<?T> (s:MultilevelStack<?T>, v:T) -> False

defn MultilevelStack<T> () :
  val items = Vector<T|Marker>()
  new MultilevelStack<T> :
    defmethod push-level (this) :
      add(items, Marker())
    defmethod pop-level (return:T -> ?, this) :
      let loop () :
        match(pop(items)) :
          (item:Marker) : false
          (item:T) : (return(item), loop())
    defmethod peek-level (return:T -> ?, this) :
      let loop (i:Int = length(items) - 1) :
        match(items[i]) :
          (item:Marker) : false
          (item:T) : (return(item), loop(i - 1))
    defmethod add (this, v:T) :
      add(items, v)
defstruct Marker

deftype MultilevelTable<K,V>
defmulti set<?K,?V> (table:MultilevelTable<?K,?V>, k:K, v:V) -> False
defmulti get<?K,?V> (table:MultilevelTable<?K,?V>, k:K) -> V
defmulti key?<?K> (table:MultilevelTable<?K,?>, k:K) -> True|False
defmulti push-level (table:MultilevelTable) -> False
defmulti pop-level (table:MultilevelTable) -> False

defn MultilevelTable<K,V> () :
  var level:Int = 0
  val table = HashTable<K,MTItem<V>>()
  val restore = MultilevelStack<KeyValue<K,MTItem<V>|False>>()
  new MultilevelTable<K,V> :
    defmethod set (this, k:K, v:V) :
      ;Record restoration
      match(get?(table,k)) :
        (e:MTItem<V>) : add(restore, k => e) when /level(e) < level
        (e:False) : add(restore, k => e)
      table[k] = MTItem<V>(level, v)
    defmethod get (this, k:K) :
      val e = table[k]
      fatal("Key %_ does not exist in table." % [k]) when /level(e) != level
      item(e)
    defmethod key? (this, k:K) :
      match(get?(table,k)) :
        (e:MTItem<V>) : /level(e) == level
        (_:False) : false
    defmethod push-level (this) :
      push-level(restore)
      level = level + 1
    defmethod pop-level (this) :
      within e = pop-level(restore) :
        val k = key(e)
        match(value(e)) :
          (v:MTItem<V>) : table[k] = v
          (v:False) : remove(table,k)
      level = level - 1

defstruct MTItem<V> :
  level: Int
  item: V

;============================================================
;============================================================
;============================================================

public defn main () :
  val pkgs = read-exps(command-line-arguments()[1])
  val t0 = current-time-us()
  for pkg in pkgs do :
    rename(pkg)
  val t1 = current-time-us()
  println("Time = %_ us" % [t1 - t0])

main()