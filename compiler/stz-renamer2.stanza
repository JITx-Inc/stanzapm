defpackage stz/renamer :
  import core
  import collections
  import reader

deftype RenameExp
defstruct PushScope <: RenameExp
with: (printer => true)
defstruct PopScope <: RenameExp
with: (printer => true)
defstruct PushGroup <: RenameExp
with: (printer => true)
defstruct PopGroup <: RenameExp
with: (printer => true)
defstruct Register <: RenameExp : (type:Symbol, name:Symbol)
with: (printer => true)
defstruct PushVis <: RenameExp : (vis:Symbol)
with: (printer => true)
defstruct PopVis <: RenameExp
with: (printer => true)

defsyntax rename :
  defn sym (v) : unwrap-token(v) as Symbol

  public defproduction pkg : Tuple<RenameExp>
  defrule pkg = (renaming package: (?es:#exp ...)) : to-tuple(es)
  
  defproduction exp : RenameExp
  defrule exp = (push scope) : PushScope()
  defrule exp = (pop scope) : PopScope()
  defrule exp = (push group) : PushGroup()
  defrule exp = (pop group) : PopGroup()
  defrule exp = (push visibility ?v) : PushVis(sym(v))
  defrule exp = (pop visibility) : PopVis()
  defrule exp = (register ?t ?n) : Register(sym(t), sym(n))

defn read-exps (filename:String) :
  val forms = read-file(filename)
  parse-syntax[rename / #pkg ...](forms)

;============================================================
;===================== Engine ===============================
;============================================================

defn rename (es:Tuple<RenameExp>) :
  var vardefs:HashSet<Symbol> = HashSet<Symbol>()
  var tvardefs:HashSet<Symbol> = HashSet<Symbol>()
  var classdefs:HashSet<Symbol> = HashSet<Symbol>()
  var labeldefs:HashSet<Symbol> = HashSet<Symbol>()
  var fielddefs:HashSet<Symbol> = HashSet<Symbol>()
  val groupdefs = MultilevelStack<Register>()
  val scope-stack = Vector<Symbol>()
  val vis-stack = Vector<Symbol>()
  add(scope-stack, `group)
  add(vis-stack, `Private)

  var o:IndentedStream = IndentedStream(current-output-stream(), 0)
  defn indent () : o = IndentedStream(o)
  defn deindent () : o = IndentedStream(o, -2)
  defn iprintln (x) : println(o, x)

  defn dump-state () :
    iprintln("vardefs = %," % [vardefs])
    iprintln("tvardefs = %," % [tvardefs])
    iprintln("classdefs = %," % [classdefs])
    iprintln("labeldefs = %," % [labeldefs])
    iprintln("fielddefs = %," % [fielddefs])
    iprintln("scope-stack = %," % [scope-stack])
    iprintln("vis-stack = %," % [vis-stack])

  defn add-unique (s:HashSet<Symbol>, name:Symbol) :
    if not add(s, name) :
      dump-state()
      iprintln("%_ already defined" % [name])
  defn add-to-group (e:Register) :
    if vardefs[name(e)] :
      dump-state()
      iprintln("%_ already defined" % [name(e)])
    add(groupdefs, e)

  val defstack = Vector<[HashSet<Symbol>, HashSet<Symbol>, HashSet<Symbol>, HashSet<Symbol>, HashSet<Symbol>]>()

  for e in es do :
    iprintln("Processing: %_" % [e])
    iprintln("  vardefs = %," % [vardefs])
    match(e) :
      (e:PushScope) :        
        iprintln("Pushing from scope depth %_" % [length(scope-stack)])
        add(defstack, [vardefs, tvardefs, classdefs, labeldefs, fielddefs])
        vardefs = HashSet<Symbol>()
        tvardefs = HashSet<Symbol>()
        classdefs = HashSet<Symbol>()
        labeldefs = HashSet<Symbol>()
        fielddefs = HashSet<Symbol>()
        
        add(scope-stack, `scope)
        add(vis-stack, `Local)
        indent()
      (e:PopScope) :
        deindent()
        val [a, b, c, d, x] = pop(defstack)
        vardefs = a
        tvardefs = b
        classdefs = c
        labeldefs = d
        fielddefs = x

        pop(scope-stack)
        pop(vis-stack)
        iprintln("Popped to scope depth %_" % [length(scope-stack)])
      (e:PushGroup) :
        push-level(groupdefs)
        add(scope-stack, `group)
        indent()
      (e:PopGroup) :
        deindent()
        within e = pop-level(groupdefs) :
          add(vardefs, name(e))
        pop(scope-stack)
      (e:PushVis) :
        add(vis-stack, vis(e))
      (e:PopVis) :
        pop(vis-stack)
      (e:Register) :
        switch(peek(scope-stack)) :
          `group :
            switch(type(e)) :
              `var : add-unique(vardefs, name(e))
              `mutable-var : add-unique(vardefs, name(e))
              `tvar : add-unique(tvardefs, name(e))
              `capvar : add-unique(tvardefs, name(e))
              `class : add-unique(classdefs, name(e))
              `multi : add-to-group(e)
              `fn : add-to-group(e)
              `ls-var : add-unique(vardefs, name(e))
              `ls-mutable-var : add-unique(vardefs, name(e))
              `ls-fn : add-to-group(e)
              `ls-class : add-unique(classdefs, name(e))
              `ls-field : add-unique(fielddefs, name(e))
              `ls-label : add-unique(labeldefs, name(e))              
          `scope :
            switch(type(e)) :
              `var : add-unique(vardefs, name(e))
              `mutable-var : add-unique(vardefs, name(e))
              `tvar : add-unique(tvardefs, name(e))
              `capvar : add-unique(tvardefs, name(e))
              `class : add-unique(classdefs, name(e))
              `multi : add-unique(vardefs, name(e))
              `fn : add-unique(vardefs, name(e))
              `ls-var : add-unique(vardefs, name(e))
              `ls-mutable-var : add-unique(vardefs, name(e))
              `ls-fn : add-unique(vardefs, name(e))
              `ls-class : add-unique(classdefs, name(e))
              `ls-field : add-unique(fielddefs, name(e))
              `ls-label : add-unique(labeldefs, name(e))  

;============================================================
;==================== Utilities =============================
;============================================================

deftype MultilevelStack<T>
defmulti push-level (s:MultilevelStack) -> False
defmulti pop-level<?T> (return:T -> ?, s:MultilevelStack<?T>) -> False
defmulti add<?T> (s:MultilevelStack<?T>, v:T) -> False

defn MultilevelStack<T> () :
  val items = Vector<T>()
  val levels = Vector<Int>()
  new MultilevelStack<T> :
    defmethod push-level (this) :
      add(levels, length(items))
    defmethod pop-level (return:T -> ?, this) :
      val l = pop(levels)
      for i in l to length(items) do :
        return(items[i])
      shorten(items, l)      
    defmethod add (this, v:T) :
      add(items, v)

deftype MultilevelTable<K,V>
defmulti set<?K,?V> (table:MultilevelTable<?K,?V>, k:K, v:V) -> False
defmulti get<?K,?V> (table:MultilevelTable<?K,?V>, k:K) -> V
defmulti key?<?K> (table:MultilevelTable<?K,?>, k:K) -> True|False
defmulti push-level (table:MultilevelTable) -> False
defmulti pop-level (table:MultilevelTable) -> False

defstruct MTItem<V> :
  level: Int
  item: V
with:
  printer => true

defn MultilevelTable<K,V> () :
  var level:Int = 0
  val table = HashTable<K,MTItem<V>>()
  val restore = MultilevelStack<KeyValue<K,MTItem<V>|False>>()
  new MultilevelTable<K,V> :
    defmethod set (this, k:K, v:V) :
      ;Record restoration
      match(get?(table,k)) :
        (e:MTItem<V>) :
          println("Overwriting previous entry: %_ (level = %_)" % [e, level])
          add(restore, k => e) when /level(e) < level
        (e:False) : add(restore, k => e)      
      table[k] = MTItem<V>(level, v)          
    defmethod get (this, k:K) :
      val e = table[k]
      fatal("Key %_ does not exist in table." % [k]) when /level(e) != level
      item(e)
    defmethod key? (this, k:K) :
      match(get?(table,k)) :
        (e:MTItem<V>) : /level(e) == level
        (_:False) : false
    defmethod push-level (this) :
      push-level(restore)
      level = level + 1
    defmethod pop-level (this) :
      within e = pop-level(restore) :
        val k = key(e)
        println("RESTORE ENTRY: %_" % [e])
        match(value(e)) :
          (v:MTItem<V>) : table[k] = v
          (v:False) : remove(table,k)
      level = level - 1

;============================================================
;============================================================
;============================================================
;
;public defn main () :
;  val pkgs = read-exps(command-line-arguments()[1])
;  for pkg in pkgs do :
;    rename(pkg)

public defn main () :

  ;val s = MultilevelStack<String>()
  ;push-level(s)
  ;add(s, "A")
  ;add(s, "B")
  ;pop-level(println, s)

  val t = MultilevelTable<Int,String>()
  defn test (k:Int) :
    if key?(t,k) : println("Value at %_ is %_" % [k, t[k]])
    else : println("No value at %_"% [k])
  defn test (name:String) :
    println(name)
    test(0)
    test(2)
    test(3)
    test(5)
    
    
  t[0] = "hi"
  t[5] = "string"  
  test("TEST ONE")
  
  push-level(t)
  test("TEST TWO")
  
  t[2] = "Cool"
  t[5] = "Boy"
  test("TEST B")
  
  pop-level(t)
  test("TEST THREE")
  
  push-level(t)
  test("TEST FOUR")
  

main()