defpackage stz/line-noise-prompter :
  import core
  import reader

extern linenoiseSetMultiLine : int -> int
extern linenoise : ptr<byte> -> ptr<byte>
extern linenoiseHistoryAdd : ptr<byte> -> int
extern linenoiseSetCompletionCallback : ptr<((ptr<byte>, ptr<?>) -> int)> -> int
extern linenoiseAddCompletion : (ptr<?>, ptr<byte>) -> int
extern linenoiseHistorySave : ptr<byte> -> int
extern linenoiseHistoryLoad : ptr<byte> -> int

var completion-callback : False|(String -> Tuple<String>) = false

lostanza defn set-multi-line (x:ref<True|False>) -> ref<False> :
  if x == true : call-c linenoiseSetMultiLine(1)
  else : call-c linenoiseSetMultiLine(0)
  return false
set-multi-line(true)

lostanza deftype CompletionInfo :
  t : ptr<?>

lostanza defn add-completion (ci:ref<CompletionInfo>, str:ref<String>) -> ref<False> :
  call-c linenoiseAddCompletion(ci.t, addr!(str.chars))
  return false

defn hi-completion (str:String, ci:CompletionInfo) :
  match(completion-callback) :
    (f:String -> Tuple<String>) :
      val ss = f(str)
      for s in ss do :
        add-completion(ci, s)
    (_) : false

extern defn completion (s:ptr<byte>, t:ptr<?>) -> int :
  hi-completion(String(call-c clib/strlen(s), s), new CompletionInfo{t})
  return 1

lostanza defn line-noise (prompt:ref<String>) -> ref<String|False> :
  call-c linenoiseSetCompletionCallback(addr(completion))

  val s = call-c linenoise(addr!(prompt.chars))
  if s == 0L as ptr<?> :
    return false
  else :
    val str = String(s)
    call-c clib/free(s)
    return str

lostanza defn add-history (str:ref<String>) -> ref<False> :
  call-c linenoiseHistoryAdd(addr!(str.chars))
  return false

lostanza defn save-history (path:ref<String>) -> ref<False> :
  call-c linenoiseHistorySave(addr!(path.chars))
  return false

lostanza defn load-history (path:ref<String>) -> ref<False> :
  call-c linenoiseHistoryLoad(addr!(path.chars))
  return false

public defn LineNoisePrompter (prompt:String, continue:String, -- history-path:False|String = false, completion:False|(String -> Tuple<String>) = false) :
  match(history-path:String) :
    attempt : load-history(history-path as String)
  completion-callback = completion
  var line-counter = to-seq(0 to false)
  new Prompter :
    defmethod get-line (this) :
      val msg = prompt when next(line-counter) == 0
           else continue
      val l = line-noise(msg)
      match(l:String) :
        add-history(l)
        match(history-path:String) :
          attempt : save-history(history-path as String)
        l