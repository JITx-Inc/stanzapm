defpackage stz/vm-analyze :
  import core
  import collections
  import stz/vm-ir

;============================================================
;====================== Driver ==============================
;============================================================

public defn analyze (prog:VMProg) :
  for func in funcs(prog) do :
    match(func) :
      (func:VMMulti) :
        do(analyze{value(_)}, funcs(func))
      (func:VMFunc) :
        analyze(func)

;============================================================
;=================== Analysis Algorithm =====================
;============================================================

public defn analyze (func:VMFunc) :
  ;Record all statistics of all blocks
  val blocks = Vector<Int>()
  val label-indices = IntTable<Int>()
  val used = IntTable<List<Int>>()
  val defd = IntTable<List<Int>>()
  val successors = IntTable<List<Int|Label>>(List())

  val def-set = IntSet()
  val use-set = IntSet()
  val num-ins = length(ins(func))
  defn loop (i:Int, current-start:Int) :
    if i < num-ins :
      val ins = ins(func)[i]
      println("loop (%_) %_ %_" % [i, ins, current-start])
      match(ins) :
        (ins:LabelIns) :
          label-indices[n(ins)] = i
          loop(i + 1, current-start)
        (ins:VMIns&DestinationIns) :
          ;Finish calculating current block
          for arg in ins do-args :
            add(use-set, arg) when not def-set[arg]
          finish-block(current-start)

          ;Add successors
          for dest in ins do-dest :
            add(successors, current-start, Label(dest))
          if fall-through?(ins) and i + 1 < num-ins :
            add(successors, current-start, i + 1)
          
          ;Start next block
          loop(i + 1, i + 1)
        (ins:VMIns&OperationIns) :
          ;Calculate statistics for current block
          for arg in ins do-args :
            add(use-set, arg) when not def-set[arg]
          for res in ins do-results :
            add(def-set, res)

          ;Determine whether to close the current block
          if i + 1 < num-ins and /ins(func)[i + 1] is LabelIns :
            finish-block(current-start)
            add(successors, current-start, i + 1)
            loop(i + 1, i + 1)
          else :
            loop(i + 1, current-start)
    else :
      if i < current-start :
        finish-block(current-start)
  defn finish-block (current-start:Int) :
    add(blocks, current-start)
    used[current-start] = to-list(use-set)
    defd[current-start] = to-list(def-set)
    clear(def-set)
    clear(use-set)
    
  ;Start from first instruction
  loop(0, 0)
  
  ;Backpatch label destinations
  for entry in successors map! :
    for dest in value(entry) map :
      match(dest:Label) : label-indices[n(dest)]
      else : dest
  
  ;Print out result
  println("Analyzing function %_" % [id(func)])
  within indented() :
    for (ins in ins(func), i in 0 to false) do :
      println("(%_) %_" % [i, ins])
  for b in blocks do :
    println("Block starting at %_" % [b])
    within indented() :
      println("Used: %," % [used[b]])
      println("Defd: %," % [defd[b]])
      println("Successors: %," % [successors[b]])
      
defn add<?T> (t:IntTable<List<?T>>, i:Int, v:T) :
  update(t, cons{v, _}, i)

defstruct Label: (n:Int)

;============================================================
;================ Instruction Categorization ================
;============================================================

deftype DestinationIns :
  GotoIns <: DestinationIns
  Branch1Ins <: DestinationIns
  Branch2Ins <: DestinationIns
  ReturnIns <: DestinationIns
  TCallIns <: DestinationIns
  TCallClosureIns <: DestinationIns

deftype OperationIns :
  CallIns <: OperationIns
  CallClosureIns <: OperationIns
  CallCIns <: OperationIns
  YieldIns <: OperationIns
  NewStackIns <: OperationIns
  SetIns <: OperationIns
  Op0Ins <: OperationIns
  Op1Ins <: OperationIns
  Op2Ins <: OperationIns
  AllocIns <: OperationIns
  StoreIns <: OperationIns
  LoadIns <: OperationIns
  DumpIns <: OperationIns
  RecordLiveIns <: OperationIns
  CommentIns <: OperationIns

defn do-results (func:Int -> ?, i:OperationIns) :
  defn f? (x:Local|False) :
    match(x:Local) : func(index(x))
  defn f? (xs:Tuple<Local|False>) :
    do(f?, xs)
    
  match(i) :
    (i:CallIns) : f?(xs(i))
    (i:CallClosureIns) : f?(xs(i))
    (i:CallCIns) : f?(xs(i))
    (i:YieldIns) : f?(xs(i))
    (i:NewStackIns) : f?(x(i))
    (i:SetIns) : f?(x(i))
    (i:Op0Ins) : f?(x(i))
    (i:Op1Ins) : f?(x(i))
    (i:Op2Ins) : f?(x(i))
    (i:AllocIns) : f?(xs(i))
    (i:StoreIns) : false
    (i:LoadIns) : f?(x(i))
    (i:DumpIns) : false
    (i:RecordLiveIns) : false
    (i:CommentIns) : false

defn do-args (func:Int -> ?, i:OperationIns|DestinationIns) :
  defn f? (y:VMImm) :
    match(y:Local) : func(index(y))
  defn f? (ys:Tuple<VMImm>) :
    do(f?, ys)
    
  match(i) :
    (i:CallIns) : (f?(f(i)), f?(ys(i)))
    (i:CallClosureIns) : (f?(f(i)), f?(ys(i)))
    (i:CallCIns) : (f?(f(i)), f?(ys(i)))
    (i:YieldIns) : (f?(f(i)), f?(ys(i)))
    (i:NewStackIns) : f?(fid(i))
    (i:SetIns) : f?(y(i))
    (i:Op0Ins) : false
    (i:Op1Ins) : f?(y(i))
    (i:Op2Ins) : (f?(y(i)), f?(z(i)))
    (i:AllocIns) : f?(sizes(i))
    (i:StoreIns) : (f?(x(i)), f?(y(i)), f?(z(i)))
    (i:LoadIns) : (f?(y(i)), f?(z(i)))
    (i:DumpIns) : f?(xs(i))
    (i:RecordLiveIns) : false
    (i:CommentIns) : false
    (i:GotoIns) : false
    (i:Branch1Ins) : f?(x(i))
    (i:Branch2Ins) : (f?(x(i)), f?(y(i)))
    (i:ReturnIns) : f?(xs(i))
    (i:TCallIns) : (f?(f(i)), f?(ys(i)))
    (i:TCallClosureIns) : (f?(f(i)), f?(ys(i)))

defn do-dest (f:Int -> ?, i:DestinationIns) :
  match(i) :
    (i:GotoIns) : f(n(i))
    (i:Branch1Ins) : f(n(i))
    (i:Branch2Ins) : f(n(i))
    (i:ReturnIns) : false
    (i:TCallIns) : false
    (i:TCallClosureIns) : false

defn fall-through? (i:DestinationIns) :
  i is Branch1Ins|Branch2Ins