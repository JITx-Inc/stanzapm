;See License.txt for details about licensing.

defpackage stz/core-macros :
   import core
   import parser
   import macro-utils
   import collections
   import stz/params

;============================================================
;==================== Exceptions ============================
;============================================================

defn CSE (info:False|FileInfo, msg) :
   throw $ new Exception :
      defmethod print (o:OutputStream, this) :
         match(info) :
            (info:FileInfo) : print(o, "%_: Syntax Error: %_" % [info msg])
            (info:False) : print(o, "Syntax Error: %_ Received %~." % [msg, form])

;============================================================
;==================== Utilities =============================
;============================================================

defstruct StructField :
   name
   type
   as-method?: True|False
   setter
   box

defn wrap-info (info:False|FileInfo, x) :
   match(info) :
      (info:FileInfo) : Token(x, info)
      (info:False) : x

;============================================================
;================= Core Syntax Package ======================
;============================================================
defsyntax core :
   ;               Tags
   ;               ====

   val TAG-TABLE = HashTable<Symbol,True>()
   for tag in `(
      $package $import $prefix-of $prefix $public $protected $deftype $defchild $def
      $defvar $defn $defn* $defmulti $defmethod $defmethod* $fn $fn*
      $multi $begin $let $match $branch $new $as $as? $set $do
      $prim $tuple $quote $none $of $and $or $->
      $cap $void $? $ls-new $ls-struct $ls-addr $ls-addr! $ls-deref
      $ls-slot $ls-field $ls-do $ls-do-in-stack $ls-do-stack $ls-call-c $ls-prim $ls-sizeof $ls-tagof $ls-as
      $ls-letexp $ls-and $ls-or $ls-set $ls-labels $ls-block $ls-goto $ls-return
      $ls-let $ls-if $ls-match $ls-branch $ls-func $ls-def $ls-defvar $ls-deftype
      $ls-defn $ls-defn* $ls-defmethod $ls-defmethod* $ls-extern $ls-byte $ls-int $ls-long $ls-float $ls-double
      $ls-? $ls-of $ls-ptr $ls-ref $ls-fn) do :
      TAG-TABLE[tag] = true

   public defproduction stanza-tag: Symbol|Token
   defn stanza-tag? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : key?(TAG-TABLE, x)
         (x) : false
   defrule stanza-tag = (?x) when stanza-tag?(x) : x

   ;                Lexer Tags
   ;                ==========

   val LEXER-TAG-TABLE = HashTable<Symbol,True>()
   for tag in `(@do @do-afn @afn @get @tuple @of @cap @quote :) do :
      LEXER-TAG-TABLE[tag] = true
   defn lexer-tag? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : key?(LEXER-TAG-TABLE, x)
         (x) : false
   public defproduction lexer-tag: Symbol|Token      
   defrule lexer-tag = (?x) when lexer-tag?(x) : x

   ;                Error Handling
   ;                ==============

   public defproduction type!
   public defproduction type$
   public defproduction types!
   defrule type! = (?x:#type) : x
   fail-if type! = () : CSE(closest-info(), "Type expected here.")
   defrule type$ = (?x:#type! ?rest ...) :
      CSE(closest-info(), "Expected a single type here.") when not empty?(rest)
      x
   defrule types! = (?x:#type ... ?rest ...) :
      CSE(closest-info(rest), "Expected a type here.") when not empty?(rest)
      x

   public defproduction id!
   public defproduction id$
   public defproduction ids!
   defrule id! = (?x:#id) : x
   fail-if id! = () : CSE(closest-info(), "Identifier expected here.")
   defrule id$ = (?x:#id! ?rest ...) :
      CSE(closest-info(), "Expected a single identifier here.") when not empty?(rest)
      x
   defrule ids! = (?x:#id ... ?rest ...) :
      CSE(closest-info(rest), "Expected an identifier here.") when not empty?(rest)
      x

   public defproduction exp!
   public defproduction exp$
   public defproduction exps!
   defrule exp! = (?x:#exp) : x
   fail-if exp! = () : CSE(closest-info(), "Expression expected here.")
   defrule exp$ = (?x:#exp! ?rest ...) :
      CSE(closest-info(rest), "Expected a single expression here.") when not empty?(rest)
      x
   defrule exps! = (?x:#exp ... ?rest ...) :
      CSE(closest-info(rest), "Expected an expression here.") when not empty?(rest)
      x

   public defproduction :!
   defrule :! = (?x: ~ :) : x
   fail-if :! = () : CSE(closest-info(), "Colon expected here.")

   defproduction type1!
   defrule type1! = (?x:#type1) : x
   fail-if type1! = () : CSE(closest-info(), "Expected a type here.")

   defproduction exp0!
   defrule exp0! = (?x:#exp0) : x
   fail-if exp0! = () : CSE(closest-info(), "Expected an expression here.")

   defproduction exp1!
   defrule exp1! = (?x:#exp1) : x
   fail-if exp1! = () : CSE(closest-info(), "Expected an expression here.")

   defproduction exp2!
   defrule exp2! = (?x:#exp2) : x
   fail-if exp2! = () : CSE(closest-info(), "Expected an expression here.")

   defproduction exp3!
   defrule exp3! = (?x:#exp3) : x
   fail-if exp3! = () : CSE(closest-info(), "Expected an expression here.")

   defproduction exp4!
   defrule exp4! = (?x:#exp4) : x
   fail-if exp4! = () : CSE(closest-info(), "Expected an expression here.")

   defproduction exp5!
   defrule exp5! = (?x:#exp5) : x
   fail-if exp5! = () : CSE(closest-info(), "Expected an expression here.")

   ;                Type Definitions
   ;                ================

   public defproduction type
   public defproduction type0
   public defproduction type1

   defrule type = (?x:#type0 -> ?y:#type!) : qquote($-> (~ x) ~ y)
   defrule type = ((?x:#types!) -> ?y:#type!) : qquote($-> ~ x ~ y)
   defrule type = (?x:#type0) : x

   defrule type0 = (?x:#type0 & ?y:#type1!) : qquote($and ~ x ~ y)
   defrule type0 = (?x:#type0 ~ | ?y:#type1!) : qquote($or ~ x ~ y)
   defrule type0 = (?x:#type1) : x

   defrule type1 = (?x:(#stanza-tag _ ...)) : x
   defrule type1 = ((~ @cap ?x:#id$)) : qquote($cap ~ x)
   defrule type1 = ([?xs:#types!]) : qquote($tuple ~@ xs)
   defrule type1 = ((?x:#type)) : x
   defrule type1 = (?x:#id<?ys:#types!>) : qquote($of ~ x ~@ ys)
   defrule type1 = (Void) : `($void)
   defrule type1 = (?) : `($?)
   defrule type1 = (?x:#id) : x

   defrule id != (-> | & | ~ | | Void | ?)

   ;                Operator Definitions
   ;                ====================

   public defproduction exp  ;and / or / not
   public defproduction exp0 ;==, !=, <, <=, >, >=
   public defproduction exp1 ;+, -
   public defproduction exp2 ;*, %, /
   public defproduction exp3 ;<<, >>, >>>
   public defproduction exp4 ;&, |, ^
   public defproduction exp5 ;others

   ;Logical Operators
   defrule exp = (?x:#exp and ?y:#exp0!) :
      parse-syntax[core / #exp](qquote(if ~ x : ~ y as? core/True|core/False))
   defrule exp = (?x:#exp or ?y:#exp0!) :
      val template = `(
         if x : true
         else : y as? core/True|core/False)
      parse-syntax[core / #exp](
         fill-template(template, [
            `x => x
            `y => y]))
   defrule exp = (not ?x:#exp0!) :
      qquote($do core/complement ~ x)
   defrule exp = (?e:#exp0) : e

   ;Comparison Operators
   public defproduction op0 : Symbol
   defrule op0 = (==) : `equal?
   defrule op0 = (!=) : `not-equal?
   defrule op0 = (<) : `less?
   defrule op0 = (<=) : `less-eq?
   defrule op0 = (>) : `greater?
   defrule op0 = (>=) : `greater-eq?
   defrule exp0 = (?x:#exp0 ?f:#op0 ?y:#exp1!) : qquote($do ~ f ~ x ~ y)
   defrule exp0 = (?x:#exp1) : x

   ;Additive Operators
   public defproduction op1 : Symbol
   defrule op1 = (+) : `plus
   defrule op1 = (-) : `minus
   defrule exp1 = (?x:#exp1 ?f:#op1 ?y:#exp2!) : qquote($do ~ f ~ x ~ y)
   defrule exp1 = (?x:#exp2) : x

   ;Multiplicative Operators
   public defproduction op2 : Symbol
   defrule op2 = (*) : `times
   defrule op2 = (%) : `modulo
   defrule op2 = (/) : `divide
   defrule exp2 = (?x:#exp2 ?f:#op2 ?y:#exp3!) : qquote($do ~ f ~ x ~ y)
   defrule exp2 = (?x:#exp3) : x

   ;Shift Operators
   public defproduction op3 : Symbol
   defrule op3 = (<<) : `shift-left
   defrule op3 = (>>) : `shift-right
   defrule op3 = (>>>) : `arithmetic-shift-right
   defrule exp3 = (?x:#exp3 ?f:#op3 ?y:#exp4!) : qquote($do ~ f ~ x ~ y)
   defrule exp3 = (?x:#exp4) : x

   ;Bitwise Operators
   public defproduction op4 : Symbol
   defrule op4 = (&) : `bit-and
   defrule op4 = (~ |) : `bit-or
   defrule op4 = (^) : `bit-xor
   defrule exp4 = (?x:#exp4 ?f:#op4 ?y:#exp5!) : qquote($do ~ f ~ x ~ y)
   defrule exp4 = (?x:#exp5) : x

   defrule id != (and | or | not | #op0 | #op1 | #op2 | #op3 | #op4)

   ;               Expressions
   ;               ===========
   defrule exp5 = (?x:(#stanza-tag _ ...)) : x

   ;          User Defined Expressions
   ;          ========================
   public defproduction user-exp5
   defrule exp5 = inline #user-exp5

   ;                Function Call
   ;                =============
   defrule exp5 = (?x:#exp5(?ys:#exps!)) : qquote($do ~ x ~@ ys)

   ;               Type Application
   ;               ================
   defrule exp5 = (?x:#exp5<?ys:#types!>) : qquote($of ~ x ~@ ys)

   ;                 Curried Functions
   ;                 =================
   defrule exp5 = (?x:#exp5{?body ...}) :
      parse-syntax[core + current-overlays / #exp](qquote({~ x(~@ body)}))

   ;                  Set and Get
   ;                  ===========
   defrule exp5 = (?x:#exp5[?es:#exps!] = ?v:#exp!) : qquote($do set ~ x ~@ es ~ v)
   defrule exp5 = (?x:#exp5[?es:#exps!]) : qquote($do get ~ x ~@ es)

   ;                   Casts
   ;                   =====
   defrule exp5 = (?x:#exp5 as ?t:#type!) : qquote($as ~ x ~ t)
   defrule exp5 = (?x:#exp5 as? ?t:#type!) : qquote($as? ~ x ~ t)
   defrule id != (as | as?)

   ;                   Functions
   ;                   =========
   defproduction binder
   defrule binder = (?x:#id) : x
   defrule binder = ([?xs:#binder ... ?rest ...]) :
      CSE(closest-info(rest), "Expected a binder here.") when not empty?(rest)
      qquote($tuple ~@ xs)

   defproduction argbinding : KeyValue
   defrule argbinding = (?x:#binder : ?t:#type!) : x => t
   defrule argbinding = (?x:#binder) : x => `($none)

   defproduction arglist : [? ?]
   defrule arglist = ((?xs:#argbinding ... ?rest ...)) :
      if empty?(rest) : [map(key, xs), map(value, xs)]
      else : CSE(closest-info(rest), "Expected an argument declaration here.")

   defproduction fnheader! : [List List ?]
   fail-if fnheader! = ((@do _ ...)) :
      CSE(closest-info(), BAD-ARGLIST-MSG)
   defrule fnheader! = (?args:#arglist -> ?a2:#type!) :
      val [xs, a1] = args
      [xs, a1, a2]
   defrule fnheader! = (?args:#arglist) :
      val [xs, a1] = args
      [xs, a1, `($none)]
   fail-if fnheader! = () :
      CSE(closest-info(), "Expected argument list here.")

   defproduction fn-tag: Symbol
   defrule fn-tag = (fn) : `$fn
   defrule fn-tag = (fn*) : `$fn*
   defrule exp5 = (?tag:#fn-tag ?header:#fnheader! #:! ?body:#exp!) :
      val [xs, a1, a2] = header
      qquote(~ tag ~ xs ~ a1 ~ a2 ~ body)

   defproduction type-arg
   defproduction fn-name!
   defrule type-arg = ((~ @cap ?x:#id$)) : qquote($cap ~ x)
   defrule type-arg = (?x:#id) : x
   defrule fn-name! = (?x:#id<?ts:#type-arg ... ?rest ...>) :
      CSE(closest-info(rest), "Expected a type argument here.") when not empty?(rest)
      qquote($of ~ x ~@ ts)
   defrule fn-name! = (?x:#id) : x
   fail-if fn-name! = () : CSE(closest-info(), "Expected a function name here.")

   defproduction defn-tag: Symbol
   defrule defn-tag = (defn) : `$defn
   defrule defn-tag = (defn*) : `$defn*
   defrule exp5 = (?tag:#defn-tag ?name:#fn-name! ?header:#fnheader! #:! ?body:#exp!) :
      val [xs, a1, a2] = header
      qquote(~ tag ~ name ~ xs ~ a1 ~ a2 ~ body)

   defproduction defmethod-tag: Symbol
   defrule defmethod-tag = (defmethod) : `$defmethod
   defrule defmethod-tag = (defmethod*) : `$defmethod*
   defproduction defmethod
   defrule defmethod = (?tag:#defmethod-tag ?name:#fn-name! ?header:#fnheader! #:! ?body:#exp!) :
      val [xs, a1, a2] = header
      qquote(~ tag ~ name ~ xs ~ a1 ~ a2 ~ body)
   defrule exp5 = inline #defmethod

   defrule exp5 = (defmulti ?name:#fn-name! ?header:#fnheader!) :
      val [xs, a1, a2] = header
      qquote($defmulti ~ name ~ a1 ~ a2)

   defproduction multifn-tag
   defrule multifn-tag = (multifn) : `$fn
   defrule multifn-tag = (multifn*) : `$fn*
   defrule exp5 = (?tag:#multifn-tag #:! ((?headers:#fnheader! #:! ?bodies:#exp!) @...)) :
      val template =
         `($multi
            funcs{
               ($fn xs a1 a2 body)
            })
      fill-template(template, [
         `$fn => tag
         `funcs => nested $
            for ([xs, a1, a2] in headers, body in bodies) map :
               [`a1 => a1
                `a2 => a2
                `xs => xs
                `body => body]])
   fail-if exp5 = (?tag:#multifn-tag #:! ?rest ...) :
      CSE(closest-info(rest), "Expected a list of function branches here.")

   defrule id != (#fn-tag | #defn-tag | defmulti | #multifn-tag) 

   ;              Variables
   ;              =========
   defrule exp5 = (var ?name:#binder : ?type:#type! = ?value:#exp!) :
      qquote($defvar ~ name ~ type ~ value)
   defrule exp5 = (var ?name:#binder : ?type:#type!) :
      qquote($defvar ~ name ~ type ($none))
   defrule exp5 = (var ?name:#binder = ?value:#exp!) :
      qquote($defvar ~ name ($none) ~ value)
   defrule exp5 = (var ?name:#binder) :
      qquote($defvar ~ name ($none) ($none))
   fail-if exp5 = (var) :
      CSE(closest-info(), "Expected variable name after var keyword.")
      
   defrule id != (var)

   ;                Values
   ;                ======
   defrule exp5 = (val ?name:#binder : ?type:#type! = ?value:#exp!) :
      qquote($def ~ name ~ type ~ value)
   fail-if exp5 = (val ?name:#binder : #type! ?rest ...) :
      CSE(closest-info(rest), "No initializing value given to val %_." % [name])
   defrule exp5 = (val ?name:#binder = ?value:#exp!) :
      qquote($def ~ name ($none) ~ value)
   fail-if exp5 = (val ?name:#binder) :
      CSE(closest-info(), "No initializing value given to val %_." % [name])
   fail-if exp5 = (val) :
      CSE(closest-info(), "Expected value name after val keyword.")

   defrule id != (val)

   ;               Set Variable
   ;               ============
   defrule exp5 = (?x:#exp5 = ?y:#exp!) : qquote($set ~ x ~ y)
   defrule id != (=)

   ;               Visibilities
   ;               ============
   defproduction visibility
   defrule visibility = (public) : `$public
   defrule visibility = (protected) : `$protected
   
   defrule exp5 = (?tag:#visibility : ?e:#exp!) :
      qquote($public ~ e)
   defrule exp5 = (?tag:#visibility ?e:#exp!) :
      qquote($public ~ e)
      
   defrule id != (#visibility)   

   ;                   New Objects
   ;                   ===========   
   defrule exp5 = (new ?t:#type! : (?methods:#defmethod ... ?rest ...)) :
      CSE(closest-info(rest), "Expected a defmethod statement here.") when not empty?(rest)
      qquote($new ~ t ~@ methods)
   fail-if exp5 = (new ?t:#type! : ?rest ...) :
      CSE(closest-info(rest), "Expected a list of defmethod statements following new keyword.")
   defrule exp5 = (new ?t:#type!) :
      qquote($new ~ t)

   defrule id != (new)

   ;                    DefType
   ;                    =======
   defproduction type-name!
   defrule type-name! = (?x:#id<?ts:#ids!>) : qquote($of ~ x ~@ ts)
   defrule type-name! = (?x:#id) : x
   fail-if type-name! = () : CSE(closest-info(), "Expected the name of a type here.")

   defproduction defchild!
   defrule defchild! = (?a:#type-name! <: ?b:#type!) : qquote($defchild ~ a ~ b)
   fail-if defchild! = () : CSE(closest-info(), "Invalid syntax for child type declaration.")
      
   defrule exp5 = (deftype ?t:#type-name! <: ?p:#type!) :
      qquote($deftype ~ t ~ p)
   defrule exp5 = (deftype ?t:#type-name! : (?cs:#defchild! ...)) :
      qquote($deftype ~ t ($none) ~@ cs)
   defrule exp5 = (deftype ?t:#type-name!) :
      qquote($deftype ~ t ($none))
      
   defrule id != (deftype)   

   ;                    Tuples
   ;                    ======
   defrule exp5 = ([?es:#exps!]) :
      qquote($tuple ~@ es)

   ;                    Match
   ;                    =====
   defrule exp5 = (match(?xs:#exps!) #:! (
                      (?arglists:#arglist #:! ?bodies:#exp!) @...
                      ?rest ...)) :
      if not empty?(rest) :      
         CSE(closest-info(rest), "Expected match clause here.")

      val template =
         `($match xs
              branch{
                 ($branch args types body)
              })
      fill-template(template, [
         `xs => xs
         `branch => nested $
            for ([xs, ts] in arglists, b in bodies) map :
               [`types => ts
                `args => xs
                `body => b]])                
   fail-if exp5 = (match (_ ...)) :
      CSE(closest-info(), BAD-MATCH-MSG)
   fail-if exp5 = (match) :
      CSE(closest-info(), "Invalid syntax for match expression.")
      
   defrule id != (match)

   ;                    If
   ;                    ==
   defn compile-if (pred, conseq, alt) :
      val template = `(
         match(pred as? core/True|core/False) :
            (x:core/True) : conseq
            (x:core/False) : alt)
      parse-syntax[core / #exp](      
         fill-template(template, [
            `x => gensym(`x)
            `pred => pred
            `conseq => conseq
            `alt => alt]))
            
   defproduction if-exp
   defrule if-exp = (if ?pred:#exp! #:! ?conseq:#exp! else : ?alt:#exp!) :
      compile-if(pred, conseq, alt)
   defrule if-exp = (if ?pred:#exp! #:! ?conseq:#exp! else ?alt:#if-exp) :
      compile-if(pred, conseq, alt)
   defrule if-exp = (if ?pred:#exp! #:! ?conseq:#exp!) :
      compile-if(pred, conseq, false)
   defrule exp5 = inline #if-exp

   defrule id != (if | else)

   ;                   Let
   ;                   ===
   defrule exp5 = (let #:! ?body:#exp!) :
      qquote(($let ~ body))
   defrule id != (let)     

   ;                   Where
   ;                   =====
   defrule exp5 = (?x:#exp5 where #:! ?defs:#exp!) :
      parse-syntax[core / #exp](
         qquote(let : (~ defs ~ x)))
   defrule id != (where)

   ;                     For
   ;                     ===
   defproduction in!
   defrule in! = (in) : `in
   fail-if in! = () : CSE(closest-info(), "Expected the in keyword here.")
   
   fail-if exp5 = (for ?x:#binder #in! ?y:#exp! :) :
      CSE(closest-info(), BAD-FOR-MSG)
   defrule exp5 = (for ?x:#binder #in! ?y:#exp! ?f:#exp! #:! ?body:#exp!) :
      parse-syntax[core / #exp](
         qquote(for (~ x in ~ y) ~ f : ~ body))
   defrule exp5 = (for ((?xs:#binder #in! ?ys:#exp!) @... ?rest ...) ?f:#exp! #:! ?body:#exp!) :
      if not empty?(rest) :
         CSE(closest-info(rest), "Expected a binding form here for the for expression.")
      parse-syntax[core / #exp](   
         qquote(~ f((fn ~ xs : ~ body) ~@ ys)))
   fail-if exp5 = (for) :
      CSE(closest-info(), "Expected binding forms after for keyword.")
      
   defrule id != (for)

   ;                   While
   ;                   =====
   defrule exp5 = (while ?pred:#exp! #:! ?body:#exp!) :
      val template = `(
         let :
            defn* loop () :
               if (pred as? core/True|core/False) :
                  body
                  loop()
            loop())
      parse-syntax[core / #exp](
         fill-template(template, [
            `loop => gensym(`loop)
            `pred => pred
            `body => body]))

   defrule id != (while)

   ;                   When
   ;                   ====
   defrule exp5 = (?x:#exp5 when ?pred:#exp! else ?y:#exp!) :
      parse-syntax[core / #exp](
         qquote(if ~ pred : ~ x else : ~ y))         
   defrule exp5 = (?x:#exp5 when ?pred:#exp!) :
      parse-syntax[core / #exp](
         qquote(if ~ pred : ~ x))

   defrule id != (when)

   ;                    To/Through
   ;                    ==========
   defproduction range-op
   defrule range-op = (to) : false
   defrule range-op = (through) : true
   
   defrule exp5 = (?x:#exp5 ?inc:#range-op ?end:#exp! by ?step:#exp!) :
      parse-syntax[core / #exp](
         qquote(core/Range(~ start, ~ end, ~ step, ~ inc)))
   defrule exp5 = (?x:#exp5 ?inc:#range-op ?end:#exp!) :      
      parse-syntax[core / #exp](
         qquote(core/Range(~ start, ~ end, 1, ~ inc)))

   defrule id != (#range-op)

   ;                 Function Application
   ;                 ====================
   defrule exp5 = (?f:#exp5 $ ?v:#exp!) :
      qquote($do ~ f ~ v)
      
   defrule id != ($)   

   ;                  Anonymous Functions
   ;                  ===================
   defrule exp5 = ({?body ...}) :
      val args = Vector<Symbol>()
      val types = Vector<?>()
      defn new-arg (t) :
         val a = gensym(`arg)
         add(args, a)
         add(types, t)
         a

      defn replace (xs:List) -> List :
         match-syntax[core + current-overlays](xs) :
            (?h:((@afn | @do-afn | @quote | $quote) _ ...) ?rest ...) :
               cons(h, replace(rest))
            ((?h ...) ?rest ...) :
               cons(replace(h), replace(rest))
            (~ _ : ?t:#type! ?rest ...) :
               cons(new-arg(t), replace(rest))
            (~ _ ?rest ...) :
               cons(new-arg(false), replace(rest))
            (?h ?rest ...) :
               cons(h, replace(rest))
            () :
               List()
               
      val body* = parse-syntax[core + current-overlays / #exp](
         replace(List(body)))         

      if empty?(args) :
         val template = `(
            multifn :
               () : body
               (x:?) : body)
         parse-syntax[core / #exp](      
            fill-template(template, [
               `body => body*
               `x => gensym(`x)]))
      else :
         val template = `(fn args : body)
         parse-syntax[core / #exp](
            fill-template(template, [
               `body => body*
               `args => for (x in args, t in types) seq-append :
                  if t is False : List(x)
                  else : qquote(~ x : ~ t)]))

   ;                       Is/Is-Not
   ;                       =========
   defrule exp5 = (?x:#exp5 is ?t:#type!) :
      parse-syntax[core / #exp](
         qquote(
            match(~ x) :
               (x: ~ t) : true
               (x) : false))
               
   defrule exp5 = (?x:#exp5 is-not ?t:#type!) :
      parse-syntax[core / #exp](
         qquote(
            match(~ x) :
               (x: ~ t) : false
               (x) : true))

   defrule id != (is | is-not)

   ;                        Label
   ;                        =====
   defrule exp5 = (label<?t:#type$> ?break:#id! #:! ?body:#exp!) :
      parse-syntax[core / #exp](
         qquote(core/LabeledScope<~ t>((fn (~ break) -> ~ t : ~ body))))
   defrule exp5 = (label ?break:#id! #:! ?body:#exp!) :
      parse-syntax[core / #exp](
         qquote(label<?> ~ break : ~ body))
         
   defrule id != (label)      

   ;                      Generate
   ;                      ========   
   defrule exp5 = (generate<?t:#type$> #:! ?body:#exp!) :
      parse-syntax[core / #exp](
         qquote(core/Generator<~ t>((fn (yield, break) : ~ body))))
   defrule exp5 = (generate #:! ?body:#exp!) :
      parse-syntax[core / #exp](
         qquote(generate<?> : ~ body))
         
   defrule id != (generate)      

   ;                      KeyValue
   ;                      ========
   defrule exp5 = (?k:#exp5 => ?v:#exp!) :
      parse-syntax[core / #exp](
         qquote(core/KeyValue(~ k ~ v)))

   defrule id != (=>)

   ;                      Switch
   ;                      ======
   defn gen-switch-exp (pred, clauses:List, alt) -> ? :
      if empty?(clauses) :
         alt
      else :
         val [v, body] = head(clauses)
         val rest = gen-switch-exp(pred, tail(clauses), alt)
         qquote(if ~ pred(~ v) : ~ body else : ~ rest)

   defproduction switch-clause! : [? ?]
   defrule switch-clause! = ((! else) ?v:#exp! #:! ?body:#exp!) :
      [v, body]

   defrule exp5 = (switch ?pred:#exp! #:! (
                      ?cs:#switch-clause! ...
                      else #:! ?alt:#exp$)) :
      parse-syntax[core / #exp](                
         gen-switch-exp(pred, cs, alt))

   defrule exp5 = (switch ?pred:#exp! #:! (
                      ?cs:#switch-clause! ...)) :
      val alt = qquote(core/fatal("No appropriate switch clause."))
      parse-syntax[core / #exp](
         gen-switch-exp(pred, cs, alt))

   defrule id != (switch)

   ;                     Let-Var
   ;                     =======
   defrule exp5 = (let-var ?x:#id! = ?e:#exp! #:! ?body:#exp!) :
      val template = `(
         let :
            val oldv = x
            val v = e
            core/dynamic-wind(
               fn () : x = v
               fn () : body
               fn (f) : x = oldv))
      parse-syntax[core / #exp](         
         fill-template(template, [
            `x => x
            `e => e
            `v => gensym(`v)
            `f => gensym(`f)
            `oldv => gensym(`oldv)
            `body => body]))

   defrule id != (let-var)

   ;                      Resource
   ;                      ========
   defrule exp5 = (resource ?name:#id! : ?type:#type! = ?value:#exp! ?rest:#exps!) :
      val template = `(
         core/with-resource(
            fn (x:type) : body
            value))
      parse-syntax[core / #exp](      
         fill-template(template, [
            `x => name
            `type => type
            `value => value
            `body => rest]))
   defrule exp5 = (resource ?name:#id! = ?value:#exp! ?rest:#exps!) :
      val template = `(
         core/with-resource(
            fn (x) : body
            value))
      parse-syntax[core / #exp](      
         fill-template(template, [
            `x => name
            `value => value
            `body => rest]))
            
   defrule id != (resource)

   ;                      Try
   ;                      ===
   defproduction catch-clause : Splice
   fail-if catch-clause = (catch (@do _ ...)) :
      CSE(closest-info(), "Invalid catch clause. Did you forget a space between the catch keyword and the argument list?")
   defrule catch-clause = (catch ?arglist:(_ ...) #:! ?body:#exp!) :
      splice(List(arglist `: body))
   fail-if catch-clause = (catch) :
      CSE(closest-info(), "Expected an argument list after catch keyword.")
      
   defrule exp5 = (try #:! ?body:#exp!
                   ?clauses:#catch-clause ...
                   finally #:! ?fbody:#exp!) :
      val template = `(
         core/with-finally(
            fn () :
               core/with-exception-handler(
                  fn () :
                     body
                  fn (e) :
                     catch{
                        core/throw(e)
                     }{
                        match(e) :
                           clauses
                           (e) : core/throw(e)
                     })
            fn (f) :
               fbody))
      parse-syntax[core / #exp](         
         fill-template(template, [
            `body => body
            `e => gensym(`e)
            `f => gensym(`f)
            `catch => choice(empty?(clauses))
            `clauses => splice(clauses)
            `fbody => fbody]))

   defrule exp5 = (try #:! ?body:#exp! ?clauses:#catch-clause ...) :
      if empty?(clauses) :
         CSE(closest-info(), "Try expression without any catch or finally clauses.")
      val template = `(
         core/with-exception-handler(
            fn () :
               body
            fn (e) :
               match(e) :
                  clauses
                  (e) : core/throw(e)))
      parse-syntax[core / #exp](
         fill-template(template, [
            `body => body
            `e => gensym(`e)
            `clauses => splice(clauses)]))

   defrule id != (try)

   ;                      Attempt
   ;                      =======
   defn compile-attempt (conseq, alt) :
      val template = `(
         core/with-attempt(
            fn* () : conseq,
            fn* () : alt))
      parse-syntax[core / #exp](      
         fill-template(template, [
            `conseq => conseq,
            `alt => alt]))

   defproduction attempt-exp
   defrule attempt-exp = (attempt #:! ?conseq:#exp! else : ?alt:#exp!) :
      compile-attempt(conseq, alt)
   defrule attempt-exp = (attempt #:! ?conseq:#exp! else ?alt:#attempt-exp) :
      compile-attempt(conseq, alt)
   defrule attempt-exp = (attempt #:! ?conseq:#exp!) :
      compile-attempt(conseq, false)
   defrule exp5 = inline #attempt-exp

   defrule id != (attempt)

   ;                      DefPackage
   ;                      ==========
   defproduction prefix-clause!
   defrule prefix-clause! = (prefix => ?p:#id!) :
      qquote($prefix ~ p)
   defrule prefix-clause! = (prefix(?xs:#id! ...) => ?p:#id!) :
      qquote($prefix-of ~ xs ~ p)
   fail-if prefix-clause! = () :
      CSE(closest-info(), "Expected prefix clause here.")

   defproduction import-clause!
   defrule import-clause! = (import ?name:#id! with #:! (?ps:#prefix-clause! ...)) :
      qquote($import ~ name ~@ ps)
   defrule import-clause! = (import ?name:#id!) :
      qquote($import ~ name)
   fail-if import-clause! = () :
      CSE(closest-info(), "Expected import clause here.")

   defrule exp5 = (defpackage ?name:#id! : (?imports:#import-clause! ...)) :
      qquote($package ~ name ~@ imports)
   defrule exp5 = (defpackage ?name:#id!) :
      qquote($package ~ name)

   defrule id != (defpackage)


   ;                      DefStruct
   ;                      =========
   defn parse-struct-field (info:False|FileInfo, name, type, ops, vs) :
      val options = map(KeyValue, ops, vs)
      val setter = unwrap-token(lookup?(options, `setter))
      if setter is-not Symbol|False :
         CSE(info, "Setter name is expected to be either false or a symbol.")
      val as-method? = unwrap-token(lookup?(options, `as-method))
      if as-method? is-not True|False :
         CSE(info, "As-method option is expected to be either true or false.")
      StructField(name, type, as-method?, setter, gensym(name))

   defn gen-struct-exp (sname, targs, parent,
                        fields:List<StructField>,
                        options:List<KeyValue<Symbol, ?>>) :
      val template = `((
         class-def{
            deftype Name<Targs>
         }{
            deftype Name<Targs> <: Parent
         }
         getter-multis{
            defmulti field<Cargs> (x: Name<Cargs>) -> type
         }
         setter-multis{
            defmulti set-field<Cargs> (x: Name<Cargs>, field:type) -> core/False
         }
         defn Constructor<Targs> (args{field : type}) :
            boxes{
               var @field : type = field
            }
            new Name<Targs> :
               getters{
                  defmethod field (this) : value
               }
               setters{
                  defmethod set-field (this, field:type) :
                     @field = field
               }))
               
      parse-syntax[core / #exp](         
         fill-template(template, [
            `class-def => choice(unwrap-token(parent) is False)
            `Name => sname
            `Constructor => lookup?(options, `constructor, sname)
            `Targs => splice(targs)
            `Cargs => splice $ for v in targs map :
                         List(`@cap, v)
            `Parent => parent
            `getter-multis => nested $ to-list $ generate :
               for f in fields do :
                  if not as-method?(f) :
                     yield $ [`field => name(f)
                              `type => type(f)]
            `setter-multis => nested $ to-list $ generate :
               for f in fields do :
                  if (not as-method?(f)) and setter(f) != false :
                     yield $ [`set-field => setter(f)
                              `field => name(f)
                              `type => type(f)]
            `args => nested $
               for f in fields map :
                  [`field => name(f)
                   `type => type(f)]
            `boxes => nested $ to-list $ generate :
               for f in fields do :
                  if setter(f) != false :
                     yield $ [`@field => box(f)
                              `type => type(f)
                              `field => name(f)]
            `getters => nested $
               for f in fields map :
                  [`field => name(f)
                   `value => if setter(f) is False : name(f)
                             else : box(f)]
            `setters => nested $ to-list $ generate :
               for f in fields do :
                  if setter(f) != false :
                     yield $ [`set-field => setter(f)
                              `@field => box(f)
                              `field => name(f)
                              `type => type(f)]]))

   defproduction struct-name! : [Symbol|Token, List<Symbol|Token>]  
   defrule struct-name! = (?name:#id!<?targs:#id! ...>) :
      [name, targs]
   defrule struct-name! = (?name:#id!) :
      [name, List()]
   fail-if struct-name! = () :
      CSE(closest-info(), "Expected name for struct here.")

   defproduction struct-parent
   defrule struct-parent = (<: ?parent:#type!) : parent
   defrule struct-parent = () : false

   defproduction struct-field! : StructField
   defproduction field-option: Symbol
   defrule field-option = (?x: (as-method | setter)) : unwrap-token(x)
   
   defrule struct-field! = (?name:#id! : ?type:#type! with #:! (
                              (?ops:#field-option => ?vs) @...
                              ?rest ...)) :
      if not empty?(rest) :
         CSE(closest-info(rest), "Invalid struct field option.")
      parse-struct-field(closest-info(), name, type, ops, vs)

   defrule struct-field! = (?name:#id! with #:! (
                              (?ops:#field-option => ?vs) @...
                              ?rest ...)) :
      if not empty?(rest) :
         CSE(closest-info(rest), "Invalid struct field option.")
      parse-struct-field(closest-info(), name, `?, ops, vs)
   defrule struct-field! = (?name:#id! : ?type:#type!) :
      parse-struct-field(closest-info(), name, type, List(), List())
   defrule struct-field! = (?name:#id!) :
      parse-struct-field(closest-info(), name, `?, List(), List())
   fail-if struct-field! = () :
      CSE(closest-info(), "Expected struct field declaration here.")

   defproduction struct-option! : KeyValue<Symbol,?>
   defrule struct-option! = (constructor => ?name:#id!) :
      `constructor => name
   fail-if struct-option! = () :
      CSE(closest-info(), "Expected struct option declaration here.")

   defproduction struct-options: List<KeyValue<Symbol,?>>
   defrule struct-options = (with #:! (?ops:#struct-option! ...)) : ops
   defrule struct-options = () : List()

   defrule exp5 = (defstruct ?struct-name:#struct-name! ?parent:#struct-parent :
                      ?fields:#struct-field! ...
                   ?ops:#struct-options) :
      val [name, targs] = struct-name
      gen-struct-exp(name, targs, parent, fields, ops)
   defrule exp5 = (defstruct ?struct-name:#struct-name! ?parent:#struct-parent ?ops:#struct-options) :
      val [name, targs] = struct-name
      gen-struct-exp(name, targs, parent, List(), ops)

   defrule id != (defstruct)

   ;                      #define
   ;                      #======
   defrule exp5 = (~ #define(?flag:#id$)) :
      add-flag(unwrap-token(flag))
      `($begin)
   fail-if exp5 = (~ #define) :
      CSE(closest-info(), "Incorrect syntax for #define.")

   defrule id != (~ #define)

   ;               #if-defined/#if-not-defined
   ;               ===========================
   defproduction list!
   defrule list! = ((?xs ...)) : xs
   fail-if list! = () : CSE(closest-info(), "Expected a list here.")

   defrule exp5 = (~ #if-defined(?flag:#id$) #:! ?conseq:#list! ~ #else #:! ?alt:#list!) :
      val body = if flag-defined?(unwrap-token(flag)) : conseq
                 else : alt
      parse-syntax[core + current-overlays / #exp](List(body))
   defrule exp5 = (~ #if-defined(?flag:#id$) #:! ?conseq:#list!) :
      if flag-defined?(unwrap-token(flag)) : parse-syntax[core + current-overlays / #exp](List(conseq))
      else : `($begin)
   fail-if exp5 = (~ #if-defined) :
      CSE(closest-info(), "Incorrect syntax for #if-defined.")

   defrule exp5 = (~ #if-not-defined(?flag:#id$) #:! ?conseq:#list! ~ #else #:! ?alt:#list!) :
      val body = if not flag-defined?(unwrap-token(flag)) : conseq
                 else : alt
      parse-syntax[core + current-overlays / #exp](List(body))
   defrule exp5 = (~ #if-not-defined(?flag:#id$) #:! ?conseq:#list!) :
      if not flag-defined?(unwrap-token(flag)) : parse-syntax[core + current-overlays / #exp](List(conseq))
      else : `($begin)
   fail-if exp5 = (~ #if-not-defined) :
      CSE(closest-info(), "Incorrect syntax for #if-not-defined.")

   defrule id != (~ #if-defined | ~ #if-not-defined)

   ;                      Quasiquote
   ;                      ==========
   defrule exp5 = (qquote(?sexp ...)) :
      defn fill (sexp:List) -> List :
         match-syntax(sexp) :
            (~ ~ ?x ?rest ...) :
               qquote(core/cons(~ x, ~ (fill(rest))))
            (~@ ?x ?rest ...) :
               qquote(core/append(~ x, ~ (fill(rest))))
            ((?fs ...) ?rest ...) :
               qquote(core/cons(~ (fill(fs)), ~ (fill(rest))))
            (?x ?rest ...) :
               qquote(core/cons((@quote ~ x), ~ (fill(rest))))
            () :
               qquote(core/List())
      parse-syntax[core + current-overlays / #exp](fill(sexp))         
   fail-if exp5 = (qquote) :
      CSE(closest-info(), "Incorrect syntax for qquote.")
      
   defrule id != (qquote)

   ;                      DefSyntax
   ;                      =========
   defproduction rule : ExpRule
   ;Import rule
   defproduction from!
   defrule from! = (from) : false
   defrule from! = () : CSE(closest-info(), "Expected the from keyword here.")
   defrule rule = (import (?names:#ids!) #from! ?package:#id!) : ImportRule(names, package)
   defrule rule = (import ?name:#id! #from! ?package:#id!) : ImportRule(List(name), package)

   ;Defproduction rule
   defproduction public? : True|False
   defrule public? = (public) : true
   defrule public? = () : false
   defrule rule = (?p:#public? defproduction ?name:#id! : ?type:#type!) : DefProductionRule(name, type, p)
   defrule rule = (?p:#public? defproduction ?name:#id!) : DefProductionRule(name, `?, p)

   ;Defrule rule
   defn prod? (x) :
      match(unwrap-token(x)) :
         (x:Symbol) : prefix?(x, "#")
         (x) : false
   defproduction prod! : Symbol|Token
   defrule prod! = (?x) when prod?(x) : x
   fail-if prod! = () : CSE(closest-info(), "Expected a production pattern here.")

   defrule rule = (defrule ?e:#id! = (?pat ...) when ?guard:#exp! #:! ?body:#exp!) : DefActionRule(e, pat, One(guard), body)
   defrule rule = (defrule ?e:#id! = (?pat ...) #:! ?body:#exp!) : DefActionRule(e, pat, None(), body)
   defrule rule = (defrule ?e:#id! = inline ?ie:#prod!) : DefInlineRule(e, ie)
   defrule rule = (defrule ?e:#id! != (?pat ...) when ?guard:#exp!) : DefNotRule(e, pat, One(guard))
   defrule rule = (defrule ?e:#id! != (?pat ...)) : DefNotRule(e, pat, None())
   fail-if rule = (defrule ?e:#id! (!= | =)) : CSE(closest-info(), "Expected a pattern definition for rule.")
   fail-if rule = (defrule ?e:#id!) : CSE(closest-info(), "Expected either = or != operator after defrule.")

   ;Failif rule
   defproduction =!
   defrule =! = (=) : false
   fail-if =! = () : CSE(closest-info(), "Expected the = operator here.")
   defrule rule = (fail-if ?e:#id! #=! (?pat ...) when ?guard:#exp! #:! ?body:#exp!) : DefFailRule(e, pat, One(guard), body)
   defrule rule = (fail-if ?e:#id! #=! (?pat ...) #:! ?body:#exp!) : DefFailRule(e, pat, None(), body)
   fail-if rule = (fail-if ?e:#id! #=!) : CSE(closest-info(), "Expected a pattern definition for fail-if rule.")

   ;Stanza expression rule
   defrule rule = (?e:#exp) : StanzaExpressionRule(e)

   ;Defsyntax rule
   defrule exp5 = (defsyntax ?name:#id! #:! (?rs:#rule ... ?rest ...)) :
      CSE(closest-info(rest), "Expected either rule definition or expression." % [rest]) when not empty?(rest)
      parse-syntax[core / #exp](compile(DefSyntaxRule(name, rs)))

   defrule id != (defsyntax)

   ;                      MatchSyntax
   ;                      ===========
   ;Match pattern
   defproduction match-pat : MatchPattern
   defrule match-pat = ((?pat ...) when ?guard:#exp! #:! ?body:#exp!) : MatchPattern(pat, One(guard), body)
   defrule match-pat = ((?pat ...) #:! ?body:#exp!) : MatchPattern(pat, None(), body)
   
   ;Match packages
   defproduction match-pkg! : [Symbol|Token List<Symbol|Token>]
   defrule match-pkg! = (?base:#id! + ?overlays:#ids!) : [base, overlays]
   defrule match-pkg! = (?base:#id! _) : CSE(closest-info(), "Expected + operator following base package.")
   defrule match-pkg! = (?base:#id!) : [base, List()]

   defrule exp5 = (match-syntax[?pkgs:#match-pkg!](?arg:#exp$) #:! (?ps:#match-pat ... ?rest ...)) :
      CSE(closest-info(rest), "Expected match pattern here.") when not empty?(rest)
      val [base, overlays] = pkgs
      parse-syntax[core / #exp](
         compile(MatchSyntaxRule(base, overlays, arg, ps)))
   defrule exp5 = (match-syntax(?arg:#exp$) #:! (?ps:#match-pat ... ?rest ...)) :
      CSE(closest-info(rest), "Expected match pattern here.") when not empty?(rest)
      parse-syntax[core / #exp](
         compile(MatchSyntaxRule(`empty, List(), arg, ps)))
   fail-if exp5 = (match-syntax) :
      CSE(closest-info(), "match-syntax must be followed by form to match upon in parenthesis.")

   defrule id != (match-syntax)

   ;                      ParseSyntax
   ;                      ===========
   defproduction parse-pat : List
   defrule parse-pat = (?e:#id! ~ ...) : List(e, `...)
   defrule parse-pat = (?e:#id!) : List(e)

   defproduction parse-props : [Symbol|Token, List<Symbol|Token>, List]
   defrule parse-props = (?base:#id + ((! /) ?overlays:#id) @... / ?pat:#parse-pat) :
      [base, overlays, pat]
   defrule parse-props = (?base:#id + ((! /) ?overlays:#id) @...) :
      CSE(closest-info(), "parse-syntax is missing specified pattern.")
   defrule parse-props = (?base:#id / ?pat:#parse-pat) :
      [base, List(), pat]
   defrule parse-props = () :
      CSE(closest-info(), "parse-syntax requires packages followed by pattern.")

   defrule exp5 = (parse-syntax[?props:#parse-props](?arg:#exp$)) :
      val [base, overlays, pattern] = props
      val template = `(
         match-syntax[base + overlays](form) :
            (?x:pattern) : x)
      parse-syntax[core / #exp](      
         fill-template(template, [
            `base => base
            `overlays => splice(overlays)
            `form => arg
            `pattern => splice(pattern)]))
            
   defrule id != (parse-syntax)

   ;                      #use-syntax
   ;                      #==========
   defproduction use-syntax-func : (List<Symbol>, () -> ?) -> ?
   defrule use-syntax-func = (~ #use-syntax) : with-syntax
   defrule use-syntax-func = (~ #use-added-syntax) : with-added-syntax

   defrule exp5 = (?f:#use-syntax-func(?names:#ids!) ?rest ...) :
      f{unwrap-all(names), _} $ fn () :
         parse-syntax[core + current-overlays / #exp](List(rest))
   fail-if exp5 = (#use-syntax-func) :
      CSE(closest-info(), "Invalid syntax for #use-syntax/#use-added-syntax.")
      
   defrule id != (#use-syntax-func)   

   ;                      #with-syntax
   ;                      #===========
   defproduction with-syntax-func : (List<Symbol>, () -> ?) -> ?
   defrule with-syntax-func = (~ #with-syntax) : with-syntax
   defrule with-syntax-func = (~ #with-added-syntax) : with-added-syntax

   defrule exp5 = (?f:#with-syntax-func(?names:#ids!) #:! ?body) :
      f{unwrap-all(names), _} $ fn () :
         parse-syntax[core + current-overlays / #exp](List(body))
   fail-if exp5 = (#with-syntax-func) :
      CSE(closest-info(), "Invalid syntax for #with-syntax/#with-added-syntax.")
      
   defrule id != (#with-syntax-func)   

   ;                 Negation Operators
   ;                 ==================
   defrule exp5 = ((- ?x:#exp$)) : qquote($do negate ~ x)
   defrule exp5 = ((~ ~ ?x:#exp$)) : qquote($do bit-not ~ x)
   defrule id != (~ ~)

   ;                  Quote Syntax
   ;                  ============
   defrule exp5 = ((@quote ?rest ...)) :
      if length(rest) == 1 : qquote($quote ~ (head(rest)))
      else : CSE(closest-info(rest), "Expected a single form here.")

   ;                  Begin Expression
   ;                  ================
   defrule exp5 = ((?x:#exp ?xs:#exps!)) :
      if empty?(xs) : x
      else : qquote($begin ~ x ~@ xs)
   defrule exp5 = (()) : wrap-info(closest-info(), `($begin))

   ;                        LoStanza Externs
   ;                        ================
   defproduction ->!
   defrule ->! = (?x: ->) : true
   fail-if ->! = () : CSE(closest-info(), "Expected -> operator here.")
   
   defrule exp5 = (extern defn ?name:#id! ((?xs:#id! #:! ?ts:#ls-type!) @...) #->! ?rt:#ls-type! #:! ?c:#ls-stmt!) :
      qquote($ls-extern-fn ~ name ~ xs ~ ts ~ rt ~ c)
   defrule exp5 = (extern ?name:#id! #:! ?t:#ls-type!) :
      qquote($ls-extern ~ name ~ t)

   ;                      LoStanza DefType
   ;                      ================
   defproduction ls-type-name
   defrule ls-type-name = (?name:#id!<?targs:#ids!>) : qquote($ls-of ~ name ~@ targs)
   defrule ls-type-name = (?name:#id!) : name

   defproduction ls-type-parent
   defrule ls-type-parent = (<: ?t:#type!) : t
   defrule ls-type-parent = () : `($none)

   fail-if exp5 = (lostanza deftype ?name:#ls-type-name ?p:#ls-type-parent : ?x:(~ ...)) :
      CSE(closest-info(x), "Rest field ellipsis must be preceded by field declaration.")
   defrule exp5 = (lostanza deftype ?name:#ls-type-name ?p:#ls-type-parent :
                      ((! ~ ...) ?fields:#id! #:! ?types:#ls-type!) @... ~ ...) :
      qquote($ls-deftype ~ name ~ p
                ~ (but-last(fields)) ~ (last(fields))
                ~ (but-last(types)) ~ (last(types)))
   defrule exp5 = (lostanza deftype ?name:#ls-type-name ?p:#ls-type-parent :
                      (?fields:#id! #:! ?types:#ls-type!) @...) :
      qquote($ls-deftype ~ name ~ p
                ~ fields ($none)
                ~ types ($none))
   defrule exp5 = (lostanza deftype ?name:#ls-type-name ?p:#ls-type-parent) :
      qquote($ls-deftype ~ name ~ p () ($none) () ($none))

   defrule id != (~ ...)

   
   ;                        LoStanza Defn
   ;                        =============
   defproduction type-arg!
   defrule type-arg! = (?x:#type-arg) : x
   fail-if type-arg! = () : CSE(closest-info(), "Type argument expected here.")

   defproduction ls-defn-tag : Symbol
   defrule ls-defn-tag = (defn) : `$ls-defn
   defrule ls-defn-tag = (defn*) : `$ls-defn*
   
   defrule exp5 = (lostanza ?tag:#ls-defn-tag ?name:#id!<?targs:#type-arg! ...>
                      ((?xs:#id! #:! ?ts:#ls-type!) @...) #->! ?rt:#ls-type! #:! ?c:#ls-stmt!) :
      qquote(~ tag ($ls-of ~ name ~@ targs) ~ xs ~ ts ~ rt ~ c)
   defrule exp5 = (lostanza ?tag:#ls-defn-tag ?name:#id!
                      ((?xs:#id! #:! ?ts:#ls-type!) @...) #->! ?rt:#ls-type! #:! ?c:#ls-stmt!) :
      qquote(~ tag ~ name ~ xs ~ ts ~ rt ~ c)

   ;                        LoStanza Defmethod
   ;                        ==================
   defproduction ls-defmethod-tag : Symbol
   defrule ls-defmethod-tag = (defmethod) : `$ls-defmethod
   defrule ls-defmethod-tag = (defmethod*) : `$ls-defmethod*
   
   defrule exp5 = (lostanza ?tag:#ls-defmethod-tag ?multi:#id!<?targs:#type-arg! ...>
                      ((?xs:#id! #:! ?ts:#ls-type!) @...) #->! ?rt:#ls-type! #:! ?c:#ls-stmt!) :
      qquote(~ tag ($ls-of ~ multi ~@ targs) ~ xs ~ ts ~ rt ~ c)

   defrule exp5 = (lostanza ?tag:#ls-defmethod-tag ?multi:#id!
                      ((?xs:#id! #:! ?ts:#ls-type!) @...) #->! ?rt:#ls-type! #:! ?c:#ls-stmt!) :
      qquote(~ tag ~ multi ~ xs ~ ts ~ rt ~ c)

   ;                        LoStanza Vars
   ;                        =============
   defrule exp5 = (lostanza var ?name:#id! : ?type:#ls-type! = ?e:#ls-exp!) :
      qquote($ls-defvar ~ name ~ type ~ e)
   defrule exp5 = (lostanza var ?name:#id! : ?type:#ls-type!) :
      qquote($ls-defvar ~ name ~ type ($none))

   ;                        LoStanza Vals
   ;                        =============
   defrule exp5 = (lostanza val ?name:#id! : ?type:#ls-type! = ?e:#ls-exp!) :
      qquote($ls-def ~ name ~ type ~ e)
   defrule exp5 = (lostanza val ?name:#id! = ?e:#ls-exp!) :
      qquote($ls-def ~ name ($none) ~ e)

   ;                        LoStanza Let
   ;                        ============   
   defrule exp5 = (lostanza let #:! ?c:#ls-stmt!) :
      qquote($ls-let ~ c)   

   ;                    Atoms
   ;                    =====
   defrule exp5 = (?x:#literal) : x
   defrule exp5 = (?x:#id) : x

   ;                      LoStanza Error Handling
   ;                      =======================
   public defproduction ls-type!
   public defproduction ls-type$
   public defproduction ls-types!
   defrule ls-type! = (?x:#ls-type) : x
   fail-if ls-type! = () : CSE(closest-info(), "LoStanza type expected here.")
   defrule ls-type$ = (?x:#ls-type! ?rest ...) :
      CSE(closest-info(), "Expected a single LoStanza type here.") when not empty?(rest)
      x
   defrule ls-types! = (?x:#ls-type ... ?rest ...) :
      CSE(closest-info(rest), "Expected a LoStanza type here.") when not empty?(rest)
      x

   public defproduction ls-exp!
   public defproduction ls-exp$
   public defproduction ls-exps!
   defrule ls-exp! = (?x:#ls-exp) : x
   fail-if ls-exp! = () : CSE(closest-info(), "LoStanza expression expected here.")
   defrule ls-exp$ = (?x:#ls-exp! ?rest ...) :
      CSE(closest-info(), "Expected a single LoStanza expression here.") when not empty?(rest)
      x
   defrule ls-exps! = (?x:#ls-exp ... ?rest ...) :
      CSE(closest-info(rest), "Expected a LoStanza expression here.") when not empty?(rest)
      x

   public defproduction ls-stmt!
   public defproduction ls-stmt$
   public defproduction ls-stmts!
   defrule ls-stmt! = (?x:#ls-stmt) : x
   fail-if ls-stmt! = () : CSE(closest-info(), "LoStanza statement expected here.")
   defrule ls-stmt$ = (?x:#ls-stmt! ?rest ...) :
      CSE(closest-info(), "Expected a single LoStanza statement here.") when not empty?(rest)
      x
   defrule ls-stmts! = (?x:#ls-stmt ... ?rest ...) :
      CSE(closest-info(rest), "Expected a LoStanza statement here.") when not empty?(rest)
      x

   defproduction ls-exp0!
   defrule ls-exp0! = (?x:#ls-exp0) : x
   fail-if ls-exp0! = () : CSE(closest-info(), "Expected a LoStanza expression here.")

   defproduction ls-exp1!
   defrule ls-exp1! = (?x:#ls-exp1) : x
   fail-if ls-exp1! = () : CSE(closest-info(), "Expected a LoStanza expression here.")

   defproduction ls-exp2!
   defrule ls-exp2! = (?x:#ls-exp2) : x
   fail-if ls-exp2! = () : CSE(closest-info(), "Expected a LoStanza expression here.")

   defproduction ls-exp3!
   defrule ls-exp3! = (?x:#ls-exp3) : x
   fail-if ls-exp3! = () : CSE(closest-info(), "Expected a LoStanza expression here.")

   defproduction ls-exp4!
   defrule ls-exp4! = (?x:#ls-exp4) : x
   fail-if ls-exp4! = () : CSE(closest-info(), "Expected a LoStanza expression here.")

   defproduction ls-exp5!
   defrule ls-exp5! = (?x:#ls-exp5) : x
   fail-if ls-exp5! = () : CSE(closest-info(), "Expected a LoStanza expression here.")

   defproduction ls-exp6!
   defrule ls-exp6! = (?x:#ls-exp6) : x
   fail-if ls-exp6! = () : CSE(closest-info(), "Expected a LoStanza expression here.")

   ;                      LoStanza Types
   ;                      ==============
   public defproduction ls-type
   public defproduction ls-type0

   ;Precedence level 0      
   defrule ls-type = (?a:#ls-type0 -> ?b:#ls-type!) : qquote($ls-fn (~ a) ($none) ~ b)
   defrule ls-type = ((((! ~ ...) ?xs:#ls-type) @... ~ ...) -> ?b:#ls-type!) :
      val a = but-last(xs)
      val r = last(xs)
      qquote($ls-fn ~ a ~ r ~ b)
   defrule ls-type = ((?a:#ls-types!) -> ?b:#ls-type!) : qquote($ls-fn ~ a ($none) ~ b)
   defrule ls-type = (?x:#ls-type0) : x

   ;Precedence level 0
   defrule ls-type0 = (?x:(#stanza-tag _ ...)) : x
   defrule ls-type0 = (byte) : wrap-info(closest-info(), `($ls-byte))
   defrule ls-type0 = (int) : wrap-info(closest-info(), `($ls-int))
   defrule ls-type0 = (long) : wrap-info(closest-info(), `($ls-long))
   defrule ls-type0 = (float) : wrap-info(closest-info(), `($ls-float))
   defrule ls-type0 = (double) : wrap-info(closest-info(), `($ls-double))
   defrule ls-type0 = (?) : wrap-info(closest-info(), `($ls-?))
   defrule ls-type0 = (ptr<?x:#ls-type$>) : qquote($ls-ptr ~ x)
   defrule ls-type0 = (ref<?x:#type$>) : qquote($ls-ref ~ x)
   defrule ls-type0 = (?x:#id<?ts:#types!>) : qquote($ls-of ~ x ~@ ts)
   defrule ls-type0 = (?x:#id) : x
   defrule ls-type0 = ((?x:#ls-type)) : x

   ;                      LoStanza Expressions
   ;                      ====================
   public defproduction ls-exp  ;and / or
   public defproduction ls-exp0 ;==, !=, <, <=, >, >=
   public defproduction ls-exp1 ;+, -
   public defproduction ls-exp2 ;*, %, /
   public defproduction ls-exp3 ;<<, >>, >>>
   public defproduction ls-exp4 ;&, |, ^
   public defproduction ls-exp5 ;others
   public defproduction ls-exp6 

   defproduction ls-op0 : Symbol
   defproduction ls-op1 : Symbol
   defproduction ls-op2 : Symbol
   defproduction ls-op3 : Symbol
   defproduction ls-op4 : Symbol

   defrule ls-op0 = (<) : `lt
   defrule ls-op0 = (<=) : `le
   defrule ls-op0 = (>) : `gt
   defrule ls-op0 = (>=) : `ge
   defrule ls-op0 = (!=) : `ne
   defrule ls-op0 = (==) : `eq

   defrule ls-op1 = (+) : `add
   defrule ls-op1 = (-) : `sub

   defrule ls-op2 = (*) : `mul
   defrule ls-op2 = (/) : `div
   defrule ls-op2 = (%) : `mod

   defrule ls-op3 = (<<) : `shl
   defrule ls-op3 = (>>) : `shr
   defrule ls-op3 = (>>>) : `ashr
   
   defrule ls-op4 = (&) : `and
   defrule ls-op4 = (~ |) : `or
   defrule ls-op4 = (^) : `xor

   defrule ls-exp = (?x:#ls-exp and ?y:#ls-exp0!) : qquote($ls-and ~ x ~ y)
   defrule ls-exp = (?x:#ls-exp or ?y:#ls-exp0!) : qquote($ls-or ~ x ~ y)
   defrule ls-exp = (?x:#ls-exp0) : x

   defrule ls-exp0 = (?x:#ls-exp0 ?f:#ls-op0 ?y:#ls-exp1!) : qquote($ls-prim ~ f ~ x ~ y)
   defrule ls-exp0 = (?x:#ls-exp1) : x
   defrule ls-exp1 = (?x:#ls-exp1 ?f:#ls-op1 ?y:#ls-exp2!) : qquote($ls-prim ~ f ~ x ~ y)
   defrule ls-exp1 = (?x:#ls-exp2) : x
   defrule ls-exp2 = (?x:#ls-exp2 ?f:#ls-op2 ?y:#ls-exp3!) : qquote($ls-prim ~ f ~ x ~ y)
   defrule ls-exp2 = (?x:#ls-exp3) : x
   defrule ls-exp3 = (?x:#ls-exp3 ?f:#ls-op3 ?y:#ls-exp4!) : qquote($ls-prim ~ f ~ x ~ y)
   defrule ls-exp3 = (?x:#ls-exp4) : x
   defrule ls-exp4 = (?x:#ls-exp4 ?f:#ls-op4 ?y:#ls-exp5!) : qquote($ls-prim ~ f ~ x ~ y)
   defrule ls-exp4 = (?x:#ls-exp5) : x

   ;                      Suffix Operators
   ;                      ================
   defrule ls-exp5 = (?x:#ls-exp5 as ?t:#ls-type!) : qquote($ls-as ~ x ~ t)
   defrule ls-exp5 = (?x:#ls-exp5[?i:#ls-exp!]) : qquote($ls-slot ~ x ~ i)
   defrule ls-exp5 = (?x:#ls-exp5 . ?f:#id!) : qquote($ls-field ~ x ~ f)
   defrule ls-exp5 = (?x:#ls-exp5(?ys:#ls-exps!)) : qquote($ls-do ~ x ~@ ys)
   defrule ls-exp5 = (?x:#ls-exp5<?ts:#types!>(?ys:#ls-exps!)) : qquote($ls-do ($ls-of ~ x ~@ ts) ~@ ys)
   defrule ls-exp5 = (?x:#ls-exp6) : x

   ;                    Prefix Operators
   ;                    ================
   defrule ls-exp6 = (?x:(#stanza-tag _ ...)) : x

   defrule ls-exp6 = (sizeof(?t:#ls-type$)) : qquote($ls-sizeof ~ t)
   
   defrule ls-exp6 = (tagof(?tag:#id$)) : qquote($ls-tagof ~ tag)
   
   defrule ls-exp6 = (new ?name:#id!{?xs:#ls-exps!}) : qquote($ls-new ~ name ~@ xs)
   defrule ls-exp6 = (new ?name:#id!<?ts:#types!>{?xs:#ls-exps!}) : qquote($ls-new ($ls-of ~ name ~@ ts) ~@ xs)
   
   defrule ls-exp6 = (addr(?e:#ls-exp$)) : qquote($ls-addr ~ e)
   defrule ls-exp6 = (addr!(?e:#ls-exp$)) : qquote($ls-addr! ~ e)
   fail-if ls-exp6 = (?x:(addr | addr!)) : CSE(closest-info(), "Expected one argument after %_ operator." % [x])
   
   defrule ls-exp6 = (new-stack<?ret:#ls-type$>{?f:#ls-exp6!(?ys:#ls-exps!) ?rest ...}) :
      CSE(closest-info(rest), "Unexpected symbol here.") when not empty?(rest)
      qquote($ls-do-in-stack ~ ret ~ f ~@ ys)
   fail-if ls-exp6 = (new-stack<?ret:#ls-type$>) :
      CSE(closest-info(), "Expected function call within {} braces after new-stack operator.")
   fail-if ls-exp6 = (new-stack) : CSE(closest-info(), "Expected return type after new-stack operator.")

   defrule ls-exp6 = (switch-stack<?ret:#ls-type$>{?f:#ls-exp!, ?ys:#ls-exps!}) :
      qquote($ls-do-stack ~ ret ~ f ~@ ys)
   fail-if ls-exp6 = (switch-stack) : CSE(closest-info(), "Expected return type after switch-stack operator.")         

   defrule ls-exp6 = (?name:#id{?xs:#ls-exps!}) : qquote($ls-struct ~ name ~@ xs)
   defrule ls-exp6 = (?name:#id<?ts:#types!>{?xs:#ls-exps!}) : qquote($ls-struct ($ls-of ~ name ~@ ts) ~@ xs)
   
   defrule ls-exp6 = (call-c ?f:#ls-exp6!(?ys:#ls-exps!)) : qquote($ls-call-c ~ f ~@ ys)
   fail-if ls-exp6 = (call-c) : CSE(closest-info(), "Expected function call after call-c keyword.")
   
   defrule ls-exp6 = (call-prim ?f:#id!(?ys:#ls-exps!)) : qquote($ls-prim ~ f ~@ ys)
   fail-if ls-exp6 = (call-prim) : CSE(closest-info(), "Expected function call after call-prim keyword.")
   
   defrule ls-exp6 = (fn(?x:#id$)) : qquote($ls-func ~ x)
   fail-if ls-exp6 = (fn) : CSE(closest-info(), "Expected identifier of referenced function after fn keyword.")
   
   defrule ls-exp6 = (let #:! ?c:#ls-stmt! in ?e:#ls-exp!) : qquote($ls-letexp ~ c ~ e)
   fail-if ls-exp6 = (let #:! ?c:#ls-stmt! ?rest ...) : CSE(closest-info(rest), "Expected the in keyword here.")

   defrule ls-exp6 = ([?x:#ls-exp$]) : qquote($ls-deref ~ x)
   defrule ls-exp6 = ((- ?x:#ls-exp$)) : qquote($ls-prim neg ~ x)
   defrule ls-exp6 = ((~ ~ ?x:#ls-exp$)) : qquote($ls-prim not ~ x)      
   defrule ls-exp6 = (?x:(#ls-exp)) : x
   defrule ls-exp6 = (?x:#literal) : x
   defrule ls-exp6 = (?x:#id) : x


   ;                     LoStanza Statements
   ;                     ===================
   public defproduction ls-stmt

   ;                        Block Tags
   ;                        ==========
   defrule ls-stmt = (?x:(#stanza-tag _ ...)) : x

   ;                        Values
   ;                        ======
   defrule ls-stmt = (val ?x:#id! : ?t:#ls-type! = ?e:#ls-exp!) :
      qquote($ls-def ~ x ~ t ~ e)
   defrule ls-stmt = (val ?x:#id! : ?t:#ls-type!) :
      CSE(closest-info(), "Missing initialization value for val %_." % [x])
   defrule ls-stmt = (val ?x:#id! = ?e:#ls-exp!) :
      qquote($ls-def ~ x ($none) ~ e)
   defrule ls-stmt = (val ?x:#id!) :
      CSE(closest-info(), "Missing initialization value for val %_." % [x])
      
   ;                        Variables
   ;                        =========
   defrule ls-stmt = (var ?x:#id! #:! ?t:#ls-type! = ?e:#ls-exp!) :
      qquote($ls-defvar ~ x ~ t ~ e)
   defrule ls-stmt = (var ?x:#id! #:! ?t:#ls-type!) :
      qquote($ls-defvar ~ x ~ t ($none))

   ;                        Return
   ;                        ======
   defrule ls-stmt = (return ?e:#ls-exp!) : qquote($ls-return ~ e)

   ;                        Labels
   ;                        ======
   defproduction ls-block
   defrule ls-block = (?name:#id! ((?xs:#id! #:! ?ts:#ls-type!) @...) #:! ?body:#ls-stmt!) :
      qquote($ls-block ~ name ~ xs ~ ts ~ body)
   defrule ls-block = (?name:#id! #:! ?body:#ls-stmt!) :
      qquote($ls-block ~ name () () ~ body)         
   defrule ls-stmt = (labels #:! (?bs:#ls-block ...)) :
      qquote($ls-labels ~@ bs)

   ;                        Goto
   ;                        ====
   defrule ls-stmt = (goto ?x:#id!(?args:#ls-exps!)) : qquote($ls-goto ~ x ~@ args)
   defrule ls-stmt = (goto ?x:#id!) : qquote($ls-goto ~ x)
   
   ;                        Let
   ;                        ===
   defrule ls-stmt = (let #:! ?c:#ls-stmt!) : qquote($ls-let ~ c)

   ;                        If
   ;                        ==
   defproduction ls-if
   defrule ls-if = (if ?pred:#ls-exp! #:! ?conseq:#ls-stmt! else : ?alt:#ls-stmt!) :
      qquote($ls-if ~ pred ~ conseq ~ alt)
   defrule ls-if = (if ?pred:#ls-exp! #:! ?conseq:#ls-stmt! else ?alt:#ls-if) :
      qquote($ls-if ~ pred ~ conseq ~ alt)
   defrule ls-if = (if ?pred:#ls-exp! #:! ?conseq:#ls-stmt!) :
      qquote($ls-if ~ pred ~ conseq ($begin))
   defrule ls-stmt = (?c:#ls-if) : c

   ;                        While
   ;                        =====
   defrule ls-stmt = (while ?pred:#ls-exp! #:! ?body:#ls-stmt!) :
      val template = `(
         labels :
            loop :
               if pred :
                  body
                  goto loop)
      parse-syntax[core / #ls-stmt](            
         fill-template(template, [
            `pred => pred
            `body => body
            `loop => gensym(`loop)]))

   ;                        Match
   ;                        =====
   defproduction branch-arg : KeyValue
   defrule branch-arg = (?x:#id! : ?t:#ls-type!) : x => t
   defrule branch-arg = (?x:#id!) : x => `($none)
   defrule ls-stmt = (match(?es:#ls-exps!) #:! (
                         ((?argss:#branch-arg ...) #:! ?bodies:#ls-stmt!) @...)) :
      val template =
         `($ls-match args
            branches{
               ($ls-branch xs ts body)
            })
      fill-template(template, [
         `args => es
         `branches => nested $ for (args in argss, body in bodies) map : [
            `xs => map(key, args)
            `ts => map(value, args)
            `body => body]])
   fail-if ls-stmt = (match) :
      CSE(closest-info(), "Expected list of arguments after match keyword.")

   
   ;                        For
   ;                        ===
   defrule ls-stmt = (for (?def:#ls-stmt!, ?pred:#ls-exp!, ?step:#ls-stmt!) #:!
                         ?body:#ls-stmt!) :
      val template = `(
         let :
            def
            labels :
               loop :
                  if pred :
                     body
                     step
                     goto loop)
      parse-syntax[core / #ls-stmt](            
         fill-template(template, [
            `def => def
            `loop => gensym(`loop)
            `pred => pred
            `body => body
            `step => step]))
   fail-if ls-stmt = (for) :
      CSE(closest-info(), "Expected list after for keyword.")   

   ;                        Set
   ;                        ===
   defrule ls-stmt = (?x:#ls-exp = ?y:#ls-exp!) : qquote($ls-set ~ x ~ y)

   ;              Side-Effecting Expressions
   ;              ==========================
   defrule ls-stmt = (?x:#ls-exp) : x

   ;                   Statement Groups
   ;                   ================
   defrule ls-stmt = ((?c:#ls-stmt ?cs:#ls-stmts!)) : qquote($begin ~ c ~@ cs)
   defrule ls-stmt = (()) : `($begin)


   ;                    #if-defined/#if-not-defined
   ;                    ===========================
   defrule ls-stmt = (~ #if-defined(?flag:#id$) #:! ?conseq:#list! ~ #else #:! ?alt:#list!) :
      val body = 
         if flag-defined?(unwrap-token(flag)) : conseq
         else : alt
      parse-syntax[core + current-overlays / #ls-stmt](List(body))   
   defrule ls-stmt = (~ #if-defined(?flag:#id$) #:! ?conseq:#list!) :
      if flag-defined?(unwrap-token(flag)) : parse-syntax[core + current-overlays / #ls-stmt](List(conseq))   
      else : `($begin)
   fail-if ls-stmt = (~ #if-defined) :
      CSE(closest-info(), "Incorrect syntax for #if-defined.")

   defrule ls-stmt = (~ #if-not-defined(?flag:#id$) #:! ?conseq:#list! ~ #else #:! ?alt:#list!) :
      val body = 
         if not flag-defined?(unwrap-token(flag)) : conseq
         else : alt
      parse-syntax[core + current-overlays / #ls-stmt](List(body))   
   defrule ls-stmt = (~ #if-not-defined(?flag:#id$) #:! ?conseq:#list!) :
      if not flag-defined?(unwrap-token(flag)) : parse-syntax[core + current-overlays / #ls-stmt](List(conseq))   
      else : `($begin)
   fail-if ls-stmt = (~ #if-not-defined) :
      CSE(closest-info(), "Incorrect syntax for #if-not-defined.")

   ;                   Literal
   ;                   =======
   public defproduction literal : Token|Char|String|Byte|Int|Long|Float|Double|True|False
   defrule literal = (?x) when unwrap-token(x) is Char|String|Byte|Int|Long|Float|Double|True|False : x

   ;                Identifier
   ;                ==========
   public defproduction id : Symbol|Token
   defrule id != (#stanza-tag)
   defrule id != (#lexer-tag)
   defrule id = (?x) when unwrap-token(x) is Symbol : x


;============== Error Messages ============================
val BAD-ARGLIST-MSG = "Incorrect syntax for argument list. Did you forget to put a space between the function name and the argument list?"
val BAD-MATCH-MSG = "Incorrect syntax for match expression. Is there an extra space between match and the argument list?"
val BAD-FOR-MSG = "Missing operating function in for expression. Did you forget to put a do after the bindings?"

