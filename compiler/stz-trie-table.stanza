defpackage stz/trie-table :
  import core
  import collections
  import stz/trie
  import stz/hash
  import dispatch-dag

;<doc>=======================================================
;=================== Trie Table Representation ==============
;============================================================

Here is how a trie is stored:

  I | N | D0 | DTable ... | Key, Value ... | Default

Where:

  I is the index of the register to perform dispatch on.
  N is the length of the table.
  D0 is the d-parameter of the first-level hash table.
  DTable are the entries of the first-level hash table.
  Key are the keys for each branch.
  Value are the values for each branch.

If N is less than or equal to 4, then the DTable is omitted, and we
perform a linear lookup instead.

If a key is not in the table, then we interpret the action given by Default.

Two cases are encoded into the value and Default :

  (- (Target + 1)) when Value < 0
  (Table offset)   when Value >= 0

When the Value is negative, it encodes the target to return.
Otherwise, it encodes the address of the next table.

;============================================================
;=======================================================<doc>

;Convert a list of branches into a trie and
;encode it
public defn encode-trie (branches:Tuple<IDispatchBranch>, start-index:Int) -> Vector<Int> :
  val trie = to-trie(branches) when not empty?(branches)
  encode-trie(trie, start-index)

;Encode Trie into Int Vector
public defn encode-trie (trie:IfTrie|False, start-index:Int) -> Vector<Int> :
  ;Accumulator for storing encoded trie
  val accum = Vector<Int|TrieTarget>()
  defn emit (x:Int|TrieTarget) : add(accum,x)
  defn pos () : length(accum)

  ;Store the addresses of all the encoded tries
  val trie-addresses = IntTable<Int>()

  ;Overall algorithm
  defn driver () :
    match(trie) :
      (t:IfTrie) : encode(t)
      (t:False) : encode-empty-trie()
    accum as Vector<Int>

  ;Encode a trie for dispatching on given arg-index.
  defn encode (trie:IfTrie) :
    val ftrie = flatten(trie, 0)
    val trie-addresses = Array<Int>(num-labeled-tries(ftrie))
    for t in tries(ftrie) do :
      if id(t) is Int :
        trie-addresses[id(t) as Int] = pos()
      val n = length(entries(t))
      emit(start-index + index(t))
      emit(n)
      if n <= 4 :
        for e in entries(t) do :
          emit(key(e))
          emit(value(e))
        emit(default(t))
      else :
        val table = PerfectHashTable(entries(t))
        fatal("Unexpected size difference") when n != length(table)
        emit(d0(table))
        for i in 0 to n do :
          emit(dentry(table,i))
        for i in 0 to n do :
          val e = entry(table,i)
          emit(key(e))
          emit(value(e))
        emit(default(t))     

    ;Fill in delayed values
    for v in accum map! :
      match(v) :
        (v:Int) :
          v
        (v:EndTrie) :
          val tgt = target(v) as Int
          (- (tgt + 1))
        (v:TrieId) :
          trie-addresses[id(v)]

  ;Encode an empty trie
  defn encode-empty-trie () :
    emit(start-index)
    emit(0)
    emit(-1) ;(target 0)

  ;Launch
  driver()

;Encode Dag into Int Vector
public defn encode-dag (dag:Dag, start-depth:Int, soln-id:Soln -> Int) -> Vector<Int> :
  ;Accumulator for storing encoded trie
  val accum = Vector<Int|TrieId>()
  defn emit (x:Int|TrieId) : add(accum,x)

  ;Overall algorithm
  defn driver () :
    val addresses = to-tuple $
      for e in entries(dag) seq :
        val address = length(accum)
        encode(e)
        address
    fill-addresses(addresses)
    accum as Vector<Int>

  ;Convert end of dag into trie-id
  defn to-trie-id (x:Int|Soln) :
    match(x) :
      (x:Int) : TrieId(x)
      (x:Soln) : (- (soln-id(x) + 1))

  ;Encode a trie for dispatching on given arg-index.
  defn encode (dag:DagEntry) :
    ;Spread out entries
    val entries = Vector<KeyValue<Int,Int|TrieId>>()
    for e in /entries(dag) do :
      val tgt = to-trie-id(value(e))
      for v in values(key(e)) do :
        add(entries, v => tgt)

    ;Compute the table
    val n = length(entries)
    emit(start-depth + depth(dag))
    emit(n)
    if n <= 4 :
      for e in entries do :
        emit(key(e))
        emit(value(e))
      emit(to-trie-id(default(dag)))
    else :
      val table = PerfectHashTable(entries)
      fatal("Unexpected size difference") when n != length(table)
      emit(d0(table))
      for i in 0 to n do :
        emit(dentry(table,i))
      for i in 0 to n do :
        val e = entry(table,i)
        emit(key(e))
        emit(value(e))
      emit(to-trie-id(default(dag)))

  defn fill-addresses (addresses:Tuple<Int>) :
    ;Fill in delayed values
    for v in accum map! :
      match(v:TrieId) : addresses[id(v)]
      else : v as Int
          
  ;Launch
  driver()