defpackage stz/trie-table :
  import core
  import collections
  import stz/trie
  import stz/hash

;<doc>=======================================================
;=================== Trie Table Representation ==============
;============================================================

Here is how a trie is stored:

  I | N | D0 | DTable ... | Key, Value ... | Default

Where:

  I is the index of the register to perform dispatch on.
  N is the length of the table.
  D0 is the d-parameter of the first-level hash table.
  DTable are the entries of the first-level hash table.
  Key are the keys for each branch.
  Value are the values for each branch.

If N is less than or equal to 4, then the DTable is omitted, and we
perform a linear lookup instead.

If a key is not in the table, then we interpret the action given by Default.

Two cases are encoded into the value and Default :

  (- (Target + 1)) when Value < 0
  (Table offset)   when Value >= 0

When the Value is negative, it encodes the target to return.
Otherwise, it encodes the address of the next table.

;============================================================
;=======================================================<doc>

;Convert a list of branches into a trie and
;encode it
public defn encode-trie (branches:Tuple<IDispatchBranch>, start-index:Int) -> Vector<Int> :
  val trie = to-trie(branches) when not empty?(branches)
  encode-trie(trie, start-index)

;Encode Trie into Int Vector
public defn encode-trie (trie:IfTrie|False, start-index:Int) -> Vector<Int> :
  ;Accumulator for storing encoded trie
  val accum = Vector<Int|TrieTarget>()
  defn emit (x:Int|TrieTarget) : add(accum,x)
  defn pos () : length(accum)

  ;Store the addresses of all the encoded tries
  val trie-addresses = IntTable<Int>()

  ;Overall algorithm
  defn driver () :
    match(trie) :
      (t:IfTrie) : encode(t)
      (t:False) : encode-empty-trie()
    accum as Vector<Int>

  ;Encode a trie for dispatching on given arg-index.
  defn encode (trie:IfTrie) :
    val ftrie = flatten(trie, 0)
    val trie-addresses = Array<Int>(num-labeled-tries(ftrie))
    for t in tries(ftrie) do :
      if id(t) is Int :
        trie-addresses[id(t) as Int] = pos()
      val n = length(entries(t))
      emit(start-index + index(t))
      emit(n)
      if n <= 4 :
        for e in entries(t) do :
          emit(key(e))
          emit(value(e))
        emit(default(t))
      else :
        val table = PerfectHashTable(entries(t))
        fatal("Unexpected size difference") when n != length(table)
        emit(d0(table))
        for i in 0 to n do :
          emit(dentry(table,i))
        for i in 0 to n do :
          val e = entry(table,i)
          emit(key(e))
          emit(value(e))
        emit(default(t))     

    ;Fill in delayed values
    for v in accum map! :
      match(v) :
        (v:Int) :
          v
        (v:EndTrie) :
          val tgt = target(v) as Int
          (- (tgt + 1))
        (v:TrieId) :
          trie-addresses[id(v)]

  ;Encode an empty trie
  defn encode-empty-trie () :
    emit(start-index)
    emit(0)
    emit(-1) ;(target 0)

  ;Launch
  driver()