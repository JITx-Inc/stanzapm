defpackage stz/tgt-ir :
  import core
  import collections

public defast :
  ;Immediates
  deftype TGImm
  deftype TGVal <: TGImm
  deftype TGLoc <: TGLoc
  defnodes TGVal :
    TGByte : (value:Byte)
    TGInt : (value:Int)
    TGLong : (value:Long)
    TGMem : (n:Int, offset:Int)
    TGExMem : (lbl:Symbol, offset:Int)
  defnodes TGLoc :
    TGVar : (n:Int)
  
  ;Types
  deftype TGType
  deftype TGIntegerT <: TGType
  deftype TGRealT <: TGType
  defnodes TGIntegerT :
    TGByteT
    TGIntT
    TGLongT
    TGRefT
  defnodes TGRealT :
    TGFloatT
    TGDoubleT

  ;Instructions
  deftype TGIns
  defnodes TGIns :
    TGDef :
      n: Int
      type: TGType
    TGDefConst :
      n: Int
      value: ?
    TGArgs :
      xs: List<Var>
    TGReturn :
      xs: List<Imm>
    TGSet :
      x: Var
      y: Imm
    TGConv :
      x: Var
      y: Imm
    TGInterpret :
      x: Var
      y: Imm
    TGBinOp :
      x: Var
      op: TGOp
      y: Imm
      z: Imm
    TGUnaOp :
      x: Var
      op: TGOp
      y: Imm
    TGLoad :
      x: Var
      y: Imm
      offset: Int
    TGStore :
      x: Imm
      y: Imm
      offset: Int
    TGCall :
      arity: Int
      xs: List<Var>
      f: Imm
      ys: List<Imm>
    TGTCall :
      arity: Int
      f: Imm
      ys: List<Imm>   
    TGSwitchStack :
      x: Var
      s: Imm
      y: Imm   
    TGLabel :
      n: Int
    TGGoto :
      n: Int
    TGBinCmp :
      n: Int
      op: TGOp
      x: Imm
      y: Imm
    TGUnaCmp :
      n: Int
      op: TGOp
      x: Imm
    TGMatch :
      xs: List<Imm>
      branches: List<TGBranch>
    TGDispatch :
      xs: List<Imm>
      branches: List<TGBranch>

  ;Operations
  deftype TGOp
  defnodes TGOp :
    TGAddOp
    TGSubOp
    TGMulOp
    TGDivOp
    TGModOp
    TGAndOp
    TGOrOp
    TGXorOp
    TGShlOp
    TGShrOp
    TGAshrOp
    TGEqOp
    TGNeOp
    TGLtOp
    TGGtOp
    TGLeOp
    TGGeOp
    TGUleOp
    TGUltOp
    TGUgtOp
    TGUgeOp
    TGNotOp
    TGNegOp    

public defstruct TGBranch :
  tags: List<KTag>
  n: Int

;============================================================
;======================= Printers ===========================
;============================================================

defmethod print (o:OutputStream, i:TGIns) :
  print{o, _} $ match(i) :
    (i:TGDef) : "def %_ : %_" % [n(i), type(i)]
    (i:TGDefConst) : "defconst %_ : %_" % [n(i), value(i)]
    (i:TGArgs) : "(%,) = args" % [xs(i)]
    (i:TGReturn) : "return (%,)" % [xs(i)]
    (i:TGSet) : "%_ = %_" % [x(i), y(i)]
    (i:TGConv) : "%_ = conv %_" % [x(i), y(i)]
    (i:TGInterpret) : "%_ = interpret %_" % [x(i), y(i)]
    (i:TGBinOp) : "%_ = %_(%_, %_)" % [x(i), op(i), y(i), z(i)]
    (i:TGUnaOp) : "%_ = %_(%_)" % [x(i), op(i), y(i)]
    (i:TGLoad) : "%_ = [%_ + %_]" % [x(i), y(i), offset(i)]
    (i:TGStore) : "[%_ + %_] = %_" % [x(i), offset(i), y(i)]
    (i:TGCall) : "(%,) = call/%_ %_(%,)" % [xs(i), arity(i), f(i), ys(i)]
    (i:TGTCall) : "tcall/%_ %_(%,)" % [arity(i), f(i), ys(i)]
    (i:TGSwitchStack) : "%_ = switch-stack(%_, %_)" % [x(i), s(i), y(i)]
    (i:TGLabel) : "label %_" % [n(i)]
    (i:TGGoto) : "goto %_" % [n(i)]
    (i:TGBinCmp) : "goto %_ when %_(%_, %_)" % [n(i), op(i), x(i), y(i)]
    (i:TGUnaCmp) : "goto %_ when %_(%_)" % [n(i), op(i), x(i)]
    (i:TGMatch) : "match(%,): %@" % [xs(i), branches(i)]
    (i:TGDispatch) : "dispatch(%,): %@" % [xs(i), branches(i)]

defmethod print (o:OutputStream, b:TGBranch) :
  print(o, "%_ => %_" % [tags(b), n(b)])

defmethod print (o:OutputStream, t:TGType) :
  print{o, _} $ match(t) :
    (t:TGByteT) : "Byte"
    (t:TGIntT) : "Int"
    (t:TGLongT) : "Long"
    (t:TGRefT) : "Ref"
    (t:TGFloatT) : "Float"
    (t:TGDoubleT) : "Double"

defmethod print (o:OutputStream, x:TGImm) :
  print{o, _} $ match(x) :
    (x:TGByte) : value(x)
    (x:TGInt) : value(x)
    (x:TGLong) : value(x)
    (x:TGMem) :
      if offset(x) == 0 : "M%_" % [n(x)]
      else : "(M%_ + %_)" % [n(x), offset(x)]
    (x:TGExMem) :
      if offset(x) == 0 : "M%_" % [lbl(x)]
      else : "(M%_ + %_)" % [lbl(x), offset(x)]
    (x:TGVar) : "V%_" % [n(x)]
    
defmethod print (o:OutputStream, x:TGOp) :
  print{o, _} $ match(x) :
    (x:TGAddOp) : "add"
    (x:TGSubOp) : "sub"
    (x:TGMulOp) : "mul"
    (x:TGDivOp) : "div"
    (x:TGModOp) : "mod"
    (x:TGAndOp) : "and"
    (x:TGOrOp) : "or"
    (x:TGXorOp) : "xor"
    (x:TGShlOp) : "shl"
    (x:TGShrOp) : "shr"
    (x:TGAshrOp) : "ashr"
    (x:TGEqOp) : "eq"
    (x:TGNeOp) : "ne"
    (x:TGLtOp) : "lt"
    (x:TGGtOp) : "gt"
    (x:TGLeOp) : "le"
    (x:TGGeOp) : "ge"
    (x:TGUleOp) : "ule"
    (x:TGUltOp) : "ult"
    (x:TGUgtOp) : "ugt"
    (x:TGUgeOp) : "uge"
    (x:TGNotOp) : "not"
    (x:TGNegOp) : "neg"