;See License.txt for details about licensing.

defpackage stz/asm-ir :
   import core
   import collections
   import stz/kl-ir

;============================================================
;=================== Immediates =============================
;============================================================

public deftype Imm
public defstruct IntImm <: Imm : (value: Byte|Int|Long)
public defstruct TagImm <: Imm : (n:Int)
public defstruct Mem <: Imm : (n:Int, offset:Int)
public defstruct ExMem <: Imm : (lbl:Symbol, offset:Int)

public deftype Loc <: Imm
public defstruct RegSP <: Loc
public defstruct Reg <: Loc : (n:Int)
public defstruct FReg <: Loc : (n:Int)

public deftype Type
public defstruct ByteT <: Type
public defstruct IntT <: Type
public defstruct LongT <: Type
public defstruct FloatT <: Type
public defstruct DoubleT <: Type

;============================================================
;=================== Instructions ===========================
;============================================================

public deftype Ins
public defstruct XchgIns <: Ins :
  x: Loc
  y: Loc
public defstruct SetIns <: Ins :
  type: Type
  x: Loc
  y: Imm
public defstruct ConvertIns <: Ins :
  xtype: Type
  x: Loc
  ytype: Type
  y: Imm
public defstruct InterpretIns <: Ins :
  xtype: Type
  x: Loc
  ytype: Type
  y: Imm
public defstruct UnaOp <: Ins :
  type: Type
  x: Loc
  op: Op
  y: Imm
public defstruct BinOp <: Ins :
  type: Type
  x: Loc
  op: Op
  y: Imm
  z: Imm
public defstruct DualOp <: Ins :
  type: Type
  x1: Loc
  x2: Loc
  op: Op
  y: Imm
  z: Imm
public defstruct Load <: Ins :
  type: Type
  x: Loc
  y: Imm
  offset: Int
public defstruct Store <: Ins :
  type: Type
  x: Imm
  y: Imm
  offset: Int
public defstruct Call <: Ins :
  x: Imm
public defstruct Return <: Ins
public defstruct Goto <: Ins :
  x: Imm
public defstruct Break <: Ins :
  type: Type
  x: Imm
  op: Op
  y: Imm
  z: Imm   
public defstruct Label <: Ins :
  n: Int
public defstruct ExLabel <: Ins :
  name: Symbol
public defstruct Match <: Ins :
  xs: List<Imm>
  branches: List<Branch>
public defstruct Dispatch <: Ins :
  xs: List<Imm>
  branches: List<Branch>
public defstruct Branch :
  tags: List<KTag>
  n: Int

;============================================================
;=================== Data Instructions ======================
;============================================================

public defstruct DefData <: Ins
public defstruct DefText <: Ins
public defstruct DefByte <: Ins : (value:Byte)
public defstruct DefInt <: Ins : (value:Int)
public defstruct DefLong <: Ins : (value:Long)
public defstruct DefFloat <: Ins : (value:Float)
public defstruct DefDouble <: Ins : (value:Double)
public defstruct DefString <: Ins : (value:String)
public defstruct DefSpace <: Ins : (size:Int)
public defstruct DefLabel <: Ins : (n:Int)

;============================================================
;====================== Operations ==========================
;============================================================
public deftype Op
public defstruct AddOp <: Op
public defstruct SubOp <: Op
public defstruct MulOp <: Op
public defstruct DivOp <: Op
public defstruct ModOp <: Op
public defstruct AndOp <: Op
public defstruct OrOp <: Op
public defstruct XorOp <: Op
public defstruct ShlOp <: Op
public defstruct ShrOp <: Op
public defstruct AshrOp <: Op
public defstruct EqOp <: Op
public defstruct NeOp <: Op
public defstruct LtOp <: Op
public defstruct GtOp <: Op
public defstruct LeOp <: Op
public defstruct GeOp <: Op
public defstruct UleOp <: Op
public defstruct UltOp <: Op
public defstruct UgtOp <: Op
public defstruct UgeOp <: Op
public defstruct NotOp <: Op
public defstruct NegOp <: Op
public defstruct DivModOp <: Op

;============================================================
;===================== Printing =============================
;============================================================
defmethod print (o:OutputStream, i:Ins) :
  print{o, _} $ match(i) :
    (i:XchgIns) : "   %~ <=> %~" % [x(i), y(i)]
    (i:SetIns) : "   %~: %~ = %~" % [type(i), x(i), y(i)]
    (i:ConvertIns) : "   %~:%~ = %~:%~" % [xtype(i), x(i), ytype(i), y(i)]
    (i:InterpretIns) : "   %~:%~ = interpret %~:%~" % [xtype(i), x(i), ytype(i), y(i)]
    (i:UnaOp) : "   %~: %~ = %~ %~" % [type(i), x(i), op(i), y(i)]
    (i:BinOp) : "   %~: %~ = %~ %~ %~" % [type(i), x(i), y(i), op(i), z(i)]
    (i:DualOp) : "   %~: %~, %~ = %~ %~ %~" % [type(i), x1(i), x2(i), y(i), op(i), z(i)]
    (i:Load) : "   %~: %~ = [%~ + %~]" % [type(i), x(i), y(i), offset(i)]
    (i:Store) : "   %~: [%~ + %~] = %~" % [type(i), x(i), offset(i), y(i)]
    (i:Call) : "   call %~" % [x(i)]
    (i:Return) : "   return"
    (i:Goto) : "   goto %~" % [x(i)]
    (i:Break) : "   %~: break %~ when %~ %~ %~" % [type(i), x(i), y(i), op(i), z(i)]
    (i:Label) : "L<%~>" % [n(i)]
    (i:ExLabel) : "L<%~>" % [name(i)]
    (i:Match) : "   match(%,) %_" % [xs(i), branches(i)]
    (i:Dispatch) : "   match(%,) %_" % [xs(i), branches(i)]
    (i:DefData) : "   .data"
    (i:DefText) : "   .text"
    (i:DefByte) : "   .byte %~" % [value(i)]
    (i:DefInt) : "   .int %~" % [value(i)]
    (i:DefLong) : "   .long %~" % [value(i)]
    (i:DefFloat) : "   .float %~" % [value(i)]
    (i:DefDouble) : "   .double %~" % [value(i)]
    (i:DefString) : "   .string %~" % [value(i)]
    (i:DefSpace) : "   .space %~" % [size(i)]
    (i:DefLabel) : "   .label L<%~>" % [n(i)]

defmethod print (o:OutputStream, b:Branch) :
  print(o, "   (%,) => L%_" % [tags(b), n(b)])

defmethod print (o:OutputStream, i:Imm) :
  print{o, _} $ match(i) :
    (i:IntImm) : value(i)
    (i:TagImm) : "T%_" % [n(i)]
    (i:Mem) :
      if offset(i) == 0 : "M%_" % [n(i)]
      else : "(M%_ + %_)" % [n(i), offset(i)]
    (i:ExMem) :
      if offset(i) == 0 : "M%_" % [lbl(i)]
      else : "(M%_ + %_)" % [lbl(i), offset(i)]
    (i:RegSP) : "rsp"
    (i:Reg) : "R%_" % [n(i)]
    (i:FReg) : "F%_" % [n(i)]

defmethod print (o:OutputStream, t:Type) :
  print{o, _} $ match(t) :
    (t:ByteT) : "byte"
    (t:IntT) : "int"
    (t:LongT) : "long"
    (t:FloatT) : "float"
    (t:DoubleT) : "double"

defmethod print (o:OutputStream, op:Op) :
  print{o, _} $ match(op) :
    (op:AddOp) : "add"
    (op:SubOp) : "sub"
    (op:MulOp) : "mul"
    (op:DivOp) : "div"
    (op:ModOp) : "mod"
    (op:AndOp) : "and"
    (op:OrOp) : "or"
    (op:XorOp) : "xor"
    (op:ShlOp) : "shl"
    (op:ShrOp) : "shr"
    (op:AshrOp) : "ashr"
    (op:EqOp) : "eq"
    (op:NeOp) : "ne"
    (op:LtOp) : "lt"
    (op:GtOp) : "gt"
    (op:LeOp) : "le"
    (op:GeOp) : "ge"
    (op:UleOp) : "ule"
    (op:UltOp) : "ult"
    (op:UgtOp) : "ugt"
    (op:UgeOp) : "uge"
    (op:NotOp) : "not"
    (op:NegOp) : "neg"
    (op:DivModOp) : "divmod"