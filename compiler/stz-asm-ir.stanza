;See License.txt for details about licensing.

defpackage stz/asm-ir :
   import core
   import collections
   import stz/kl-ir

;Use utilities for defining ASTs quickly
#use-added-syntax(stz-ast-lang)

;============================================================
;=================== Immediates =============================
;============================================================

public deftype Imm <: Equalable
public defstruct IntImm <: Imm : (value: Byte|Int|Long)
public defstruct TagImm <: Imm : (n:Int, marker?:True|False)
public defstruct Mem <: Imm : (n:Int, offset:Int)
public defstruct ExMem <: Imm : (lbl:Symbol, offset:Int)

public deftype Loc <: Imm
public defstruct RegSP <: Loc
public defstruct Reg <: Loc : (n:Int)
public defstruct FReg <: Loc : (n:Int)

public deftype ASMType <: Equalable
public defstruct ByteT <: ASMType
public defstruct IntT <: ASMType
public defstruct LongT <: ASMType
public defstruct FloatT <: ASMType
public defstruct DoubleT <: ASMType

;============================================================
;====================== Equality ============================
;============================================================

defmethod equal? (a:Imm, b:Imm) :
  match(a, b) :
    (a:IntImm, b:IntImm) : value(a) == value(b)
    (a:TagImm, b:TagImm) : (n(a) == n(b)) and (marker?(a) == marker?(b))
    (a:Mem, b:Mem) : n(a) == n(b) and offset(a) == offset(b)
    (a:ExMem, b:ExMem) : lbl(a) == lbl(b) and offset(a) == offset(b)
    (a:RegSP, b:RegSP) : true
    (a:Reg, b:Reg) : n(a) == n(b)
    (a:FReg, b:FReg) : n(a) == n(b)
    (a, b) : false

defmethod equal? (a:ASMType, b:ASMType) :
  match(a, b) :
    (a:ByteT, b:ByteT) : true
    (a:IntT, b:IntT) : true
    (a:LongT, b:LongT) : true
    (a:FloatT, b:FloatT) : true
    (a:DoubleT, b:DoubleT) : true
    (a, b) : false

;============================================================
;=================== Instructions ===========================
;============================================================

public defast :
  ;Instructions
  deftype Ins  
  defnodes Ins :
    ;==== Local Instructions ====
    XchgIns :
      x: Loc
      y: Loc
    SetIns :
      type: ASMType
      x: Loc
      y: Imm
    ConvertIns :
      xtype: ASMType
      x: Loc
      ytype: ASMType
      y: Imm
    InterpretIns :
      xtype: ASMType
      x: Loc
      ytype: ASMType
      y: Imm
    UnaOp :
      type: ASMType
      x: Loc
      op: Op
      y: Imm
    BinOp :
      type: ASMType
      x: Loc
      op: Op
      y: Imm
      z: Imm
    DualOp :
      type: ASMType
      x1: Loc
      x2: Loc
      op: Op
      y: Imm
      z: Imm
    Load :
      type: ASMType
      x: Loc
      y: Imm
      offset: Int
    Store :
      type: ASMType
      x: Imm
      y: Imm
      offset: Int
    Call :
      x: Imm
      info: False|FileInfo
    Return
    Goto :
      x: Imm
    Break :
      type: ASMType
      x: Imm
      op: Op
      y: Imm
      z: Imm   
    Label :
      n: Int
    ExLabel :
      name: Symbol
    Match :
      xs: List<Imm>
      branches: List<Branch>
      info: False|FileInfo
    Dispatch :
      xs: List<Imm>
      branches: List<Branch>
      info: False|FileInfo

    ;==== Data Instructions ====
    DefData
    DefText
    DefByte : (value:Byte)
    DefInt : (value:Int)
    DefLong : (value:Long)
    DefFloat : (value:Float)
    DefDouble : (value:Double)
    DefString : (value:String)
    DefSpace : (size:Int)
    DefLabel : (n:Int)

  ;Mapper Utilities
  defmapper (f:Imm -> Imm) :
    (x:Loc) : f(x) as Loc
    (x:Imm) : f(x)
    (x:List<Imm>) : map(f,x)
  defdoer (f:Imm -> ?) :
    (x:Loc) : f(x)
    (x:Imm) : f(x)
    (x:List<Imm>) : do(f,x)

  ;Other
  ignore :
    List<Branch>
    ASMType
    Op
    Byte
    Int
    Long
    Float
    Double
    String
    Symbol
    False|FileInfo

  ;Mappers
  make-mapper(f:Imm -> Imm, e:Ins)
  make-doer(f:Imm -> ?, e:Ins)

public defstruct Branch :
  tags: List<KTag>
  n: Int

;============================================================
;====================== Operations ==========================
;============================================================
public deftype Op
public defstruct AddOp <: Op
public defstruct SubOp <: Op
public defstruct MulOp <: Op
public defstruct DivOp <: Op
public defstruct ModOp <: Op
public defstruct AndOp <: Op
public defstruct OrOp <: Op
public defstruct XorOp <: Op
public defstruct ShlOp <: Op
public defstruct ShrOp <: Op
public defstruct AshrOp <: Op
public defstruct EqOp <: Op
public defstruct NeOp <: Op
public defstruct LtOp <: Op
public defstruct GtOp <: Op
public defstruct LeOp <: Op
public defstruct GeOp <: Op
public defstruct UleOp <: Op
public defstruct UltOp <: Op
public defstruct UgtOp <: Op
public defstruct UgeOp <: Op
public defstruct NotOp <: Op
public defstruct NegOp <: Op
public defstruct DivModOp <: Op
public defstruct BitSetOp <: Op
public defstruct BitNotSetOp <: Op

;============================================================
;================ Operation Flipping ========================
;============================================================

public defn flip (op:Op) :
  match(op) :
    (op:EqOp) : NeOp()
    (op:NeOp) : EqOp()
    (op:LtOp) : GeOp()
    (op:GtOp) : LeOp()
    (op:LeOp) : GtOp()
    (op:GeOp) : LtOp()
    (op:UleOp) : UgtOp()
    (op:UltOp) : UgeOp()
    (op:UgtOp) : UleOp()
    (op:UgeOp) : UltOp()
    (op:BitSetOp) : BitNotSetOp()
    (op:BitNotSetOp) : BitSetOp()

;============================================================
;===================== Printing =============================
;============================================================
defmethod print (o:OutputStream, i:Ins) :
  print{o, _} $ match(i) :
    (i:XchgIns) : "   %~ <=> %~" % [x(i), y(i)]
    (i:SetIns) : "   %~: %~ = %~" % [type(i), x(i), y(i)]
    (i:ConvertIns) : "   %~:%~ = %~:%~" % [xtype(i), x(i), ytype(i), y(i)]
    (i:InterpretIns) : "   %~:%~ = interpret %~:%~" % [xtype(i), x(i), ytype(i), y(i)]
    (i:UnaOp) : "   %~: %~ = %~ %~" % [type(i), x(i), op(i), y(i)]
    (i:BinOp) : "   %~: %~ = %~ %~ %~" % [type(i), x(i), y(i), op(i), z(i)]
    (i:DualOp) : "   %~: %~, %~ = %~ %~ %~" % [type(i), x1(i), x2(i), y(i), op(i), z(i)]
    (i:Load) : "   %~: %~ = [%~ + %~]" % [type(i), x(i), y(i), offset(i)]
    (i:Store) : "   %~: [%~ + %~] = %~" % [type(i), x(i), offset(i), y(i)]
    (i:Call) : "   call %~ @ %_" % [x(i), info(i)]
    (i:Return) : "   return"
    (i:Goto) : "   goto %~" % [x(i)]
    (i:Break) : "   %~: break %~ when %~ %~ %~" % [type(i), x(i), y(i), op(i), z(i)]
    (i:Label) : "L<%~>" % [n(i)]
    (i:ExLabel) : "L<%~>" % [name(i)]
    (i:Match) : "   match(%,) %_ @ %_" % [xs(i), branches(i), info(i)]
    (i:Dispatch) : "   dispatch(%,) %_ @ %_" % [xs(i), branches(i), info(i)]
    (i:DefData) : "   .data"
    (i:DefText) : "   .text"
    (i:DefByte) : "   .byte %~" % [value(i)]
    (i:DefInt) : "   .int %~" % [value(i)]
    (i:DefLong) : "   .long %~" % [value(i)]
    (i:DefFloat) : "   .float %~" % [value(i)]
    (i:DefDouble) : "   .double %~" % [value(i)]
    (i:DefString) : "   .string %~" % [value(i)]
    (i:DefSpace) : "   .space %~" % [size(i)]
    (i:DefLabel) : "   .label L<%~>" % [n(i)]

defmethod print (o:OutputStream, b:Branch) :
  print(o, "(%,) => L%_" % [tags(b), n(b)])

defmethod print (o:OutputStream, i:Imm) :
  print{o, _} $ match(i) :
    (i:IntImm) : value(i)
    (i:TagImm) : "T%_" % [n(i)]
    (i:Mem) :
      if offset(i) == 0 : "M%_" % [n(i)]
      else : "(M%_ + %_)" % [n(i), offset(i)]
    (i:ExMem) :
      if offset(i) == 0 : "M%_" % [lbl(i)]
      else : "(M%_ + %_)" % [lbl(i), offset(i)]
    (i:RegSP) : "rsp"
    (i:Reg) : "R%_" % [n(i)]
    (i:FReg) : "F%_" % [n(i)]

defmethod print (o:OutputStream, t:ASMType) :
  print{o, _} $ match(t) :
    (t:ByteT) : "byte"
    (t:IntT) : "int"
    (t:LongT) : "long"
    (t:FloatT) : "float"
    (t:DoubleT) : "double"

defmethod print (o:OutputStream, op:Op) :
  print{o, _} $ match(op) :
    (op:AddOp) : "add"
    (op:SubOp) : "sub"
    (op:MulOp) : "mul"
    (op:DivOp) : "div"
    (op:ModOp) : "mod"
    (op:AndOp) : "and"
    (op:OrOp) : "or"
    (op:XorOp) : "xor"
    (op:ShlOp) : "shl"
    (op:ShrOp) : "shr"
    (op:AshrOp) : "ashr"
    (op:EqOp) : "eq"
    (op:NeOp) : "ne"
    (op:LtOp) : "lt"
    (op:GtOp) : "gt"
    (op:LeOp) : "le"
    (op:GeOp) : "ge"
    (op:UleOp) : "ule"
    (op:UltOp) : "ult"
    (op:UgtOp) : "ugt"
    (op:UgeOp) : "uge"
    (op:NotOp) : "not"
    (op:NegOp) : "neg"
    (op:DivModOp) : "divmod"
    (op:BitSetOp) : "bitset"
    (op:BitNotSetOp) : "bitnotset"