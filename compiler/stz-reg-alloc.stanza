;See License.txt for details about licensing.

defpackage stz/reg-alloc :
  import core
  import collections
  import stz/algorithms
  import stz/tgt-ir
  import stz/kl-ir
  import stz/ids

;============================================================
;===================== Driver ===============================
;============================================================

public defn allocate-registers (ins:Collection<TGIns>) :
  load-instructions(ins)
  remove-critical-edges()
  compute-predecessors()
  liveness-analysis()
  print-prog()
  clear-working-set()

;============================================================
;======================= Utilities ==========================
;============================================================

;============================================================
;========================== IR ==============================
;============================================================

;==============================
;==== Variable Definitions ====
;==============================

deftype Imm
defstruct Var <: Imm :
  n: Int
  reg? : False|Reg|FReg
defstruct Val <: Imm :
  value: TGImm
  
defstruct Reg :
  n: Int
defstruct FReg :
  n: Int
  
;=================================
;==== Instruction Definitions ====
;=================================
public deftype Ins
public defmulti killed? (i:Ins) -> False|List<Int>

public defstruct Set <: Ins :
  x: Var
  y: Imm
  killed?: False|List<Int> with: (as-method => true)

public defstruct Args <: Ins :
  xs: List<Var>
  ctxt: FnContext
  killed?: False|List<Int> with: (as-method => true)

public defstruct Return <: Ins :
  xs: List<Imm>
  ctxt: FnContext
  killed?: False|List<Int> with: (as-method => true)
   
public defstruct Call <: Ins :
  xs: List<Var>
  f: Imm
  ys: List<Imm>
  type: CallType
  killed?: False|List<Int> with: (as-method => true)
   
public defstruct Op <: Ins :
  op: TGOp
  xs: List<Var>
  ys: List<Imm>   
  killed?: False|List<Int> with: (as-method => true)

public defstruct Branch <: Ins :
  op: TGOp
  xs: List<Imm>
  killed?: False|List<Int> with: (as-method => true)

public defstruct Save <: Ins :
   x: Var
   
public defstruct Load <: Ins :
   x: Var

;==========================
;==== Block Definition ====
;==========================
public defstruct Block :
  ins: Vector<Ins>
  next: List<Int>

;========================
;=== Port Definition ====
;========================
defstruct Port :
   n: Int
   saved?: True|False
   loaded?: True|False|Any
   reg: False|Reg|FReg
   dist: Int

;==================================
;==== Convenience Constructors ====
;==================================

public defn Set (x:Var, y:Imm) : Set(x, y, false)
public defn Args (xs:List<Var>, ctxt:FnContext) : Args(xs, ctxt, false)
public defn Return (xs:List<Imm>, ctxt:FnContext) : Return(xs, ctxt, false)
public defn Call (xs:List<Var>, f:Imm, ys:List<Imm>, type:CallType) : Call(xs, f, ys, type, false)
public defn Op (op:TGOp, xs:List<Var>, ys:List<Imm>) : Op(op, xs, ys, false)
public defn Branch (op:TGOp, xs:List<Imm>) : Branch(op, xs, false)

;==========================
;==== Function Context ====
;==========================

public deftype FnContext
public defstruct StanzaContext <: FnContext
public defstruct CContext <: FnContext

;===================
;==== Call Type ====
;===================

public deftype CallType
public defstruct StanzaCall <: CallType :
  arity: Int
public defstruct StanzaTCall <: CallType :
  arity: Int
public defstruct CCall <: CallType :
  arity: Int
  vararity: Int
public defstruct StackSwitch <: CallType

;=====================
;==== Special Ops ====
;=====================

public defstruct ConvOp <: TGOp
defmethod print (o:OutputStream, op:ConvOp) :
  print(o, "conv")

public defstruct InterpretOp <: TGOp
defmethod print (o:OutputStream, op:InterpretOp) :
  print(o, "interpret")

public defstruct NewStackOp <: TGOp
defmethod print (o:OutputStream, op:NewStackOp) :
  print(o, "newstk")

public defstruct SaveCContextOp <: TGOp
defmethod print (o:OutputStream, op:SaveCContextOp) :
  print(o, "save-c-ctxt")

public defstruct LoadOp <: TGOp : (offset:Int)
defmethod print (o:OutputStream, op:LoadOp) :
  print(o, "load/%_" % [offset(op)])

public defstruct StoreOp <: TGOp : (offset:Int)
defmethod print (o:OutputStream, op:StoreOp) :
  print(o, "store/%_" % [offset(op)])

public defstruct MatchOp <: TGOp : (tagss:List<List<KTag>>)
defmethod print (o:OutputStream, op:MatchOp) :
  print(o, "match(%,)" % [tagss(op)])

public defstruct DispatchOp <: TGOp : (tagss:List<List<KTag>>)
defmethod print (o:OutputStream, op:DispatchOp) :
  print(o, "dispatch(%,)" % [tagss(op)])

public defstruct CastOp <: TGOp : (tag:KTag)
defmethod print (o:OutputStream, op:CastOp) :
  print(o, "cast(%_)" % [tag(op)])

;============================================================
;====================== Any =================================
;============================================================

defstruct Any <: Equalable
defmethod equal? (a:Any, b:Any) : true
defmethod print (o:OutputStream, x:Any) : print(o, "any")

;============================================================
;====================== Printing ============================
;============================================================

defn print-prog () :
  for i in 0 to nvars() do :
    println("val %_ : %_" % [i, VAR-TYPES[i]])
  for i in 0 to nblocks() do :
    println("block %_ :" % [i])
    if length(IN-PORTS) == nblocks() :
      println("input ports:")
      indented $ fn () :
        do(println, IN-PORTS[i])
    println("instructions:")
    if length(OUT-PORTS) == nblocks() :
      indented $ fn () :
        println(BLOCKS[i])
    println("output ports:")
    indented $ fn () :
      do(println, OUT-PORTS[i])

defmethod print (o:OutputStream, v:Imm) :
  print{o, _} $ match(v) :
    (v:Var) :
      val reg = match(reg?(v)) :
        (r:False) : ""
        (r) : ":%_" % [r]
      "V%_%_" % [n(v), reg]
    (v:Val) :
      value(v)

defmethod print (o:OutputStream, r:Reg) :
  print(o, "R%_" % [n(r)])
  
defmethod print (o:OutputStream, r:FReg) :
  print(o, "F%_" % [n(r)])

defmethod print (o:OutputStream, i:Ins) :
  val ks = match(killed?(i)) :
             (ks:False) : ""
             (ks:List<Int>) : " killed: %," % [ks]
  print{o, _} $ match(i) :
    (i:Set) : "%_ = %_%_" % [x(i), y(i), ks]
    (i:Args) : "(%,) = Args%_" % [xs(i), ks]
    (i:Call) : "(%,) = %_(%,) %_%_" % [xs(i), f(i), ys(i), type(i), ks]
    (i:Return) : "return (%,)%_" % [xs(i), ks]
    (i:Op) : "(%,) = %_(%,)%_" % [xs(i), op(i), ys(i), ks]
    (i:Branch) : "branch when %_(%,)%_" % [op(i), xs(i), ks]

defmethod print (o:OutputStream, c:FnContext) :
  print{o, _} $ match(c) :
    (c:StanzaContext) : "ST"
    (c:CContext) : "C"

defmethod print (o:OutputStream, c:CallType) :
  print{o, _} $ match(c) :
    (c:StanzaCall) : "S(%_)" % [arity(c)]
    (c:StanzaTCall) : "ST(%_)" % [arity(c)]
    (c:CCall) : "C(%_, %_)" % [arity(c), vararity(c)]
    (c:StackSwitch) : "STK"

defmethod print (o:OutputStream, b:Block) :
  do(println{o, _}, ins(b))
  print(o, "next: %," % [next(b)])

defmethod print (o:OutputStream, p:Port) :
   print(o, "%~ (s:%~, l:%~, at:%~, dist:%~)" % [n(p), saved?(p), loaded?(p), reg(p), dist(p)])

;============================================================
;=================== Working Functions ======================
;============================================================

defn do-defined (f: Var -> False, e:Ins) :
   match(e) :
      (e:Set) : f(x(e))
      (e:Args) : do(f, xs(e))
      (e:Call) : do(f, xs(e))
      (e:Return) : false
      (e:Op) : do(f, xs(e))
      (e:Branch) : false
      (e:Save) : false
      (e:Load) : f(x(e))

defn do-used (g: Var -> False, e:Ins) :
   defn gi (i:Imm) : match(i:Var) : g(i)
   match(e) :
      (e:Set) : gi(y(e))
      (e:Args) : false
      (e:Call) : (gi(f(e)), do(gi, ys(e)))
      (e:Return) : do(gi, xs(e))
      (e:Op) : do(gi, ys(e))
      (e:Branch) : do(gi, xs(e))
      (e:Save) : gi(x(e))
      (e:Load) : false
      
;============================================================
;===================== Working Set ==========================
;============================================================

val CONSTANTS = Vector<TGDefConst>()
val BLOCKS = Vector<Block>()
val VAR-TYPES = Vector<TGType>()
val IN-PORTS = Vector<List<Port>>()
val OUT-PORTS = Vector<List<Port>>()
val PREDECESSORS = Vector<List<Int>>()

defn nblocks () : length(BLOCKS)
defn nvars () : length(VAR-TYPES)

defn clear-working-set () :
  clear(CONSTANTS)
  clear(BLOCKS)
  clear(VAR-TYPES)

;============================================================
;================= Load into Working Set ====================
;============================================================

defn load-instructions (instructions:Collection<TGIns>) :
  ;========================
  ;==== Variable Table ====
  ;========================
  val var-table = HashTable<Int,Int>()
  defn make-var (n:Int, t:TGType) :
    var-table[n] = length(VAR-TYPES)
    add(VAR-TYPES, t)
  defn get-var (v:TGVar) :
    val n = var-table[n(v)]
    Var(n, false)
  defn get-imm (v:TGImm) :
    match(v) :
      (v:TGVar) : get-var(v)
      (v) : Val(v)
  defn get-vars (vs:List<TGVar>) :
    map(get-var, vs)
  defn get-imms (vs:List<TGImm>) :
    map(get-imm, vs)

  ;=====================
  ;==== Block Table ====
  ;=====================
  val block-table = HashTable<Int,Int>()
  var active-block : False|Block = false
  var active-block-index : False|Int = false
  
  defn open-block (lbl:Int) -> Int :
    if not key?(block-table, lbl) :
      val i = length(BLOCKS)
      block-table[lbl] = i
      add(BLOCKS, Block(Vector<Ins>(), List()))
    val i = block-table[lbl]
    active-block-index = i
    active-block = BLOCKS[i]
    i
    
  defn close-block (next-lbls:List<Int>) :
    val b = active-block
    match(b:Block) :
      val i = active-block-index as Int
      BLOCKS[i] = Block(ins(b), map(open-block, next-lbls))
      active-block = false
      active-block-index = false

  defn push (e:Ins) :
    match(active-block:False) :
      open-block(fresh-id())
    val b = active-block as Block
    add(ins(b), e)

  ;=================
  ;==== Loading ====
  ;=================
  open-block(fresh-id())
  for e in instructions do :
    match(e) :
      (e:TGDef) :
        make-var(n(e), type(e))
      (e:TGDefConst) :
        add(CONSTANTS, e)
      (e:TGArgs) :      
        push(Args(get-vars(xs(e)), StanzaContext()))
      (e:TGReturn) :
        push(Return(get-imms(xs(e)), StanzaContext()))
        close-block(List())
      (e:TGSet) :
        push(Set(get-var(x(e)), get-imm(y(e))))
      (e:TGConv) :
        push(Op(ConvOp(), List(get-var(x(e))), List(get-imm(y(e)))))
      (e:TGInterpret) :
        push(Op(InterpretOp(), List(get-var(x(e))), List(get-imm(y(e)))))
      (e:TGBinOp) :
        push(Op(op(e), List(get-var(x(e))), List(get-imm(y(e)), get-imm(z(e)))))
      (e:TGUnaOp) :
        push(Op(op(e), List(get-var(x(e))), List(get-imm(y(e)))))
      (e:TGLoad) :
        push(Op(LoadOp(offset(e)), List(get-var(x(e))), List(get-imm(y(e)))))
      (e:TGStore) :
        push(Op(StoreOp(offset(e)), List(), List(get-imm(x(e)), get-imm(y(e)))))
      (e:TGCall) :
        val type = StanzaCall(arity(e))
        push(Call(get-vars(xs(e)), get-imm(f(e)), get-imms(ys(e)), type))
      (e:TGTCall) :
        val type = StanzaTCall(arity(e))
        push(Call(List(), get-imm(f(e)), get-imms(ys(e)), type))
        close-block(List())
      (e:TGSwitchStack) :
        val type = StackSwitch()
        push(Call(List(get-var(x(e))), get-imm(s(e)), List(get-imm(y(e))), type))
      (e:TGLabel) :
        close-block(List(n(e)))
        open-block(n(e))
      (e:TGGoto) :
        close-block(List(n(e)))
      (e:TGBinCmp) :
        push(Branch(op(e), List(get-imm(x(e)), get-imm(y(e)))))
        val alt = fresh-id()
        close-block(List(n(e), alt))
        open-block(alt)
      (e:TGUnaCmp) :
        push(Branch(op(e), List(get-imm(x(e)))))
        val alt = fresh-id()
        close-block(List(n(e), alt))
        open-block(alt)
      (e:TGNullCmp) :
        push(Branch(op(e), List()))
        val alt = fresh-id()
        close-block(List(n(e), alt))
        open-block(alt)
      (e:TGMatch) :
        push(Branch(MatchOp(map(tags, branches(e))), get-imms(xs(e))))
        close-block(map(n, branches(e)))
      (e:TGDispatch) :
        push(Branch(DispatchOp(map(tags, branches(e))), get-imms(xs(e))))
        close-block(map(n, branches(e)))
      (e:TGCast) :
        push(Op(CastOp(tag(e)), List(), List(get-imm(x(e)))))
      (e:TGCallC) :
        val type = CCall(length(ys(e)), length(vs(e)))
        val args = append(get-imms(ys(e)), get-imms(vs(e)))
        push(Call(get-vars(xs(e)), get-imm(f(e)), args, type))
      (e:TGArgsC) :
        push(Args(get-vars(xs(e)), CContext()))   
      (e:TGReturnC) :
        push(Return(get-imms(xs(e)), CContext()))
        close-block(List())
      (e:TGNewStack) :
        push(Op(NewStackOp(), List(), List()))
      (e:TGSaveCContext) :
        push(Op(SaveCContextOp(), List(), List()))

;============================================================
;================= Critical Edge Removal ====================
;============================================================

defn remove-critical-edges () :
  ;Count predecessors
  val num-preds-table = Array<Int>(nblocks(),0)
  for i in 0 to nblocks() do :
    val b = BLOCKS[i]
    for n in next(b) do :
      num-preds-table[n] = 1 + num-preds-table[n]
      
  ;Insert safe blocks
  defn safe-block (next:Int) :
    val id = length(BLOCKS)
    add(BLOCKS, Block(Vector<Ins>(), List(next)))
    id
  for i in 0 to nblocks() do :
    val b = BLOCKS[i]
    ;If multiple successors
    if length(next(b)) > 1 :
      val next* = for n in next(b) map :
        if num-preds-table[n] > 1 : safe-block(n)
        else : n
      BLOCKS[i] = Block(ins(b), next*)

;============================================================
;================= Compute Predecessors =====================
;============================================================
defn compute-predecessors () :
  clear(PREDECESSORS, nblocks(), List())
  for (b in BLOCKS, i in 0 to false) do :
    for n in next(b) do :
      PREDECESSORS[n] = cons(i, PREDECESSORS[n])
  
;============================================================
;================== Liveness Analysis =======================
;============================================================

defstruct VarUse :
  block: Int
  dist: Int

defn liveness-analysis () :
  ;Clear state
  val var-uses = Array<List<VarUse>>(nvars(), List())
  val block-defs = BitArray(nblocks() * nvars(), false)

  ;Mark uses and defs
  for (blk in BLOCKS, i in 0 to false) do :
    ;Marking functions
    defn mark-defined (v:Var) :
      block-defs[i * nvars() + n(v)] = true
    defn defined? (v:Var) :
      block-defs[i * nvars() + n(v)]
    defn mark-used (v:Var, d:Int) :
      if not defined?(v) :
        val use = VarUse(i,d)
        var-uses[n(v)] = cons(use, var-uses[n(v)])
    ;Mark instructions
    for (e in ins(blk), i in 0 to false) do :
      do-used(mark-used{_, i}, e)
      do-defined(mark-defined, e)
      
  ;Propagate liveness
  clear(IN-PORTS, nblocks(), List())
  clear(OUT-PORTS, nblocks(), List())
  val in-dists = Array<Int>(nblocks(), INT-MAX)
  val out-dists = Array<Int>(nblocks(), INT-MAX)
  val in-dirty = Vector<Int>()
  val out-dirty = Vector<Int>()

  ;For each variable
  for (v in 0 to nvars(), uses in var-uses) do :
    if not empty?(uses) :
      ;Mark all usages of the variable
      clear(in-dirty)
      clear(out-dirty)
      for use in uses do :
        mark-live-in(block-defs, in-dists, out-dists, in-dirty, out-dirty,
                     block(use), v, dist(use))
      ;Record all live in ports
      for b in in-dirty do :
        val p = Port(v, false, Any(), false, in-dists[b])
        IN-PORTS[b] = cons(p, IN-PORTS[b])
        in-dists[b] = INT-MAX
      ;Record all live in ports
      for b in out-dirty do :
        val p = Port(v, false, Any(), false, out-dists[b])
        OUT-PORTS[b] = cons(p, OUT-PORTS[b])        
        out-dists[b] = INT-MAX      

;Mark that variable v is live-in to block b with distance d
lostanza defn mark-live-in (defs:ref<BitArray>,
                            in-dists:ref<Array<Int>>,
                            out-dists:ref<Array<Int>>,
                            in-dirty:ref<Vector<Int>>,
                            out-dirty:ref<Vector<Int>>,
                            b:ref<Int>,
                            v:ref<Int>,
                            d:ref<Int>) -> ref<False> :
  ;Only mark if distance is smaller
  val old-value = get(in-dists, b).value
  if d.value >= old-value : return false
  set(in-dists, b, d)

  ;Note that block b has been marked
  if old-value == INT-MAX.value : 
    add(in-dirty, b)
    
  ;Loop through all predecessors of block
  ;and mark variable v as live-out from them
  labels :
    begin :
      goto loop(get(PREDECESSORS, b))
    loop (preds:ref<List<Int>>) :
      if empty?(preds) == false :
        mark-live-out(defs, in-dists, out-dists, in-dirty, out-dirty, head(preds), v, d)
        goto loop(tail(preds))

  ;Done
  return false


;Mark that variable v is live-out from block b with distance d
lostanza defn mark-live-out (defs:ref<BitArray>,
                             in-dists:ref<Array<Int>>,
                             out-dists:ref<Array<Int>>,
                             in-dirty:ref<Vector<Int>>,
                             out-dirty:ref<Vector<Int>>,
                             b:ref<Int>,
                             v:ref<Int>,
                             d:ref<Int>) -> ref<False> :
  ;Only mark if distance is smaller
  val old-value = get(out-dists, b).value
  if d.value >= old-value : return false
  set(out-dists, b, d)

  ;Note that block b has been marked
  if old-value == INT-MAX.value :
    add(out-dirty, b)
    
  ;Mark variable v as live-in to block if not defined in block
  val idx = b.value * nvars().value + v.value
  if get(defs, new Int{idx}) == false :
    val d* = new Int{d.value + length(ins(get(BLOCKS, b))).value}
    mark-live-in(defs, in-dists, out-dists, in-dirty, out-dirty, b, v, d*)
      
  ;Done
  return false