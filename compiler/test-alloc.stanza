defpackage test-alloc :
  import core
  import collections
  import stz/vm-ir
  import stz/backend
  import stz/reg-alloc with :
    prefix(Ins) => reg-alloc-
  import stz/vm-normalize
  import stz/codegen
  import stz/asm-ir
  import stz/asm-emitter
  import stz/stitcher

public defn allocate-pkg (filename:String) :
  val vmp = read-vm-package(filename)
  val backend = X64Backend()
  val vmp2 = normalize(vmp, backend)  
  val stubs = AsmStubs(backend)
  val emitter = new CodeEmitter :
    defmethod emit (this, i:Ins) :
      print("    ")
      println(i)
  for f in funcs(vmp2) do :
    println("Allocating function %_" % [id(f)])
    allocate-registers(func(f), emitter, backend, stubs)

public defn normalize-pkg (filename:String) :
  val vmp = read-vm-package(filename)
  val vmp* = normalize(vmp, X64Backend())
  println(vmp*)

public defn test-emit (filename:String) :
  val file = FileOutputStream(filename)
  val backend = X64Backend()
  val emitter = new CodeEmitter :
    defmethod emit (this, i:Ins) :
      emit(i, backend)
  with-output-file(file, fn () :
    val stubs = AsmStubs(backend)
    compile-entry-function(emitter, stubs))

public defn link-together (filenames:Tuple<String>) :
  val backend = X64Backend()
  val stubs = AsmStubs(backend)
  val vmps = map(read-vm-package, filenames)
  val stitcher = Stitcher(vmps, stubs)
  val file-emitter = new CodeEmitter :
    defmethod emit (this, i:Ins) :
      print("   ")
      println(i)
  emit-tables(stitcher, file-emitter)
  for p in vmps do :
    val np = normalize(p, backend)
    val emitter = emitter(stitcher, package(p), file-emitter)
    for f in funcs(np) do :
      allocate-registers(func(f), emitter, backend, stubs)
  
    
#if-defined(TEST-ALLOC-MAIN) :
  allocate-pkg(command-line-arguments()[1])
    