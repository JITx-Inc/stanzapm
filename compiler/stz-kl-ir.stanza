;See License.txt for details about licensing.

defpackage stz/kl-ir :
  import core
  import collections
  import stz/tl-ir
  import stz/pl-ir
  import stz/primitives  

;Use utilities for defining ASTs quickly.
#use-added-syntax(stz-ast-lang, stz-printer-lang)

;============================================================
;===================== Structures ===========================
;============================================================

public defast :
  ;Tags
  deftype KTag
  defnodes KTag :
    KOf :
      n: Int
    KTVar :
      n: Int
    KAnd :
      a: KTag
      b: KTag
    KOr :
      a: KTag
      b: KTag
    KTop
    KBot
  
  ;Commands
  deftype KComm
  defnodes KComm :
    KDef :
      n: Int
      tag: KTag
      value: KExp
    KDefVar :
      n: Int
      tag: KTag
      value: False|KExp
    KDefn :
      n: Int
      value: KFn
    KDefmulti :
      n: Int
      tail?: True|False
      targs: List<Int>
      a1: List<KTag>
      a2: KTag
    KDefmethod :
      multi: Int
      targs: List<KTag>
      thisn: False|Int
      value: KFn
    KDefTag :
      n: Int
      parent: False|KTag
      children: List<KChild>
    KInit :
      exp: KExp

    KLSDef :
      n: Int
      type: KLSType
      value: KLSExp
    KLSDefVar :
      n: Int
      type: KLSType
      value: False|KLSExp
    KLSDefn :
      n: Int
      value: KLSFn
    KLSDefmethod :
      multi: Int
      targs: List<KTag>
      value: KLSFn      
    KLSDefStruct :
      n: Int
      parent: False|KTag
      fields: List<KStructField>
      rfield: False|KStructField
    KLSExternFn :
      n: Int
      lbl: Symbol
      value: KLSFn
    KLSExtern :
      n: Int
      lbl: Symbol
      type: KLSType      
    KLSInit :
      comm: KLSComm

  ;Expressions
  deftype KExp
  defnodes KExp :
    KSet :
      n: Int
      tag: KTag
      value: KExp
    KCast :
      exp: KExp
      tag: KTag
    KLet :
      def: KDef|KDefVar
      body: KExp
    KLetRec :
      defs: List<KDefn>
      body: KExp
    KSeq :
      a: KExp
      b: KExp
    KMatch :
      args: List<KExp>
      branches: List<KBranch>
    KNew :
      tag: KTag
      methods: List<KDefmethod>
    KDo :
      func: KExp
      args: List<KExp>
      a1: List<KTag>
      a2: KTag
    KVar :
      n: Int
    KLiteral :
      value: ?
    KTuple :
      exps: List<KExp>
    KTupleGet :
      exp: KExp
      index: Int
    KEnsureLength :
      exp: KExp
      length: Int
    KMix :
      exps: List<KCurry|KVar>
    KCurry :
      n: Int
      targs: List<KTag>
    KAFn :
      value: KFunc
    KPrim :
      op: Primitive
      args: List<KExp>

    ;[Mix Conversion]
    KDispatch :
      args: List<KExp>
      branches: List<KBranch>
    ;[Void Checks]
    KEnsureSet :
      exp: KExp
    ;[Boundary Guards]  
    KDo! :
      func: KExp
      targs: List<KTag>
      args: List<KExp>
      
  ;LoStanza Types
  deftype KLSType
  defnodes KLSType :
    KByteT
    KIntT
    KLongT
    KFloatT
    KDoubleT
    KUnknownT
    KPtrT :
     type: KLSType
    KRefT :
     tag: KTag
    KFnT :
     a: List<KLSType>
     r: False|KLSType
     b: KLSType
    KStructT :
     n: Int
      
  ;LoStanza Commands
  deftype KLSComm
  defnodes KLSComm :
    KLSExec :
      exp: KLSExp
    KLSSet :
      loc: KLoc
      value: KLSExp
    KLSLabels :
      blocks: List<KLSLabeledBlock>
    KLSGoto :
      n: Int
      args: List<KLSExp>
    KLSReturn :
      exp: KLSExp
    KLSDefLocal :
      n: Int
      type: KLSType
      value: KLSExp
    KLSDefLocalVar :
      n: Int
      type: KLSType
      value: False|KLSExp
    KLSSeq :
      a: KLSComm
      b: KLSComm
    KLSIf :
      pred: KLSExp
      conseq: KLSComm
      alt: KLSComm
    KLSMatch :
      args: List<KLSExp>
      branches: List<KLSBranch>
    KLSSkip
    
  ;LoStanza Locations
  deftype KLoc
  defnodes KLoc :
    KValue :
      exp: KLSExp
    KDeref :
      exp: KLSExp
      type: KLSType
    KDeptr :
      exp: KLSExp
      type: KLSType
    KSlot :
      exp: KLSExp
      type: KLSType
      index: KLSExp
    KField :
      exp: KLoc
      n: Int
      
  ;LoStanza Expressions
  deftype KLSExp
  defnodes KLSExp :
    KLSVar :
      n: Int
    KLSRef :
      n: Int
      args: List<KLSExp>
    KLSArray :
      n: Int
      args: List<KLSExp>
    KLSStruct :
      n: Int
      args: List<KLSExp>
    KLSPtr :
      loc: KLoc      
    KLSRead :
      loc: KLoc
    KLSCall :
      func: KLSExp
      args: List<KLSExp>
      type: KLSType      
    KLSCallC :
      func: KLSExp
      args: List<KLSExp>
      varargs: List<KLSExp>
      type: KLSType
    KLSLiteral :
      value: ?
    KLSMix :
      exps: List<KLSCurry|KLSVar>
    KLSCurry :
      n: Int
      targs: List<KTag>
    KLSCast :
      exp: KLSExp
      type: KLSType
    KLSAnd :
      a: KLSExp
      b: KLSExp
    KLSOr :
      a: KLSExp
      b: KLSExp
    KLSPrim :
      op: LSPrimitive
      args: List<KLSExp>
    KLSSizeof :
      type: KLSType
    KLSTagof :
      n: Int

    ;[For closure creation]
    KLSAFn :
      value: KFunc

  ;==========================
  ;==== Mapper Functions ====
  ;==========================
  ;KLSExp
  defmapper (f:KLSExp -> KLSExp) :
    (x:KLSExp) : f(x)
    (x:List<KLSExp>) : map(f, x)
    (x:False|KLSExp) : match(x:KLSExp) : f(x)
    (x:List<KLSCurry|KLSVar>) : map({f(_) as KLSCurry|KLSVar}, x)
  defdoer (f:KLSExp -> ?) :
    (x:KLSExp) : f(x)
    (x:List<KLSExp>) : do(f, x)
    (x:False|KLSExp) : match(x:KLSExp) : f(x)
    (x:List<KLSCurry|KLSVar>) : do(f, x)
    
  ;KLSComm
  defmapper (f:KLSComm -> KLSComm) :
    (x:KLSComm) : f(x)
    (x:List<KLSBranch>) : map(map{f, _}, x)
    (x:List<KLSLabeledBlock>) : map(map{f, _}, x)
    (x:KLSFn) : map(f, x)
  defdoer (f:KLSComm -> ?) :  
    (x:KLSComm) : f(x)
    (x:List<KLSBranch>) : do(do{f, _}, x)
    (x:List<KLSLabeledBlock>) : do(do{f, _}, x)
    (x:KLSFn) : do(f, x)
    
  ;KLoc
  defmapper (f:KLoc -> KLoc) :
    (x:KLoc) : f(x)
  defdoer (f:KLoc -> ?) :
    (x:KLoc) : f(x)
    
  ;KExp
  defmapper (f:KExp -> KExp) :
    (x:KExp) : f(x)
    (x:False|KExp) : match(x:KExp) : f(x)
    (x:List<KExp>) : map(f, x)
    (x:KFunc) : map(f, x)
    (x:KFn) : map(f, x)
    (x:List<KBranch>) : map(map{f, _}, x)
    (x:List<KCurry|KVar>) : map({f(_) as KCurry|KVar}, x)
  defdoer (f:KExp -> ?) :
    (x:KExp) : f(x)
    (x:False|KExp) : match(x:KExp) : f(x)
    (x:List<KExp>) : do(f, x)
    (x:KFunc) : do(f, x)
    (x:KFn) : do(f, x)
    (x:List<KBranch>) : do(do{f, _}, x)
    (x:List<KCurry|KVar>) : do(f, x)

  ;KComm
  defmapper (f:KComm -> KComm) :
    (x:KDef|KDefVar) : f(x) as KDef|KDefVar
    (x:List<KDefn>) : map({f(_) as KDefn}, x)
    (x:List<KDefmethod>) : map({f(_) as KDefmethod}, x)
  defdoer (f:KComm -> ?) :
    (x:KDef|KDefVar) : f(x)
    (x:List<KDefn>) : do(f, x)
    (x:List<KDefmethod>) : do(f, x)

  ;KTag
  defmapper (f:KTag -> KTag) :
    (x:KTag) : f(x)
    (x:List<KTag>) : map(f, x)
    (x:False|KTag) : match(x:KTag) : f(x)
    (x:List<KChild>) : map(map{f, _}, x)
    (x:KFunc) : map(f, x)
    (x:KFn) : map(f, x)
    (x:List<KBranch>) : map(map{f, _}, x)
  defdoer (f:KTag -> ?) :
    (x:KTag) : f(x)
    (x:List<KTag>) : do(f, x)
    (x:False|KTag) : match(x:KTag) : f(x)
    (x:List<KChild>) : do(do{f, _}, x)
    (x:KFunc) : do(f, x)
    (x:KFn) : do(f, x)
    (x:List<KBranch>) : do(do{f, _}, x)

  ;KLSType
  defmapper (f:KLSType -> KLSType) :
    (x:KLSType) : f(x)
    (x:List<KLSType>) : map(f, x)
    (x:False|KLSType) : match(x:KLSType) : f(x)
    (x:False|KStructField) : match(x:KStructField) : map(f, x)
    (x:List<KStructField>) : map(map{f, _}, x)
  defdoer (f:KLSType -> ?) :
    (x:KLSType) : f(x)
    (x:List<KLSType>) : do(f, x)
    (x:False|KLSType) : match(x:KLSType) : f(x)
    (x:False|KStructField) : match(x:KStructField) : do(f, x)
    (x:List<KStructField>) : do(do{f, _}, x)

  ;Other
  ignore :
    ?
    Symbol
    True|False
    Int
    List<Int>
    False|Int
    Primitive
    LSPrimitive    

  ;=================
  ;==== Mappers ====
  ;=================
  ;KExp
  make-mapper(f:KExp -> KExp, e:KExp)
  make-doer(f:KExp -> ?, e:KExp)
  make-mapper(f:KComm -> KComm, e:KExp)
  make-doer(f:KComm -> ?, e:KExp)
  make-mapper(f:KTag -> KTag, e:KExp)
  make-doer(f:KTag -> ?, e:KExp)

  ;KComm
  make-mapper(f:KExp -> KExp, c:KComm)
  make-doer(f:KExp -> ?, c:KComm)
  make-mapper(f:KLSExp -> KLSExp, c:KComm)
  make-doer(f:KLSExp -> ?, c:KComm)
  make-mapper(f:KLSComm -> KLSComm, c:KComm)
  make-doer(f:KLSComm -> ?, c:KComm)
  make-mapper(f:KTag -> KTag, c:KComm)
  make-doer(f:KTag -> ?, c:KComm)
  make-mapper(f:KLSType -> KLSType, c:KComm)
  make-doer(f:KLSType -> ?, c:KComm)

  ;KLSExp
  make-mapper(f:KLSExp -> KLSExp, e:KLSExp)
  make-doer(f:KLSExp -> ?, e:KLSExp)
  make-mapper(f:KLSComm -> KLSComm, e:KLSExp)
  make-doer(f:KLSComm -> ?, e:KLSExp)
  make-mapper(f:KLoc -> KLoc, e:KLSExp)
  make-doer(f:KLoc -> ?, e:KLSExp)
  make-mapper(f:KTag -> KTag, e:KLSExp)
  make-doer(f:KTag -> ?, e:KLSExp)
  make-mapper(f:KLSType -> KLSType, e:KLSExp)
  make-doer(f:KLSType -> ?, e:KLSExp)
  make-mapper(f:KExp -> KExp, e:KLSExp)
  make-doer(f:KExp -> ?, e:KLSExp)

  ;KLSComm
  make-mapper(f:KLSExp -> KLSExp, c:KLSComm)
  make-doer(f:KLSExp -> ?, c:KLSComm)
  make-mapper(f:KLSComm -> KLSComm, c:KLSComm)
  make-doer(f:KLSComm -> ?, c:KLSComm)
  make-mapper(f:KLoc -> KLoc, c:KLSComm)
  make-doer(f:KLoc -> ?, c:KLSComm)
  make-mapper(f:KLSType -> KLSType, c:KLSComm)
  make-doer(f:KLSType -> ?, c:KLSComm)

  ;KLoc
  make-mapper(f:KLSExp -> KLSExp, l:KLoc)
  make-doer(f:KLSExp -> ?, l:KLoc)
  make-mapper(f:KLoc -> KLoc, l:KLoc)
  make-doer(f:KLoc -> ?, l:KLoc)
  make-mapper(f:KLSType -> KLSType, l:KLoc)
  make-doer(f:KLSType -> ?, l:KLoc)

  ;KTag
  make-mapper(f:KTag -> KTag, t:KTag)
  make-doer(f:KTag -> ?, t:KTag)
  
  ;KLSType
  make-mapper(f:KTag -> KTag, t:KLSType)
  make-doer(f:KTag -> ?, t:KLSType)
  make-mapper(f:KLSType -> KLSType, t:KLSType)
  make-doer(f:KLSType -> ?, t:KLSType)  
  
      
;Children
public defstruct KChild :
  n: Int
  parent: KTag

;Functions
public deftype KFunc

public defstruct KFn <: KFunc :
  tail?: True|False
  targs: List<Int>
  a1: List<KTag>
  a2: KTag
  args: List<Int>
  body: KExp
public defstruct KMultifn <: KFunc :
  funcs: List<KFn>

;Branches
public defstruct KBranch :
  args: List<Int>
  tags: List<KTag>
  body: KExp

public defstruct KLSBranch :
  args: List<Int>
  tags: List<KTag>
  body: KLSComm

public defstruct KLSLabeledBlock :
  n: Int
  args: List<Int>
  types: List<KLSType>
  body: KLSComm

public defstruct KLSFn :
  tail?: True|False
  targs: List<Int>
  a1: List<KLSType>
  a2: KLSType
  args: List<Int>
  body: KLSComm

public defstruct KStructField :
  n: Int
  type: KLSType    

public defstruct KPackage :
  name: Symbol
  ids: PkgIds
  comms: List<KComm>

;============================================================
;====================== Mappers =============================
;============================================================

;KLSBranch
public defn map (f:KLSComm -> KLSComm, b:KLSBranch) :
  KLSBranch(args(b), tags(b), f(body(b)))
public defn do (f:KLSComm -> ?, b:KLSBranch) :
  f(body(b))
public defn map (f:KTag -> KTag, b:KLSBranch) :
  KLSBranch(args(b), map(f,tags(b)), body(b))
public defn do (f:KTag -> ?, b:KLSBranch) :
  do(f, tags(b))

;KBranch
public defn map (f:KExp -> KExp, b:KBranch) :
  KBranch(args(b), tags(b), f(body(b)))
public defn do (f:KExp -> ?, b:KBranch) :
  f(body(b))
public defn map (f:KTag -> KTag, b:KBranch) :
  KBranch(args(b), map(f,tags(b)), body(b))
public defn do (f:KTag -> ?, b:KBranch) :
  do(f, tags(b))

;KLSLabeledBlock
public defn map (f:KLSType -> KLSType, b:KLSLabeledBlock) :
  KLSLabeledBlock(n(b), args(b), map(f,types(b)), body(b))
public defn do (f:KLSType -> ?, b:KLSLabeledBlock) :
  do(f,types(b))
public defn map (f:KLSComm -> KLSComm, b:KLSLabeledBlock) :
  KLSLabeledBlock(n(b), args(b), types(b), f(body(b)))
public defn do (f:KLSComm -> ?, b:KLSLabeledBlock) :
  f(body(b))

;Func
public defn map<?T> (f:KExp -> KExp, x:?T&KFunc) -> T :
  {_ as T&KFunc} $ match(x) :
    (x:KFn) :
      KFn(tail?(x), targs(x), a1(x), a2(x), args(x), f(body(x)))
    (x:KMultifn) :
      KMultifn(map(map{f, _}, funcs(x)))
public defn do (f:KExp -> ?, x:KFunc) :
  match(x) :
    (x:KFn) :
      f(body(x))
    (x:KMultifn) :
      do(do{f, _}, funcs(x))

public defn map<?T> (f:KTag -> KTag, x:?T&KFunc) -> T :
  {_ as T&KFunc} $ match(x) :
    (x:KFn) :
      KFn(tail?(x), targs(x), map(f,a1(x)), f(a2(x)), args(x), body(x))
    (x:KMultifn) :
      KMultifn(map(map{f, _}, funcs(x)))
public defn do (f:KTag -> ?, x:KFunc) :
  match(x) :
    (x:KFn) :
      do(f, a1(x))
      f(a2(x))
    (x:KMultifn) :
      do(do{f, _}, funcs(x))

;KLSFn
public defn map (f:KLSComm -> KLSComm, x:KLSFn) :
  KLSFn(tail?(x), targs(x), a1(x), a2(x), args(x), f(body(x)))
public defn do (f:KLSComm -> ?, x:KLSFn) :
  f(body(x))
public defn map (f:KLSType -> KLSType, x:KLSFn) :
  KLSFn(tail?(x), targs(x), map(f,a1(x)), f(a2(x)), args(x), body(x))
public defn do (f:KLSType -> ?, x:KLSFn) :
  do(f,a1(x))
  f(a2(x))

;StructField
public defn map (f:KLSType -> KLSType, s:KStructField) :
  KStructField(n(s), f(type(s)))
public defn do (f:KLSType -> ?, s:KStructField) :
  f(type(s))

;KChild
public defn map (f:KTag -> KTag, c:KChild) :
  KChild(n(c), f(parent(c)))
public defn do (f:KTag -> ?, c:KChild) :
  f(parent(c))

;============================================================
;=================== Recursive Mappers ======================
;============================================================

;KExp
public defn mapr (f:KExp -> KExp, x:KLSExp) :
  defn fe (e:KLSExp) : mapr(f, e)
  defn fl (l:KLoc) : mapr(f, l)
  map(fl, map(fe, map(f, x)))
public defn mapr (f:KExp -> KExp, x:KLoc) :
  defn fe (e:KLSExp) : mapr(f, e)
  defn fl (l:KLoc) : mapr(f, l)
  map(fl, map(fe, x))
public defn mapr (f:KExp -> KExp, x:KExp) :
  defn fc (c:KComm) : mapr(f, c)
  map(fc, map(f, x))
public defn mapr (f:KExp -> KExp, x:KComm) :
  defn fe (e:KExp) : mapr(f, e)
  map(fe, x)

;KLSExp
public defn mapr (f:KLSExp -> KLSExp, x:KLSExp) :
  defn fl (l:KLoc) : mapr(f, l)
  map(fl, map(f, x))
public defn mapr (f:KLSExp -> KLSExp, x:KLoc) :
  defn fl (l:KLoc) : mapr(f, l)
  map(fl, map(f, x))
public defn mapr (f:KLSExp -> KLSExp, x:KLSComm) :
  defn fl (l:KLoc) : mapr(f, l)
  map(fl, map(f, x))
public defn mapr (f:KLSExp -> KLSExp, x:KComm) :
  defn fc (c:KLSComm) : mapr(f, c)
  map(fc, map(f, x))

;KComm
public defn mapr (f:KComm -> KComm, x:KComm) :
  defn fe (e:KExp) : mapr(f, e)
  map(fe, x)
public defn mapr (f:KComm -> KComm, x:KExp) :
  defn fe (e:KExp) : mapr(f, e)
  map(fe, map(f, x))
public defn mapr (f:KComm -> KComm, x:KLSExp) :
  defn fe (e:KExp) : mapr(f, e)
  mapr(fe, x)
public defn mapr (f:KComm -> KComm, x:KLoc) :
  defn fe (e:KExp) : mapr(f, e)
  mapr(fe, x)

public defn dor (f:KComm -> ?, x:KComm) :
  defn f* (c:KComm) : (f(c), c)
  mapr(f*, x)
  false
  
;KLoc
public defn mapr (f:KLoc -> KLoc, x:KLSExp) :
  defn fe (e:KLSExp) : mapr(f, e)
  map(fe, map(f, x))
public defn mapr (f:KLoc -> KLoc, x:KLoc) :
  defn fe (e:KLSExp) : mapr(f, e)
  map(fe, map(f, x))
public defn mapr (f:KLoc -> KLoc, x:KLSComm) :
  defn fe (e:KLSExp) : mapr(f, e)
  map(fe, map(f, x))
public defn mapr (f:KLoc -> KLoc, x:KComm) :
  defn fc (c:KLSComm) : mapr(f, c)
  defn fe (e:KLSExp) : mapr(f, e)
  map(fc, map(fe, x))

;KTag
public defn mapr (f:KTag -> KTag, x:KExp) :
  defn fe (e:KExp) : mapr(f, e)
  map(fe, map(f, x))
public defn mapr (f:KTag -> KTag, x:KLSType) :
  defn ft (t:KLSType) : mapr(f, t)
  map(ft, map(f, x))
public defn mapr (f:KTag -> KTag, x:KLSExp) :
  defn ft (t:KLSType) : mapr(f, t)
  mapr(ft, x)
public defn mapr (f:KTag -> KTag, x:KLoc) :
  defn ft (t:KLSType) : mapr(f, t)
  mapr(ft, x)
public defn mapr (f:KTag -> KTag, x:KLSComm) :
  defn ft (t:KLSType) : mapr(f, t)
  mapr(ft, x)
public defn mapr (f:KTag -> KTag, x:KComm) :
  defn fe (e:KExp) : mapr(f, e)
  defn fle (e:KLSExp) : mapr(f, e)
  defn fc (c:KLSComm) : mapr(f, c)
  defn ft (t:KLSType) : mapr(f, t)
  map(fe, map(fle, map(fc, map(ft, map(f, x)))))

;KLSType
public defn mapr (f:KLSType -> KLSType, x:KLSExp) :
  defn fe (e:KLSExp) : mapr(f, e)
  defn fl (l:KLoc) : mapr(f, l)
  map(fl, map(fe, map(f, x)))
public defn mapr (f:KLSType -> KLSType, x:KLoc) :
  defn fe (e:KLSExp) : mapr(f, e)
  defn fl (l:KLoc) : mapr(f, l)
  map(fl, map(fe, map(f, x)))
public defn mapr (f:KLSType -> KLSType, c:KLSComm) :
  defn fe (e:KLSExp) : mapr(f, e)
  defn fl (l:KLoc) : mapr(f, l)
  map(fl, map(fe, map(f, c)))
public defn mapr (f:KLSType -> KLSType, x:KComm) :
  defn fle (e:KLSExp) : mapr(f, e)
  defn fc (c:KLSComm) : mapr(f, c)
  map(fle, map(fc, map(f, x)))

;============================================================
;====================== Printers ============================
;============================================================

defprinter (p:KPackage) :
  KPackage :
    ($package name ids comms ...)

defprinter (f:KFunc) :
  KFn :
    if tail?(f) : ($fn* (targs ...) (a1 ...) a2 (args ...) body)
    else : ($fn (targs ...) (a1 ...) a2 (args ...) body)
  KMultifn :
    ($multi funcs ...)

defprinter (f:KLSFn) :
  KLSFn :
    if tail?(f) : ($fn* (targs ...) (a1 ...) a2 (args ...) body)
    else : ($fn (targs ...) (a1 ...) a2 (args ...) body)

defprinter (b:KBranch) :
  KBranch :
    ($branch (args ...) (tags ...) body)

defprinter (b:KLSBranch) :
  KLSBranch :
    ($branch (args ...) (tags ...) body)

defprinter (b:KLSLabeledBlock) :
  KLSLabeledBlock :
    ($block n (args ...) (types ...) body)

defprinter (c:KChild) :
  KChild :
    ($child n parent)

defprinter (f:KStructField) :
  KStructField :
    ($field n type)

defprinter (t:KTag) :
  KOf :
    custom{"$T%_" % [n(t)]}
  KTVar :
    custom{"$V%_" % [n(t)]}
  KAnd :
    ($and a b)
  KOr :
    ($or a b)
  KTop :
    custom{"$top"}
  KBot :
    custom{"$bot"}

defprinter (t:KLSType) :
  KByteT :
    custom{"$byte"}
  KIntT :
    custom{"$int"}
  KLongT :
    custom{"$long"}
  KFloatT :
    custom{"$float"}
  KDoubleT :
    custom{"$double"}
  KUnknownT :
    custom{"$?"}
  KPtrT :
    ($ptr type)
  KRefT :
    ($ref tag)
  KFnT :
    ($fn a r b)
  KStructT :
    custom{"$T%_" % [n(t)]}

defprinter (c:KComm) :
  KDef :
   ($def n tag value)
  KDefVar :
   if value(c) is False : ($defvar n tag)
   else : ($defvar n tag value)
  KDefn :
    ($defn n value)
  KDefmulti :
    if tail?(c) : ($defmulti* n (targs ...) (a1 ...) a2)
    else : ($defmulti n (targs ...) (a1 ...) a2)
  KDefmethod :
    ($defmethod multi (targs ...) thisn value)
  KDefTag :
    ($deftag n parent children ...)
  KInit :
    custom{exp(c)}

  KLSDef :
    ($lsdef n type value)
  KLSDefVar :
    ($lsdefvar n type value)
  KLSDefn :
    ($lsdefn n value)
  KLSDefmethod :
    ($lsdefmethod multi (targs ...) value)
  KLSDefStruct :
    ($lsdefstruct n parent (fields ...) rfield)    
  KLSInit :
    custom{comm(c)}
  KLSExternFn :
    ($defexfn n lbl value)
  KLSExtern :
    ($extern n lbl type)

defprinter (c:KLSComm) :
  KLSExec :
    custom{exp(c)}
  KLSSet :
    ($set loc value)
  KLSLabels :
    ($labels blocks ...)
  KLSGoto :
    ($goto n args ...)
  KLSReturn :
    ($return exp)
  KLSDefLocal :
    ($def n type value)
  KLSDefLocalVar :
    ($defvar n type value)
  KLSSeq :
    ($seq a b)
  KLSIf :
    ($if pred conseq alt)
  KLSMatch :
    ($match (args ...) branches ...)
  KLSSkip :
    ($skip)

defprinter (e:KExp) :
  KSet :
    ($set n tag value)
  KCast :
    ($cast exp tag)
  KLet :
    ($let def body)
  KLetRec :
    ($letrec (defs ...) body)
  KSeq :
    ($seq a b)
  KMatch :
    ($match (args ...) branches ...)
  KNew :
    ($new tag methods ...)
  KDo :
    ($do (a1 ...) a2 func args ...)
  KVar :
    custom{"$v%_" % [n(e)]}
  KLiteral :
    ($value value)
  KTuple :
    ($tuple exps ...)
  KTupleGet :
    ($tuple-get exp index)
  KEnsureLength :
    ($ensure-length exp length)      
  KMix :
    ($mix exps ...)
  KCurry :
    ($curry n (targs ...))
  KAFn :
    ($afn value)
  KPrim :
    ($prim op args ...)
  ;Working  
  KDispatch :
    ($dispatch (args ...) branches ...)
  KEnsureSet :
    ($ensure-set exp)
  KDo! :
    ($do! func (targs ...) args ...)

defprinter (l:KLoc) :
  KValue :
    custom{exp(l)}
  KDeref :
    ($deref exp type)
  KDeptr :
    ($deptr exp type)
  KSlot :
    ($slot exp type index)
  KField :
    ($field exp n)

defprinter (e:KLSExp) :
  KLSVar :
    custom{"$v%_" % [n(e)]}
  KLSRef :
    ($ref n args ...)
  KLSArray :
    ($array n args ...)
  KLSStruct :
    ($struct n args ...)
  KLSPtr :
    ($ptr loc)
  KLSRead :
    custom{loc(e)}
  KLSCall :
    ($call func (args ...) type)
  KLSCallC :
    ($callc func (args ...) (varargs ...) type)
  KLSLiteral :
    custom{value(e)}
  KLSMix :
    ($mix exps ...)
  KLSCurry :
    ($curry n (targs ...))
  KLSCast :
    ($cast exp type)
  KLSAnd :
    ($and a b)
  KLSOr :
    ($or a b)
  KLSPrim :
    ($prim op args ...)
  KLSSizeof :
    ($sizeof type)
  KLSTagof :
    ($tagof n)
  ;Working  
  KLSAFn :
    ($afn value)