defpackage stz/hash :
  import core
  import collections

;Returns a perfect hash table
public deftype PerfectHashTable <: Lengthable
public defmulti dentry (h:PerfectHashTable, i:Int) -> Int
public defmulti entry (h:PerfectHashTable, i:Int) -> KeyValue<Int,Int>
public defmulti get? (h:PerfectHashTable, k:Int) -> Int|False

;Construct perfect hash table
public defn PerfectHashTable (entries0:Tuple<KeyValue<Int,Int>>) :
  ;Get length
  val n = length(entries0)

  ;Construct buckets
  val buckets = Array<List<KeyValue<Int,Int>>>(n, List())
  for e in entries0 do :
    val slot = dhash(1, key(e), n)
    buckets[slot] = cons(e, buckets[slot])

  ;Sort bucket indices by size of bucket
  val bucket-indices = to-array<Int>(0 to n)
  qsort!({(- length(buckets[_]))}, bucket-indices)

  ;Construct dtable and etable
  val dtable = Array<Int>(n, 0)
  val etable = Array<KeyValue<Int,Int>|False>(n, false)

  ;Compute d's for spreading.
  ;Put given entries into etable and return computed d for spreading
  val slots = Vector<Int>()
  defn put-in-unique-slots (es:Seqable<KeyValue<Int,Int>>) -> Int :
    clear(slots)
    label<Int> return :
      for d in 2 to false do :
        label break :
          for e in es do :
            val s = dhash(d, key(e), n)
            if etable[s] is False :
              etable[s] = e
              add(slots, s)
            else :
              for s in slots do :
                etable[s] = false
              clear(slots)    
              break()
          return(d)
      fatal("Unreachable")

  ;Currently processing bucket index i.
  ;If bucket size dips below or equal to 1, then go to singles placing.
  defn* spread-buckets (i:Int) :
    if i < n :
      val b = bucket-indices[i]
      val l = length(buckets[b])
      if l > 1 :
        val d = put-in-unique-slots(buckets[b])
        dtable[b] = d
        spread-buckets(i + 1)
      else :
        put-singles(i)
  ;Place singles into etable and compute their slots for dtable
  defn* put-singles (i:Int) :
    val iseq = to-seq(i to n)
    for s in 0 to n do :
      if etable[s] is False :
        val i = next(iseq)
        val b = bucket-indices[i]
        etable[s] = head(buckets[b])
        dtable[b] = (- s) - 1
  ;Launch
  spread-buckets(0)

  ;Return generated hash table
  new PerfectHashTable :
    defmethod length (this) : n
    defmethod dentry (this, i:Int) : dtable[i]
    defmethod entry (this, i:Int) : etable[i] as KeyValue<Int,Int>
    defmethod get? (this, k:Int) :
      val dslot = dhash(1,k,n)
      val d = dtable[dslot]
      if d == 0 :
        false
      else :
        val slot =
          if d < 0 : (- (d + 1))
          else : dhash(d,k,n)
        val e = etable[slot] as KeyValue<Int,Int>
        value(e) when key(e) == k  

;Returns a hash with given search d, key x, and total length of table n.
;d is assumed to be 1 or greater.
defn dhash (d:Int, x:Int, n:Int) :
  #if-not-defined(OPTIMIZE) :
    fatal("Illegal d") when d < 1    
  val d0 = d
  val d1 = (d0 * 0x1000193) ^ ((x >> 0) & 0xFF)
  val d2 = (d1 * 0x1000193) ^ ((x >> 8) & 0xFF)
  val d3 = (d2 * 0x1000193) ^ ((x >> 16) & 0xFF)
  val d4 = (d3 * 0x1000193) ^ ((x >> 24) & 0xFF)
  ((d4 & 0x7FFFFFFF) % 10003199) % n