defpackage stz/auto-doc :
  import core
  import collections
  import stz/compiler
  import stz/front-end
  import stz/visibility
  import stz/il-ir
  import stz/pkg
  import stz/dl-ir
  import stz/algorithms
  import stz/proj-manager

defn public-definitions (ipackage:IPackage) -> Seq<IExp> :
  generate<IExp> :
    defn loop (e:IExp) :
      defn* loop-public (e:IExp) :
        match(e) :
          (e:IBegin) :
            do(loop-public, exps(e))
          (e:IDefn|IDef|IDefChild|IDefType|IDefVar|IDefmulti|IDefmethod|ILSDefn|ILSDefType|ILSDefmethod) :
            yield(e)
          (e) :
            false
      match(e) :
        (e:IBegin) :
          do(loop, exps(e))
        (e:IDoc) :
          yield(e)
        (e:IVisibility) :
          loop-public(exp(e)) when visibility(e) is Public
        (e) :
          false
    for e in exps(ipackage) do :
      loop(e)

defn pretty-targs (targs:List<IExp>) :
  "" when empty?(targs) else ("<%,>" % [pretties(targs)])

defn pretty (e:IExp) :
  match(e) :
    (e:IOf) : "%_%_" % [pretty(class(e)), pretty-targs(args(e))]
    (e:IAnd) : "%_&%_" % [pretty(a(e)), pretty(b(e))]
    (e:IOr) : "%_|%_" % [pretty(a(e)), pretty(b(e))]
    (e:IArrow) : "%_ -> %_" % [pretties(a1(e)), pretty(a2(e))]
    (e:IGradual) : "?"
    (e:IVoid) : "void"
    (e:INone) : "none"
    (e:ITuple) : "[%,]" % [pretties(exps(e))]
    (e:IVar) : name(e)
    (e:ICap) : "?%_" % [pretty(name(e))]
    (e:ILSOfT) : "%_%_" % [pretty(class(e)), pretty-targs(args(e))]
    (e:ILSRefT) : "ref<%_>" % [pretty(type(e))]
    (e) : e

defn pretties (e:List<IExp>) :
  map(pretty, e)

defn pretty-arg-type (a:IExp, t:IExp) :
  "%_:%_" % [a, pretty(t)]

defn pretty-return-type (t:IExp) :
  "" when t is INone else (" -> %_" % [pretty(t)])

defn pretty-parent (t:IExp) :
  "" when t is INone else (" <: %_" % [pretty(t)])

defn pretty-type (t:IExp) :
  "" when t is INone else (" : %_" % [pretty(t)])

defn pretty-args (targs:List<IExp>, args:List<IExp>, a1:List<IExp>, a2:IExp) :
  "%_ (%,)%_" % [pretty-targs(targs), map(pretty-arg-type, args, a1), pretty-return-type(a2)]

defn pretty-args (targs:List<IExp>, a1:List<IExp>, a2:IExp) :
  "%_ (%,)%_" % [pretty-targs(targs), pretties(a1), pretty-return-type(a2)]

defn print-definition (e:IExp) :
  match(e) :
    (e:ILSDefType) :   println("lostanza deftype %_%_%_" % [name(e) pretty-targs(args(e)) pretty-parent(parent(e))])
    (e:ILSDefn) :      println("lostanza defn %_%_" % [name(e) pretty-args(targs(e), args(e), a1(e) a2(e))])
    (e:ILSDefmethod) : println("lostanza defmethod %_%_" % [multi(e) pretty-args(targs(e), args(e), a1(e) a2(e))])
    (e:IDefType) :     println("deftype %_%_%_" % [class(e) pretty-targs(args(e)) pretty-parent(parent(e))])
    (e:IDef) :         println("val %_%_" % [name(e) pretty-type(type(e))])
    (e:IDefVar) :      println("var %_%_" % [name(e) pretty-type(type(e))])
    (e:IDefn) :        println("defn %_%_" % [name(e) pretty-args(targs(e), args(e), a1(e) a2(e))])
    (e:IDefmulti) :    println("defmulti %_%_" % [name(e) pretty-args(targs(e), a1(e) a2(e))])
    (e:IDefmethod) :   println("defmethod %_%_" % [multi(e) pretty-args(targs(e), args(e), a1(e) a2(e))])
    (e:IDoc) :         println("doc: %_" % [value(string(e) as ILiteral)])
    (e) : false

defn breakup<?T> (break?:T -> True|False, s:Seqable<?T>) -> Seqable<Tuple<T>> :
  generate<Tuple<T>> :
    val ss = to-seq(s)
    val v = Vector<T>()
    let loop () :
      if empty?(ss) :
        yield(to-tuple(v)) when length(v) > 0
      else :
        val e = next(ss)
        if break?(e) :
          yield(to-tuple(v)) when length(v) > 0
          clear(v)
        add(v, e)
        loop()

public defn gen-doc (all-ipackages:Seqable<IPackage>) :
  for ipackage in all-ipackages do :
    val definitions = public-definitions(ipackage)
    ;; println(";;; FILENAME %_" % [filename])
    val groups = breakup(fn (d) : d is IDefType|ILSDefType|IPackage, definitions)
    var code? = false
    for group in groups do :
      for def in group do :
        val to-code? = not def is IDoc
        if to-code? == true and code? == false :
          println("```") 
        else if to-code? == false and code? == true :
          println("```") 
        code? = to-code?
        print-definition(def)
      println("```") when code?
      code? = false
    println("")

public defn auto-doc (settings:BuildSettings, output:String|False) :
  println("AUTO DOCING...")
  defn ipackages (settings:BuildSettings) -> Seqable<IPackage>:
    val dep-result = dependencies(settings)
    filter-by<IPackage>(packages(dep-result))

  gen-doc(ipackages(settings))

  ; for package in ipackages(settings) do :
  ;   for e in exps(package) do :
  ;     match(e:IDoc) : println(e)


