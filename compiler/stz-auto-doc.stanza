defpackage stz/auto-doc :
  import core
  import collections
  import stz/namemap
  import stz/compiler
  import stz/front-end
  import stz/visibility
  import stz/il-ir
  import stz/pkg
  import stz/dl-ir
  import stz/algorithms
  import stz/proj-manager

defn mangle (name:Symbol) -> Symbol :
  to-symbol(replace(to-string(name), '/', '$'))

defn public-definitions (ipackage:IPackage) -> Seq<IExp> :
  generate<IExp> :
    defn loop (e:IExp) :
      defn* loop-public (e:IExp) :
        match(e) :
          (e:IBegin) :
            do(loop-public, exps(e))
          (e:IDefn|IDef|IDefChild|IDefType|IDefVar|IDefmulti|IDefmethod|ILSDefn|ILSDefType|ILSDefmethod|IDoc) :
            yield(e)
          (e) :
            false
      match(e) :
        (e:IBegin) :
          do(loop, exps(e))
        (e:IDoc) :
          yield(e)
        (e:IDefmethod|ILSDefmethod) :
          yield(e)
        (e:IVisibility) :
          loop-public(exp(e)) when visibility(e) is Public
        (e) :
          false
    for e in exps(ipackage) do :
      loop(e)

defn lookup (nm:NameMap, e:IExp) :
  match(e) :
    (e:VarN) : name(nm[n(e)])
    (e) : e

defn lookup-and-link (nm:NameMap, e:IExp) :
  match(e) :
    (e:VarN) : "[`%_`](#V%_)" % [name(nm[n(e)]), n(e)]
    (e) : e

defn print-anchor (o:OutputStream, e:IExp) :
  match(e:VarN) :
    println(o, "<a name=\"V%_\"></a>\n" % [n(e)])

defn pretty-targs (nm:NameMap, targs:List<IExp>) :
  "" when empty?(targs) else ("<%,>" % [pretties(nm, targs)])

defn pretty (nm:NameMap, e:IExp) :
  match(e) :
    (e:IOf) : "%_%_" % [pretty(nm, class(e)), pretty-targs(nm, args(e))]
    (e:IAnd) : "%_&%_" % [pretty(nm, a(e)), pretty(nm, b(e))]
    (e:IOr) : "%_|%_" % [pretty(nm, a(e)), pretty(nm, b(e))]
    (e:IArrow) : "%_ -> %_" % [pretties(nm, a1(e)), pretty(nm, a2(e))]
    (e:IGradual) : "?"
    (e:IVoid) : "void"
    (e:INone) : "none"
    (e:ITuple) : "[%,]" % [pretties(nm, exps(e))]
    (e:IVar) : name(e)
    (e:ICap) : "?%_" % [pretty(nm, name(e))]
    (e:ILSOfT) : "%_%_" % [pretty(nm, class(e)), pretty-targs(nm, args(e))]
    (e:ILSRefT) : "ref<%_>" % [pretty(nm, type(e))]
    (e:VarN) : lookup(nm, e)
    (e:Raw) : pretty(nm, class(e))
    (e) : e

defn pretties (nm:NameMap, e:List<IExp>) :
  map(pretty{nm, _}, e)

defn pretty-arg-type (nm:NameMap, a:IExp, t:IExp) :
  "%_:%_" % [lookup(nm, a), pretty(nm, t)]

defn pretty-return-type (nm:NameMap, t:IExp) :
  "" when t is INone else (" -> %_" % [pretty(nm, t)])

defn pretty-parent (nm:NameMap, t:IExp) :
  "" when t is INone else (" <: %_" % [pretty(nm, t)])

defn pretty-type (nm:NameMap, t:IExp) :
  "" when t is INone else (" : %_" % [pretty(nm, t)])

defn pretty-args (nm:NameMap, targs:List<IExp>, args:List<IExp>, a1:List<IExp>, a2:IExp) :
  "%_ (%,)%_" % [pretty-targs(nm, targs), map(pretty-arg-type{nm, _, _}, args, a1), pretty-return-type(nm, a2)]

defn pretty-args (nm:NameMap, targs:List<IExp>, a1:List<IExp>, a2:IExp) :
  "%_ (%,)%_" % [pretty-targs(nm, targs), pretties(nm, a1), pretty-return-type(nm, a2)]

defstruct DefRef :
  id:          Int
  pkg:         Symbol
  name:        Symbol
  description: String

defn maybe-define (pkg:Symbol, nm:NameMap, tbl:IntTable<DefRef>, e:IExp, dt:IntTable<String>) :
  match(e:VarN) :
    val name = name(nm[n(e)])
    tbl[n(e)] = DefRef(n(e), pkg, name, get?(dt, n(e), to-string $ name))

defn collect-definition (pkg:Symbol, nm:NameMap, e:IExp, types:IntTable<DefRef>, vars:IntTable<DefRef>, functions:IntTable<DefRef>, dt:IntTable<String>) :
  match(e) :
    (e:ILSDefType) : maybe-define(pkg, nm, types, name(e), dt)
    (e:ILSDefn) :    maybe-define(pkg, nm, functions, name(e), dt)
    (e:IDefType) :   maybe-define(pkg, nm, types, class(e), dt)
    (e:IDef) :       maybe-define(pkg, nm, vars, name(e), dt)
    (e:IDefVar) :    maybe-define(pkg, nm, vars, name(e), dt)
    (e:IDefn) :      maybe-define(pkg, nm, functions, name(e), dt)
    (e:IDefmulti) :  maybe-define(pkg, nm, functions, name(e), dt)
    (e) :            false

defn split (s:String, c:Char, max:Int) -> Tuple<String> :
  defn return (lc:False|Int) :
    if length(s) > 80 :
      match(lc:Int) :
        [s[0 to (lc + 1)], s[(lc + 1) to false]]
      else :
        [s]
    else :
      [s]
  let inner (start:Int = 0, lc:False|Int = false) :
    match(index-of-char(s, start to false, c)) :
      (j:Int) :
        if j > 80 : return(lc)
        else : inner(j + 1, j)
      (j:False) :
        return(lc)

defn print-code (o:OutputStream, s:String) :
  val ss =
    if length(s) > 80 :
      match(index-of-char(s, '(')) :
        (i:Int) :
          val name = s[0 to i]
          val sig = string-join $ ["  " s[i to false]]
          if length(sig) > 80 :
            val res = Vector<String>()
            let loop (s:String = sig, i:Int = 0) :
              defn add-res (s:String) :
                add(res, s when (i == 0) else (string-join $ ["  ", s]))
              val ss = split(s, ',', 80)
              add-res(ss[0])
              loop(ss[1], i + 1) when length(ss) == 2
            cat-all $ [[name], res]
          else :
            [name, sig]
        (i:False) :
          [s]
    else :
      [s]
  println(o, "```")
  for s in ss do : println(o, s)
  println(o, "```")

defn put-description (id:IExp, gen:IExp -> Printable, dt:IntTable<String>) :
  match(id:VarN) :
    val d = to-string $ gen(id)
    dt[n(id)] = d
    d
  else :
    ""

defn gen-description (nm:NameMap, e:IExp, dt:IntTable<String>) -> String:
  match(e) :
    (e:ILSDefType) :
      put-description(name(e), { "lostanza deftype %_%_%_" % [lookup(nm, _) pretty-targs(nm, args(e)) pretty-parent(nm, parent(e))] }, dt)
    (e:IDefType) :
      put-description(class(e), { "deftype %_%_%_" % [lookup(nm, _) pretty-targs(nm, args(e)) pretty-parent(nm, parent(e))] }, dt)
    (e:IDef) :
      put-description(name(e), { "val %_%_" % [lookup(nm, _) pretty-type(nm, type(e))] }, dt)
    (e:IDefVar) :
      put-description(name(e), { "var %_%_" % [lookup(nm, _) pretty-type(nm, type(e))] }, dt)
    (e:ILSDefn) :
      put-description(name(e), { "lostanza defn %_%_" % [lookup(nm, _) pretty-args(nm, targs(e), args(e), a1(e) a2(e))] }, dt)
    (e:IDefn) :
      put-description(name(e), { "defn %_%_" % [lookup(nm, _) pretty-args(nm, targs(e), args(e), a1(e) a2(e))] }, dt)
    (e:IDefmulti) :
      put-description(name(e), { "defmulti %_%_" % [lookup(nm, _) pretty-args(nm, targs(e), a1(e) a2(e))] }, dt)
    (e) :
      ""

defn print-definition (o:OutputStream, nm:NameMap, e:IExp, dt:IntTable<String>) :
  match(e) :
    (e:ILSDefType) :
      print-anchor(o, name(e))   
      print-code(o, gen-description(nm, e, dt))
    (e:IDefType) :
      print-anchor(o, class(e))   
      print-code(o, gen-description(nm, e, dt))
    (e:IDef) :
      print-anchor(o, name(e))   
      print-code(o, gen-description(nm, e, dt))
    (e:IDefVar) :
      print-anchor(o, name(e))   
      print-code(o, gen-description(nm, e, dt))
    (e:ILSDefn) :
      print-anchor(o, name(e))   
      print-code(o, gen-description(nm, e, dt))
    (e:IDefn) :
      print-anchor(o, name(e))   
      print-code(o, gen-description(nm, e, dt))
    (e:IDefmulti) :
      print-anchor(o, name(e))   
      print-code(o, gen-description(nm, e, dt))
    ; (e:ILSDefmethod) :
    ;   println(o, "`lostanza defmethod `%_`%_`" % [lookup-and-link(nm, multi(e)) pretty-args(nm, targs(e), args(e), a1(e) a2(e))])
    ; (e:IDefmethod) :
    ;   println(o, "`defmethod `%_`%_`" % [lookup-and-link(nm, multi(e)) pretty-args(nm, targs(e), args(e), a1(e) a2(e))])
    (e:IDoc) :
      println(o, "%_" % [value(string(e) as ILiteral)])
    (e) :
      false

defn print-defpackage (o:OutputStream, nm:NameMap, ipackage:IPackage) :
  println(o, "\n%_\n======\n" % [name(ipackage)])
  println(o, "```") 
  println(o, "defpackage %_" % [name(ipackage)])
  for imp in imports(ipackage) do :
    println(o, "  import %_" % [package(imp)])
  println(o, "```") 

defn breakup<?T> (break?:T -> True|False, s:Seqable<?T>) -> Seqable<Tuple<T>> :
  generate<Tuple<T>> :
    val ss = to-seq(s)
    val v = Vector<T>()
    let loop () :
      if empty?(ss) :
        yield(to-tuple(v)) when length(v) > 0
      else :
        val e = next(ss)
        if break?(e) :
          yield(to-tuple(v)) when length(v) > 0
          clear(v)
        add(v, e)
        loop()

defn gen-index (so:FileOutputStream, dir:String, kind:String, elts:IntTable<DefRef>) :
  println(so, "- [%_](./%_/README.md)" % [kind, kind])
  val kind-dir = string-join $ [dir "/" kind]
  create-dir(kind-dir) when not file-exists?(kind-dir)
  val ts = FileOutputStream(string-join $ [kind-dir "/README.md"])
  println(ts, "# %_\n" % [kind])
  val refs = qsort(name, values(elts))
  for ref in refs do :
    val url = string-join $ ["../packages/" mangle(pkg(ref)) ".html#V" id(ref)]
    println(ts, "[`%_`](%_)\n" % [description(ref), url])
  close(ts)

public defn gen-doc (dir:String, nm:NameMap, i-all-ipackages:Seqable<IPackage>) :
  val all-ipackages = to-tuple $ i-all-ipackages
  create-dir(dir) when not file-exists?(dir)
  val pkg-dir = string-join $ [dir "/packages"]
  val so = FileOutputStream $ string-join $ [dir "/SUMMARY.md"]
  println(so, "# Summary\n")
  println(so, "- [Packages](./packages/README.md)")
  create-dir(pkg-dir) when not file-exists?(pkg-dir)
  val vars = IntTable<DefRef>()
  val types = IntTable<DefRef>()
  val functions = IntTable<DefRef>()
  val dt = IntTable<String>()
  for ipackage in qsort(name, all-ipackages) do :
    println(so, "    - [%_](./packages/%_.md)" % [name(ipackage), mangle(name(ipackage))])
    val definitions = to-tuple $ public-definitions(ipackage)
    ;; println(";;; FILENAME %_" % [filename])
    ; println(exps(ipackage))
    val po = FileOutputStream(string-join $ [pkg-dir "/" mangle(name(ipackage)) ".md"])
    print-defpackage(po, nm, ipackage)
    for d in definitions do :
      print-definition(po, nm, d, dt)
      collect-definition(name(ipackage), nm, d, types, vars, functions, dt)
      println(po, "")
    println(po, "")
    close(po)
  gen-index(so, dir, "Types", types)
  gen-index(so, dir, "Vars", vars)
  gen-index(so, dir, "Functions", functions)
  close(so)

public defn auto-doc (settings:BuildSettings, output:String|False) :
  val dep-result = dependencies(settings, true)
  val dir = match(output:String): output else: "docs"
  gen-doc(dir, namemap(dep-result), filter-by<IPackage>(packages(dep-result)))

