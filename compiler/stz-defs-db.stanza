defpackage stz/defs-db :
  import core
  import collections
  import stz/namemap
  import stz/compiler
  import stz/front-end
  import stz/visibility
  import stz/il-ir
  import stz/pkg
  import stz/dl-ir
  import stz/vm-ir
  import stz/algorithms
  import stz/proj-manager
  import stz/defs-db-serializer

defstruct DefRec :
  name: Symbol
  info: FileInfo

defmulti public-definitions (pkg:IPackage|Pkg, nm:NameMap) -> Seq<DefRec>

defn lookup (nm:NameMap, e:IExp) -> False|Symbol :
  match(e:VarN) : name(nm[n(e)])
  else: false

;find all public definitions in ipackage
defmethod public-definitions (ipackage:IPackage, nm:NameMap) -> Seq<DefRec> :
  val exps = generate<IExp> :
    defn loop (e:IExp) :
      defn* loop-public (e:IExp, public?:True|False) :
        match(e) :
          (e:IBegin) :
            do(loop-public{_, public?}, exps(e))
          (e:IDefn|IDef|IDefChild|IDefType|IDefVar|IDefmulti|IDefmethod|ILSDefn|ILSDefType|ILSDefmethod|IDoc) :
            yield(e)
          (e:IVisibility) :
            loop-public(exp(e), visibility(e) is Public)
          (e) :
            false
      match(e) :
        (e:IBegin) :
          do(loop, exps(e))
        (e:IDoc) :
          yield(e)
        (e:IDefmethod|ILSDefmethod) :
          yield(e)
        (e:IVisibility) :
          loop-public(exp(e), visibility(e) is Public)
        (e) :
          false
    for e in exps(ipackage) do :
      loop(e)
  generate<DefRec> :
    for exp in exps do :
      defn add-def (name:IExp, info:False|FileInfo) :
        match(info:FileInfo) :
          match(lookup(nm, name)) :
            (name:Symbol) : yield $ DefRec(name, info)
            (o) : false
      match(exp) :
        (e:ILSDefType|IDef|IDefVar|ILSDefn|IDefn|IDefmulti) :
          add-def(name(e), info(e))
        (e:IDefType) :
          add-def(class(e), info(e))
        (e:ILSDefmethod|IDefmethod) :
          add-def(multi(e), info(e))
        (e) :
          false
    
defn collect-public-definitions (packageio:PackageIO) -> Seq<DefRec> :
  generate<DefRec> :
    defn add-def (name:Symbol, info:False|FileInfo) :
      match(info:FileInfo) : yield $ DefRec(name, info)
    for e in exports(packageio) do :
      if visibility(e) is Public :
        add-def(name(id(rec(e))), info(e))

defmethod public-definitions (pkg:FastPkg, nm:NameMap) -> Seq<DefRec> :
  collect-public-definitions(packageio(pkg))

defmethod public-definitions (pkg:StdPkg, nm:NameMap) -> Seq<DefRec> :
  collect-public-definitions(packageio(vmp(pkg)))

public defn gen-defs-db (defs-db:String, nm:NameMap, i-all-packages:Seqable<IPackage|Pkg>) :
  val all-packages = to-tuple $ i-all-packages
  val defs = HashTable<String,List<FileInfo>>(List())
  for package in all-packages do :
    val definitions = to-tuple $ public-definitions(package, nm)
    for d in definitions do :
      val n = to-string(name(d))
      defs[n] = cons(info(d), defs[n])
  val o = FileOutputStream $ defs-db
  serialize(o, defs)
  close(o)
  val i = FileInputStream(defs-db)
  val d = deserialize(i)
  println("READ DB %_" % [length(d)])
  close(i)

public defn defs-db (settings:BuildSettings, filename:String) :
  val dep-result = dependencies(settings, true)
  gen-defs-db(filename, namemap(dep-result), packages(dep-result))

