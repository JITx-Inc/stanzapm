defpackage stz/loaded-ids :
  import core
  import collections
  import stz/dl-ir
  import stz/el-ir
  import stz/vm-ir

;============================================================
;====================== Global Ids ==========================
;============================================================

public deftype LoadedIds
public defmulti make-id (ids:LoadedIds, rec:Rec) -> VMId
public defmulti init (ids:LoadedIds, package:Symbol) -> CodeId
public defmulti dependencies (ids:LoadedIds, vmids:Seqable<VMId>) -> Tuple<Rec>
public defmulti package-ids (ids:LoadedIds, packageio:PackageIO, epackage:EPackage) -> PackageIds

public deftype PackageIds
public defmulti init (ids:PackageIds) -> CodeId
public defmulti get (ids:PackageIds, id:RecId) -> VMId
public defmulti get (ids:PackageIds, n:Int) -> VMId
public defmulti set-dependencies (ids:PackageIds, id:Int, dependencies:Tuple<Int>) -> False
public defmulti make-fn-id (ids:PackageIds) -> CodeId
public defmulti make-data-id (ids:PackageIds) -> DataId
public defmulti make-const-id (ids:PackageIds) -> ConstId

public defn LoadedIds () :
  ;Tables
  val rec-table = HashTable<VMId,Rec>()
  val id-table = HashTable<RecId,VMId>()
  val init-table = HashTable<Symbol,CodeId>()
  val dependencies = HashTable<VMId, Tuple<VMId>>([])

  ;Counters
  val fn-counter = to-seq(0 to false)
  val extern-counter = to-seq(0 to false)
  val global-counter = to-seq(0 to false)
  val data-counter = to-seq(0 to false)
  val const-counter = to-seq(0 to false)
  val class-counter = to-seq(NUM-BUILTIN-TYPES to false)
  defn make-fn-id () : CodeId(next(fn-counter))
  defn make-extern-id () : ExternId(next(extern-counter))
  defn make-global-id () : GlobalId(next(global-counter))
  defn make-data-id () : DataId(next(data-counter))
  defn make-const-id () : ConstId(next(const-counter))
  defn make-class-id () : ClassId(next(class-counter))

  ;Compute dependencies
  defn set-dependencies (id:VMId, ds:Tuple<VMId>) :
    dependencies[id] = ds
  defn get-dependencies (ids:Seqable<VMId>) :
    val visited = HashSet<VMId>()
    val recs = Vector<Rec>()
    for id in ids do :
      let loop (id:VMId = id) :
        if not visited[id] :
          add(visited, id)
          match(get?(rec-table, id)) :
            (r:Rec) : add(recs, r)
            (r:False) : do(loop, dependencies[id])
    to-tuple(recs)

  ;Retrieve package init 
  defn get-init (package:Symbol) :
    if not key?(init-table, package) :
      init-table[package] = make-fn-id()
    init-table[package]

  ;Create PackageIds
  defn make-package-ids (packageio:PackageIO, epackage:EPackage) :
    ;Populate table of ids
    val table = IntTable<VMId>()
    for e in cat(imports(packageio), exports(packageio)) do :
      table[n(e)] = id-table[id(rec(e))]
    for e in exps(epackage) do :
      defn set-id (n:Int, f:() -> VMId) :
        if not key?(table,n) :
          table[n] = f()
      match(e) :
        (e:EDefGlobal) : set-id(n(e), make-global-id)
        (e:EDefn) : set-id(n(e), make-fn-id)
        (e:EDefClosure) : set-id(n(e), make-fn-id)
        (e:EDefmulti) : set-id(n(e), make-fn-id)
        (e:EDefmethod) : set-id(n(e), make-fn-id)
        (e:EDefStruct) : set-id(n(e), make-class-id)
        (e:EExternFn) : fatal("Not yet implemented.")
        (e:EExtern) : set-id(n(e), make-extern-id)
        (e:EDefType) : set-id(n(e), make-class-id)
        (e:EDefObject) : set-id(n(e), make-class-id)
        (e:EDefTypeObject) : set-id(n(e), make-fn-id)
        (e) : false
    ;Return Structure
    new PackageIds :
      defmethod init (this) : get-init(name(epackage))
      defmethod get (this, n:Int) : table[n]
      defmethod get (this, id:RecId) : id-table[id]
      defmethod set-dependencies (this, n:Int, ds:Tuple<Int>) :
        set-dependencies(table[n], map({table[_]}, ds))
      defmethod make-fn-id (this) : make-fn-id()
      defmethod make-data-id (this) : make-data-id()
      defmethod make-const-id (this) : make-const-id()

  ;Populate built-in IDs
  for (name in [`False, `True, `Byte, `Char, `Int,
                `Float, `Stack, `Fn, `Type],
       i in [FALSE-TYPE, TRUE-TYPE, BYTE-TYPE,  CHAR-TYPE,  INT-TYPE,
             FLOAT-TYPE,  STACK-TYPE,  FN-TYPE,  TYPE-TYPE]) do :
    id-table[TypeId(`core, name)] = ClassId(i)

  ;Return LoadedIds datastructure
  new LoadedIds :
    defmethod make-id (this, rec:Rec) :
      ;Create a VM id for the record
      val vmid = within init(id-table, id(rec)) :
        match(rec) :
          (r:ValRec) : make-global-id()
          (r:FnRec) : make-fn-id()
          (r:MultiRec) : make-fn-id()
          (r:ExternFnRec) : fatal("Not yet implemented")
          (r:ExternRec) : make-extern-id()
          (r:StructRec) : make-class-id()
          (r:TypeRec) : make-class-id()
      ;Store record into rec-table
      if not key?(rec-table, vmid) :
        rec-table[vmid] = rec
      ;Return VM id
      vmid
      
    defmethod init (this, package:Symbol) :
      get-init(package)

    defmethod dependencies (this, vmids:Seqable<VMId>) :
      get-dependencies(vmids)

    defmethod package-ids (this, packageio:PackageIO, epackage:EPackage) :
      make-package-ids(packageio, epackage)

;Initialize table[k] with value produced by f if necessary.
defn init<?K,?V> (f:() -> V, t:Table<?K,?V>, k:K) :
  if key?(t,k) :
    t[k]
  else :
    val v = f()
    t[k] = v
    v
    