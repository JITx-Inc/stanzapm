defpackage stz/parser2 :
   import core
   import collections
   import macro-utils

;============================================================
;==================== Parse Structure =======================
;============================================================

public defstruct DefSyntaxRule :
   name
   exps: List<ExpRule>

public deftype ExpRule
public defstruct StanzaExpressionRule <: ExpRule :
   form
public defstruct ImportRule <: ExpRule :
   names: List
   package
public defstruct DefProductionRule <: ExpRule :
   name
   type
   public?: True|False
public defstruct DefActionRule <: ExpRule :
   production
   pattern
   guard: Maybe
   body
public defstruct DefNotRule <: ExpRule :
   production
   pattern
   guard: Maybe
public defstruct DefFailRule <: ExpRule :
   production
   pattern
   guard: Maybe
   body

defmethod print (o:OutputStream, r:DefSyntaxRule) :
   print(o, "($defsyntax %_ %@)" % [name(r), exps(r)])

defmethod print (o:OutputStream, r:ExpRule) :
   print{o, _} $ match(r) :
      (r:StanzaExpressionRule) : "($expression %_)" % [form(r)]
      (r:ImportRule) : "($import %@ %_)" % [names(r), package(r)]
      (r:DefProductionRule) : "($production %_ %_ %_)" % [name(r), type(r), public?(r)]
      (r:DefActionRule) : "($action %_ %_ %_ %_)" % [production(r), pattern(r), guard(r), body(r)]
      (r:DefNotRule) : "($not %_ %_ %_)" % [production(r), pattern(r), guard(r)]
      (r:DefFailRule) : "($fail %_ %_ %_ %_)" % [production(r), pattern(r), guard(r), body(r)]      

;============================================================
;==================== Compilation ===========================
;============================================================

deftype SyntaxProperties
defmulti production-type-cast-function (p:SyntaxProperties, name:Symbol) -> Symbol
defmulti return-type-cast-function (p:SyntaxProperties, name:Symbol) -> Symbol
defmulti imports (p:SyntaxProperties) -> List<ImportRule>
defmulti stanza-expressions (p:SyntaxProperties) -> List<StanzaExpressionRule>
defmulti productions (p:SyntaxProperties) -> List<DefProductionRule>
defmulti rules (p:SyntaxProperties) -> List<DefActionRule|DefNotRule|DefFailRule>

defn analyze (r:DefSyntaxRule) -> SyntaxProperties :
   ;Categorize expressions
   val imports = {to-list(_) as List<ImportRule>} $
      filter({_ is ImportRule}, exps(r))
   val productions = {to-list(_) as List<DefProductionRule>} $
      filter({_ is DefProductionRule}, exps(r))
   val stanza-expressions = {to-list(_) as List<StanzaExpressionRule>} $
      filter({_ is StanzaExpressionRule}, exps(r))
   val rules = {to-list(_) as List<DefActionRule|DefNotRule|DefFailRule>} $
      filter({_ is DefActionRule|DefNotRule|DefFailRule}, exps(r))

   ;Package
   val package-table = HashTable<Symbol,Symbol>()
   for import in imports do :
      val p = unwrap-token(package(import))
      do({package-table[unwrap-token(_)] = p}, names(import))
   val package-name = unwrap-token(name(r))   
   for p in productions do :
      package-table[unwrap-token(name(p))] = package-name         

   ;Return new properties
   new SyntaxProperties :
      defmethod production-type-cast-function (this, prod:Symbol) :
         to-symbol("%_-%_ production-type" % [package-table[prod], prod])
      defmethod return-type-cast-function (this, prod:Symbol) :
         to-symbol("%_-%_ return-type" % [package-table[prod], prod])
      defmethod stanza-expressions (this) : stanza-expressions
      defmethod imports (this) : imports
      defmethod productions (this) : productions
      defmethod rules (this) : rules

public defn compile (syntax-rule:DefSyntaxRule) :
   val props = analyze(syntax-rule)

   ;Compile a pattern
   defn compile-pattern (pattern, guard:Maybe) :
      var form = substitute(`(parse-pattern(`pat)), [
         `pat => pattern])
      if not empty?(guard) :
         form = substitute(`(Guard(guard, pat)), [
            `guard => compile-guard(props, pattern, value!(guard))
            `pat => form])
      form
      
   ;Compile rules
   defn compile (r:DefActionRule) :
      substitute(`(DefRule(`name, Action(action, pat))), [
         `name => production(r)
         `action => compile-action(props, production(r), pattern(r), body(r))
         `pat => compile-pattern(pattern(r), guard(r))])         
   defn compile (r:DefNotRule) :
      substitute(`(DefRule(`name, NotPat(pat))), [
         `name => production(r)
         `pat => compile-pattern(pattern(r), guard(r))])
   defn compile (r:DefFailRule) :
      substitute(`(DefRule(`name, FailPat(action, pat))), [
         `name => production(r)
         `action => compile-fail(props, pattern(r), body(r))
         `pat => compile-pattern(pattern(r), guard(r))])

   ;Compile productions
   defn compile (r:DefProductionRule) :
      substitute(`(DefProduction(`name, public?)), [
         `name => name(r)
         `public? => public?(r)])

   ;Compile imports
   defn compile (r:ImportRule) :
      substitute(`(DefImport(`names, `package)), [
         `names => names(r)
         `package => package(r)])

   ;Compile type-cast-functions
   defn compile-production-type-cast-function (r:DefProductionRule) :
      substitute(`(public?{public}{} defn name (x) -> (() -> type) : x), [
         `public? => choice(public?(r))
         `name => production-type-cast-function(props, name(r))
         `type => type(r)])
   defn compile-return-type-cast-function (r:DefProductionRule) :
      substitute(`(public?{public}{} defn name (x:type) : x), [
         `public? => choice(public?(r))
         `name => return-type-cast-function(props, name(r))
         `type => type(r)])

   ;Compile package
   defn compile-all (r:DefSyntaxRule) :
      val template = `((
         production-type-cast-functions
         return-type-cast-functions
         let :
            stanza-expressions
            register-syntax-package(SyntaxPackage(
               `name
               to-list([imports])
               to-list([prods])
               to-list([rules])))))
      val bindings = [
         `production-type-cast-functions => map(compile-production-type-cast-function, productions(props))
         `return-type-cast-functions => map(compile-return-type-cast-function, productions(props))
         `stanza-expressions => stanza-expressions(props)
         `name => name(r)
         `imports => splice(map(compile, imports(props)))
         `prods => splice(map(compile, productions(props)))
         `rules => splice(map(compile, rules(props)))]
      val imports = deep-prefix(`stz/parser2/, `(
         parse-pattern Guard DefRule FailPat Action NotPat FailPat DefProduction DefImport
         SyntaxPackage register-syntax-package))   
      fill-template(template, append-all([bindings, imports]))

   ;Driver
   compile-all(syntax-rule)


;============================================================
;================ Compilation Utilities =====================
;============================================================

defn append-all<?T> (xss:Collection<Collection<?T>>) :
   new Collection<T> :
      defmethod to-seq (this) : cat-all(xss)

defn deep-prefix (prefix:Symbol, names:List<Symbol>) :
   for n in names map :
      n => deep(symbol-join([prefix n]))

defn compile-bindings (pkg:SyntaxProperties, bindings:List<Binding>, body, ret-type:Maybe) :
   val template = `(
      fn (#bindings) ret{-> R}{} :
         defn closest-info () : stz/parser2/info(#bindings)
         defn closest-info (form) : stz/parser2/info(#bindings, form)
         bindings{
            val #x = stz/parser2/get(#bindings, i)
            val x = cast-x()
         }
         body)
   substitute(template, [
      `#bindings => gensym(`bindings)
      `bindings => nested $
         for binding in bindings map :
            val #x = gensym(name(binding))
            [`#x => #x
             `i => index(binding)
             `x => name(binding)
             `cast-x => compile-binding-type(pkg, type(binding), #x)]
      `ret => choice(not empty?(ret-type))
      `R => value?(ret-type)
      `body => body])   

defn compile-binding-type (pkg:SyntaxProperties, t:BindingType, temp:Symbol) :
   defn loop (t:BindingType) :
      match(t) :
         (t:TerminalBinding) :
            substitute(`(temp as () -> T), [
               `temp => temp
               `T => name(t)])
         (t:ProductionBinding) :
            substitute(`(name(temp)), [
               `temp => temp
               `name => production-type-cast-function(pkg, name(t))])
         (t:UnionBinding) :
            substitute(`(union-type(a, b)), [
               `a => loop(a(t))
               `b => loop(b(t))])
         (t:ListBinding) :
            substitute(`(list-type(x)), [
               `x => loop(type(t))])
   val bindings = [`x => loop(t)]            
   val prefixes = deep-prefix(`stz/parser2/, `(union-type, list-type))
   fill-template(`x, append-all([bindings prefixes]))

;TODO: Parse Pattern Exceptions
defn compile-action (pkg:SyntaxProperties, production:Symbol, pat:List, body) :
   val bindings = get-bindings(parse-pattern(pat))
   val body* = substitute(`(cast(let : body)), [
      `cast => return-type-cast-function(pkg, production)
      `body => body])
   compile-bindings(pkg, bindings, body*, None())

;TODO: Parse Pattern Exceptions
defn compile-fail (pkg:SyntaxProperties, pat:List, body) :
   val bindings = get-bindings(parse-pattern(pat))
   compile-bindings(pkg, bindings, body, One(`Void))

;TODO: Parse Pattern Exceptions
defn compile-guard (pkg:SyntaxProperties, pat:List, body) :
   val bindings = get-bindings(parse-pattern(pat))
   val rbindings = to-list(filter(recomputable?, bindings))
   compile-bindings(pkg, rbindings, body, One(`(core/True|core/False)))

;============================================================
;==================== Syntax Packages =======================
;============================================================

protected :
   defstruct SyntaxPackage :
      name: Symbol
      imports: List<DefImport>
      productions: List<DefProduction>
      rules: List<DefRule>

   defstruct DefImport :
      names: List<Symbol>
      package: Symbol

   defstruct DefProduction :
      name: Symbol
      public?: True|False

   defstruct DefRule :
      name: Symbol
      pattern: Pattern

defmethod print (o:OutputStream, p:SyntaxPackage) :
   println(o, "defsyntax %_ :" % [name(p)])
   for io in o do-indented :
      do(println{io, _}, imports(p))
      do(println{io, _}, productions(p))
      do(println{io, _}, rules(p))

defmethod print (o:OutputStream, i:DefImport) :
   print(o, "import %, from %_" % [names(i), package(i)])
   
defmethod print (o:OutputStream, p:DefProduction) :
   print(o, "%_defproduction %_" % [
      "public " when public?(p) else ""
      name(p)])

defmethod print (o:OutputStream, r:DefRule) :
   print(o, "defrule %_ = %_" % [name(r), pattern(r)])

;============================================================
;================= Public Interface =========================
;============================================================

protected defn register-syntax-package (p:SyntaxPackage) :
   println("Registered syntax package %_" % [name(p)])
   println(p)

;protected defn register-syntax-package (p:SyntaxPackage) :
;   SYNTAX-PACKAGES[name(p)] = p
;
;protected defn call-with-syntax<?T> (pkgs:List<Symbol>, f: () -> ?T) :
;   let-var CURRENT-SYNTAX-PACKAGES = pkgs :
;      f()
;
;protected defn call-with-added-syntax<?T> (pkgs:List<Symbol>, f: () -> ?T) :
;   let-var CURRENT-SYNTAX-PACKAGES = append(pkgs, CURRENT-SYNTAX-PACKAGES) :
;      f()
;
;protected defn syntax-match (form:List,
;                             id:Int,
;                             pat:() -> Pattern,
;                             actions:Tuple<(Context -> ?)>) :
;   val ruleset = RuleSet(map({SYNTAX-PACKAGES[_]}, CURRENT-SYNTAX-PACKAGES))
;   match(interpret(prepare(pat()), form, ruleset, actions)) :
;      (r:MResult) : head(r)()
;      (r:False) : fatal("No match.")
;
;;============================================================
;;===================== Storage ==============================
;;============================================================
;
;val SYNTAX-PACKAGES = HashTable<Symbol,SyntaxPackage>()
;
;var CURRENT-SYNTAX-PACKAGES : List<Symbol> = List()
;
;;============================================================
;;=================== SyntaxPackage ==========================
;;============================================================
;
;protected defstruct SyntaxPackage :
;   name: Symbol
;   productions: List<DefProduction>
;
;protected defstruct DefProduction :
;   name: Symbol
;   patterns: List<Pattern>
;
;defmethod print (o:OutputStream, p:SyntaxPackage) :
;   print(o, "($syntax %_ %_)" % [name(p), productions(p)])
;
;defmethod print (o:OutputStream, p:DefProduction) :
;   print(o, "($production %_ %_)" % [name(p), patterns(p)])
;
;============================================================
;================== Pattern Definition ======================
;============================================================

protected :
   deftype Pattern
   defstruct SeqPat <: Pattern :
      a: Pattern
      b: Pattern
   with :
      constructor => #SeqPat
   defstruct Choice <: Pattern :
      a: Pattern
      b: Pattern
   defstruct Empty <: Pattern
   defstruct Terminal <: Pattern :
      value
   defstruct Action <: Pattern :
      action: Context -> ?
      pattern: Pattern
      num-binders: Int
   defstruct IndexedAction <: Pattern :
      index: Int
      pattern: Pattern
      num-binders: Int
   defstruct FailPat <: Pattern :
      action: Context -> Void
      pattern: Pattern
      num-binders: Int
   defstruct NotPat <: Pattern :
      pattern: Pattern
   defstruct Form <: Pattern
   defstruct Production <: Pattern :
      name: Symbol
   defstruct Repeat <: Pattern :
      pattern: Pattern
      binders: List<Int>
      num-binders: Int
   defstruct Rest <: Pattern      
   defstruct ListPat <: Pattern :
      pattern: Pattern
   defstruct Binder <: Pattern :
      name: Symbol
      pattern: Pattern
      index: Int
   defstruct Guard <: Pattern :
      predicate: Context -> True|False
      pattern: Pattern
      binders: List<Int>
      num-binders: Int

   defn SeqPat (a:Pattern, b:Pattern) :      
      match(b) :
         (b:Empty) : a
         (b) : #SeqPat(a, b)
   defn SeqPat (xs:Seqable<Pattern>) :
      reduce-right(SeqPat, xs, Empty())
   defn Choice (ps:Seqable<Pattern>) :
      reduce-right(Choice, ps)
   defn Action (action:Context -> ?, pattern:Pattern) :
      Action(action, pattern, 0)
   defn IndexedAction (index:Int, pattern:Pattern) :
      IndexedAction(index, pattern, 0)
   defn FailPat (action:Context -> ?, pattern:Pattern) :
      FailPat(action, pattern, 0)
   defn Repeat (pattern:Pattern) :
      Repeat(pattern, List(), 0)
   defn Binder (name:Symbol, pattern:Pattern) :
      Binder(name, pattern, 0)
   defn Guard (predicate:Context -> True|False, pattern:Pattern) :
      Guard(predicate, pattern, List(), 0)


defmethod print (o:OutputStream, p:Pattern) :
   print{o, _} $ match(p) :
      (p:SeqPat) : "($seq %@)" % [flatten(p)]
      (p:Choice) : "($or %@)" % [flatten(p)]
      (p:Empty) : "eps"
      (p:Terminal) : value(p)
      (p:Action) : "A{%~ %_}" % [pattern(p), num-binders(p)]
      (p:IndexedAction) : "A%_{%~ %_}" % [index(p), pattern(p), num-binders(p)]
      (p:FailPat) : "($fail %~ %_)" % [pattern(p), num-binders(p)]
      (p:NotPat) : "($not %~)" % [pattern(p)]
      (p:Form) : "_"
      (p:Production) : "#%_" % [name(p)]
      (p:Repeat) : "($repeat %~ {%_|%,})" % [pattern(p), num-binders(p), binders(p)]
      (p:Rest) : "$rest"
      (p:ListPat) : "($list %~)" % [pattern(p)]
      (p:Binder) : "($bind %~(%_) %~)" % [name(p), index(p), pattern(p)]
      (p:Guard) : "($when %~ {%_|%,})" % [pattern(p), num-binders(p), binders(p)]

;============================================================
;==================== Mappers ===============================
;============================================================

defn map (f:Pattern -> Pattern, p:Pattern) :
   match(p) :
      (p:SeqPat) : SeqPat(f(a(p)), f(b(p)))
      (p:Choice) : Choice(f(a(p)), f(b(p)))
      (p:Empty) : p
      (p:Terminal) : Terminal(value(p))
      (p:Action) : Action(action(p), f(pattern(p)), num-binders(p))
      (p:IndexedAction) : IndexedAction(index(p), f(pattern(p)), num-binders(p))
      (p:FailPat) : FailPat(action(p), f(pattern(p)), num-binders(p))
      (p:NotPat) : NotPat(f(pattern(p)))
      (p:Form) : p
      (p:Production) : Production(name(p))
      (p:Repeat) : Repeat(f(pattern(p)), binders(p), num-binders(p))
      (p:Rest) : p
      (p:ListPat) : ListPat(f(pattern(p)))
      (p:Binder) : Binder(name(p), f(pattern(p)), index(p))
      (p:Guard) : Guard(predicate(p), f(pattern(p)), binders(p), num-binders(p))

defn do (f:Pattern -> ?, p:Pattern) :
   defn f* (p:Pattern) : (f(p), p)
   map(f*, p)
   false

defn children (p:Pattern) :
   generate<Pattern> : do(yield, p)

defn any? (f:Pattern -> True|False, p:Pattern) :
   any?(f, children(p))

defn all? (f:Pattern -> True|False, p:Pattern) :
   all?(f, children(p))

;============================================================
;================== Type Builders ===========================
;============================================================

protected defn list-type<?T> (f: () -> ?T) :
   f as ? as () -> List<T>
protected defn union-type<?T,?S> (g: () -> ?T, h: () -> ?S) :
   g as ? as () -> T|S

;============================================================
;================== Binding Analysis ========================
;============================================================

deftype BindingType
defstruct ListBinding <: BindingType : (type:BindingType)
defstruct TerminalBinding <: BindingType : (name:Symbol)
defstruct ProductionBinding <: BindingType : (name:Symbol)
defstruct UnionBinding <: BindingType : (a:BindingType, b:BindingType)

defstruct Binding :
   name: Symbol
   index: Int
   type: BindingType
   pattern: Pattern

defn recomputable? (b:Binding) :
   recomputable?(pattern(b))


defn get-bindings (p:Pattern) -> List<Binding> :
   ;Common Types
   defn gradual-type () : TerminalBinding(`?)
   defn void-type () : TerminalBinding(`Void)
   defn literal-type (name:Symbol) :
      UnionBinding(TerminalBinding(name), TerminalBinding(`core/Token))
      
   ;Type of a literal
   defn primitive-type (v) :
      match(v) :
         (v:Token) : primitive-type(item(v))
         (v:Byte) : literal-type(`core/Byte)
         (v:Int) : literal-type(`core/Int)
         (v:Long) : literal-type(`core/Long)
         (v:Char) : literal-type(`core/Char)
         (v:Float) : literal-type(`core/Float)
         (v:Double) : literal-type(`core/Double)
         (v:String) : literal-type(`core/String)
         (v:Symbol) : literal-type(`core/Symbol)
         (v:List) : literal-type(`core/List)
         (v:True) : literal-type(`core/True)
         (v:False) : literal-type(`core/False)
         (v) : gradual-type()

   ;Compute the type of a pattern at nlists level of nesting
   defn binding-type (p:Pattern, nlists:Int) :
      defn typeof-contents (p:Pattern) :
         match(p) :
            (p:SeqPat) : UnionBinding(typeof(a(p)), typeof(b(p))) 
            (p:Choice) : UnionBinding(typeof(a(p)), typeof(b(p))) 
            (p:Empty) : void-type() 
            (p:Terminal) : primitive-type(value(p)) 
            (p:NotPat) : void-type() 
            (p:Form) : gradual-type() 
            (p:Production) : ProductionBinding(name(p)) 
            (p:Repeat) : typeof-contents(pattern(p)) 
            (p:Rest) : gradual-type() 
            (p:ListPat) : ListBinding(typeof-contents(pattern(p))) 
            (p:Binder) : typeof-contents(pattern(p))          
      defn typeof (p:Pattern) :
         if single?(p) : typeof-contents(p)
         else : ListBinding(typeof-contents(p))
      defn* wrap-lists (t:BindingType, n:Int) :
         if n == 0 : t
         else : wrap-lists(ListBinding(t), n - 1)
      wrap-lists(typeof(p), nlists)

   ;Discover bindings
   val bindings = Vector<Binding>()         
   defn loop (p:Pattern, nlists:Int) :
      match(p) :
         (p:Binder) :
            val t = binding-type(pattern(p), nlists)
            add(bindings, Binding(name(p), index(p), t, pattern(p)))
            loop(pattern(p), nlists)
         (p:Repeat) :
            loop(pattern(p), nlists + 1)
         (p:Action|IndexedAction|FailPat|Guard) :
            fatal("Unexpected pattern")
         (p) :
            do(loop{_, nlists}, p)         
   loop(p, 0)
   to-list(bindings)

;============================================================
;================= Pattern Utilities ========================
;============================================================

defn recomputable? (p:Pattern) :
   match(p) :
      (p:Production) : false
      (p) : all?(recomputable?, p)

defn flatten (p:SeqPat) :
   generate<Pattern> :
      defn loop (p:Pattern) :
         match(p) :
            (p:SeqPat) : do(loop, p)
            (p) : yield(p)
      loop(p)

defn flatten (p:Choice) :
   generate<Pattern> :
      defn loop (p:Pattern) :
         match(p) :
            (p:Choice) : do(loop, p)
            (p) : yield(p)
      loop(p)

defn single? (p:Pattern) :
   match(p) :
      (p:SeqPat|Empty|NotPat|Repeat|Rest) : false
      (p:Terminal|Action|IndexedAction|Form|ListPat|Production) : true
      (p:Binder) : single?(pattern(p))
      (p) : fatal("Unexpected pattern: %_" % [p])
      
;============================================================
;================= Pattern Parser ===========================
;============================================================

defn subsymbol (x:Symbol, n:Int) :
   to-symbol(to-string(x)[n to false])

defn ensure-cap-form (form) -> Symbol :
   val f:List = unwrap-token(form)
   if length(f) != 2 :
      throw $ PatternException $
      "Invalid binding form %~. Cap form should have form (@cap name)." % [form]
   val name = unwrap-token(f[1])
   if name is-not Symbol :
      throw $ PatternException $
      "Invalid binding form %~. Cap form should have form (@cap name)." % [form]
   name

defn ensure-escape-value (form:List) :
   if empty?(form) :
      throw $ PatternException $
      "Expected escaped value, but reached end of list."

defn ensure-splice-list (p:Pattern) :
   match(p) :
      (p:ListPat) :
         pattern(p)
      (p) :
         throw $ PatternException $
         "Splice repeat operator @... requires a list pattern, but found %~." % [p]

public defn parse-pattern (form:List) -> Pattern :
   ;Sequence of forms (without handling | operator)
   defn pseq (f:List) -> [Pattern, List] :
      ;End of sequence
      if empty?(f) :
         [Empty(), f]
      ;Choice operator
      else if tagged-list?(f, `|) :
         [Empty(), f]
      ;Binder
      else if tagged-list?(head(f), `@cap) :
         val name = ensure-cap-form(head(f))
         val [p, rest] = pseq $
            if tagged-list?(tail(f), `:) : tailn(f, 2)
            else : cons(`_, tail(f))
         val p* = match(p) :
            (p:SeqPat) : SeqPat(Binder(name, a(p)), b(p))
            (p) : Binder(name, p)
         [p*, rest]
      ;Escape
      else if tagged-list?(f, `~) :
         ensure-escape-value(tail(f))
         val [p, rest] = pseq(tailn(f, 2))
         [SeqPat(Terminal(unwrap-all(f[1])), p), rest]
      ;Repeat Splice
      else if tagged-list?(tail(f), `@...) :
         val p1 = ensure-splice-list(pp(head(f)))
         val [p2, rest] = pseq(tailn(f, 2))
         [SeqPat(Repeat(p1), p2), rest]
      ;Repeat
      else if tagged-list?(tail(f), `...) :
         val p1 = pp(head(f))
         val [p2, rest] = pseq(tailn(f, 2))
         [SeqPat(Repeat(p1), p2), rest]
      ;Otherwise
      else :
         val p1 = pp(head(f))
         val [p2, rest] = pseq(tail(f))
         [SeqPat(p1, p2), rest]
   ;Sequence of pseq forms (handles | operator)
   defn pexp (f:List) :
      val [p1, rest] = pseq(f)
      if tagged-list?(rest, `|) :
         val p2 = pexp(tail(rest))
         Choice(p1, p2)
      else :
         fatal("Unhandled Pattern: %_" % [form]) when not empty?(rest)
         p1         
   ;General Form (handles ! operator)
   defn pform (f:List) :
      if tagged-list?(f, `!) : NotPat(pexp(tail(f)))
      else : pexp(f)
      
   ;Single Pattern
   defn pp (f) :
      match(f) :
         (f:Token) :
            pp(item(f))
         (f:List) :
            match(pform(f)) :
               (p:Choice|NotPat) : p
               (p) : ListPat(p)
         (f:Symbol) :
            if f == `_ : Form()
            else if prefix?(f, "#") : Production(subsymbol(f, 1))
            else : Terminal(f)
         (f) :
            Terminal(f)

   ;Driver
   index-binders(pform(form))

;============================================================
;================== Index Binders ===========================
;============================================================

deftype IndexPool
defmulti next (i:IndexPool, name:Symbol) -> Int
defmulti num-indices (i:IndexPool) -> Int
defmulti get (i:IndexPool, name:Symbol) -> Int

defn IndexPool () :
   val indices = to-seq(0 to false)
   val binders = HashTable<Symbol,Int>()
   new IndexPool :
      defmethod next (this, name:Symbol) :
         val i = next(indices)
         binders[name] = i
         i
      defmethod num-indices (this) :
         peek(indices)
      defmethod get (this, name:Symbol) :
         binders[name]

defn bound-indices (p:Pattern) :
   match(p) :
      (p:Action|IndexedAction|FailPat|Guard) : List()
      (p:Binder) : cons(index(p), bound-indices(pattern(p)))
      (p) : seq-append(bound-indices, children(p))

defn index-binders (p:Pattern) -> Pattern :
   defn new-index (p:Pattern) -> [Pattern, Int] :
      val indices = IndexPool()
      val p* = new-index(p, indices)
      [p*, num-indices(indices)]
   defn new-index (p:Pattern, indices:IndexPool) :
      match(p) :
         (p:Action) :
            val [p* n] = new-index(pattern(p))
            Action(action(p), p*, n)
         (p:IndexedAction) :
            val [p* n] = new-index(pattern(p))
            IndexedAction(index(p), p*, n)
         (p:FailPat) :
            val [p* n] = new-index(pattern(p))
            FailPat(action(p), p*, n)
         (p:Binder) :
            val i = next(indices, name(p))
            val p* = new-index(pattern(p), indices)
            Binder(name(p), p*, i)
         (p:Repeat) :
            val p* = new-index(pattern(p), indices)
            val bs = bound-indices(p*)
            val n = maximum(0, bs) + 1
            Repeat(p*, bs, n)
         (p:Guard) :
            val p* = new-index(pattern(p), indices)
            val bs = bound-indices(p*)
            val n = maximum(0, bs) + 1
            Guard(predicate(p), p*, bs, n)
         (p:Choice) :
            val a* = new-index(a(p), indices)
            val b* = assign(b(p), indices)
            Choice(a*, b*)
         (p) :
            map(new-index{_, indices}, p)
   defn assign (p:Pattern, indices:IndexPool) :
      match(p) :
         (p:Action|IndexedAction|FailPat|Guard) :
            new-index(p, indices)
         (p:Binder) :
            val i = indices[name(p)]
            val p* = assign(pattern(p), indices)
            Binder(name(p), p*, i)
         (p:Repeat) :
            val p* = assign(pattern(p), indices)
            val bs = bound-indices(p*)
            val n = maximum(0, bs) + 1
            Repeat(p*, bs, n)
         (p:Guard) :
            val p* = assign(pattern(p), indices)
            val bs = bound-indices(p*)
            val n = maximum(0, bs) + 1
            Guard(predicate(p), p*, bs, n)
         (p) :
            map(assign{_, indices}, p)
   new-index(p, IndexPool())

;;============================================================
;;================= Identify Rests ===========================
;;============================================================
;
;defn identify-rests (p:Pattern) -> Pattern :
;   defn rest? (p:Pattern) :
;      label<True|False> return :
;         ;Must be a sequence
;         return(false) when p is-not SeqPat
;         val pseq = p as SeqPat
;         ;Must be a single item sequence
;         return(false) when b(pseq) is-not Empty
;         ;First item must be form
;         a(pseq) is Form
;   match(map(identify-rests, p)) :
;      (p:Repeat) : Rest() when rest?(pattern(p)) else p
;      (p) : p
;
;;============================================================
;;=================== Prepare Pattern ========================
;;============================================================
;
;defn prepare (p:Pattern) -> Pattern :
;   val indexed = index-binders(p)
;   identify-rests(indexed)
;
;;============================================================
;;====================== RuleSet =============================
;;============================================================
;
;deftype RuleSet
;defmulti get (r:RuleSet, name:Symbol) -> Pattern
;
;defn RuleSet (pkgs:List<SyntaxPackage>) :
;   ;Accumulate production table
;   val prods = HashTable<Symbol, List<Pattern>>(List())
;   for pkg in in-reverse(pkgs) do :
;      for prod in productions(pkg) do :
;         prods[name(prod)] = append(patterns(prod), prods[name(prod)])
;   ;Form accumulated patterns
;   val patterns = HashTable<Symbol, Pattern>()
;   for entry in prods do :
;      patterns[key(entry)] = prepare(Choice(value(entry)))
;
;   println("Created Ruleset")
;   do(println, patterns)
;
;   ;Return new rule set
;   new RuleSet :
;      defmethod get (this, name:Symbol) : patterns[name]
;
;============================================================
;====================== Context =============================
;============================================================

deftype Context
protected defmulti get (c:Context, i:Int) -> (() -> ?)
protected defmulti info (c:Context) -> False|FileInfo
protected defmulti info (c:Context, form) -> False|FileInfo

defn Context (bindings:Array<(() -> ?)>, form, current-info:False|FileInfo) :
   defn first-info (form) :
      match(form) :
         (form:Token) :
            info(form)
         (form:List) :
            if empty?(form) : current-info
            else : first-info(head(form))
         (form) : current-info
         
   defn closest-info (form) -> Maybe<FileInfo> :
      match(form) :
         (form:Token) : One(info(form))
         (form:List) : first(closest-info, form)
         (form) : None()
               
   new Context :
      defmethod get (this, i:Int) :
         bindings[i]
      defmethod info (this) :
         match(first-info(form)) :
            (info:FileInfo) : info
            (info:False) : value?(closest-info(form))
      defmethod info (this, subform) :
         val inf = closest-info(subform)
         if empty?(inf) : info(this)
         else : value!(inf)

;;============================================================
;;================= Pattern Interpreter ======================
;;============================================================
;
;defstruct MResult :
;   pattern: Pattern
;   head: () -> List
;   tail: List
;   info: False|FileInfo  ;The most update-to-date file information from head
;
;;Empty bindings optimization
;val EMPTY-BINDINGS = Array<?>(0)
;defn BindingArray (n:Int) :
;   if n == 0 : EMPTY-BINDINGS
;   else : Array<(() -> ?)>(n)
;defn BindingArray<T> (n:Int, v:T) :
;   if n == 0 : EMPTY-BINDINGS
;   else : Array<T>(n, v)
;defn setter (b:Array<(() -> ?)>) :
;   set{b, _:Int, _:() -> ?}
;
;defn interpret (pat:Pattern,
;                form:List,
;                patterns:RuleSet,
;                actions:Tuple<(Context -> ?)>) ->
;                MResult|False :
;   ;Pattern Matcher
;   defn match-pat (pat:Pattern, form:List, last-info:False|FileInfo, bind:(Int, () -> ?) -> ?) :               
;      ;Farthest info
;      defn farthest-info (form) :
;         defn loop (form) -> Maybe<FileInfo> :
;            match(form) :
;               (form:Token) :
;                  val inf = loop(item(form))
;                  if empty?(inf) : One(info(form))
;                  else : inf
;               (form:List) :
;                  first(loop, in-reverse(form))
;               (form) :
;                  None()
;         match(loop(form)) :
;            (i:One<FileInfo>) : value(i)
;            (i:None) : last-info
;
;      match(pat) :
;         (pat:Terminal) :
;            if not empty?(form) :
;               val h = head(form)
;               if unwrap-token(h) == value(pat) :
;                  MResult(pat, List{h}, tail(form), farthest-info(h))
;         (pat:Empty) :
;            MResult(pat, List, form, last-info)
;         (pat:Form) :
;            if not empty?(form) :
;               val h = head(form)
;               MResult(pat, List{h}, tail(form), farthest-info(h))
;         (pat:Production) :
;            val p = patterns[name(pat)]
;            match-pat(p, form, last-info, bind)
;         (pat:SeqPat) :
;            match(match-pat(a(pat), form, last-info, bind)) :
;               (r1:MResult) :
;                  match(match-pat(b(pat), tail(r1), info(r1), bind)) :
;                     (r2:MResult) :
;                        val h* = fn* () : append(head(r1)(), head(r2)())
;                        MResult(pat, h*, tail(r2), info(r2))
;                     (r2:False) :
;                        false
;               (r1:False) :
;                  false
;         (pat:Choice) :
;            match(match-pat(a(pat), form, last-info, bind)) :
;               (r1:MResult) : r1
;               (r1:False) : match-pat(b(pat), form, last-info, bind)
;         (pat:Binder) :
;            match(match-pat(pattern(pat), form, last-info, bind)) :
;               (r1:MResult) :
;                  val v =
;                     if single?(pattern(r1)) : head{head(r1)()}
;                     else : head(r1)
;                  bind(index(pat), v)
;                  r1
;               (r1:False) :
;                  false
;         (pat:Action) :
;            val bindings = BindingArray(num-binders(pat))
;            match(match-pat(pattern(pat), form, last-info, setter(bindings))) :
;               (r1:MResult) :
;                  defn head* () : List(action(pat)(Context(bindings, form, last-info)))
;                  MResult(pat, head*, tail(r1), info(r1))
;               (r1:False) :
;                  false
;         (pat:IndexedAction) :
;            val bindings = BindingArray(num-binders(pat))
;            match(match-pat(pattern(pat), form, last-info, setter(bindings))) :
;               (r1:MResult) :
;                  defn head* () : List(actions[index(pat)](Context(bindings, form, last-info)))
;                  MResult(pat, head*, tail(r1), info(r1))
;               (r1:False) :
;                  false
;         (pat:FailPat) :
;            val bindings = BindingArray(num-binders(pat))
;            match(match-pat(pattern(pat), form, last-info, setter(bindings))) :
;               (r1:MResult) : action(pat)(Context(bindings, form, last-info))
;               (r1:False) : false
;         (pat:NotPat) :
;            match(match-pat(pattern(pat), form, last-info, bind)) :
;               (r1:MResult) : false
;               (r1:False) : MResult(pat, List, form, last-info)
;         (pat:ListPat) :
;            if not empty?(form) :
;               val h = unwrap-token(head(form))
;               if h is List :
;                  val list-info = match(head(form)) :
;                     (t:Token) : info(t)
;                     (t) : last-info                     
;                  match(match-pat(pattern(pat), h, list-info, bind)) :
;                     (r1:MResult) :
;                        if empty?(tail(r1)) :
;                           MResult(pat, List{head(r1)()}, tail(form), info(r1))
;                     (r1:False) :
;                        false
;         (pat:Repeat) :
;            ;Set up new binding list
;            val bindings = BindingArray<List<(() -> ?)>>(num-binders(pat), List())
;            val counts = BindingArray<Int>(num-binders(pat), 0)
;            defn add-bind (i:Int, v:() -> ?) :
;               counts[i] = counts[i] + 1
;               bindings[i] = cons(v, bindings[i])
;            defn call-all (fs:List<(() -> ?)>) :
;               for f in reverse(fs) map :
;                  f()                  
;            ;Match as much as we can
;            defn loop (form:List, last-info:False|FileInfo, n:Int) -> MResult :
;               val r1 = match-pat(pattern(pat), form, last-info, add-bind) when not empty?(form)
;               match(r1) :
;                  (r1:MResult) :
;                     val r2 = loop(tail(r1), info(r1), n + 1)
;                     defn h* () : append(head(r1)(), head(r2)())
;                     MResult(pat, h*, tail(r2), info(r2))
;                  (r1:False) :
;                     ;Bind repeated listp
;                     for b in binders(pat) do :
;                        val bs = tailn(bindings[b], counts[b] - n)
;                        bind(b, call-all{bs})
;                     MResult(pat, List, form, last-info)                     
;            ;Driver
;            loop(form, last-info, 0)
;         (pat:Rest) :
;            MResult(pat, {form}, List(), farthest-info(form))
;         (pat:Guard) :
;            ;Set up new binding list
;            val bindings = BindingArray(num-binders(pat))
;            match(match-pat(pattern(pat), form, last-info, setter(bindings))) :
;               (r1:MResult) :
;                  if predicate(pat)(Context(bindings, form, last-info)) :
;                     for b in binders(pat) do :
;                        bind(b, bindings[b])
;                     r1
;               (r1:False) :
;                  false
;   ;Driver
;   defn bad-bind (i:Int, v:() -> ?) : fatal("Unexpected binder")
;   match-pat(pat, form, false, bad-bind)
;
;
;;============================================================
;;==================== Exceptions ============================
;;============================================================

public deftype PatternException <: Exception

defn PatternException (msg) :
   new PatternException :
      defmethod print (o:OutputStream, this) : print(o, msg)