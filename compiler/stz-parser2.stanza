defpackage stz/parser2 :
   import core
   import collections
   import macro-utils

;============================================================
;===================== Ruleset ==============================
;============================================================

;defstruct SyntaxPackage :
;   name: Symbol
;   imports: List<Symbol>
;   productions: List<DefProduction>
;   rules: List<DefRule>
;
;defstruct DefProduction :
;   name: Symbol
;   type
;   public?: True|False
;   inline?: True|False
;
;defstruct DefRule :
;   name: Symbol
;   pattern: Pattern

;============================================================
;================= Public Interface =========================
;============================================================

protected defn register-syntax-package (p:SyntaxPackage) :
   SYNTAX-PACKAGES[name(p)] = p

protected defn call-with-syntax<?T> (pkgs:List<Symbol>, f: () -> ?T) :
   let-var CURRENT-SYNTAX-PACKAGES = pkgs :
      f()

protected defn call-with-added-syntax<?T> (pkgs:List<Symbol>, f: () -> ?T) :
   let-var CURRENT-SYNTAX-PACKAGES = append(pkgs, CURRENT-SYNTAX-PACKAGES) :
      f()

protected defn syntax-match (form:List,
                             id:Int,
                             pat:() -> Pattern,
                             actions:Tuple<(Array<(() -> ?)> -> ?)>) :
   val ruleset = RuleSet(map({SYNTAX-PACKAGES[_]}, CURRENT-SYNTAX-PACKAGES))
   match(interpret(prepare(pat()), form, ruleset, actions)) :
      (r:MResult) : head(r)()
      (r:False) : fatal("No match.")

;============================================================
;===================== Storage ==============================
;============================================================

val SYNTAX-PACKAGES = HashTable<Symbol,SyntaxPackage>()

var CURRENT-SYNTAX-PACKAGES : List<Symbol> = List()

;============================================================
;=================== SyntaxPackage ==========================
;============================================================

protected defstruct SyntaxPackage :
   name: Symbol
   productions: List<DefProduction>

protected defstruct DefProduction :
   name: Symbol
   patterns: List<Pattern>

defmethod print (o:OutputStream, p:SyntaxPackage) :
   print(o, "($syntax %_ %_)" % [name(p), productions(p)])
   
defmethod print (o:OutputStream, p:DefProduction) :
   print(o, "($production %_ %_)" % [name(p), patterns(p)])

;============================================================
;================== Pattern Definition ======================
;============================================================

protected :
   deftype Pattern
   defstruct SeqPat <: Pattern :
      a: Pattern
      b: Pattern
   defstruct Choice <: Pattern :
      a: Pattern
      b: Pattern
   defstruct Empty <: Pattern
   defstruct Terminal <: Pattern :
      value
   defstruct Action <: Pattern :
      action: Array<(() -> ?)> -> ?
      pattern: Pattern
      num-binders: Int
   defstruct IndexedAction <: Pattern :
      index: Int
      pattern: Pattern
      num-binders: Int
   defstruct FailPat <: Pattern :
      action: Array<(() -> ?)> -> Void
      pattern: Pattern
      num-binders: Int
   defstruct NotPat <: Pattern :
      pattern: Pattern
   defstruct Form <: Pattern
   defstruct Production <: Pattern :
      name: Symbol
   defstruct Repeat <: Pattern :
      pattern: Pattern
      binders: List<Int>
      num-binders: Int
   defstruct ListPat <: Pattern :
      pattern: Pattern
   defstruct Binder <: Pattern :
      name: Symbol
      pattern: Pattern
      index: Int
   defstruct Guard <: Pattern :
      predicate: Array<(() -> ?)> -> True|False
      pattern: Pattern
      binders: List<Int>
      num-binders: Int

   defn SeqPat (xs:Seqable<Pattern>) :
      reduce-right(SeqPat, xs, Empty())
   defn Choice (ps:Seqable<Pattern>) :
      reduce-right(Choice, ps)
   defn Action (action:Array<(() -> ?)> -> ?, pattern:Pattern) :
      Action(action, pattern, 0)
   defn IndexedAction (index:Int, pattern:Pattern) :
      IndexedAction(index, pattern, 0)
   defn FailPat (action:Array<(() -> ?)> -> ?, pattern:Pattern) :
      FailPat(action, pattern, 0)
   defn Repeat (pattern:Pattern) :
      Repeat(pattern, List(), 0)
   defn Binder (name:Symbol, pattern:Pattern) :
      Binder(name, pattern, 0)
   defn Guard (predicate:Array<(() -> ?)> -> True|False, pattern:Pattern) :
      Guard(predicate, pattern, List(), 0)
   

defmethod print (o:OutputStream, p:Pattern) :
   print{o, _} $ match(p) :
      (p:SeqPat) : "($seq %@)" % [flatten(p)]
      (p:Choice) : "($or %@)" % [flatten(p)]
      (p:Empty) : "eps"
      (p:Terminal) : value(p)
      (p:Action) : "A{%~ %_}" % [pattern(p), num-binders(p)]
      (p:IndexedAction) : "A%_{%~ %_}" % [index(p), pattern(p), num-binders(p)]
      (p:FailPat) : "($fail %~ %_)" % [pattern(p), num-binders(p)]
      (p:NotPat) : "($not $~)" % [pattern(p)]
      (p:Form) : "_"
      (p:Production) : "#%_" % [name(p)]
      (p:Repeat) : "($repeat %~ {%_|%,})" % [pattern(p), num-binders(p), binders(p)]
      (p:ListPat) : "($list %~)" % [pattern(p)]
      (p:Binder) : "($bind %~(%_) %~)" % [name(p), index(p), pattern(p)]
      (p:Guard) : "($when %~ {%_|%,})" % [pattern(p), num-binders(p), binders(p)]   

;============================================================
;==================== Mappers ===============================
;============================================================

defn map (f:Pattern -> Pattern, p:Pattern) :
   match(p) :
      (p:SeqPat) : SeqPat(f(a(p)), f(b(p)))
      (p:Choice) : Choice(f(a(p)), f(b(p)))
      (p:Empty) : Empty()
      (p:Terminal) : Terminal(value(p))
      (p:Action) : Action(action(p), f(pattern(p)), num-binders(p))
      (p:IndexedAction) : IndexedAction(index(p), f(pattern(p)), num-binders(p))
      (p:FailPat) : FailPat(action(p), f(pattern(p)), num-binders(p))
      (p:NotPat) : NotPat(f(pattern(p)))
      (p:Form) : Form()
      (p:Production) : Production(name(p))
      (p:Repeat) : Repeat(f(pattern(p)), binders(p), num-binders(p))
      (p:ListPat) : ListPat(f(pattern(p)))
      (p:Binder) : Binder(name(p), f(pattern(p)), index(p))
      (p:Guard) : Guard(predicate(p), f(pattern(p)), binders(p), num-binders(p))

defn do (f:Pattern -> ?, p:Pattern) :
   defn f* (p:Pattern) : (f(p), p)
   map(f*, p)
   false

defn children (p:Pattern) :
   generate<Pattern> : do(yield, p)

defn any? (f:Pattern -> True|False, p:Pattern) :
   any?(f, children(p))

defn all? (f:Pattern -> True|False, p:Pattern) :
   all?(f, children(p))

;============================================================
;================= Pattern Utilities ========================
;============================================================

public defn get-bindings (p:Pattern) -> List<KeyValue<Symbol, Int>> :
   match(p) :
      (p:Action|IndexedAction|FailPat) : List()
      (p:Binder) : cons(name(p) => index(p), get-bindings(pattern(p)))
      (p) : seq-append(get-bindings, children(p))

public defn get-recomputable-bindings (p:Pattern) -> List<KeyValue<Symbol, Int>> :
   match(p) :
      (p:Action|IndexedAction|FailPat) : List()
      (p:Binder) :
         val bs = get-bindings(pattern(p))
         if recomputable?(pattern(p)) : cons(name(p) => index(p), bs)
         else : bs
      (p) : seq-append(get-bindings, children(p))

defn recomputable? (p:Pattern) :
   match(p) :
      (p:Production|Action|IndexedAction|FailPat) : false
      (p) : all?(recomputable?, p)

defn flatten (p:SeqPat) :
   generate<Pattern> :
      defn loop (p:Pattern) :
         match(p) :
            (p:SeqPat) : (yield(a(p)), loop(b(p)))
            (p:Empty) : false
      loop(p)

defn flatten (p:Choice) :
   generate<Pattern> :
      defn loop (p:Pattern) :
         match(p) :
            (p:Choice) : (loop(a(p)), loop(b(p)))
            (p) : yield(p)
      loop(p)

;============================================================
;================= Pattern Parser ===========================
;============================================================

defn subsymbol (x:Symbol, n:Int) :
   to-symbol(to-string(x)[n to false])

defn ensure-cap-form (form) -> Symbol :
   val f:List = unwrap-token(form)
   if length(f) != 2 :
      throw $ PatternException $
      "Invalid binding form %~. Cap form should have form (@cap name)." % [form]
   val name = unwrap-token(f[1])
   if name is-not Symbol :
      throw $ PatternException $
      "Invalid binding form %~. Cap form should have form (@cap name)." % [form]
   name

defn ensure-escape-value (form:List) :
   if empty?(form) :
      throw $ PatternException $
      "Expected escaped value, but reached end of list."

defn ensure-splice-list (p:Pattern) :
   match(p) :
      (p:ListPat) :
         pattern(p)
      (p) :   
         throw $ PatternException $
         "Splice repeat operator @... requires a list pattern, but found %~." % [p]

public defn parse-pattern (form:List) -> Pattern :
   ;Sequence of forms (without handling | operator)
   defn pseq (f:List) -> [Pattern, List] :
      ;End of sequence
      if empty?(f) :
         [Empty(), f]
      ;Choice operator   
      else if tagged-list?(f, `|) :
         [Empty(), f]
      ;Binder   
      else if tagged-list?(head(f), `@cap) :
         val name = ensure-cap-form(head(f))
         val [p, rest] = pseq $
            if tagged-list?(tail(f), `:) : tailn(f, 2)
            else : cons(`_, tail(f))
         val p* = SeqPat(Binder(name, a(p as SeqPat)), b(p as SeqPat))
         [p*, rest]
      ;Escape   
      else if tagged-list?(f, `~) :
         ensure-escape-value(tail(f))
         val [p, rest] = pseq(tailn(f, 2))
         [SeqPat(Terminal(unwrap-all(f[1])), p), rest]
      ;Repeat Splice
      else if tagged-list?(tail(f), `@...) :
         val p1 = ensure-splice-list(pp(head(f)))
         val [p2, rest] = pseq(tailn(f, 2))
         [SeqPat(Repeat(p1), p2), rest]
      ;Repeat
      else if tagged-list?(tail(f), `...) :
         val p1 = SeqPat(pp(head(f)), Empty())
         val [p2, rest] = pseq(tailn(f, 2))
         [SeqPat(Repeat(p1), p2), rest]
      ;Otherwise
      else :
         val p1 = pp(head(f))
         val [p2, rest] = pseq(tail(f))
         [SeqPat(p1, p2), rest]
   ;Sequence of pseq forms (handles | operator)      
   defn pexp (f:List) :
      val [p1, rest] = pseq(f)
      if tagged-list?(rest, `|) :
         val p2 = pexp(tail(rest))
         Choice(p1, p2)
      else :
         fatal("Unhandled Pattern: %_" % [form]) when not empty?(rest)
         p1
   ;General Form (handles ! operator)
   defn pform (f:List) :
      if tagged-list?(f, `!) : NotPat(pexp(tail(f)))
      else : pexp(f)
   ;Single Pattern
   defn pp (f) :
      match(f) :
         (f:Token) :
            pp(item(f))
         (f:List) :
            match(pform(f)) :
               (p:SeqPat|Empty) : ListPat(p)
               (p:Choice) : p
         (f:Symbol) :
            if f == `_ : Form()
            else if prefix?(f, "#") : Production(subsymbol(f, 1))
            else : Terminal(f)
         (f) :
            Terminal(f)

   ;Driver
   index-binders(pform(form))

;============================================================
;================== Index Binders ===========================
;============================================================

deftype IndexPool
defmulti next (i:IndexPool, name:Symbol) -> Int
defmulti num-indices (i:IndexPool) -> Int
defmulti get (i:IndexPool, name:Symbol) -> Int

defn IndexPool () :
   val indices = to-seq(0 to false)
   val binders = HashTable<Symbol,Int>()
   new IndexPool :
      defmethod next (this, name:Symbol) :
         val i = next(indices)
         binders[name] = i
         i
      defmethod num-indices (this) :
         peek(indices)
      defmethod get (this, name:Symbol) :
         binders[name]

defn bound-indices (p:Pattern) :
   match(p) :
      (p:Action|IndexedAction|FailPat|Guard) : List()
      (p:Binder) : cons(index(p), bound-indices(pattern(p)))
      (p) : seq-append(bound-indices, children(p))

defn index-binders (p:Pattern) -> Pattern :
   defn new-index (p:Pattern) -> [Pattern, Int] :
      val indices = IndexPool()
      val p* = new-index(p, indices)
      [p*, num-indices(indices)]
   defn new-index (p:Pattern, indices:IndexPool) :   
      match(p) :
         (p:Action) :
            val [p* n] = new-index(pattern(p))
            Action(action(p), p*, n)
         (p:IndexedAction) :
            val [p* n] = new-index(pattern(p))
            IndexedAction(index(p), p*, n)
         (p:FailPat) :
            val [p* n] = new-index(pattern(p))
            FailPat(action(p), p*, n)
         (p:Binder) :
            val i = next(indices, name(p))
            val p* = new-index(pattern(p), indices)
            Binder(name(p), p*, i)
         (p:Repeat) :
            val p* = new-index(pattern(p), indices)
            val bs = bound-indices(p*)
            val n = maximum(0, bs) + 1
            Repeat(p*, bs, n)
         (p:Guard) :
            val p* = new-index(pattern(p), indices)
            val bs = bound-indices(p*)
            val n = maximum(0, bs) + 1
            Guard(predicate(p), p*, bs, n)
         (p:Choice) :
            val a* = new-index(a(p), indices)
            val b* = assign(b(p), indices)
            Choice(a*, b*)
         (p) :
            map(new-index{_, indices}, p)
   defn assign (p:Pattern, indices:IndexPool) :
      match(p) :
         (p:Action|IndexedAction|FailPat|Guard) :
            new-index(p, indices)
         (p:Binder) :
            val i = indices[name(p)]
            val p* = assign(pattern(p), indices)
            Binder(name(p), p*, i)
         (p:Repeat) :
            val p* = assign(pattern(p), indices)
            val bs = bound-indices(p*)
            val n = maximum(0, bs) + 1
            Repeat(p*, bs, n)
         (p:Guard) :
            val p* = assign(pattern(p), indices)
            val bs = bound-indices(p*)
            val n = maximum(0, bs) + 1
            Guard(predicate(p), p*, bs, n)
         (p) :
            map(assign{_, indices}, p)
   new-index(p, IndexPool())            

;============================================================
;=================== Prepare Pattern ========================
;============================================================

defn prepare (p:Pattern) -> Pattern :
   index-binders(p)

;============================================================
;====================== RuleSet =============================
;============================================================

deftype RuleSet
defmulti get (r:RuleSet, name:Symbol) -> Pattern

defn RuleSet (pkgs:List<SyntaxPackage>) :
   ;Accumulate production table
   val prods = HashTable<Symbol, List<Pattern>>(List())
   for pkg in pkgs do :
      for prod in productions(pkg) do :
         for pat in patterns(prod) do :
            prods[name(prod)] = cons(pat, prods[name(prod)])
   ;Form accumulated patterns
   val patterns = HashTable<Symbol, Pattern>()
   for entry in prods do :
      patterns[key(entry)] = prepare(Choice(value(entry)))

   println("Created Ruleset")
   do(println, patterns)
   
   ;Return new rule set
   new RuleSet :
      defmethod get (this, name:Symbol) : patterns[name]         

;============================================================
;================= Pattern Interpreter ======================
;============================================================

defstruct MResult :
   head: () -> ?
   tail: List

defn interpret (pat:Pattern,
                form:List,
                patterns:RuleSet,
                actions:Tuple<(Array<(() -> ?)> -> ?)>) ->
                MResult|False :
   ;Empty bindings optimization             
   val empty-bindings = Array<?>(0)         
   defn BindingArray (n:Int) :
      if n == 0 : empty-bindings
      else : Array<(() -> ?)>(n)
   defn BindingArray<T> (n:Int, v:T) :
      if n == 0 : empty-bindings
      else : Array<T>(n, v)
      
   defn match-pat (pat:Pattern, form:List, bind:(Int, () -> ?) -> ?) :
      match(pat) :
         (pat:Terminal) :
            if not empty?(form) :
               val h = head(form)
               if unwrap-token(h) == value(pat) :
                  MResult({h}, tail(form))
         (pat:Empty) :
            MResult(List, form)
         (pat:Form) :
            if not empty?(form) :
               MResult(head{form}, tail(form))
         (pat:Production) :
            val p = patterns[name(pat)]
            match-pat(p, form, bind)            
         (pat:SeqPat) :
            match(match-pat(a(pat), form, bind)) :
               (r1:MResult) :
                  match(match-pat(b(pat), tail(r1), bind)) :
                     (r2:MResult) :
                        val h* = fn* () : cons(head(r1)(), head(r2)())
                        MResult(h*, tail(r2))
                     (r2:False) :
                        false
               (r1:False) :
                  false
         (pat:Choice) :
            match(match-pat(a(pat), form, bind)) :
               (r1:MResult) : r1
               (r1:False) : match-pat(b(pat), form, bind)
         (pat:Binder) :
            match(match-pat(pattern(pat), form, bind)) :
               (r1:MResult) :
                  bind(index(pat), head(r1))
                  MResult(head(r1), tail(r1))
               (r1:False) :
                  false
         (pat:Action) :
            val bindings = BindingArray(num-binders(pat))
            match(match-pat(pattern(pat), form, set{bindings, _, _})) :
               (r1:MResult) :
                  defn head* () : action(pat)(bindings)
                  MResult(head*, tail(r1))
               (r1:False) :
                  false
         (pat:IndexedAction) :
            val bindings = BindingArray(num-binders(pat))
            match(match-pat(pattern(pat), form, set{bindings, _, _})) :
               (r1:MResult) :
                  defn head* () : actions[index(pat)](bindings)
                  MResult(head*, tail(r1))
               (r1:False) :
                  false            
         (pat:FailPat) :
            val bindings = BindingArray(num-binders(pat))
            match(match-pat(pattern(pat), form, set{bindings, _, _})) :
               (r1:MResult) : action(pat)(bindings)
               (r1:False) : false
         (pat:NotPat) :
            match(match-pat(pattern(pat), form, bind)) :
               (r1:MResult) : false
               (r1:False) : MResult(List, form)
         (pat:ListPat) :
            if not empty?(form) :
               val h = unwrap-token(head(form))
               if h is List :               
                  match(match-pat(pattern(pat), h, bind)) :
                     (r1:MResult) :
                        if empty?(tail(r1)) :
                           MResult(head(r1), tail(form))
                     (r1:False) :
                        false
         (pat:Repeat) :
            ;Set up new binding list
            val bindings = BindingArray<List<(() -> ?)>>(num-binders(pat), List())
            val counts = BindingArray<Int>(num-binders(pat), 0)            
            defn bind* (i:Int, v:() -> ?) :               
               counts[i] = counts[i] + 1
               bindings[i] = cons(v, bindings[i])
            defn call-all (fs:List<(() -> ?)>) :
               for f in reverse(fs) map :
                  f()               
            ;Match as much as we can   
            defn loop (form:List, n:Int) -> MResult :
               val r1 = match-pat(pattern(pat), form, bind*) when not empty?(form)
               match(r1) :
                  (r1:MResult) :
                     val r2 = loop(tail(r1), n + 1)
                     defn h* () : append(head(r1)(), head(r2)())
                     MResult(h*, tail(r2))
                  (r1:False) :
                     ;Bind repeated list
                     for b in binders(pat) do :
                        val bs = tailn(bindings[b], counts[b] - n)
                        bind(b, call-all{bs})
                     MResult(List, form)
            ;Driver         
            loop(form, 0)
         (pat:Guard) :
            ;Set up new binding list
            val bindings = BindingArray(num-binders(pat))            
            match(match-pat(pattern(pat), form, set{bindings, _, _})) :
               (r1:MResult) :
                  if predicate(pat)(bindings) :
                     for b in binders(pat) do :
                        bind(b, bindings[b])
                     r1   
               (r1:False) :
                  false
   ;Driver
   defn bad-bind (i:Int, v:() -> ?) : fatal("Unexpected binder")
   match-pat(pat, form, bad-bind)


;============================================================
;==================== Exceptions ============================
;============================================================

public deftype PatternException <: Exception

defn PatternException (msg) :
   new PatternException :
      defmethod print (o:OutputStream, this) : print(o, msg)