defpackage stz/parser2 :
   import core
   import collections
   import macro-utils

;============================================================
;===================== Ruleset ==============================
;============================================================

;defstruct SyntaxPackage :
;   name: Symbol
;   imports: List<Symbol>
;   productions: List<DefProduction>
;   rules: List<DefRule>
;
;defstruct DefProduction :
;   name: Symbol
;   type
;   public?: True|False
;   inline?: True|False
;
;defstruct DefRule :
;   name: Symbol
;   pattern: Pattern

;============================================================
;===================== Storage ==============================
;============================================================

val SYNTAX-PACKAGES = HashTable<Symbol,SyntaxPackage>()

var CURRENT-SYNTAX-PACKAGES : List<Symbol> = List()

;============================================================
;=================== SyntaxPackage ==========================
;============================================================

protected defstruct SyntaxPackage :
   name: Symbol
   productions: List<DefProduction>

protected defstruct DefProduction :
   name: Symbol
   patterns: List<Pattern>

defmethod print (o:OutputStream, p:SyntaxPackage) :
   print(o, "($syntax %_ %_)" % [name(p), productions(p)])
   
defmethod print (o:OutputStream, p:DefProduction) :
   print(o, "($production %_ %_)" % [name(p), patterns(p)])

protected defn register-syntax-package (p:SyntaxPackage) :
   SYNTAX-PACKAGES[name(p)] = p

;============================================================
;================== Pattern Definition ======================
;============================================================

protected deftype Pattern
protected defstruct SeqPat <: Pattern :
   a: Pattern
   b: Pattern
protected defstruct Choice <: Pattern :
   a: Pattern
   b: Pattern
protected defstruct Empty <: Pattern
protected defstruct Terminal <: Pattern :
   value
protected defstruct Action <: Pattern :
   action: List<KeyValue<Symbol, (() -> ?)>> -> ?
   pattern: Pattern
protected defstruct IndexedAction <: Pattern :
   index: Int
   pattern: Pattern
protected defstruct FailPat <: Pattern :
   action: List<KeyValue<Symbol, (() -> ?)>> -> Void
   pattern: Pattern   
protected defstruct NotPat <: Pattern :
   pattern: Pattern
protected defstruct Form <: Pattern
protected defstruct Production <: Pattern :
   name: Symbol
protected defstruct Repeat <: Pattern :
   pattern: Pattern
protected defstruct ListPat <: Pattern :
   pattern: Pattern
protected defstruct Binder <: Pattern :
   name: Symbol
   pattern: Pattern
protected defstruct Guard <: Pattern :
   predicate: List<KeyValue<Symbol, (() -> ?)>> -> True|False
   pattern: Pattern

defmethod print (o:OutputStream, p:Pattern) :
   print{o, _} $ match(p) :
      (p:SeqPat) : "($seq %@)" % [flatten(p)]
      (p:Choice) : "($or $@)" % [flatten(p)]
      (p:Empty) : "eps"
      (p:Terminal) : value(p)
      (p:Action) : "A{%~}" % [pattern(p)]
      (p:IndexedAction) : "A%_{%~}" % [index(p), pattern(p)]
      (p:FailPat) : "($fail %~)" % [pattern(p)]
      (p:NotPat) : "($not $~)" % [pattern(p)]
      (p:Form) : "_"
      (p:Production) : "#%_" % [name(p)]
      (p:Repeat) : "($repeat %~)" % [pattern(p)]
      (p:ListPat) : "($list %~)" % [pattern(p)]
      (p:Binder) : "($bind %~ %~)" % [name(p), pattern(p)]
      (p:Guard) : "($when %~)" % [pattern(p)]   

;============================================================
;==================== Mappers ===============================
;============================================================

defn map (f:Pattern -> Pattern, p:Pattern) :
   match(p) :
      (p:SeqPat) : SeqPat(f(a(p)), f(b(p)))
      (p:Choice) : Choice(f(a(p)), f(b(p)))
      (p:Empty) : Empty()
      (p:Terminal) : Terminal(value(p))
      (p:Action) : Action(action(p), f(pattern(p)))
      (p:IndexedAction) : IndexedAction(index(p), f(pattern(p)))
      (p:FailPat) : FailPat(action(p), f(pattern(p)))
      (p:NotPat) : NotPat(f(pattern(p)))
      (p:Form) : Form()
      (p:Production) : Production(name(p))
      (p:Repeat) : Repeat(f(pattern(p)))
      (p:ListPat) : ListPat(f(pattern(p)))
      (p:Binder) : Binder(name(p), f(pattern(p)))
      (p:Guard) : Guard(predicate(p), f(pattern(p)))

defn do (f:Pattern -> ?, p:Pattern) :
   defn f* (p:Pattern) : (f(p), p)
   map(f*, p)
   false

defn children (p:Pattern) :
   generate<Pattern> : do(yield, p)

defn any? (f:Pattern -> True|False, p:Pattern) :
   any?(f, children(p))

defn all? (f:Pattern -> True|False, p:Pattern) :
   all?(f, children(p))

;============================================================
;================= Pattern Utilities ========================
;============================================================

public defn get-bindings (p:Pattern) :
   unique $ generate<Symbol> :
      defn loop (p:Pattern) :
         match(p) :
            (p:Binder) : (yield(name(p)), loop(pattern(p)))
            (p:Action|IndexedAction|FailPat) : false
            (p) : do(loop, p)
      loop(p)

public defn get-recomputable-bindings (p:Pattern) :
   unique $ generate<Symbol> :
      defn loop (p:Pattern) :
         match(p) :
            (p:Binder) :
               loop(pattern(p))
               yield(name(p)) when recomputable?(pattern(p))
            (p:Action|IndexedAction|FailPat) : false
            (p) : do(loop, p)
      loop(p)

defn recomputable? (p:Pattern) :
   match(p) :
      (p:Production) : false
      (p) : all?(recomputable?, p)

defn flatten (p:SeqPat) :
   generate<Pattern> :
      defn loop (p:Pattern) :
         match(p) :
            (p:SeqPat) : (yield(a(p)), loop(b(p)))
            (p:Empty) : false
      loop(p)

defn flatten (p:Choice) :
   generate<Pattern> :
      defn loop (p:Pattern) :
         match(p) :
            (p:Choice) : (loop(a(p)), loop(b(p)))
            (p) : yield(p)
      loop(p)

;============================================================
;================= Pattern Parser ===========================
;============================================================

defn subsymbol (x:Symbol, n:Int) :
   to-symbol(to-string(x)[n to false])

defn ensure-cap-form (form) -> Symbol :
   val f:List = unwrap-token(form)
   if length(f) != 2 :
      throw $ PatternException $
      "Invalid binding form %~. Cap form should have form (@cap name)." % [form]
   val name = unwrap-token(f[1])
   if name is-not Symbol :
      throw $ PatternException $
      "Invalid binding form %~. Cap form should have form (@cap name)." % [form]
   name

defn ensure-escape-value (form:List) :
   if empty?(form) :
      throw $ PatternException $
      "Expected escaped value, but reached end of list."

defn ensure-splice-list (p:Pattern) :
   match(p) :
      (p:ListPat) :
         pattern(p)
      (p) :   
         throw $ PatternException $
         "Splice repeat operator @... requires a list pattern, but found %~." % [p]

public defn parse-pattern (form:List) -> Pattern :
   ;Sequence of forms (without handling | operator)
   defn pseq (f:List) -> [Pattern, List] :
      ;End of sequence
      if empty?(f) :
         [Empty(), f]
      ;Choice operator   
      else if tagged-list?(f, `|) :
         [Empty(), f]
      ;Binder   
      else if tagged-list?(head(f), `@cap) :
         val name = ensure-cap-form(head(f))
         val [p, rest] = pseq $
            if tagged-list?(tail(f), `:) : tailn(f, 2)
            else : cons(`_, tail(f))
         val p* = SeqPat(Binder(name, a(p as SeqPat)), b(p as SeqPat))
         [p*, rest]
      ;Escape   
      else if tagged-list?(f, `~) :
         ensure-escape-value(tail(f))
         val [p, rest] = pseq(tailn(f, 2))
         [SeqPat(Terminal(unwrap-all(f[1])), p), rest]
      ;Repeat Splice
      else if tagged-list?(tail(f), `@...) :
         val p1 = ensure-splice-list(pp(head(f)))
         val [p2, rest] = pseq(tailn(f, 2))
         [SeqPat(Repeat(p1), p2), rest]
      ;Repeat
      else if tagged-list?(tail(f), `...) :
         val p1 = pp(head(f))
         val [p2, rest] = pseq(tailn(f, 2))
         [SeqPat(Repeat(p1), p2), rest]
      ;Otherwise
      else :
         val p1 = pp(head(f))
         val [p2, rest] = pseq(tail(f))
         [SeqPat(p1, p2), rest]
   ;Sequence of pseq forms (handles | operator)      
   defn pexp (f:List) :
      val [p1, rest] = pseq(f)
      if tagged-list?(rest, `|) :
         val p2 = pexp(tail(rest))
         Choice(p1, p2)
      else :
         fatal("Unhandled Pattern: %_" % [form]) when not empty?(rest)
         p1
   ;General Form (handles ! operator)
   defn pform (f:List) :
      if tagged-list?(f, `!) : NotPat(pexp(tail(f)))
      else : pexp(f)
   ;Single Pattern
   defn pp (f) :
      match(f) :
         (f:Token) :
            pp(item(f))
         (f:List) :
            match(pform(f)) :
               (p:SeqPat|Empty) : ListPat(p)
               (p:Choice) : p
         (f:Symbol) :
            if f == `_ : Form()
            else if prefix?(f, "#") : Production(subsymbol(f, 1))
            else : Terminal(f)
         (f) :
            Terminal(f)

   ;Driver
   pform(form)      
         

;============================================================
;================= Pattern Interpreter ======================
;============================================================
;
;defstruct MResult :
;   bindings: List<KeyValue<Symbol, (() -> ?)>>
;   head: () -> ?
;   tail: List
;
;defn interpret (pat:Pattern,
;                form:List,
;                patterns:RuleSet,
;                actions:Tuple<(List<KeyValue<Symbol, (() -> ?)>> -> ?)>) ->
;                MResult|False :
;   defn loop (pat:Pattern, form:List) :
;      match(pat) :
;         (pat:Terminal) :
;            if not empty?(form) :
;               val h = head(form)
;               if unwrap-token(h) == value(pat) :
;                  MResult(List(), {h}, tail(form))
;         (pat:Empty) :
;            MResult(List(), List, form)
;         (pat:Form) :
;            if not empty?(form) :
;               MResult(List(), head{form}, tail(form))
;         (pat:Production) :
;            val p = patterns[name(pat)]
;            loop(p, form)            
;         (pat:SeqPat) :
;            match(loop(a(pat), form)) :
;               (r1:MResult) :
;                  match(loop(b(pat), tail(r1))) :
;                     (r2:MResult) :
;                        val b* = append(bindings(r1), bindings(r2))
;                        val h* = fn* () : cons(head(r1)(), head(r2)())
;                        MResult(b*, h*, tail(r2))
;                     (r2:False) :
;                        false
;               (r1:False) :
;                  false
;         (pat:Choice) :
;            match(loop(a(pat), form)) :
;               (r1:MResult) : r1
;               (r1:False) : loop(b(pat), form)
;         (pat:Binder) :
;            match(loop(pattern(pat), form)) :
;               (r1:MResult) :
;                  val b* = cons(name(pat) => head(r1), bindings(r1))
;                  MResult(b*, head(r1), tail(r1))
;               (r1:False) :
;                  false
;         (pat:Action) :
;            match(loop(pattern(pat), form)) :
;               (r1:MResult) :
;                  defn head* () : action(pat)(bindings(r1))
;                  MResult(List(), head*, tail(r1))
;               (r1:False) :
;                  false
;         (pat:IndexedAction) :
;            match(loop(pattern(pat), form)) :
;               (r1:MResult) :
;                  defn head* () : actions[index(pat)](bindings(r1))
;                  MResult(List(), head*, tail(r1))
;               (r1:False) :
;                  false            
;         (pat:FailPat) :
;            match(loop(pattern(pat), form)) :
;               (r1:MResult) : action(r1)(bindings(r1))
;               (r1:False) : false
;         (pat:NotPat) :
;            match(loop(pattern(pat), form)) :
;               (r1:MResult) : false
;               (r1:False) : MResult(List(), List, form)
;         (pat:ListPat) :
;            if (not empty?(form)) :
;               val h = unwrap-token(head(form))
;               if h is List :               
;                  match(loop(pattern(pat), h)) :
;                     (r1:MResult) :
;                        if empty?(tail(r1)) :
;                           MResult(bindings(r1), head(r1), tail(forms))
;                     (r1:False) :
;                        false
;         (pat:Repeat) :
;            defn loop (form:List) -> MResult :
;               match(loop(pattern(pat), form)) :
;                  (r1:MResult) :
;                     val r2 = loop(pattern(pat), tail(r1), patterns)
;                     val b* = append(bindings(r1), bindings(r2))
;                     defn h* () : append(head(r1)(), head(r2)())
;                     MResult(b*, h*, tail(r2))
;                  (r1:False) :
;                     MResult(List(), List, form)
;            loop(form)
;         (pat:Guard) :
;            match(loop(pattern(pat), form)) :
;               (r1:MResult) :
;                  r1 when predicate(pat)(bindings(r1))               
;               (r1:False) :
;                  false
;   ;Driver               
;   loop(pat, form)
;
;
;============================================================
;==================== Exceptions ============================
;============================================================

public deftype PatternException <: Exception

defn PatternException (msg) :
   new PatternException :
      defmethod print (o:OutputStream, this) : print(o, msg)