defpackage stz/parser2 :
   import core
   import collections
   import macro-utils

;============================================================
;===================== Ruleset ==============================
;============================================================

;defstruct SyntaxPackage :
;   name: Symbol
;   imports: List<Symbol>
;   productions: List<DefProduction>
;   rules: List<DefRule>
;
;defstruct DefProduction :
;   name: Symbol
;   type
;   public?: True|False
;   inline?: True|False
;
;defstruct DefRule :
;   name: Symbol
;   pattern: Pattern

;============================================================
;================= Public Interface =========================
;============================================================

protected defn register-syntax-package (p:SyntaxPackage) :
   SYNTAX-PACKAGES[name(p)] = p

protected defn call-with-syntax<?T> (pkgs:List<Symbol>, f: () -> ?T) :
   let-var CURRENT-SYNTAX-PACKAGES = pkgs :
      f()

protected defn call-with-added-syntax<?T> (pkgs:List<Symbol>, f: () -> ?T) :
   let-var CURRENT-SYNTAX-PACKAGES = append(pkgs, CURRENT-SYNTAX-PACKAGES) :
      f()

protected defn syntax-match (form:List,
                             id:Int,
                             pat:() -> Pattern,
                             actions:Tuple<(List<KeyValue<Symbol, (() -> ?)>> -> ?)>) :
   val ruleset = RuleSet(map({SYNTAX-PACKAGES[_]}, CURRENT-SYNTAX-PACKAGES))
   match(interpret(pat(), form, ruleset, actions)) :
      (r:MResult) : head(r)()
      (r:False) : fatal("No match.")

;============================================================
;===================== Storage ==============================
;============================================================

val SYNTAX-PACKAGES = HashTable<Symbol,SyntaxPackage>()

var CURRENT-SYNTAX-PACKAGES : List<Symbol> = List()

;============================================================
;=================== SyntaxPackage ==========================
;============================================================

protected defstruct SyntaxPackage :
   name: Symbol
   productions: List<DefProduction>

protected defstruct DefProduction :
   name: Symbol
   patterns: List<Pattern>

defmethod print (o:OutputStream, p:SyntaxPackage) :
   print(o, "($syntax %_ %_)" % [name(p), productions(p)])
   
defmethod print (o:OutputStream, p:DefProduction) :
   print(o, "($production %_ %_)" % [name(p), patterns(p)])

;============================================================
;================== Pattern Definition ======================
;============================================================

protected deftype Pattern
protected defstruct SeqPat <: Pattern :
   a: Pattern
   b: Pattern
protected defstruct Choice <: Pattern :
   a: Pattern
   b: Pattern
protected defstruct Empty <: Pattern
protected defstruct Terminal <: Pattern :
   value
protected defstruct Action <: Pattern :
   action: List<KeyValue<Symbol, (() -> ?)>> -> ?
   pattern: Pattern
protected defstruct IndexedAction <: Pattern :
   index: Int
   pattern: Pattern
protected defstruct FailPat <: Pattern :
   action: List<KeyValue<Symbol, (() -> ?)>> -> Void
   pattern: Pattern   
protected defstruct NotPat <: Pattern :
   pattern: Pattern
protected defstruct Form <: Pattern
protected defstruct Production <: Pattern :
   name: Symbol
protected defstruct Repeat <: Pattern :
   binders: List<Int>
   pattern: Pattern
protected defstruct ListPat <: Pattern :
   pattern: Pattern
protected defstruct Binder <: Pattern :
   name: Symbol
   index: Int
   pattern: Pattern
protected defstruct Guard <: Pattern :
   predicate: List<KeyValue<Symbol, (() -> ?)>> -> True|False
   pattern: Pattern

protected defn SeqPat (xs:Seqable<Pattern>) :
   reduce-right(SeqPat, xs, Empty())

protected defn Choice (ps:Seqable<Pattern>) :
   reduce-right(Choice, ps)

defmethod print (o:OutputStream, p:Pattern) :
   print{o, _} $ match(p) :
      (p:SeqPat) : "($seq %@)" % [flatten(p)]
      (p:Choice) : "($or $@)" % [flatten(p)]
      (p:Empty) : "eps"
      (p:Terminal) : value(p)
      (p:Action) : "A{%~}" % [pattern(p)]
      (p:IndexedAction) : "A%_{%~}" % [index(p), pattern(p)]
      (p:FailPat) : "($fail %~)" % [pattern(p)]
      (p:NotPat) : "($not $~)" % [pattern(p)]
      (p:Form) : "_"
      (p:Production) : "#%_" % [name(p)]
      (p:Repeat) : "($repeat %~)" % [pattern(p)]
      (p:ListPat) : "($list %~)" % [pattern(p)]
      (p:Binder) : "($bind %~ %~)" % [name(p), pattern(p)]
      (p:Guard) : "($when %~)" % [pattern(p)]   

;============================================================
;==================== Mappers ===============================
;============================================================

defn map (f:Pattern -> Pattern, p:Pattern) :
   match(p) :
      (p:SeqPat) : SeqPat(f(a(p)), f(b(p)))
      (p:Choice) : Choice(f(a(p)), f(b(p)))
      (p:Empty) : Empty()
      (p:Terminal) : Terminal(value(p))
      (p:Action) : Action(action(p), f(pattern(p)))
      (p:IndexedAction) : IndexedAction(index(p), f(pattern(p)))
      (p:FailPat) : FailPat(action(p), f(pattern(p)))
      (p:NotPat) : NotPat(f(pattern(p)))
      (p:Form) : Form()
      (p:Production) : Production(name(p))
      (p:Repeat) : Repeat(f(pattern(p)))
      (p:ListPat) : ListPat(f(pattern(p)))
      (p:Binder) : Binder(name(p), f(pattern(p)))
      (p:Guard) : Guard(predicate(p), f(pattern(p)))

defn do (f:Pattern -> ?, p:Pattern) :
   defn f* (p:Pattern) : (f(p), p)
   map(f*, p)
   false

defn children (p:Pattern) :
   generate<Pattern> : do(yield, p)

defn any? (f:Pattern -> True|False, p:Pattern) :
   any?(f, children(p))

defn all? (f:Pattern -> True|False, p:Pattern) :
   all?(f, children(p))

;============================================================
;================= Pattern Utilities ========================
;============================================================

public defn get-bindings (p:Pattern) :
   unique $ generate<Symbol> :
      defn loop (p:Pattern) :
         match(p) :
            (p:Binder) : (yield(name(p)), loop(pattern(p)))
            (p:Action|IndexedAction|FailPat) : false
            (p) : do(loop, p)
      loop(p)

public defn get-recomputable-bindings (p:Pattern) :
   unique $ generate<Symbol> :
      defn loop (p:Pattern) :
         match(p) :
            (p:Binder) :
               loop(pattern(p))
               yield(name(p)) when recomputable?(pattern(p))
            (p:Action|IndexedAction|FailPat) : false
            (p) : do(loop, p)
      loop(p)

defn recomputable? (p:Pattern) :
   match(p) :
      (p:Production) : false
      (p) : all?(recomputable?, p)

defn flatten (p:SeqPat) :
   generate<Pattern> :
      defn loop (p:Pattern) :
         match(p) :
            (p:SeqPat) : (yield(a(p)), loop(b(p)))
            (p:Empty) : false
      loop(p)

defn flatten (p:Choice) :
   generate<Pattern> :
      defn loop (p:Pattern) :
         match(p) :
            (p:Choice) : (loop(a(p)), loop(b(p)))
            (p) : yield(p)
      loop(p)

;============================================================
;================= Pattern Parser ===========================
;============================================================

defn subsymbol (x:Symbol, n:Int) :
   to-symbol(to-string(x)[n to false])

defn ensure-cap-form (form) -> Symbol :
   val f:List = unwrap-token(form)
   if length(f) != 2 :
      throw $ PatternException $
      "Invalid binding form %~. Cap form should have form (@cap name)." % [form]
   val name = unwrap-token(f[1])
   if name is-not Symbol :
      throw $ PatternException $
      "Invalid binding form %~. Cap form should have form (@cap name)." % [form]
   name

defn ensure-escape-value (form:List) :
   if empty?(form) :
      throw $ PatternException $
      "Expected escaped value, but reached end of list."

defn ensure-splice-list (p:Pattern) :
   match(p) :
      (p:ListPat) :
         pattern(p)
      (p) :   
         throw $ PatternException $
         "Splice repeat operator @... requires a list pattern, but found %~." % [p]

public defn parse-pattern (form:List) -> Pattern :
   ;Sequence of forms (without handling | operator)
   defn pseq (f:List) -> [Pattern, List] :
      ;End of sequence
      if empty?(f) :
         [Empty(), f]
      ;Choice operator   
      else if tagged-list?(f, `|) :
         [Empty(), f]
      ;Binder   
      else if tagged-list?(head(f), `@cap) :
         val name = ensure-cap-form(head(f))
         val [p, rest] = pseq $
            if tagged-list?(tail(f), `:) : tailn(f, 2)
            else : cons(`_, tail(f))
         val p* = SeqPat(Binder(name, a(p as SeqPat)), b(p as SeqPat))
         [p*, rest]
      ;Escape   
      else if tagged-list?(f, `~) :
         ensure-escape-value(tail(f))
         val [p, rest] = pseq(tailn(f, 2))
         [SeqPat(Terminal(unwrap-all(f[1])), p), rest]
      ;Repeat Splice
      else if tagged-list?(tail(f), `@...) :
         val p1 = ensure-splice-list(pp(head(f)))
         val [p2, rest] = pseq(tailn(f, 2))
         [SeqPat(Repeat(p1), p2), rest]
      ;Repeat
      else if tagged-list?(tail(f), `...) :
         val p1 = SeqPat(pp(head(f)), Empty())
         val [p2, rest] = pseq(tailn(f, 2))
         [SeqPat(Repeat(p1), p2), rest]
      ;Otherwise
      else :
         val p1 = pp(head(f))
         val [p2, rest] = pseq(tail(f))
         [SeqPat(p1, p2), rest]
   ;Sequence of pseq forms (handles | operator)      
   defn pexp (f:List) :
      val [p1, rest] = pseq(f)
      if tagged-list?(rest, `|) :
         val p2 = pexp(tail(rest))
         Choice(p1, p2)
      else :
         fatal("Unhandled Pattern: %_" % [form]) when not empty?(rest)
         p1
   ;General Form (handles ! operator)
   defn pform (f:List) :
      if tagged-list?(f, `!) : NotPat(pexp(tail(f)))
      else : pexp(f)
   ;Single Pattern
   defn pp (f) :
      match(f) :
         (f:Token) :
            pp(item(f))
         (f:List) :
            match(pform(f)) :
               (p:SeqPat|Empty) : ListPat(p)
               (p:Choice) : p
         (f:Symbol) :
            if f == `_ : Form()
            else if prefix?(f, "#") : Production(subsymbol(f, 1))
            else : Terminal(f)
         (f) :
            Terminal(f)

   ;Driver
   pform(form)      

;============================================================
;====================== RuleSet =============================
;============================================================

deftype RuleSet
defmulti get (r:RuleSet, name:Symbol) -> Pattern

defn RuleSet (pkgs:List<SyntaxPackage>) :
   ;Accumulate production table
   val prods = HashTable<Symbol, List<Pattern>>(List())
   for pkg in pkgs do :
      for prod in productions(pkg) do :
         for pat in patterns(prod) do :
            prods[name(prod)] = cons(pat, prods[name(prod)])
   ;Form accumulated patterns
   val patterns = HashTable<Symbol, Pattern>()
   for entry in prods do :
      patterns[key(entry)] = Choice(value(entry))
   ;Return new rule set
   new RuleSet :
      defmethod get (this, name:Symbol) : patterns[name]         

;============================================================
;================= Pattern Interpreter ======================
;============================================================

defstruct MResult :
   bindings: List<KeyValue<Symbol, (() -> ?)>>
   head: () -> ?
   tail: List

defn interpret (pat:Pattern,
                form:List,
                patterns:RuleSet,
                actions:Tuple<(List<KeyValue<Symbol, (() -> ?)>> -> ?)>) ->
                MResult|False :
   defn match-pat (pat:Pattern, form:List) :
      match(pat) :
         (pat:Terminal) :
            if not empty?(form) :
               val h = head(form)
               if unwrap-token(h) == value(pat) :
                  MResult(List(), {h}, tail(form))
         (pat:Empty) :
            MResult(List(), List, form)
         (pat:Form) :
            if not empty?(form) :
               MResult(List(), head{form}, tail(form))
         (pat:Production) :
            val p = patterns[name(pat)]
            match-pat(p, form)            
         (pat:SeqPat) :
            match(match-pat(a(pat), form)) :
               (r1:MResult) :
                  match(match-pat(b(pat), tail(r1))) :
                     (r2:MResult) :
                        val b* = append(bindings(r1), bindings(r2))
                        val h* = fn* () : cons(head(r1)(), head(r2)())
                        MResult(b*, h*, tail(r2))
                     (r2:False) :
                        false
               (r1:False) :
                  false
         (pat:Choice) :
            match(match-pat(a(pat), form)) :
               (r1:MResult) : r1
               (r1:False) : match-pat(b(pat), form)
         (pat:Binder) :
            match(match-pat(pattern(pat), form)) :
               (r1:MResult) :
                  val b* = cons(name(pat) => head(r1), bindings(r1))
                  MResult(b*, head(r1), tail(r1))
               (r1:False) :
                  false
         (pat:Action) :
            match(match-pat(pattern(pat), form)) :
               (r1:MResult) :
                  defn head* () : action(pat)(bindings(r1))
                  MResult(List(), head*, tail(r1))
               (r1:False) :
                  false
         (pat:IndexedAction) :
            match(match-pat(pattern(pat), form)) :
               (r1:MResult) :
                  defn head* () : actions[index(pat)](bindings(r1))
                  MResult(List(), head*, tail(r1))
               (r1:False) :
                  false            
         (pat:FailPat) :
            match(match-pat(pattern(pat), form)) :
               (r1:MResult) : action(pat)(bindings(r1))
               (r1:False) : false
         (pat:NotPat) :
            match(match-pat(pattern(pat), form)) :
               (r1:MResult) : false
               (r1:False) : MResult(List(), List, form)
         (pat:ListPat) :
            if (not empty?(form)) :
               val h = unwrap-token(head(form))
               if h is List :               
                  match(match-pat(pattern(pat), h)) :
                     (r1:MResult) :
                        if empty?(tail(r1)) :
                           MResult(bindings(r1), head(r1), tail(form))
                     (r1:False) :
                        false
         (pat:Repeat) :
            defn loop (form:List) -> MResult :                  
               match(match-pat(pattern(pat), form)) :
                  (r1:MResult) :
                     val r2 = loop(tail(r1))
                     val b* = append(bindings(r1), bindings(r2))
                     defn h* () : append(head(r1)(), head(r2)())
                     MResult(b*, h*, tail(r2))
                  (r1:False) :
                     MResult(List(), List, form)
            loop(form)
         (pat:Guard) :
            match(match-pat(pattern(pat), form)) :
               (r1:MResult) :
                  r1 when predicate(pat)(bindings(r1))               
               (r1:False) :
                  false
   ;Driver               
   match-pat(pat, form)


;============================================================
;==================== Exceptions ============================
;============================================================

public deftype PatternException <: Exception

defn PatternException (msg) :
   new PatternException :
      defmethod print (o:OutputStream, this) : print(o, msg)