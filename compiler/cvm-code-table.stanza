defpackage stz/cvm-code-table :
  import core
  import collections
  import stz/vm-ir
  import stz/code-table
  import stz/utils
  import stz/backend
  import stz/cvm-encoder
  import stz/vm-structures
  import stz/ptr-buffer
  import stz/branch-dag
  import stz/trie-table
  import stz/vm-ids

extern printf: (ptr<byte>, ? ...) -> int

;============================================================
;=================== Struct Definition ======================
;============================================================

public lostanza deftype CVMCodeTable <: CodeTable :
  bytecode:ref<Buffer>
  dag-tables:ref<PtrBuffer>

public lostanza defn CVMCodeTable () -> ref<CVMCodeTable> :
  return new CVMCodeTable{Buffer(), PtrBuffer(new Int{8})}

;============================================================
;================== Instruction Memory ======================
;============================================================

;Returns the address of the instructions in the code table.
lostanza defmethod instructions (t:ref<CVMCodeTable>) -> ref<Long> :
  return new Long{t.bytecode.mem as long}

;============================================================
;==================== Loading Functions =====================
;============================================================

defn maybe-print-rec (rec:CodeRec|False) :
  println(rec) when rec is-not False

lostanza defmethod load-function (table:ref<CVMCodeTable>,
                                  fid:ref<Int>,
                                  func:ref<VMFunction>,
                                  rec:ref<CodeRec|False>,
                                  externfn?:ref<True|False>,
                                  resolver:ref<EncodingResolver>,
                                  backend:ref<Backend>) -> ref<LoadedFunction> :
  ; call-c printf("--- LOAD-FUNCTION %d\n", fid.value)
  ; maybe-print-rec(rec)
  ;Encode the function using the CVM encoder.
  val encoded-function = encode(func, resolver, backend)

  ;Load the bytecode into the bytecode vector.
  val num-bytes = length(buffer(encoded-function))
  val offset = alloc(table.bytecode, num-bytes.value)
  call-c clib/memcpy(table.bytecode.mem + offset, data(buffer(encoded-function)), num-bytes.value)

  ;Add the offset to the trace entries so that we know their absolute position.
  val relocated-trace-entries = add-offset(trace-entries(encoded-function), new Long{offset})

  ;Return the new loaded function
  return LoadedFunction(new Long{offset}, relocated-trace-entries)

;Add 'offset' to the 'pc' of every entry in 'trace-entries' and return
;the result.
defn add-offset (trace-entries:Seqable<TraceTableEntry>, offset:Long) -> Vector<TraceTableEntry> :
  to-vector<TraceTableEntry> $ for e in trace-entries seq :
    TraceTableEntry(pc(e) + offset, entry(e))

;============================================================
;================== Branches/Dispatching ====================
;============================================================

;Encode and store the DAG  as Trie for performing the given DAG dispatch.
lostanza defmethod encode-branch-dag (t:ref<CVMCodeTable>,
                                      dag:ref<BranchDag>,
                                      resolver:ref<EncodingResolver>,
                                      backend:ref<Backend>) -> ref<False> :
  add(t.dag-tables, dag)
  return false

;Returns the address of the DAG table.
lostanza defmethod dag-table (t:ref<CVMCodeTable>) -> ref<Long> :
  return data-address(t.dag-tables)

;============================================================
;================== Launch ==================================
;============================================================

extern vmloop: (ptr<VMState>, long, long) -> int

lostanza defmethod launch (vmstate-address:ref<Long>, table:ref<CVMCodeTable>, func-id:ref<Int>) -> ref<False> :
  call-c printf("CVM LAUNCH\n")
  val vmstate = vmstate-address.value as ptr<VMState>
  call-c vmloop(vmstate, call-prim crsp() as long, func-id.value)
  return false