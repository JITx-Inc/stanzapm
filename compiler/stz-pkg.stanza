;See License.txt for details about licensing

defpackage stz/pkg :
  import core
  import collections
  import stz/asm-ir
  import stz/serializer

#use-added-syntax(stz-serializer-lang)

;============================================================
;=============== Variable Length Integer ====================
;============================================================

;Variable-Length Integer
;  0 <= x < 250 :             [x]
;  250 <= x < 506 :           [250 | x - 250]
;  506 <= x < 762 :           [251 | x - 506]
;  762 <= x < 1018 :          [252 | x - 762]
;  â€“32768 <= x < 32768 :      [253 | b1 , b0]
;  -8388608 <= x < 8388608 :  [254 | b2 , b1 , b0]
;  otherwise :                [255 | b3 , b2 , b1, b0]

defn to-var-int (x:Int, Y: Byte -> False) :
  defn B0 (x:Int) : Y(to-byte(x))
  defn B1 (x:Int) : Y(to-byte(x >> 8))
  defn B2 (x:Int) : Y(to-byte(x >> 16))
  defn B3 (x:Int) : Y(to-byte(x >> 24))    
  if x >= 0 :
    if x < 250 : B0(x)
    else if x < 506 : (Y(250Y), B0(x - 250))
    else if x < 762 : (Y(251Y), B0(x - 506))
    else if x < 1018 : (Y(252Y), B0(x - 762))
    else if x < 32768 : (Y(253Y), B1(x), B0(x))
    else if x < 8388608 : (Y(254Y), B2(x), B1(x), B0(x))
    else : (Y(255Y), B3(x), B2(x), B1(x), B0(x))
  else :
    if x >= -32768 : (Y(253Y), B1(x), B0(x))
    else if x >= -8388608 : (Y(254Y), B2(x), B1(x), B0(x))
    else : (Y(255Y), B3(x), B2(x), B1(x), B0(x))

defn from-var-int (N: () -> Byte) -> Int :
  defn B0 () : to-int(N())
  defn B1 () : B0() << 8
  defn B2 () : B0() << 16
  defn S1 () : (B0() << 24) >>> 16
  defn S2 () : (B0() << 24) >>> 8
  defn S3 () : (B0() << 24)
  
  val x = N()
  switch(x) :
    255Y : S3() | B2() | B1() | B0()
    254Y : S2() | B1() | B0()
    253Y : S1() | B0()
    252Y : B0() + 762
    251Y : B0() + 506
    250Y : B0() + 250
    else : to-int(x)

;============================================================
;=================== Serializer =============================
;============================================================

public defn serialize (filename:String, ins:Vector<Ins>) :
  val f = FileOutputStream(filename)
  try :
    put(f, length(ins))
    for e in ins do :
      serialize(f, e)
  finally :
    close(f)

public defn deserialize-instructions (filename:String) -> Vector<Ins> :
  val f = FileInputStream(filename)
  val n = get-int(f) as Int
  val ins = Vector<Ins>()
  for i in 0 to n do :
    add(ins, deserialize-ins(f))
  ins

defserializer (out:FileOutputStream, in:FileInputStream) :
  ;======================
  ;==== Instructions ====
  ;======================
  defunion ins (Ins) :
    ;Function instructions
    XchgIns: (x:loc, y:loc)
    SetIns: (type:type, x:loc, y:imm)
    ConvertIns: (xtype:type, x:loc, ytype:type, y:imm)
    InterpretIns: (xtype:type, x:loc, ytype:type, y:imm)
    UnaOp: (type:type, x:loc, op:op, y:imm)
    BinOp: (type:type, x:loc, op:op, y:imm, z:imm)
    DualOp: (type:type, x1:loc, x2:loc, op:op, y:imm, z:imm)
    Load: (type:type, x:loc, y:imm, offset:int)
    Store: (type:type, x:imm, y:imm, offset:int)
    Call: (x:imm)
    Return: ()
    Goto: (x:imm)
    Break: (type:type, x:imm, op:op, y:imm, z:imm)
    Label: (n:int)
    ExLabel: (name:symbol)
    ;Match: (xs:list(imm), branches:list(branch))
    ;Dispatch: (xs:list(imm), branches:list(branch))
    
    ;Data instructions
    DefData: ()
    DefText: ()
    DefByte: (value:byte)
    DefInt: (value:int)
    DefLong: (value:long)
    DefFloat: (value:float)
    DefDouble: (value:double)
    DefString: (value:string)
    DefSpace: (size:int)
    DefLabel: (n:int)

  ;====================
  ;==== Immediates ====
  ;====================
  defunion imm (Imm) :
    IntImm: (value:lit as Byte|Int|Long)
    TagImm: (n:int, marker?:bool)
    Mem: (n:int, offset:int)
    ExMem: (lbl:symbol, offset:int)
    RegSP: ()
    Reg: (n:int)
    FReg: (n:int)
    
  defatom loc (x:Loc) :
    writer :
      write-imm(x)
    reader :
      match(read-imm()) :
        (x:Loc) : x
        (x) : throw(DeserializeException())

  ;===============
  ;==== Types ====
  ;===============
  defunion type (Type) :
    ByteT: ()
    IntT: ()
    LongT: ()
    FloatT: ()
    DoubleT: ()

  ;==================
  ;==== Literals ====
  ;==================
  defatom lit (x:?) :
    writer :
      match(x) :
        (x:Byte) :
          write-byte(0Y)
          write-byte(x)
        (x:Int) :
          write-byte(1Y)
          write-int(x)
        (x:Long) :
          write-byte(2Y)
          write-long(x)          
    reader :
      switch(read-byte()) :
        0Y : read-byte()
        1Y : read-int()
        2Y : read-long()
        else : throw(DeserializeException())

  ;====================
  ;==== Operations ====
  ;====================
  defunion op (Op) :
    AddOp: ()
    SubOp: ()
    MulOp: ()
    DivOp: ()
    ModOp: ()
    AndOp: ()
    OrOp: ()
    XorOp: ()
    ShlOp: ()
    ShrOp: ()
    AshrOp: ()
    EqOp: ()
    NeOp: ()
    LtOp: ()
    GtOp: ()
    LeOp: ()
    GeOp: ()
    UleOp: ()
    UltOp: ()
    UgtOp: ()
    UgeOp: ()
    NotOp: ()
    NegOp: ()
    DivModOp: ()
    BitSetOp: ()
    BitNotSetOp: ()

  ;=====================
  ;==== Combinators ====
  ;=====================
  reader defn read-list<?T> (f: () -> ?T) :
    val n = read-int()
    to-list(repeatedly(f, n))

  writer defn write-list<?T> (f: T -> False, xs:List<?T>) :
    write-int(length(xs))
    do(f, xs)

  ;===============
  ;==== Atoms ====
  ;===============
  defatom bool (x:True|False) :
    writer :
      match(x) :
        (x:True) : put(out, 1Y)
        (x:False) : put(out, 0Y)
    reader :
      switch(get-byte(in)) :
        1Y : true
        0Y : false
        else : throw(DeserializeException())
    
  defatom int (x:Int) :
    writer :
      to-var-int(x, put{out, _})
    reader :
      from-var-int(read-byte)

  defatom long (x:Long) :
    writer :
      put(out, x)
    reader :
      match(get-long(in)) :
        (x:Long) : x
        (x:False) : throw(DeserializeException())

  defatom float (x:Float) :
    writer :
      put(out, x)
    reader :
      match(get-float(in)) :
        (x:Float) : x
        (x:False) : throw(DeserializeException())

  defatom double (x:Double) :
    writer :
      put(out, x)
    reader :
      match(get-double(in)) :
        (x:Double) : x
        (x:False) : throw(DeserializeException())

  defatom byte (x:Byte) :
    writer :
      put(out, x)
    reader :
      match(get-byte(in)) :
        (x:Byte) : x
        (x:False) : throw(DeserializeException())

  defatom char (x:Char) :
    writer :
      print(out, x)
    reader :
      match(get-char(in)) :
        (x:Char) : x
        (x:False) : throw(DeserializeException())

  defatom string (x:String) :
    writer :
      write-int(length(x))
      print(out, x)
    reader :
      val n = read-int()
      String(repeatedly(read-char, n))

  defatom symbol (x:Symbol) :
    writer :
      write-string(to-string(x))
    reader :
      to-symbol(read-string())




