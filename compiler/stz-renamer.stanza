;See License.txt for details about licensing.

defpackage stz/renamer :
   import core
   import collections
   import stz/il-ir
   import stz/namemap
   import stz/ids

;============================================================
;===================== Rename ===============================
;============================================================

public defn rename-il (ipackages:Tuple<IPackage>) -> Tuple<IPackage>|RenameErrors :
  ;Rename all packages
  val errors = Vector<DuplicateError>()
  val ipackages* = for ipackage in ipackages map :
    val eng = Engine(name(ipackage))
    val exps* = map(rename-exp{_, eng}, exps(ipackage))
    add-all(errors, /errors(eng))
    sub-namemap(sub-exps(ipackage, exps*), namemap(eng))

  ;Either return the renamed packages or the errors
  if empty?(errors) : ipackages*
  else : RenameErrors(errors)
   
;============================================================
;================== Specification ===========================
;============================================================

#use-added-syntax(stz-renamer-lang)
defrenamer rename-exp (e:IExp, eng:Engine) :
   e :
      ;Stanza
      IDefType: (class:c+, {args:t+}, children:e)
      IDefChild: ({args:t+})
      IDef: (name:v+, value:e)
      IDefVar: (name:mv+, value:e)
      IDefn: (name:f+, {targs:t+, args:v+, body:se})
      IDefmulti: (name:m+, {targs:t+})
      IDefmethod: ({targs:t+, args:v+, body:se})
      IFn: ({args:v+, body:se})
      IBranch: ({args:v+, body:se})
      IDo: (func:f, args:e)
      INew: (methods:e)
      ICast: (exp:e)
      IUpCast: (exp:e)
      ISet: (value:e)
      IPrim: (args:e)
      ILet: ({exp:se})
      LetRec: (group{defns:e}, body:e)
      IPublic: (public{exp:e})
      IProtected: (protected{exp:e})
      IAnnotate: (body:e)

      ;LoStanza
      ILSDef: (name:lv+, exp:e)
      ILSDefVar: (name:lmv+, exp:e)
      ILSDefType: (name:lc+, {args:t+, fields:fd+, rfield:fd+})
      ILSExtern: custom{
         match(type(e)) :
            (t:ILSFnT) : ILSExtern(rename-lf+(name(e)), t, info(e))
            (t) : ILSExtern(rename-lmv+(name(e)), t, info(e))}
      ILSDefn: (name:lf+, {targs:t+, args:lv+, body:e})
      ILSExternFn: (name:lf+, {args:lv+, body:e})
      ILSDefmethod: ({targs:t+, args:lv+, body:e})
      ILSLabels: ({blocks:e})
      ILSLabeledBlock: (name:lbl+, {args:lv+, body:e})
      ILSLet: ({comm:e})
      ILSIf: ({conseq:e}, {alt:e})
      ILSBranch: ({args:lv+, body:e})
      ILSDo: (func:f, args:e)
      ILSPrim: (args:e)
      ILSSizeof: ()
      ILSTagof: ()
      ILSFn: ()
      ILSAs: (exp:e)

      ;Fallthrough
      IExp: (_:e)

   se :
      IExp: custom{rename-e(flatten-se(e))}

   f :
      IOf: (class:e)
      ILSOfT: (class:e)
      IExp: custom{rename-e(e)}

   v+ :
      IVar : register var
      ITuple : (_:v+)
   mv+ :
      IVar : register mutable-var
   t+ :
      IVar : register tvar
      ICap : (name:cv+)
   cv+ :
      IVar : register capvar
   c+ :
      IVar : register class
   m+ :
      IVar : register multi
   f+ :
      IVar : register fn

   lv+ :
      IVar : register ls-var
   lmv+ :
      IVar : register ls-mutable-var
   lf+ :
      IVar : register ls-fn
   lc+ :
      IVar : register ls-class
   fd+ :
      IVar: register ls-field
      INone: ()
   lbl+ :
      IVar : register ls-label

;============================================================
;================= LetRec Grouping ==========================
;============================================================

defn begin-exps (e:IExp) -> List<IExp> :
  match(e) :
    (e:IBegin) : exps(e)
    (e) : List(e)

defn flatten-se (e:IExp) :
  defn loop (es:List<IExp>) -> IExp :
    if empty?(tail(es)) :
      head(es)
    else :
      match(head(es), loop(tail(es))) :
        (h:IDefn, t:LetRec) : LetRec(cons(h, defns(t)), body(t), info(h))
        (h:IDefn, t) : LetRec(List(h), t, info(h))
        (h:IDef|IDefVar, t) : Let(h, t, info(h))
        (h, t:IBegin) : Begin(cons(h, exps(t)), info(h))
        (h, t) : Begin(List(h, t), info(h))
  loop(begin-exps(e))

;============================================================
;=================== Renaming Engine ========================
;============================================================

deftype Engine
defmulti push-scope (e:Engine) -> False
defmulti pop-scope (e:Engine) -> False
defmulti push-group (e:Engine) -> False
defmulti pop-group (e:Engine) -> False
defmulti push-visibility (e:Engine, v:Vis) -> False
defmulti pop-visibility (e:Engine) -> False
defmulti register (v:IVar, eng:Engine, type:Symbol) -> IExp
defmulti namemap (eng:Engine) -> NameMap
defmulti errors (eng:Engine) -> Vector<DuplicateError>

defn Engine (package:Symbol) :
  val vardefs = MultilevelTable<Symbol,VEntry>()
  val tvardefs = MultilevelTable<Symbol,VEntry>()
  val classdefs = MultilevelTable<Symbol,VEntry>()
  val labeldefs = MultilevelTable<Symbol,VEntry>()
  val fielddefs = MultilevelTable<Symbol,VEntry>()
  val groupdefs = MultilevelStack<VEntry>()
  val scope-stack = Vector<Symbol>()
  val vis-stack = Vector<Vis>()
  val errors = Vector<DuplicateError>()
  val namemap = NameMap()

  ;Initialize top-level scope
  add(scope-stack, `group)
  add(vis-stack, Private())

  ;Add the given name to a multi-level table
  defn register (defs:MultilevelTable<Symbol,VEntry>, e:VEntry) :
    if key?(defs, name(e)) :
      already-defined(e, defs[name(e)])
    else :
      add(namemap, e)
      defs[name(e)] = e
  defn already-defined (e:VEntry, existing:VEntry) :
    add(errors, DuplicateError(e, existing))

  new Engine :
    defmethod namemap (this) :
      namemap
    defmethod errors (this) :
      errors
    defmethod push-scope (this) :
      push-level(vardefs)
      push-level(tvardefs)
      push-level(classdefs)
      push-level(labeldefs)
      push-level(fielddefs)
      add(scope-stack, `scope)
      add(vis-stack, Local())
    defmethod pop-scope (this) :
      pop-level(vardefs)
      pop-level(tvardefs)
      pop-level(classdefs)
      pop-level(labeldefs)
      pop-level(fielddefs)
      pop(scope-stack)
      pop(vis-stack)
      false
    defmethod push-group (this) :
      push-level(groupdefs)
      add(scope-stack, `group)
    defmethod pop-group (this) :
      for e in groupdefs peek-level :
        if key?(vardefs, name(e)) :
          already-defined(e, vardefs[name(e)])
      for e in groupdefs pop-level :
        if not key?(vardefs, name(e)) :
          vardefs[name(e)] = e
      pop(scope-stack)
      false
    defmethod push-visibility (this, v:Vis) :
      add(vis-stack, v)
    defmethod pop-visibility (this) :
      pop(vis-stack)
      false
    defmethod register (v:IVar, this, type:Symbol) :
      ;Create VEntry
      switch(type) :
        `var : add-scope(vardefs, ValE())
        `mutable-var : add-scope(vardefs, VarE())
        `tvar : add-scope(tvardefs, TVarE())
        `capvar : add-scope(tvardefs, CapVarE())
        `class : add-scope(classdefs, TypeE())
        `ls-var : add-scope(vardefs, LValE())
        `ls-mutable-var : add-scope(vardefs, LVarE())
        `ls-class : add-scope(classdefs, LTypeE())
        `ls-field : add-scope(fielddefs, FieldE())
        `ls-label : add-scope(labeldefs, LabelE())
        `multi : add-group(MultiE())
        `fn : add-group(FnE())
        `ls-fn : add-group(LFnE())
      where :
        defn make-ventry (etype:EType) :
          VEntry(fresh-id(), package, name(v), peek(vis-stack), etype, info(v))
        defn make-varn (e:VEntry) :
          VarN(n(e), info(v))
        defn add-scope (defs:MultilevelTable<Symbol,VEntry>, etype:EType) :
          val e = make-ventry(etype)
          register(defs, e)
          make-varn(e)          
        defn add-group (etype:EType) :
          val e = make-ventry(etype)
          switch(peek(scope-stack)) :
            `group : add(groupdefs, e)
            `scope : register(vardefs, e)          
          make-varn(e)

;============================================================
;==================== Utilities =============================
;============================================================

deftype MultilevelStack<T>
defmulti push-level (s:MultilevelStack) -> False
defmulti pop-level<?T> (return:T -> ?, s:MultilevelStack<?T>) -> False
defmulti peek-level<?T> (return:T -> ?, s:MultilevelStack<?T>) -> False
defmulti add<?T> (s:MultilevelStack<?T>, v:T) -> False

defn MultilevelStack<T> () :
  val items = Vector<T|Marker>()
  new MultilevelStack<T> :
    defmethod push-level (this) :
      add(items, Marker())
    defmethod pop-level (return:T -> ?, this) :
      let loop () :
        match(pop(items)) :
          (item:Marker) : false
          (item:T) : (return(item), loop())
    defmethod peek-level (return:T -> ?, this) :
      let loop (i:Int = length(items) - 1) :
        match(items[i]) :
          (item:Marker) : false
          (item:T) : (return(item), loop(i - 1))
    defmethod add (this, v:T) :
      add(items, v)
defstruct Marker

deftype MultilevelTable<K,V>
defmulti set<?K,?V> (table:MultilevelTable<?K,?V>, k:K, v:V) -> False
defmulti get<?K,?V> (table:MultilevelTable<?K,?V>, k:K) -> V
defmulti key?<?K> (table:MultilevelTable<?K,?>, k:K) -> True|False
defmulti push-level (table:MultilevelTable) -> False
defmulti pop-level (table:MultilevelTable) -> False

defn MultilevelTable<K,V> () :
  var level:Int = 0
  val table = HashTable<K,MTItem<V>>()
  val restore = MultilevelStack<KeyValue<K,MTItem<V>|False>>()
  new MultilevelTable<K,V> :
    defmethod set (this, k:K, v:V) :
      ;Record restoration
      match(get?(table,k)) :
        (e:MTItem<V>) : add(restore, k => e) when /level(e) < level
        (e:False) : add(restore, k => e)
      table[k] = MTItem<V>(level, v)
    defmethod get (this, k:K) :
      val e = table[k]
      fatal("Key %_ does not exist in table." % [k]) when /level(e) != level
      item(e)
    defmethod key? (this, k:K) :
      match(get?(table,k)) :
        (e:MTItem<V>) : /level(e) == level
        (_:False) : false
    defmethod push-level (this) :
      push-level(restore)
      level = level + 1
    defmethod pop-level (this) :
      within e = pop-level(restore) :
        val k = key(e)
        match(value(e)) :
          (v:MTItem<V>) : table[k] = v
          (v:False) : remove(table,k)
      level = level - 1

defstruct MTItem<V> :
  level: Int
  item: V

;============================================================
;======================= Errors =============================
;============================================================

public defstruct DuplicateError :
  entry: VEntry
  existing: VEntry

defmethod print (o:OutputStream, e:DuplicateError) :
  defn info? (e:VEntry) :
    match(info(e)) :
      (i:FileInfo) : i
      (_:False) : "package %~" % [package(e)]
  print(o, "%_: Duplicate definition of %~. Previous definition at %_." % [
    info?(entry(e)), name(entry(e)), info?(existing(e))])

public defstruct RenameErrors <: Exception :
  errors: Collection<DuplicateError>

defmethod print (o:OutputStream, e:RenameErrors) :
  print(o, "%n" % [errors(e)])

;============================================================
;================ ID Stabilization ==========================
;============================================================
;
;;Class name for field
;var CLASS-NAME: False|Symbol = false
;
;defn stabilize (e:VEntry) :
;  val n* =
;    if package(e) == `core :
;      match(type(e)) :
;        (t:LTypeE|TypeE) :
;          switch(name(e)) :
;            `Byte : BYTE-TYPE-ID
;            `Char : CHAR-TYPE-ID
;            `Int : INT-TYPE-ID
;            `Long : LONG-TYPE-ID
;            `Float : FLOAT-TYPE-ID
;            `Double : DOUBLE-TYPE-ID
;            `String : STRING-TYPE-ID
;            `CharArray : CHAR-ARRAY-TYPE-ID
;            `True : TRUE-TYPE-ID
;            `False : FALSE-TYPE-ID
;            `Tuple : TUPLE-TYPE-ID
;            `Fn : FN-TYPE-ID
;            `Stack : STACK-TYPE-ID
;            `Type : TYPE-TYPE-ID
;            `Box : BOX-TYPE-ID
;            `Symbol : SYMBOL-TYPE-ID
;            `List : LIST-TYPE-ID
;            `Array : ARRAY-TYPE-ID
;            else : false            
;        (t:LFnE) :
;          switch(name(e)) :
;            `extend-heap : EXTEND-HEAP-ID
;            `extend-stack : EXTEND-STACK-ID
;            `variable-uninitialized-error : VARIABLE-UNINITIALIZED-ERROR-ID
;            `tuple-length-error : TUPLE-LENGTH-ERROR-ID
;            `no-method-error : NO-METHOD-ERROR-ID
;            `amb-method-error : AMB-METHOD-ERROR-ID
;            `no-branch-error : NO-BRANCH-ERROR-ID
;            `amb-branch-error : AMB-BRANCH-ERROR-ID
;            `cast-error : CAST-ERROR-ID
;            `arity-error : ARITY-ERROR-ID
;            `void-tuple : VOID-TUPLE-ID
;            `make-string : MAKE-STRING-ID
;            `unreachable-error : UNREACHABLE-ERROR-ID
;            else : false
;        (t:FieldE) :
;          switch([CLASS-NAME, name(e)]) :
;            [`Byte `value] : BYTE-VALUE-FIELD-ID
;            [`Char `value] : CHAR-VALUE-FIELD-ID
;            [`Int `value] : INT-VALUE-FIELD-ID
;            [`Float `value] : FLOAT-VALUE-FIELD-ID
;            [`Box `item] : BOX-ITEM-FIELD-ID
;            [`Fn `code] : FN-CODE-FIELD-ID
;            [`Fn `free] : FN-FREE-FIELD-ID
;            [`Tuple `items] : TUPLE-ITEMS-FIELD-ID
;            [`RawArray `items] : RAWARRAY-ITEMS-FIELD-ID
;            [`CharArray `chars] : CHARARRAY-CHARS-FIELD-ID
;            [`String `chars] : STRING-CHARS-FIELD-ID
;            [`Type `free] : TYPE-FREE-FIELD-ID
;            [`Type `code] : TYPE-CODE-FIELD-ID
;            else : false
;        (t) :
;          false
;  match(n*, e) :
;    (n*:False, e) : e
;;    (n*:Int, e:DeclEntry) : DeclEntry(n*, package(e), decl(e))
;    (n*:Int, e:VEntry) : VEntry(n*, package(e), name(e), visibility(e), type(e), info(e))
;
;============================================================
;=================== Implementation =========================
;============================================================
;
;deftype Engine
;defmulti push-scope (e:Engine) -> False
;defmulti pop-scope (e:Engine) -> False
;defmulti push-group (e:Engine) -> False
;defmulti pop-group (e:Engine) -> False
;defmulti push-visibility (e:Engine, v:Vis) -> False
;defmulti pop-visibility (e:Engine) -> False
;defmulti register (v:IVar, eng:Engine, type:Symbol) -> IExp
;
;deftype Item
;defstruct Scope <: Item :
;   entries: Vector<Item>
;   top: True|False
;defstruct Group <: Item :
;   entries: Vector<Atom>
;defstruct Atom <: Item :
;   n: Int
;
;public defn rename (e:IExp) -> [NameMap List<LetPackage|ILoadPackage>] :
;   val packages = flatten-pe(e)
;   val namemap = NameMap()
;   val scopes = Vector<Scope>()
;
;   val renamed = for p in packages map :
;      val items = Vector<Scope|Group>()
;      add(items, Scope(Vector<Item>(), true))
;      val visibilities = Vector<Vis>()
;      add(visibilities, Private())
;            
;      match(p) :
;         ;(p:ILoadPackage) :
;         ;   val pkg* = rename(namemap, pkg(p))
;         ;   ILoadPackage(filename(p), pkg*, info(p))
;         (p:LetPackage) :
;            defn register-elem (vname:Symbol, type:EType, info:FileInfo|False) :
;               val e = stabilize $ VEntry(fresh-id(), name(p),
;                 vname, peek(visibilities), type, info)
;               register(namemap, e)
;               add(entries(peek(items)), Atom(n(e)))
;               n(e)             
;
;            val body* = rename-exp(body(p), eng) where :
;               val eng = new Engine :
;                  defmethod push-scope (this) :
;                     add(items, Scope(Vector<Item>(), false))
;                     push-visibility(this, Local())
;                  defmethod pop-scope (this) :
;                     pop-visibility(this)
;                     add(scopes, pop(items) as Scope)
;                  defmethod push-group (this) :
;                     add(items, Group(Vector<Atom>()))
;                  defmethod pop-group (this) :
;                     val g = pop(items)
;                     add(entries(peek(items)), g)
;                  defmethod push-visibility (this, vis:Vis) :
;                     add(visibilities, vis)
;                  defmethod pop-visibility (this) :
;                     pop(visibilities)
;                     false
;                  defmethod register (v:IVar, this, type:Symbol) -> IExp :
;                     val etype = switch {type == _} :
;                        `var : ValE()
;                        `mutable-var : VarE()
;                        `tvar : TVarE()
;                        `capvar : CapVarE()
;                        `class : TypeE()
;                        `multi : MultiE()
;                        `fn : FnE()
;                        `ls-var : LValE()
;                        `ls-mutable-var : LVarE()
;                        `ls-fn : LFnE()
;                        `ls-class : LTypeE()
;                        `ls-field : FieldE()
;                        `ls-label : LabelE()
;                     val n = register-elem(name(v), etype, info(v))
;                     VarN(n, info(v))
;
;            add(scopes, pop(items) as Scope)
;            LetPackage(name(p), imports(p), body*, info(p))
;
;   check-duplicates(packages)
;   check-duplicates(namemap, scopes)
;   [namemap, renamed]
;
;;============================================================
;;========== Check Duplicate Package Declarations ============
;;============================================================
;
;defn check-duplicates (ps:List<LetPackage|ILoadPackage>) :
;  ;Check whether package already included
;  val table = HashTable<Symbol,LetPackage|ILoadPackage>()
;  defn included? (p:LetPackage|ILoadPackage) :
;    if key?(table, name!(p)) :
;      true
;    else :
;      table[name!(p)] = p
;      false
;
;  ;Issue duplicate! error
;  val errors = Vector<?>()
;  defn duplicate! (e:LetPackage|ILoadPackage, other:LetPackage|ILoadPackage) :
;    val msg-a = match(e) :
;      (e:ILoadPackage) : "Duplicate load of package %_ from %_." % [name!(e), filename(e)]
;      (e:LetPackage) : "%_: Duplicate definition of package %_." % [info(e), name(e)]
;    val msg-b = match(other) :
;      (o:ILoadPackage) : "Already loaded from %_." % [filename(o)]
;      (o:LetPackage) : "Already defined at %_." % [info(o)]
;    add(errors, "%_ %_" % [msg-a, msg-b])
;
;  ;Check duplicates for all packages
;  for p in ps do :
;    if included?(p) :
;      duplicate!(p, table[name!(p)])
;
;  ;Issue any errors
;  if not empty?(errors) :
;    throw(RenameError(errors))
;
;;============================================================
;;========== Check Duplicate Definitions in Scope ============
;;============================================================
;
;defn check-duplicates (namemap:NameMap, scopes: Vector<Scope>) :
;   defn name! (i:Int) : name(namemap[i])
;   defn type! (i:Int) : type(namemap[i])
;
;   val errors = Vector<?>()
;   defn duplicate! (e:Atom, es:List<Int>) :
;      defn info? (i:Int) :
;        match(info(namemap[i])) :
;          (info:FileInfo) : info
;          (info:False) : "package %~" % [package(namemap[i])]
;      val infos = for ei in es seq :
;         "\n   %_ as %~" % [info?(ei), name!(ei)]
;      val msg = "%_: Duplicate definition of %_. Also defined at: %*" %
;         [info?(n(e)), name!(n(e)), infos]
;      add(errors, msg)
;
;   ;Mapping for each type of definition into a map containing all the definitions
;   val elems = Array<HashTable<Symbol,List<Int>>>(4)
;   for i in 0 to length(elems) do :
;      elems[i] = HashTable<Symbol,List<Int>>()
;
;   defn clear-elems () :
;      for i in 0 to length(elems) do :
;         clear(elems[i])
;   defn ensure-no-duplicates (e:Atom, g:Int) :
;      val name = name!(n(e))
;      if key?(elems[g], name) :
;         duplicate!(e, to-list(elems[g][name]))
;   defn add-elem (e:Atom, g:Int) :
;      val name = name!(n(e))
;      elems[g][name] = cons(n(e), get?(elems[g], name, List()))
;
;   defn check-top-scope (s:Scope) :
;      clear-elems()
;
;      ;Element Types
;      val variables = 0
;      val functions = 1
;      val types = 2
;
;      for e in entries(s) as Vector<Atom> do :
;         match(type!(n(e))) :
;            ;Variables
;            (t:ValE|VarE|LValE|LVarE) :
;               ensure-no-duplicates(e, variables)
;               ensure-no-duplicates(e, functions)
;               add-elem(e, variables)
;            ;Functions
;            (t:FnE|MultiE|LFnE) :
;               ensure-no-duplicates(e, variables)
;               add-elem(e, functions)
;            ;Types
;            (t:TypeE|LTypeE) :
;               ensure-no-duplicates(e, types)
;               add-elem(e, types)
;
;   defn check-local-scope (s:Scope) :
;      clear-elems()
;
;      ;Element Types
;      defn type-id (e:Atom) :
;         match(type!(n(e))) :
;            (t:ValE|VarE|FnE|LValE|LVarE) : 0
;            (t:TVarE|CapVarE) : 1
;            (t:LabelE) : 2
;            (t:FieldE) : 3
;      defn ensure-no-dups (e:Atom) :
;         ensure-no-duplicates(e, type-id(e))
;      defn add (e:Atom) :
;         add-elem(e, type-id(e))
;      for e in entries(s) do :
;         match(e) :
;            (e:Atom) :
;               ensure-no-dups(e)
;               add(e)
;            (e:Group) :
;               do(ensure-no-dups, entries(e))
;               do(add, entries(e))
;
;   for s in scopes do :
;      if top(s) : check-top-scope(s)
;      else : check-local-scope(s)
;   if not empty?(errors) :
;      throw(RenameError(errors))
;
;;============================================================
;;===================== Errors ===============================
;;============================================================
;
;defstruct RenameError <: Exception :
;   msgs: Seqable
;
;defmethod print (o:OutputStream, e:RenameError) :
;   print-all(o, join(msgs(e), "\n"))
