;See License.txt for details about licensing.

defpackage stz/renamer :
   import core
   import collections
   import stz/il-ir
   import stz/namemap
   import stz/ids

;============================================================
;===================== Rename ===============================
;============================================================

public defn rename-il (ipackages:Tuple<IPackage>) -> Tuple<IPackage>|RenameErrors :
  ;Rename all packages
  val errors = Vector<DuplicateError>()
  val ipackages* = for ipackage in ipackages map :
    val eng = Engine(name(ipackage))
    val exps* = map(rename-exp{_, eng}, exps(ipackage))
    add-all(errors, /errors(eng))
    sub-namemap(sub-exps(ipackage, exps*), namemap(eng))

  ;Either return the renamed packages or the errors
  if empty?(errors) : ipackages*
  else : RenameErrors(errors)
   
;============================================================
;================== Specification ===========================
;============================================================

#use-added-syntax(stz-renamer-lang)
defrenamer rename-exp (e:IExp, eng:Engine) :
  e :
    ;Stanza
    IDefType: (class:c+, {args:t+}, children:e)
    IDefChild: ({args:t+})
    IDef: (name:v+, value:e)
    IDefVar: (name:mv+, value:e)
    IDefn: (name:f+, {targs:t+, args:v+, body:se})
    IDefmulti: (name:m+, {targs:t+})
    IDefmethod: ({targs:t+, args:v+, body:se})
    IFn: ({args:v+, body:se})
    IBranch: ({args:v+, body:se})
    IDo: (func:f, args:e)
    INew: (methods:e)
    ICast: (exp:e)
    IUpCast: (exp:e)
    ISet: (value:e)
    IPrim: (args:e)
    ILet: ({exp:se})
    LetRec: (group{defns:e}, body:e)
    IPublic: (public{exp:e})
    IProtected: (protected{exp:e})
    IAnnotate: (body:e)

    ;LoStanza
    ILSDef: (name:lv+, exp:e)
    ILSDefVar: (name:lmv+, exp:e)
    ILSDefType: (name:lc+, {args:t+, fields:fd+, rfield:fd+})
    ILSExtern: custom{
      match(type(e)) :
        (t:ILSFnT) : ILSExtern(rename-lf+(name(e)), t, info(e))
        (t) : ILSExtern(rename-lmv+(name(e)), t, info(e))}
    ILSDefn: (name:lf+, {targs:t+, args:lv+, body:e})
    ILSExternFn: (name:lf+, {args:lv+, body:e})
    ILSDefmethod: ({targs:t+, args:lv+, body:e})
    ILSLabels: ({blocks:e})
    ILSLabeledBlock: (name:lbl+, {args:lv+, body:e})
    ILSLet: ({comm:e})
    ILSIf: ({conseq:e}, {alt:e})
    ILSBranch: ({args:lv+, body:e})
    ILSDo: (func:f, args:e)
    ILSPrim: (args:e)
    ILSSizeof: ()
    ILSTagof: ()
    ILSFn: ()
    ILSAs: (exp:e)

    ;Fallthrough
    IExp: (_:e)

  se :
    IExp: custom{rename-e(flatten-se(e))}

  f :
    IOf: (class:e)
    ILSOfT: (class:e)
    IExp: custom{rename-e(e)}

  v+ :
    IVar : register var
    ITuple : (_:v+)
  mv+ :
    IVar : register mutable-var
  t+ :
    IVar : register tvar
    ICap : (name:cv+)
  cv+ :
    IVar : register capvar
  c+ :
    IVar : register class
  m+ :
    IVar : register multi
  f+ :
    IVar : register fn

  lv+ :
    IVar : register ls-var
  lmv+ :
    IVar : register ls-mutable-var
  lf+ :
    IVar : register ls-fn
  lc+ :
    IVar : register ls-class
  fd+ :
    IVar: register ls-field
    INone: ()
  lbl+ :
    IVar : register ls-label

;============================================================
;================= LetRec Grouping ==========================
;============================================================

defn begin-exps (e:IExp) -> List<IExp> :
  match(e) :
    (e:IBegin) : exps(e)
    (e) : List(e)

defn flatten-se (e:IExp) :
  defn loop (es:List<IExp>) -> IExp :
    if empty?(tail(es)) :
      head(es)
    else :
      match(head(es), loop(tail(es))) :
        (h:IDefn, t:LetRec) : LetRec(cons(h, defns(t)), body(t), info(h))
        (h:IDefn, t) : LetRec(List(h), t, info(h))
        (h:IDef|IDefVar, t) : Let(h, t, info(h))
        (h, t:IBegin) : Begin(cons(h, exps(t)), info(h))
        (h, t) : Begin(List(h, t), info(h))
  loop(begin-exps(e))

;============================================================
;=================== Renaming Engine ========================
;============================================================

deftype Engine
defmulti push-scope (e:Engine) -> False
defmulti pop-scope (e:Engine) -> False
defmulti push-group (e:Engine) -> False
defmulti pop-group (e:Engine) -> False
defmulti push-visibility (e:Engine, v:Vis) -> False
defmulti pop-visibility (e:Engine) -> False
defmulti register (v:IVar, eng:Engine, type:Symbol) -> IExp
defmulti namemap (eng:Engine) -> NameMap
defmulti errors (eng:Engine) -> Vector<DuplicateError>

defn Engine (package:Symbol) :
  val vardefs = MultilevelTable<Symbol,VEntry>()
  val tvardefs = MultilevelTable<Symbol,VEntry>()
  val classdefs = MultilevelTable<Symbol,VEntry>()
  val labeldefs = MultilevelTable<Symbol,VEntry>()
  val fielddefs = MultilevelTable<Symbol,VEntry>()
  val groupdefs = MultilevelStack<VEntry>()
  val scope-stack = Vector<Symbol>()
  val vis-stack = Vector<Vis>()
  val errors = Vector<DuplicateError>()
  val namemap = NameMap()

  ;Initialize top-level scope
  add(scope-stack, `group)
  add(vis-stack, Private())

  ;Add the given name to a multi-level table
  defn register (defs:MultilevelTable<Symbol,VEntry>, e:VEntry) :
    if key?(defs, name(e)) :
      already-defined(e, defs[name(e)])
    else :
      add(namemap, e)
      defs[name(e)] = e
  defn already-defined (e:VEntry, existing:VEntry) :
    add(errors, DuplicateError(e, existing))

  new Engine :
    defmethod namemap (this) :
      namemap
    defmethod errors (this) :
      errors
    defmethod push-scope (this) :
      push-level(vardefs)
      push-level(tvardefs)
      push-level(classdefs)
      push-level(labeldefs)
      push-level(fielddefs)
      add(scope-stack, `scope)
      add(vis-stack, Local())
    defmethod pop-scope (this) :
      pop-level(vardefs)
      pop-level(tvardefs)
      pop-level(classdefs)
      pop-level(labeldefs)
      pop-level(fielddefs)
      pop(scope-stack)
      pop(vis-stack)
      false
    defmethod push-group (this) :
      push-level(groupdefs)
      add(scope-stack, `group)
    defmethod pop-group (this) :
      for e in groupdefs peek-level :
        if key?(vardefs, name(e)) :
          already-defined(e, vardefs[name(e)])
      for e in groupdefs pop-level :
        if not key?(vardefs, name(e)) :
          vardefs[name(e)] = e
      pop(scope-stack)
      false
    defmethod push-visibility (this, v:Vis) :
      add(vis-stack, v)
    defmethod pop-visibility (this) :
      pop(vis-stack)
      false
    defmethod register (v:IVar, this, type:Symbol) :
      ;Create VEntry
      switch(type) :
        `var : add-scope(vardefs, ValE())
        `mutable-var : add-scope(vardefs, VarE())
        `tvar : add-scope(tvardefs, TVarE())
        `capvar : add-scope(tvardefs, CapVarE())
        `class : add-scope(classdefs, TypeE())
        `ls-var : add-scope(vardefs, LValE())
        `ls-mutable-var : add-scope(vardefs, LVarE())
        `ls-class : add-scope(classdefs, LTypeE())
        `ls-field : add-scope(fielddefs, FieldE())
        `ls-label : add-scope(labeldefs, LabelE())
        `multi : add-group(MultiE())
        `fn : add-group(FnE())
        `ls-fn : add-group(LFnE())
      where :
        defn make-ventry (etype:EType) :
          VEntry(fresh-id(), package, name(v), peek(vis-stack), etype, info(v))
        defn make-varn (e:VEntry) :
          VarN(n(e), info(v))
        defn add-scope (defs:MultilevelTable<Symbol,VEntry>, etype:EType) :
          val e = make-ventry(etype)
          register(defs, e)
          make-varn(e)          
        defn add-group (etype:EType) :
          val e = make-ventry(etype)
          switch(peek(scope-stack)) :
            `group : add(groupdefs, e)
            `scope : register(vardefs, e)          
          make-varn(e)

;============================================================
;==================== Utilities =============================
;============================================================

deftype MultilevelStack<T>
defmulti push-level (s:MultilevelStack) -> False
defmulti pop-level<?T> (return:T -> ?, s:MultilevelStack<?T>) -> False
defmulti peek-level<?T> (return:T -> ?, s:MultilevelStack<?T>) -> False
defmulti add<?T> (s:MultilevelStack<?T>, v:T) -> False

defn MultilevelStack<T> () :
  val items = Vector<T|Marker>()
  new MultilevelStack<T> :
    defmethod push-level (this) :
      add(items, Marker())
    defmethod pop-level (return:T -> ?, this) :
      let loop () :
        match(pop(items)) :
          (item:Marker) : false
          (item:T) : (return(item), loop())
    defmethod peek-level (return:T -> ?, this) :
      let loop (i:Int = length(items) - 1) :
        match(items[i]) :
          (item:Marker) : false
          (item:T) : (return(item), loop(i - 1))
    defmethod add (this, v:T) :
      add(items, v)
defstruct Marker

deftype MultilevelTable<K,V>
defmulti set<?K,?V> (table:MultilevelTable<?K,?V>, k:K, v:V) -> False
defmulti get<?K,?V> (table:MultilevelTable<?K,?V>, k:K) -> V
defmulti key?<?K> (table:MultilevelTable<?K,?>, k:K) -> True|False
defmulti push-level (table:MultilevelTable) -> False
defmulti pop-level (table:MultilevelTable) -> False

defn MultilevelTable<K,V> () :
  var level:Int = 0
  val table = HashTable<K,MTItem<V>>()
  val restore = MultilevelStack<KeyValue<K,MTItem<V>|False>>()
  new MultilevelTable<K,V> :
    defmethod set (this, k:K, v:V) :
      ;Record restoration
      match(get?(table,k)) :
        (e:MTItem<V>) : add(restore, k => e) when /level(e) < level
        (e:False) : add(restore, k => e)
      table[k] = MTItem<V>(level, v)
    defmethod get (this, k:K) :
      val e = table[k]
      fatal("Key %_ does not exist in table." % [k]) when /level(e) != level
      item(e)
    defmethod key? (this, k:K) :
      match(get?(table,k)) :
        (e:MTItem<V>) : /level(e) == level
        (_:False) : false
    defmethod push-level (this) :
      push-level(restore)
      level = level + 1
    defmethod pop-level (this) :
      within e = pop-level(restore) :
        val k = key(e)
        match(value(e)) :
          (v:MTItem<V>) : table[k] = v
          (v:False) : remove(table,k)
      level = level - 1

defstruct MTItem<V> :
  level: Int
  item: V

;============================================================
;======================= Errors =============================
;============================================================

public defstruct DuplicateError :
  entry: VEntry
  existing: VEntry

defmethod print (o:OutputStream, e:DuplicateError) :
  defn info? (e:VEntry) :
    match(info(e)) :
      (i:FileInfo) : i
      (_:False) : "package %~" % [package(e)]
  print(o, "%_: Duplicate definition of %~. Previous definition at %_." % [
    info?(entry(e)), name(entry(e)), info?(existing(e))])

public defstruct RenameErrors <: Exception :
  errors: Collection<DuplicateError>

defmethod print (o:OutputStream, e:RenameErrors) :
  print(o, "%n" % [errors(e)])