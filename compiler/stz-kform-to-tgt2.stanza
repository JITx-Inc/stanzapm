defpackage stz/kform-to-tgt :
  import core
  import collections
  import stz/kl-ir
  import stz/pl-ir
  import stz/tgt-ir
  import stz/tgt-utils
  import stz/tl-ir with :
    prefix(CExp, CLSExp) => TL
  import stz/ids
  import stz/khier
  import stz/primitives
  import stz/utils
  import stz/dec-table

;<STRUCTURE>
=============================================================
=================== Declaration Table =======================
=============================================================

==== Entry Types ====
FnEntry
VarEntry
ClosureEntry
ObjectEntry
TypeEntry
StructEntry
FieldEntry
MultifnEntry

==== Desired Queries ====
defn tgt-types (t:DecTable, n:Int) -> List<TGType>
defn tgt-types (t:DecTable, t:KType) -> List<TGType>
  Returns the list of TGTypes corresponding to a type, or identifier
  of a struct. Used by expression compilation, for example to get
  types of corresponding to val declaration.

defn extern-label (t:DecTable, n:Int) -> Symbol|False
  Returns the external label, if there is one, of the given function
  or variable. Used during compilation for extern functions and
  variables.

defn size (t:DecTable, n:Int) -> Int
defn size (t:DecTable, t:KType) -> Int
  Returns the size of the given type.

defn alignment (t:DecTable, n:Int) -> Int
defn alignment (dt:DecTable, t:KType) -> Int
  Returns the alignment of the given type. Used for compilation of
  globals.

public defn name (t:DecTable, n:Int) -> String
  Returns the name of the given type. Used for compiling type
  printers.

defn field-offsets (t:DecTable, n:Int) -> List<Int>
defn field-offsets (t:DecTable, t:KType) -> List<Int>
  Returns the offsets of all subelements within the given type. Used
  for, example, loading the fields of a global struct variable at the
  proper offsets.

defn field-type (t:DecTable, n:Int) -> KType
  Retrieves the type of the field with the given id. Used for
  retrieving the type of a KField expression.

defn field-index (t:DecTable, n:Int) -> Int
  Retrieves the index of the first subelement of the given field. Used
  for, example, retrieving the subelements corresponding to a field
  within a struct.

defn field-offset (t:DecTable, n:Int) -> Int
  Retrieves the offset of the first subelement of the given field.
  Used for loading the subelements corresponding to a field within a
  struct.

defn field-size (t:DecTable, n:Int) -> Int
  Retrieves the size of the field n. Used for computing field offsets.

defn rest-size (t:DecTable, n:Int) -> Int
  Retrieves the size of the rest field in the given struct. The struct
  must have a rest field.

defn field+rest-offsets (t:DecTable, n:Int) -> Seqable<Int>
  Retrieves a sequence containing all offsets of all subelements in
  the struct. If the struct has a rest field, then the offsets may be
  infinite.

defn length (t:DecTable, n:Int) -> Int
defn length (dt:DecTable, t:KLSType) -> Int
  Returns the number of subelements within the given type. Used for,
  example, retrieving the appropriate elements in a field expression.

defn closure? (t:DecTable, n:Int) -> True|False
defn closure-code (t:DecTable, n:Int) -> Int
  Returns whether the given id refers to a closure object. If it does,
  closure-code returns the id of its code.

defn object-tarity (t:DecTable, n:Int) -> Int
  Returns the tarity of the object corresponding to the given id. Used
  for compiling KObjectGet and KObjectTGet expressions.

=============================================================
=================== Expression Compilation ==================
=============================================================

==== Allocation Utilities ====
defn calloc (fields:List<TGImm|CExp>, info:False|FileInfo)
  Word sized allocation
defn calloc (#size:Int, offsets:List<Int>, fields:List<TGImm|CExp>, info:False|FileInfo)
  Explicit offsets allocation
defn carray (size:Int, rest-size:Int, offsets:Seqable<Int>, fields:List<TGImm|CLSExp>, info:False|FileInfo)
  Array allocation
defn ctuple (args:List<CExp|TGImm>, info:False|FileInfo)
  Tuple allocation

==== Context ====
val imm-table:IntTable<List<TGImm>>
  Stores the list of immediates corresponding to every binder.
val type-table:IntTable<List<TGType>>
  Stores the list of types corresponding to every binder.
val block-arg-table:IntTable<List<List<Int>>>
  Stores the name of the arguments for labeled blocks.
var use-tail-calls?:True|False
  Set to true when compiling TCO functions.
<STRUCTURE>

;============================================================
;======================== Driver ============================
;============================================================

public defn to-tgpackage (dec-table:DecTable, pkg:KPackage) :
  ;Accumulated declarations
  val decls = Vector<TGDecl>()
  defn emit (d:TGDecl) : add(decls, d)
  
  ;Compile all declarations
  for e in exps(pkg) do :
    match(e) :
      (e:KDef) : 
        emit(compile-global(dec-table, n(e), type(e)))
      (e:KDefVar) : 
        emit(compile-global(dec-table, n(e), type(e)))
      (e:KDefn) : 
        emit $ compile-function(
          Compiler(dec-table), n(e), false, List(), List(),
          value(e) as KFn|KMultifn, false, true)
      (e:KDefmulti) :  
        val tarity = length(targs(e))
        val arity = length(a1(e))
        emit(TGDefmulti(n(e), tarity, arity, info(e)))
      (e:KDefmethod) :
        ;Code
        val v = value(e) as KFn
        emit $ compile-function(
          Compiler(dec-table), n(e), false, List(), List(),
          v, false, false)
        ;Method
        emit(TGDefmethod(multi(e), map(erase-tvars,a1(v)), n(e)))
      (e:KDefType) :
        false
      (e:KDefStruct) : 
        emit(compile-struct(dec-table, e))
      (e:KExternFn) :
        emit $ compile-function(
          Compiler(dec-table), lbl(e), false, List(), List(),
          value(e) as KFn, true, false)
      (e:KExtern) :
        false
      (e:KInit) :
        false
      (e:KDefConst) : 
        emit(compile-const(e))        
      (e:KDefObject) : 
        emit(compile-object(e))
      (e:KDefClosure) :
        emit $ compile-function(
          Compiler(dec-table), n(e), closure(e), freetypes(e), freevars(e),
          func(e) as KFn|KMultifn, false, true)
      (e:KDefTypeObject) :
        emit $ compile-type-obj(Compiler(dec-table), n(e), args(e), type(e))

  ;Compile main function
  val main = compile-main(exps(pkg))
  emit(main)
  
  ;Return package
  TGPackage(name(pkg), ids(pkg), n(main), decls, false)  

;============================================================
;================= Compilation Utilities ====================
;============================================================

defn compile-global (dt:DecTable, n:Int, type:KType) :
  TGDefGlobal(
    n
    size(dt, type)
    alignment(dt, type)
    tgt-types(dt, type)
    field-offsets(dt, type))

defn compile-struct (dt:DecTable, e:KDefStruct) :
  val [rsize, rtypes, roffsets] = match(rfield(e)) :
    (rf:KStructField) :
      val rft = type(rf)
      [size(dt, rft), tgt-types(dt, rft), field-offsets(dt, rft)]
    (rf:False) :
      [0, List(), List()]    
  TGDefObject(n(e), name(e), parent(e), size(dt, n(e)), tgt-types(dt, n(e))
    field-offsets(dt, n(e)), rsize, rtypes, roffsets)

defn compile-object (e:KDefObject) :
  val len = tarity(e) + arity(e)
  TGDefObject(n(e), name(e), parent(e),
    8 * len,
    map(TGRefT{}, 0 to len),
    to-list(0 to 8 * len by 8)
    0, List(), List())

defn compile-const (e:KDefConst) :
  val v* = match(value(e)) :
    (v:KTypeObject) :
      fatal("Non-empty type object.") when not empty?(targs(v))
      TGTypeObject(n(v))      
    (v:KClosure) :
      fatal("Non-empty closure.") when not empty?(args(v))
      TGClosure(n(v))
    (v) : v
  TGDefConst(n(e), v*)

;============================================================
;================= Expression Compilation ===================
;============================================================

;=======================
;===== Convenience =====
;=======================

;Convenience functions
defn imm (c:CExp) :
  val xs = imms(c)
  fatal("Not a single immediate.") when length(xs) != 1
  head(xs)

defn imm? (c:TGImm|CExp) :
  match(c) :
    (c:TGImm) : c
    (c:CExp) : imm(c)

defn imms? (c:TGImm|CExp) :
  match(c) :
    (c:TGImm) : List(c)
    (c:CExp) : imms(c)

defn set (n:Int, c:CExp) :
  set(List(n), c)

;======================================
;===== Compiled Expression System =====
;======================================
;Minimum implementation: set, ignore, types
;Custom return behaviour: implement return

deftype CExp
defmulti set (ns:List<Int>, c:CExp) -> False
defmulti ignore (c:CExp) -> False
defmulti types (c:CExp) -> List<TGType>
defmulti return (c:CExp) -> False
defmulti imms (c:CExp) -> List<TGImm>

;Default implementation of imms defined in terms of set
defmethod imms (c:CExp) :
  val ts = types(c)
  val ns = map(fresh-id{}, ts)
  do(emit{TGDef(_, _)}, ns, ts)
  set(ns, c)
  map(TGVar, ns)

;Default implementation of return in terms of imms
var EXTERN-CTXT? = false
defmethod return (c:CExp) :
  if EXTERN-CTXT? : emit(TGReturnC(imms(c)))
  else : emit(TGReturn(imms(c)))

;======================
;===== Immediates =====
;======================
;Minimum implementation: imms, types
deftype CImm <: CExp

defmethod set (ns:List<Int>, c:CImm) :
  for (n in ns, x in imms(c)) do :
    emit(TGSet(TGVar(n), x))

defmethod ignore (c:CImm) :
  imms(c)
  false

;======================
;===== Ignorables =====
;======================
;Implements: ignore

deftype Ignorable
defmethod ignore (c:CExp&Ignorable) : false
defmethod ignore (c:CImm&Ignorable) : false

;===========================================
;===== Compiled Body Expression System =====
;===========================================
;Minimum implementation: body, compile

deftype CBody <: CExp
defmulti body (c:CBody) -> CExp
defmulti compile (c:CBody) -> False

defmethod set (ns:List<Int>, c:CBody) :
  compile(c)
  set(ns, body(c))
defmethod ignore (c:CBody) :
  compile(c)
  ignore(body(c))
defmethod return (c:CBody) :
  compile(c)
  return(body(c))
defmethod types (c:CBody) :
  types(body(c))
defmethod imms (c:CBody) :
  compile(c)
  imms(body(c))

;=============================================
;===== Compiled Bodies Expression System =====
;=============================================
;Minimum implementation: compile, types

deftype CBodies <: CExp
defmulti compile (c:CBodies, kont: CExp -> False, end?:True|False) -> False

defmethod set (ns:List<Int>, c:CBodies) : compile(c, set{ns, _}, false)
defmethod ignore (c:CBodies) : compile(c, ignore, false)
defmethod return (c:CBodies) : compile(c, return, true)

;====================================
;===== Compiled Location System =====
;====================================
deftype CLoc
defstruct PtrLoc <: CLoc :
  base: CExp
  offset: Int
defstruct VarLoc <: CLoc :
  n: Int
  index: Int
defstruct ExpLoc <: CLoc :
  base: CExp
  index: Int

;====================
;===== Compiler =====
;====================

deftype Compiler
defmulti compile-function (c:Compiler, lbl:Int|Symbol,
                           closure:False|Int, freetypes:List<Int>, freevars:List<Int>,
                           f:KFn|KMultifn, extern?:True|False, check-arity?:True|False) -> TGDefCode
defmulti compile-type-obj (c:Compiler, lbl:Int, args:List<Int>, type:KType) -> TGDefCode
defmulti compile-main (c:Compiler, exps:List<KTExp>) -> TGDefCode

defn Compiler (dec-table:DecTable) :
  ;Context
  val imm-table = IntTable<List<TGImm>>()
  val type-table = IntTable<List<TGType>>()
  val block-arg-table = IntTable<List<List<Int>>>()
  var use-tail-calls? = false

  ;Commonly used quantities
  val false-marker = TGLong(bit-representation(false))

  ;Utilities
  ;Allocate a structure to store a list of word quantities.
  defn calloc (fields:List<TGImm|CExp>, info:False|FileInfo) :
    val n = length(fields)
    calloc(8 * n, to-list(0 to 8 * n by 8), fields, info)

  ;Allocate a structure to store fields with given total size and offsets.
  defn calloc (#size:Int, offsets:List<Int>, fields:List<TGImm|CExp>, info:False|FileInfo) :
    new CExp :
      defmethod types (this) :
        List(TGRefT())
      defmethod set (ns:List<Int>, this) :
        fatal("Not a single immediate.") when length(ns) != 1
        val n = head(ns)
        val fs = seq-append(imms?,fields)
        val size = ceil8(#size)
        allocate-ref(n, size, info)
        for (f in fs, o in offsets) do :
          emit(TGStore(TGVar(n), f, o - REF-TAG-BITS))
      defmethod ignore (this) :
        do(ignore, filter-by<CExp>(fields))

  ;Allocate an array to store fields with given size and offsets.
  ;Tag of the array must be in fields[0]. Length must be fields[1].
  defn carray (size:Int, rest-size:Int, offsets:Seqable<Int>, fields:List<TGImm|CExp>, info:False|FileInfo) :
    new CExp :
      defmethod types (this) :
        List(TGRefT())
      defmethod set (ns:List<Int>, this) :
        fatal("Not a single immediate.") when length(ns) != 1
        val n = head(ns)
        ;Evaluate fields
        val fs = seq-append(imms?,fields)
        ;Compute length
        val len = make-var(TGLongT())
        emit(TGBinOp(len, TGMulOp(), fs[1], TGLong(to-long(rest-size))))
        emit(TGBinOp(len, TGAddOp(), len, TGLong(to-long(size + 7))))
        emit(TGBinOp(len, TGAndOp(), len, TGLong(-8L)))
        ;Allocate array
        allocate-ref(n, len, info)
        ;Store fields
        for (f in fs, o in offsets) do :
          emit(TGStore(TGVar(n), f, o - REF-TAG-BITS))
      defmethod ignore (this) :
        do(ignore, filter-by<CExp>(fields))

  ;Allocate a tuple
  defn ctuple (args:List<CExp|TGImm>, info:False|FileInfo) :
    val len = length(args)
    calloc{_, info} $ cons(
      TGTag(TUPLE-TYPE-ID)
      TGLong(to-long(len))
      args)

  ;Get the offset of a field
  defn foffset (n:Int) :
    field-offset(dec-table, n) + 8 - REF-TAG-BITS


  ;==================================
  ;===== Expression Compilation =====
  ;==================================
  defn cexp (e:KExp) -> CExp :
    match(e) :
      (e:KLet) :
        val cbody = cexp(body(e))
        new CBody :
          defmethod body (this) : cbody
          defmethod compile (this) :
            val v = cexp(value(e))
            val ts = types(v)
            imm-table[n(e)] = imms(v)
            type-table[n(e)] = ts
      (e:KLetVar) :
        val cbody = cexp(body(e))
        new CBody :
          defmethod body (this) : cbody
          defmethod compile (this) :
            val ts = tgt-types(dec-table, type(e))
            val xs = map(make-var, ts)
            imm-table[n(e)] = xs
            type-table[n(e)] = ts
            attempt: set(map(n,xs), cexp(value(e) as? KExp))
      (e:KLetRec) :
        val cbody = cexp(body(e))
        new CBody :
          defmethod body (this) : cbody
          defmethod compile (this) :
            ;Allocate closures
            val cs = for n in ns(e) map :
              val c = make-var(TGRefT())
              imm-table[n] = List(c)
              type-table[n] = List(TGRefT())
              c
            ;Compile all arguments to closures
            val argss = for c in values(e) as List<KClosure> map :
              qquote(
                ~ (TGTag(FN-TYPE-ID))
                ~ (TGLong(to-long(length(targs(c)) + length(args(c)))))
                ~ (TGMem(n(c), 0))
                ~@ (map(imm{ctype(_)}, targs(c)))
                ~@ (map(imm{cexp(_)}, args(c))))
            val sizes = map({8 * length(_)}, argss)
            allocate-refs(map(n,cs), sizes, info(c0)) where :
              val c0 = head(values(e)) as KClosure
            ;Store arguments
            for (c in cs, args in argss) do :
              for (x in args, i in 0 to false) do :
                emit(TGStore(c, x, 8 * i - REF-TAG-BITS))
      (e:KVar) :
        if global?(dec-table, n(e)) :
          val t = var-type(dec-table, n(e))
          new CExp & Ignorable :
            defmethod types (this) :
              tgt-types(dec-table,t)
            defmethod set (xs:List<Int>, this) :
              for (x in xs, o in field-offsets(dec-table,t)) do :
                val m = global-mem(dec-table, n(e))
                emit(TGLoad(TGVar(x), m, o))
        else :
          new CImm & Ignorable :
            defmethod types (this) : type-table[n(e)]
            defmethod imms (this) : imm-table[n(e)]
      (e:KSet) :      
        val type = match(exp(e)) :
          (e:KDeref) : type(e)
          (e:KDeptr) : type(e)
          (e:KField) : field-type(dec-table, n(e))
          (e:KSlot) : type(e)
          (e:KVar) : var-type(dec-table, n(e))
        new CImm :
          defmethod types (this) :
            List(TGRefT())
          defmethod imms (this) :
            match(cloc(exp(e))) :
              (l:PtrLoc) :
                val p = imm(base(l))
                val vs = imms(cexp(value(e)))
                val os = field-offsets(dec-table, type)
                for (v in vs, o in os) do :
                  emit(TGStore(p, v, o + offset(l)))
              (l:VarLoc) :
                val base = imm-table[n(l)] as List<TGVar>
                val len = length(dec-table, type)
                val xs = headn(tailn(base, index(l)), len)
                set(map(n,xs), cexp(value(e)))
            List(false-marker)
      (e:KTuple) :
        ;Big Tuples
        val len = length(exps(e))
        if len > 32 :
          new CExp :
            defmethod types (this) :
              List(TGRefT())
            defmethod set (ns:List<Int>, this) :
              val n = head(ns)
              emit(TGCall(1, ret, f, len, info(e), false)) where :
                val ret = List(TGVar(n))
                val f = TGMem(VOID-TUPLE-ID)
                val len = List(TGLong(to-long(len)))
              for (e in exps(e), i in 0 to false) do :
                val offset = 8 * i + foffset(TUPLE-ITEMS-FIELD-ID)
                emit(TGStore(TGVar(n), imm(cexp(e)), offset))
            defmethod ignore (this) :
              do(ignore{cexp(_)}, exps(e))
        ;Small Tuples
        else :
          ctuple(map(cexp,exps(e)), info(e))
      (e:KTupleGet) :
        val o = cexp(exp(e))
        new CExp :
          defmethod types (this) :
            List(TGRefT())
          defmethod set (ns:List<Int>, this) :
            val x = TGVar(head(ns))
            val offset = 8 * index(e) + foffset(TUPLE-ITEMS-FIELD-ID)
            emit(TGLoad(x, imm(o), offset))
          defmethod ignore (this) :
            ignore(o)
      (e:KEnsureLength) :
        new CImm :
          defmethod types (this) :
            List(TGRefT())
          defmethod imms (this) :
            val lbl = fresh-id()
            val o = imm(cexp(exp(e)))
            val len = make-var(TGLongT())
            val exp-len = TGLong(to-long(length(e)))
            emit(TGLoad(len, o, 8 - REF-TAG-BITS))
            emit(TGBinCmp(lbl, TGEqOp(), len, exp-len))
            emit(TGCall(2, List(), TGMem(TUPLE-LENGTH-ERROR-ID), List(len, exp-len), info(e), true))
            emit(TGLabel(lbl))
            List(o)
      (e:KObject) : 
        ;Marker object
        if empty?(args(e)) :
          new CImm :
            defmethod types (this) :
              List(TGRefT())
            defmethod imms (this) :
              List(TGTag(n(e), true))
        ;Allocated object
        else :
          val size = 8 + size(dec-table, n(e))
          val offsets = cons(0, map({8 + _}, field-offsets(dec-table, n(e))))
          val fields = cons(TGTag(n(e)), map(cexp, args(e)))
          calloc(size, offsets, fields, info(e))
      (e:KArray) :
        val size = 8 + size(dec-table, n(e))
        val rest-size = rest-size(dec-table, n(e))
        val offsets = cat([0], seq({8 + _}, field+rest-offsets(dec-table, n(e))))
        val fields = cons(TGTag(n(e)), map(cexp, args(e)))
        carray(size, rest-size, offsets, fields, info(e))
      (e:KStruct) :
        new CImm :
          defmethod types (this) :
            tgt-types(dec-table, n(e))
          defmethod imms (this) :
            seq-append(imms{cexp(_)}, args(e))
      (e:KPtr) : 
        val l = cloc(loc(e)) as PtrLoc
        if offset(l) == 0 :
          base(l)
        else :
          new CExp :
            defmethod types (this) :
              List(TGLongT())
            defmethod set (ns:List<Int>, this) :
              set(ns, base(l))
              val x = TGVar(head(ns))
              val off = TGLong(to-long(offset(l)))
              emit(TGBinOp(x, TGAddOp(), x, off))
            defmethod ignore (this) :
              ignore(base(l))
      (e:KDo) :
        ;Call to closure
        defn make-call (f:CExp, arity:Int, args:List<CExp>) :
          defn code (f:TGImm) :
            val x = make-var(TGLongT())
            emit(TGLoad(x, f, foffset(FN-CODE-FIELD-ID)))
            x          
          new CExp :
            defmethod types (this) :
              tgt-types(dec-table, type(e))
            defmethod set (ns:List<Int>, this) :
              val xs = map(TGVar, ns)
              val args* = seq-append(imms?,args)
              val f* = imm(f)
              emit(TGCall(arity, xs, code(f*), cons(f*,args*), info(e), false))
            defmethod return (this) :
              if use-tail-calls? :
                val args* = seq-append(imms?,args)
                val f* = imm(f)
                emit(TGTCall(arity, code(f*), cons(f*,args*)))
              else if EXTERN-CTXT? : emit(TGReturnC(imms(this)))
              else : emit(TGReturn(imms(this)))
            defmethod ignore (this) :
              set(List(), this)
        ;Call to known immediate
        defn make-call (f:TGImm, arity:Int, args:List<CExp>) :
          new CExp :
            defmethod types (this) :
              tgt-types(dec-table, type(e))
            defmethod set (ns:List<Int>, this) :
              val xs = map(TGVar, ns)
              val args* = seq-append(imms?,args)
              emit(TGCall(arity, xs, imm?(f), args*, info(e), false))
            defmethod return (this) :
              if use-tail-calls? :
                val args* = seq-append(imms?,args)
                emit(TGTCall(arity, imm?(f), args*))
              else if EXTERN-CTXT? : emit(TGReturnC(imms(this)))
              else : emit(TGReturn(imms(this)))
            defmethod ignore (this) :
              set(List(), this)
        ;Cases
        defn call-pointer (p:KExp, args:List<KExp>) :
          make-call(cexp(p), length(args), map(cexp, args))
        defn call-closure-w-code (n:Int, c:KExp, targs:List<KType>, args:List<KExp>) :
          val args* = append-all $ [List(cexp(c)), map(ctype, targs), map(cexp, args)]
          make-call(global-mem(dec-table,n), length(args), args*)
        defn call-closure-wo-code (c:KExp, targs:List<KType>, args:List<KExp>) :
          val args* = append(map(ctype,targs), map(cexp,args))
          make-call(cexp(c), length(args), args*)
        defn call-label (n:Int, targs:List<KType>, args:List<KExp>) :
          val args* = append(map(ctype,targs), map(cexp,args))
          make-call(global-mem(dec-table,n), length(args), args*)
        ;Categorize
        match(func(e)) :
          (f:KVar|KCurry) :
            val [f*, targs] = match(f) :
              (f:KVar) : [f, List()]
              (f:KCurry) : [KVar(n(f)), targs(f)]
            if function?(dec-table, n(f)) :
              call-label(n(f), targs, args(e))
            else if closure?(dec-table, n(f)) :
              val n = closure-code(dec-table, n(f))
              call-closure-w-code(n, f*, targs, args(e))
            else :
              call-closure-wo-code(f*, targs, args(e))
          (f:KDeptr) : call-pointer(exp(f), args(e))
          (f:KExp) : call-closure-wo-code(f, List(), args(e))
      (e:KDoC) :
        defn make-call (f:TGImm|CExp, args:List<TGImm|CExp>, varargs:List<TGImm|CExp>) :
          new CExp :
            defmethod types (this) :
              tgt-types(dec-table, type(e))
            defmethod set (ns:List<Int>, this) :
              val xs = map(TGVar, ns)
              val args* = seq-append(imms?, args)
              val varargs* = seq-append(imms?, varargs)
              emit(TGCallC(xs, imm?(f), args*, varargs*))
            defmethod ignore (this) :
              set(List(), this)
        ;Categorize
        val f* = match(func(e)) :
          (f:KDeptr) : cexp(exp(f))
          (f:KVar) : global-mem(dec-table, n(f))
        make-call(f*, map(cexp,args(e)), map(cexp,varargs(e)))            
      (e:KLSLiteral) : 
        match(value(e)) :
          (v:Char|Byte|Int|Long|True|False|String) :
            new CImm & Ignorable :
              defmethod types (this) :
                List $ match(v) :
                  (v:Byte) : TGByteT()
                  (v:Char) : TGByteT()
                  (v:Int) : TGIntT()
                  (v:Long) : TGLongT()
                  (v:String) : TGLongT()
              defmethod imms (this) :
                List $ match(v) :
                  (v:Char) : TGByte(to-byte(v))
                  (v:Byte) : TGByte(v)
                  (v:Int) : TGInt(v)
                  (v:Long) : TGLong(v)
                  (v:True) : TGLong(bit-representation(v))
                  (v:False) : TGLong(bit-representation(v))
                  (v:String) :
                    val c = fresh-id()
                    emit(TGDefData(c, v))
                    TGMem(c,0)
          (v:Float|Double) :
            new CExp & Ignorable :
              defmethod types (this) :
                List $ match(v) :
                  (v:Float) : TGFloatT()
                  (v:Double) : TGDoubleT()
              defmethod set (ns:List<Int>, this) :
                val x = TGVar(head(ns))
                match(v) :
                  (v:Float) :
                    emit(TGInterpret(x, TGInt(bits(v))))
                  (v:Double) :
                    val c = fresh-id()
                    emit(TGDefData(c, v))
                    emit(TGLoad(x, TGMem(c,0), 0))
      (e:KLiteral) :
        new CImm & Ignorable :
          defmethod types (this) :
            List(TGRefT())
          defmethod imms (this) :
            List(TGLong(bit-representation(value(e))))            
      (e:KInterpret) :
        new CExp :
          defmethod types (this) :
            List $ match(type(e)) :
              (t:KByteT) : TGByteT()
              (t:KIntT) : TGIntT()
              (t:KLongT) : TGLongT()
              (t:KFloatT) : TGFloatT()
              (t:KDoubleT) : TGDoubleT()
              (t:KPtrT) : TGLongT()
              (t) : TGRefT()
          defmethod set (ns:List<Int>, this) :
            set(ns, cexp(exp(e)))
          defmethod ignore (this) :
            ignore(cexp(exp(e)))
      (e:KConv) :
        new CExp :
          defmethod types (this) :
            List $ match(type(e)) :
              (t:KByteT) : TGByteT()
              (t:KIntT) : TGIntT()
              (t:KLongT) : TGLongT()
              (t:KFloatT) : TGFloatT()
              (t:KDoubleT) : TGDoubleT()
              (t:KPtrT) : TGLongT()
              (t) : TGRefT()
          defmethod set (ns:List<Int>, this) :
            val x = TGVar(head(ns))
            emit(TGConv(x, imm(cexp(exp(e)))))
          defmethod ignore (this) :
            ignore(cexp(exp(e)))
      (e:KCheck) : 
        new CImm :
          defmethod types (this) :
            List(TGRefT())
          defmethod imms (this) :
            val pass-lbl = fresh-id()
            val fail-lbl = fresh-id()
            val obj = imm(cexp(exp(e)))
            compile-typeof(obj, type(e), pass-lbl, fail-lbl, head{imm-table[_]})
            ;Emit fail code
            emit(TGLabel(fail-lbl))
            val targ* = imm(ctype(tobj!(e)))
            tcall(CAST-ERROR-ID, List(TGInt(option(e)), obj, targ*), info(e))
            ;Emit pass code
            emit(TGLabel(pass-lbl))
            List(obj)            
      (e:KAndExp) : 
        new CExp :
          defmethod types (this) :
            List(TGLongT())
          defmethod set (ns:List<Int>, this) :
            val x = TGVar(head(ns))
            val done-lbl = fresh-id()
            set(ns, cexp(a(e)))
            emit(TGBinCmp(done-lbl, TGEqOp(), x, TGLong(0L)))
            set(ns, cexp(b(e)))
            emit(TGLabel(done-lbl))            
      (e:KOrExp) :
        new CExp :
          defmethod types (this) :
            List(TGLongT())
          defmethod set (ns:List<Int>, this) :
            val x = TGVar(head(ns))
            val done-lbl = fresh-id()
            set(ns, cexp(a(e)))
            emit(TGBinCmp(done-lbl, TGNeOp(), x, TGLong(0L)))
            set(ns, cexp(b(e)))
            emit(TGLabel(done-lbl))
      (e:KIf) :
        val conseq-exp = cexp(conseq(e))
        val alt-exp = cexp(alt(e))
        new CBodies :
          defmethod types (this) :
            types(conseq-exp)
          defmethod compile (this, kont:CExp -> False, end?:True|False) :
            val false-lbl = fresh-id()
            val done-lbl = fresh-id()
            val p = imm(cexp(pred(e)))
            emit(TGBinCmp(false-lbl, TGEqOp(), p, TGLong(0L)))
            kont(conseq-exp)
            emit(TGGoto(done-lbl)) when not end?
            emit(TGLabel(false-lbl))
            kont(alt-exp)
            emit(TGLabel(done-lbl)) when not end?
      (e:KPrim) :
        ;Utilities
        defn binop (x:TGVar, op:TGOp, a:TGImm, b:TGImm) :
          emit(TGBinOp(x, op, a, b))
        defn binop (n:Int, op:TGOp, a:TGImm, b:TGImm) :
          binop(TGVar(n), op, a, b)
        defn unaop (x:TGVar, op:TGOp, a:TGImm) :
          emit(TGUnaOp(x, op, a))
        defn unaop (n:Int, op:TGOp, a:TGImm) :
          unaop(TGVar(n), op, a)
        defn detag-int (y:TGImm) :
          val x = make-var(TGLongT())
          binop(x, TGAshrOp(), y, TGLong(32L))
          x
        defn detag-char (y:TGImm) :
          val x = make-var(TGLongT())
          val b = make-var(TGByteT())
          binop(x, TGShrOp(), y, TGLong(3L))
          emit(TGConv(b,x))
          b
        defn tag-as-bool (x:TGVar, y:TGImm) :
          binop(x, TGShlOp(), y, TGLong(3L))
          binop(x, TGAddOp(), x, TGLong(to-long(MARKER-TAG-BITS)))
        defn tag-as-char (x:TGVar, y:TGImm) :
          emit(TGConv(x,y))
          binop(x, TGShlOp(), x, TGLong(3L))
          binop(x, TGAddOp(), x, TGLong(to-long(CHAR-TAG-BITS)))

        ;Dispatch
        match(op(e)) :
          (op:Primitive) :
            switch contains?{_, op} :
              BINARY-OPS :
                val a = cexp(args(e)[0])
                val b = cexp(args(e)[1])
                new CExp :
                  defmethod types (this) :
                    List(TGRefT())
                  defmethod set (ns:List<Int>, this) :
                    val n = head(ns)
                    val a = imm(a)
                    val b = imm(b)
                    switch(op) :
                      ADD-OP :
                        binop(n, TGAddOp(), a, b)
                      SUB-OP :
                        binop(n, TGSubOp(), a, b)
                      MUL-OP :
                        binop(n, TGMulOp(), detag-int(a), b)
                      DIV-OP :
                        val x = make-var(TGLongT())
                        binop(x, TGDivOp(), a, b)
                        binop(n, TGShlOp(), x, TGLong(32L))
                      MOD-OP :
                        binop(n, TGModOp(), a, b)
                      AND-OP :
                        binop(n, TGAndOp(), a, b)
                      OR-OP :
                        binop(n, TGOrOp(), a, b)
                      XOR-OP :
                        binop(n, TGXorOp(), a, b)
                      SHL-OP :
                        binop(n, TGShlOp(), a, detag-int(b))
                      SHR-OP :
                        val x = make-var(TGLongT())
                        binop(x, TGShrOp(), a, detag-int(b))
                        binop(x, TGShrOp(), x, TGLong(32L))
                        binop(n, TGShlOp(), x, TGLong(32L))
                      ASHR-OP :
                        val x = make-var(TGLongT())
                        binop(x, TGAshrOp(), a, detag-int(b))
                        binop(x, TGShrOp(), x, TGLong(32L))
                        binop(n, TGShlOp(), x, TGLong(32L))
                      EQ-OP :
                        binop(n, TGEqOp(), a, b)
                        tag-as-bool(TGVar(n), TGVar(n))
                      NE-OP :
                        binop(n, TGNeOp(), a, b)
                        tag-as-bool(TGVar(n), TGVar(n))
                      LT-OP :
                        binop(n, TGLtOp(), a, b)
                        tag-as-bool(TGVar(n), TGVar(n))
                      GT-OP :
                        binop(n, TGGtOp(), a, b)
                        tag-as-bool(TGVar(n), TGVar(n))
                      LE-OP :
                        binop(n, TGLeOp(), a, b)
                        tag-as-bool(TGVar(n), TGVar(n))
                      GE-OP :
                        binop(n, TGGeOp(), a, b)
                        tag-as-bool(TGVar(n), TGVar(n))
                      IDENTICAL-OP :
                        binop(n, TGEqOp(), a, b)
                        tag-as-bool(TGVar(n), TGVar(n))
                      AGET-OP :
                        val o = make-var(TGLongT())
                        binop(o, TGAshrOp(), b, TGLong(32L - 3L))
                        binop(o, TGAddOp(), o, a)
                        emit(TGLoad(TGVar(n), o, foffset(RAWARRAY-ITEMS-FIELD-ID)))
                      CHAR-AGET-OP :
                        val o = make-var(TGLongT())
                        val c = make-var(TGByteT())
                        binop(o, TGAshrOp(), b, TGLong(32L))
                        binop(o, TGAddOp(), o, a)
                        emit(TGLoad(c, o, foffset(CHARARRAY-CHARS-FIELD-ID)))
                        tag-as-char(TGVar(n), c)
                      STRING-GET-OP :
                        val o = make-var(TGLongT())
                        val c = make-var(TGByteT())
                        binop(o, TGAshrOp(), b, TGLong(32L))
                        binop(o, TGAddOp(), o, a)
                        emit(TGLoad(c, o, foffset(STRING-CHARS-FIELD-ID)))
                        tag-as-char(TGVar(n), c)
                  defmethod ignore (this) :
                    ignore(a)
                    ignore(b)
              UNARY-OPS :
                val a = cexp(head(args(e)))
                new CExp :
                  defmethod types (this) :
                    List(TGRefT())
                  defmethod set (ns:List<Int>, this) :
                    val n = head(ns)
                    val a = imm(a)
                    switch(op) :
                      NOT-OP :
                        val x = make-var(TGLongT())
                        unaop(x, TGNotOp(), a)
                        binop(x, TGShrOp(), x, TGLong(32L))
                        binop(n, TGShlOp(), x, TGLong(32L))
                      NEG-OP :
                        unaop(n, TGNegOp(), a)
                      ALEN-OP :
                        emit(TGLoad(TGVar(n), a, 8 - REF-TAG-BITS))
                        binop(n, TGShlOp(), TGVar(n), TGLong(32L))
                      STRING-LEN-OP :
                        emit(TGLoad(TGVar(n), a, 8 - REF-TAG-BITS))
                        binop(n, TGShlOp(), TGVar(n), TGLong(32L))
                  defmethod ignore (this) :
                    ignore(a)
              EFFECTFUL-TERNARY-OPS :
                val a = cexp(args(e)[0])
                val b = cexp(args(e)[1])
                val c = cexp(args(e)[2])
                new CImm :
                  defmethod types (this) :
                    List(TGRefT())
                  defmethod imms (this) :
                    val a = imm(a)
                    val b = imm(b)
                    val c = imm(c)
                    switch(op) :
                      ASET-OP :
                        val o = make-var(TGLongT())
                        binop(o, TGAshrOp(), b, TGLong(32L - 3L))
                        binop(o, TGAddOp(), o, a)
                        emit(TGStore(o, c, foffset(RAWARRAY-ITEMS-FIELD-ID)))
                      CHAR-ASET-OP :
                        val o = make-var(TGLongT())
                        binop(o, TGAshrOp(), b, TGLong(32L))
                        binop(o, TGAddOp(), o, a)
                        emit(TGStore(o, detag-char(c), foffset(CHARARRAY-CHARS-FIELD-ID)))
                    List(false-marker)
          (op:GetterPrimitive) :
            if op == GET-SP-OP :
              new CImm & Ignorable :
                defmethod types (this) : List(TGLongT())
                defmethod imms (this) : List(TGRegSP())
            else :
              new CExp & Ignorable :
                defmethod types (this) :
                  tgt-types(dec-table, type(e))
                defmethod set (ns:List<Int>, this) :
                  val x = TGVar(head(ns))
                  val p = TGMem(lbl(op),0)
                  emit(TGLoad(x, p, 0))               
          (op:AddrPrimitive) :
            new CImm & Ignorable :
              defmethod types (this) : List(TGLongT())
              defmethod imms (this) : List(TGMem(lbl(op),0))
          (op:SetterPrimitive) :
            val a = cexp(head(args(e)))
            new CImm :
              defmethod types (this) :
                List(TGLongT())
              defmethod imms (this) :
                val p = TGMem(lbl(op),0)
                emit(TGStore(p, imm(a), 0))
                List(TGLong(0L))
          (op:LSPrimitive) :
            if op == LS-YIELD-OP :
              val s = cexp(args(e)[0])
              val y = cexp(args(e)[1])
              new CExp :
                defmethod types (this) :
                  List(TGRefT())
                defmethod set (ns:List<Int>, this) :
                  val x = TGVar(head(ns))
                  emit(TGSwitchStack(x, imm(s), imm(y)))
                defmethod ignore (this) :
                  val x = make-var(TGRefT())
                  set(n(x), this)
            else :
              switch contains?{_, op} :
                LS-BINARY-OPS :
                  val a = cexp(args(e)[0])
                  val b = cexp(args(e)[1])
                  new CExp :
                    defmethod types (this) :
                      switch(op) :
                        LS-ADD-OP : types(a)
                        LS-SUB-OP : types(a)
                        LS-MUL-OP : types(a)
                        LS-DIV-OP : types(a)
                        LS-MOD-OP : types(a)
                        LS-AND-OP : types(a)
                        LS-OR-OP : types(a)
                        LS-XOR-OP : types(a)
                        LS-SHL-OP : types(a)
                        LS-SHR-OP : types(a)
                        LS-ASHR-OP : types(a)
                        LS-EQ-OP : List(TGLongT())
                        LS-NE-OP : List(TGLongT())
                        LS-LT-OP : List(TGLongT())
                        LS-GT-OP : List(TGLongT())
                        LS-LE-OP : List(TGLongT())
                        LS-GE-OP : List(TGLongT())
                        LS-ULT-OP : List(TGLongT())
                        LS-UGT-OP : List(TGLongT())
                        LS-ULE-OP : List(TGLongT())
                        LS-UGE-OP : List(TGLongT())
                    defmethod set (ns:List<Int>, this) :
                      val op* = switch(op) :
                        LS-ADD-OP : TGAddOp()
                        LS-SUB-OP : TGSubOp()
                        LS-MUL-OP : TGMulOp()
                        LS-DIV-OP : TGDivOp()
                        LS-MOD-OP : TGModOp()
                        LS-AND-OP : TGAndOp()
                        LS-OR-OP : TGOrOp()
                        LS-XOR-OP : TGXorOp()
                        LS-SHL-OP : TGShlOp()
                        LS-SHR-OP : TGShrOp()
                        LS-ASHR-OP : TGAshrOp()
                        LS-EQ-OP : TGEqOp()
                        LS-NE-OP : TGNeOp()
                        LS-LT-OP : TGLtOp()
                        LS-GT-OP : TGGtOp()
                        LS-LE-OP : TGLeOp()
                        LS-GE-OP : TGGeOp()
                        LS-ULT-OP : TGUltOp()
                        LS-UGT-OP : TGUgtOp()
                        LS-ULE-OP : TGUleOp()
                        LS-UGE-OP : TGUgeOp()
                      val x = TGVar(head(ns))
                      emit(TGBinOp(x, op*, imm(a), imm(b)))
                    defmethod ignore (this) :
                      ignore(a)
                      ignore(b)
                LS-UNARY-OPS :
                  val a = cexp(head(args(e)))
                  new CExp :
                    defmethod types (this) :
                      switch(op) :
                        LS-NOT-OP : types(a)
                        LS-NEG-OP : types(a)
                        LS-BITS-OP : List(TGIntegerT(head(types(a)) as TGRealT))
                        LS-FNUM-OP : List(TGRealT(head(types(a)) as TGIntegerT))
                    defmethod set (ns:List<Int>, this) :
                      val t = head(types(this))
                      val x = TGVar(head(ns))
                      switch(op) :
                        LS-NOT-OP :
                          emit(TGUnaOp(x, TGNotOp(), imm(a)))
                        LS-NEG-OP :
                          emit(TGUnaOp(x, TGNegOp(), imm(a)))
                        LS-BITS-OP :
                          emit(TGInterpret(x, imm(a)))
                        LS-FNUM-OP :
                          emit(TGInterpret(x, imm(a)))
                    defmethod ignore (this) :
                      ignore(a)
      (e:KSizeof) : 
        new CImm & Ignorable :
          defmethod types (this) :
            List(TGLongT())
          defmethod imms (this) :
            val size = size(dec-table, type(e))
            List(TGLong(to-long(size)))
      (e:KTagof) : 
        new CImm & Ignorable :
          defmethod types (this) : List(TGLongT())
          defmethod imms (this) : List(TGTag(n(e)))
      (e:KMatch|KDispatch) :
        ;Compile branches
        val branches = branches(e) as List<KBranch>
        val bexps = map(cexp{body(_)}, branches)        
        new CBodies :
          defmethod types (this) :
            types(head(bexps))
          defmethod compile (this, kont:CExp -> False, end?:True|False) :
            val m-args = seq-append(imms{cexp(_)}, args(e))
            val bs = map(TGBranch{types(_), fresh-id()}, branches)
            val done = fresh-id()
            val no-branch = fresh-id()            
            ;Emit error paths
            defn arg-tuple () : ctuple(m-args, info(e))
            match(e) :
              (e:KMatch) :
                emit(TGMatch(m-args, bs, no-branch))
                emit(TGLabel(no-branch))
                tcall(NO-BRANCH-ERROR-ID, imms(arg-tuple()), info(e))
              (e:KDispatch) :
                val amb-branch = fresh-id()
                emit(TGDispatch(m-args, bs, no-branch, amb-branch))
                ;Error branches
                emit(TGLabel(no-branch))
                tcall(NO-BRANCH-ERROR-ID, imms(arg-tuple()), info(e))
                emit(TGLabel(amb-branch))
                tcall(AMB-BRANCH-ERROR-ID, imms(arg-tuple()), info(e))
            ;Emit branch paths
            for (b in branches, id in seq(n,bs), body in bexps) do :
              emit(TGLabel(id))
              for (a in args(b), ma in m-args) do :
                val x = make-var(TGRefT())
                imm-table[a] = List(x)
                type-table[a] = List(TGRefT())
                emit(TGSet(x, ma))
              kont(body)
              emit(TGGoto(done)) when not end?
            emit(TGLabel(done)) when not end?
      (e:KLabels) :
        val blocks = blocks(e) as List<KBlock>
        ;Create block args
        for b in blocks do :
          val tss = map(tgt-types{dec-table, _}, types(b))
          val xss = map(map{make-var, _}, tss)
          for (a in args(b), xs in xss, ts in tss) do :
            imm-table[a] = xs
            type-table[a] = ts
          block-arg-table[n(b)] = map(map{n, _}, xss)
        ;Compile blocks
        val bexps = map(cexp{body(_)}, blocks)
        new CBodies :
          defmethod types (this) :
            types(head(bexps))
          defmethod compile (this, kont:CExp -> False, end?:True|False) :
            val end-lbl = fresh-id()
            for (b in blocks, body in bexps) do :
              emit(TGLabel(n(b)))
              kont(body)
              emit(TGGoto(end-lbl)) when not end?
            emit(TGLabel(end-lbl)) when not end?        
      (e:KSeq) :
        val cb = cexp(b(e))
        new CBody :
          defmethod body (this) : cb
          defmethod compile (this) : ignore(cexp(a(e)))
      (e:KGoto) : 
        new CExp :
          defmethod types (this) :
            List(TGLongT())
          defmethod set (ns:List<Int>, this) :
            ignore(this)
          defmethod ignore (this) :
            val nss = block-arg-table[n(e)]
            val vs = seq(cexp, args(e))
            do(set, nss, vs)
            emit(TGGoto(n(e)))
      (e:KReturn) : 
        new CExp :
          defmethod types (this) :
            List(TGLongT())
          defmethod set (ns:List<Int>, this) :
            ignore(this)
          defmethod ignore (this) :
            return(cexp(exp(e)))            
      (e:KDeref|KDeptr|KField|KSlot) :
        val type = match(e) :
          (e:KDeref) : type(e)
          (e:KDeptr) : type(e)
          (e:KSlot) : type(e)
          (e:KField) : field-type(dec-table, n(e))
        match(cloc(e)) :
          (l:PtrLoc) :
            new CExp :
              defmethod types (this) :
                tgt-types(dec-table, type)
              defmethod set (ns:List<Int>, this) :
                val p = imm(base(l))
                for (n in ns, o in field-offsets(dec-table, type)) do :
                  emit(TGLoad(TGVar(n), p, offset(l) + o))
              defmethod ignore (this) :
                ignore(base(l))
          (l:ExpLoc) :
            new CImm :
              defmethod types (this) :
                tgt-types(dec-table, type)
              defmethod imms (this) :
                val xs = imms(base(l))
                val len = length(dec-table, type)
                headn(tailn(xs, index(l)), len)                
          (l:VarLoc) :
            new CImm & Ignorable :
              defmethod types (this) :
                tgt-types(dec-table, type)
              defmethod imms (this) :
                val xs = imm-table[n(l)]
                val len = length(dec-table, type)
                headn(tailn(xs, index(l)), len)
      (e:KEnsureSet) : 
        new CImm :
          defmethod types (this) :
            List(TGRefT())
          defmethod imms (this) :
            val lbl = fresh-id()
            val o = imm(cexp(exp(e)))
            emit(TGBinCmp(lbl, TGNeOp(), o, TGLong(to-long(VOID-TAG))))            
            emit(TGCall(0, List(), TGMem(VARIABLE-UNINITIALIZED-ERROR-ID), List(), info(e), true))
            emit(TGLabel(lbl))
            List(o)
      (e:KNewObject) : 
        if empty?(targs(e)) and empty?(args(e)) :
          new CImm & Ignorable :
            defmethod types (this) :
              List(TGRefT())
            defmethod imms (this) :
              List(TGTag(n(e), true))
        else :
          calloc{_, info(e)} $ qquote(
            ~ (TGTag(n(e)))
            ~@ (map(ctype, targs(e)))
            ~@ (map(cexp, args(e))))
      (e:KObjectGet) : 
        val o = cexp(object(e))
        new CExp :
          defmethod types (this) :
            List(TGRefT())
          defmethod set (ns:List<Int>, this) :
            val num-targs = object-tarity(dec-table, n(e))
            val x = TGVar(head(ns))
            val offset = 8 * (num-targs + index(e)) + 8 - REF-TAG-BITS
            emit(TGLoad(x, imm(o), offset))
          defmethod ignore (this) :
            ignore(o)          
      (e:KObjectTGet) : 
        val o = cexp(object(e))
        new CExp :
          defmethod types (this) :
            List(TGRefT())
          defmethod set (ns:List<Int>, this) :
            val x = TGVar(head(ns))
            val offset = 8 * index(e) + 8 - REF-TAG-BITS
            emit(TGLoad(x, imm(o), offset))
          defmethod ignore (this) :
            ignore(o)                  
      (e:KLetType) :
        val cbody = cexp(body(e))
        new CBody :
          defmethod body (this) : cbody
          defmethod compile (this) :
            val v = imm(cexp(value(e)))
            imm-table[n(e)] = List(v)
      (e:KBox) : 
        val v = match(exp(e)) :
          (e:KExp) : cexp(e)
          (e:False) : TGLong(to-long(VOID-TAG))
        calloc(List(TGTag(BOX-TYPE-ID), v), false)
      (e:KBoxGet) : 
        val box = cexp(exp(e))
        new CExp :
          defmethod types (this) :
            List(TGRefT())
          defmethod set (ns:List<Int>, this) :
            val x = TGVar(head(ns))
            emit(TGLoad(x, imm(box), foffset(BOX-ITEM-FIELD-ID)))
          defmethod ignore (this) :
            ignore(box)            
      (e:KBoxSet) :
        val box = cexp(exp(e))
        val value = cexp(value(e))
        new CImm :
          defmethod types (this) :
            List(TGRefT())
          defmethod imms (this) :
            emit(TGStore(imm(box), imm(value), foffset(BOX-ITEM-FIELD-ID)))
            List(false-marker)
      (e:KClosure) : 
        calloc{_, info(e)} $ qquote(
          ~ (TGTag(FN-TYPE-ID))
          ~ (TGLong(to-long(length(args(e)))))
          ~ (TGMem(n(e)))
          ~@ (map(ctype, targs(e)))
          ~@ (map(cexp, args(e))))
      (e:KTagPrim) : 
        val v = cexp(exp(e))
        new CExp :
          defmethod types (this) :
            List(TGRefT())
          defmethod set (ns:List<Int>, this) :
            val x = TGVar(head(ns))
            switch(n(e)) :
              BYTE-TYPE-ID :
                val y = make-var(TGLongT())
                emit(TGConv(y, imm(v)))
                emit(TGBinOp(y, TGShlOp(), y, TGLong(3L)))
                emit(TGBinOp(x, TGAddOp(), y, TGLong(to-long(BYTE-TAG-BITS))))
              CHAR-TYPE-ID :
                val y = make-var(TGLongT())
                emit(TGConv(y, imm(v)))
                emit(TGBinOp(y, TGShlOp(), y, TGLong(3L)))
                emit(TGBinOp(x, TGAddOp(), y, TGLong(to-long(CHAR-TAG-BITS))))
              INT-TYPE-ID :
                val y = make-var(TGLongT())
                emit(TGConv(y, imm(v)))
                emit(TGBinOp(x, TGShlOp(), y, TGLong(32L)))
              FLOAT-TYPE-ID :
                val y1 = make-var(TGIntT())
                emit(TGInterpret(y1, imm(v)))
                val y2 = make-var(TGLongT())
                emit(TGConv(y2, y1))
                emit(TGBinOp(y2, TGShlOp(), y2, TGLong(3L)))
                emit(TGBinOp(x, TGAddOp(), y2, TGLong(to-long(FLOAT-TAG-BITS))))            
          defmethod ignore (this) :
            ignore(v)
      (e:KDetagPrim) :
        val v = cexp(exp(e))
        new CExp :
          defmethod types (this) :
            List $ switch(n(e)) :
              BYTE-TYPE-ID : TGByteT()
              CHAR-TYPE-ID : TGByteT()
              INT-TYPE-ID : TGIntT()
              FLOAT-TYPE-ID : TGFloatT()
          defmethod set (ns:List<Int>, this) :
            val x = TGVar(head(ns))
            val y = make-var(TGLongT())
            set(List(n(y)), v)
            switch(n(e)) :
              BYTE-TYPE-ID :
                emit(TGBinOp(y, TGAshrOp(), y, TGLong(3L)))
                emit(TGConv(x, y))
              CHAR-TYPE-ID :
                emit(TGBinOp(y, TGAshrOp(), y, TGLong(3L)))
                emit(TGConv(x, y))
              INT-TYPE-ID :
                emit(TGBinOp(y, TGAshrOp(), y, TGLong(32L)))
                emit(TGConv(x, y))
              FLOAT-TYPE-ID :
                emit(TGBinOp(y, TGAshrOp(), y, TGLong(3L)))
                val y2 = make-var(TGIntT())
                emit(TGConv(y2, y))
                emit(TGInterpret(x, y2))            
          defmethod ignore (this) :
            ignore(v)

  ;============================
  ;===== Type Compilation =====
  ;============================
  defn ctype (t:KType) -> CExp :
    match(t) :
      (t:KTVar) : 
        if global?(dec-table, n(t)) :
          new CExp & Ignorable :
            defmethod types (this) : List(TGRefT())
            defmethod set (ns:List<Int>, this) :
              val x = TGVar(head(ns))
              val m = global-mem(dec-table,n(t))
              emit(TGLoad(x, m, 0))
        else :
          new CImm & Ignorable :
            defmethod types (this) : List(TGRefT())
            defmethod imms (this) : imm-table[n(t)]
      (t:KTypeObject) :
        calloc{_, false} $ qquote(
          ~ (TGTag(TYPE-TYPE-ID))
          ~ (TGLong(to-long(length(targs(t)))))
          ~ (TGMem(n(t),0))
          ~@ (map(ctype, targs(t))))

  ;================================
  ;===== Location Compilation =====
  ;================================
  defn cloc (e:KExp) -> CLoc :
    match(e) :
      (e:KVar) :
        if global?(dec-table, n(e)) :
          val base = new CImm :
            defmethod types (this) : List(TGLongT())
            defmethod imms (this) : List(global-mem(dec-table, n(e)))
          PtrLoc(base, 0)
        else :
          VarLoc(n(e), 0)
      (e:KDeref) :
        PtrLoc(cexp(exp(e)), 8 - REF-TAG-BITS)
      (e:KDeptr) :
        PtrLoc(cexp(exp(e)), 0)
      (e:KField) :
        match(cloc(exp(e))) :
          (l:PtrLoc) :
            PtrLoc(
              base(l),
              offset(l) + field-offset(dec-table, n(e)))
          (l:ExpLoc) :
            ExpLoc(
              base(l),
              index(l) + field-index(dec-table, n(e)))
          (l:VarLoc) :
            VarLoc(
              n(l),
              index(l) + field-index(dec-table, n(e)))
      (e:KSlot) :
        ;Compute location
        val loc = match(exp(e)) :
          (e:KPtr) : cloc(loc(e))
          (e) : PtrLoc(cexp(e), 0)
        ;Compute ptr and offset
        val [ptr, ptr-offset] = match(loc) :
          (l:PtrLoc) : [base(l), offset(l)]
          (l:ExpLoc) : [base(l), 0]
        ;Compute base cexp
        val base = new CExp :
          defmethod types (this) :
            List(TGLongT())
          defmethod set (ns:List<Int>, this) :
            ;ns = base
            ;offset = index
            ;offset = offset * size
            ;n = n + offset
            set(ns, ptr)
            val offset = make-var(TGLongT())
            set(n(offset), cexp(index(e)))
            val size = size(dec-table, type(e))
            emit(TGBinOp(offset, TGMulOp(), offset, TGLong(to-long(size)))) when size != 1
            val x = TGVar(head(ns))
            emit(TGBinOp(x, TGAddOp(), x, offset))
          defmethod ignore (this) :
            ignore(ptr)
        ;Return location
        PtrLoc(base, ptr-offset)
      (e) :
        ExpLoc(cexp(e), 0)

  ;=============================
  ;===== Function Preludes =====
  ;=============================
  ;Get args
  defn cargs (args:List<TGVar>) :
    if EXTERN-CTXT? : emit(TGArgsC(args))
    else : emit(TGArgs(args))
      
  ;Extend stack if necessary
  defn stack-extension-prelude (args:List<TGVar>, info:False|FileInfo) :
    ;  goto default if has-space
    ;  new-stack
    ;  vs = args
    ;  goto body if num-free-stacks >= 3 ;See [3 Reserve Stacks]
    ;  extend-stack()
    ;  goto body
    ;default:
    ;  vs = args
    ;body:
    val default-lbl = fresh-id()
    val body-lbl = fresh-id()
    val num-free = make-var(TGLongT())
    emit(TGSaveCContext()) when EXTERN-CTXT?
    emit(TGNullCmp(default-lbl, TGHasStackSpace()))
    emit(TGNewStack())
    cargs(args)
    emit(TGLoad(num-free, TGMem(NUM-FREE-STACKS-LBL,0), 0))
    emit(TGBinCmp(body-lbl, TGGeOp(), num-free, TGLong(3L)))
    call(EXTEND-STACK-ID, info)
    emit(TGGoto(body-lbl))
    emit(TGLabel(default-lbl))
    cargs(args)
    emit(TGLabel(body-lbl))    

  ;Always run function in new stack
  defn new-stack-prelude (args:List<TGVar>, info:False|FileInfo) :
    ;  new-stack
    ;  vs = args
    ;  goto body if num-free-stacks >= 3 ;See [3 Reserve Stacks]
    ;  extend-stack()
    ;body:
    val body-lbl = fresh-id()
    val num-free = make-var(TGLongT())
    emit(TGSaveCContext()) when EXTERN-CTXT?
    emit(TGNewStack())
    cargs(args)
    emit(TGLoad(num-free, TGMem(NUM-FREE-STACKS-LBL,0), 0))
    emit(TGBinCmp(body-lbl, TGGeOp(), num-free, TGLong(3L)))
    call(EXTEND-STACK-ID, info)
    emit(TGLabel(body-lbl))

  ;Run function in last stack (without checking stack exhaustion)
  defn last-stack-prelude (args:List<TGVar>, info:False|FileInfo) :
    ;  new-stack
    ;  vs = args
    emit(TGSaveCContext()) when EXTERN-CTXT?
    emit(TGNewStack())
    cargs(args)

  ;================================
  ;===== Function Compilation =====
  ;================================
  ;Compile function
  ;[3 Reserve stacks]
  ;  - For handling stack overflow
  ;  - For running the GC
  ;  - For handling overflow during GC
  defn cfn (closure:False|Int, freetypes:List<Int>, freevars:List<Int>,
            f:KFn, extern?:True|False) :
    ;Establish context
    let-var EXTERN-CTXT? = extern? :
      let-var use-tail-calls? = tail?(f) :
      
        ;Load closure free variables
        defn load-free () :
          for (v in append(freetypes, freevars), i in 0 to false) do :
            defn imm-var (n:Int) : head(imm-table[n]) as TGVar
            val c = imm-var(closure as Int)
            val x = make-var(TGRefT())
            imm-table[v] = List(x)
            type-table[v] = List(TGRefT())
            emit(TGLoad(x, c, 8 * i + foffset(FN-FREE-FIELD-ID)))

        ;Register arguments
        match(closure:Int) :
          imm-table[closure] = List(make-var(TGRefT()))
          type-table[closure] = List(TGRefT())      
        for a in targs(f) do :
          imm-table[a] = List(make-var(TGRefT()))
          type-table[a] = List(TGRefT())
        for (a in args(f), t in a1(f)) do :
          val ts = tgt-types(dec-table, t)
          imm-table[a] = map(make-var, ts)
          type-table[a] = ts
          
        ;Get arg vars
        val args* = match(closure) :
          (c:Int) : cons(c, append(targs(f), args(f)))
          (c:False) : append(targs(f), args(f))
        defn vars (n:Int) : imm-table[n] as List<TGVar>
        val arg-vars = seq-append(vars, args*)
          
        ;Prelude    
        match(stack-properties(f)) :
          (sp:NewStack) : new-stack-prelude(arg-vars, info(f))
          (sp:LastStack) : last-stack-prelude(arg-vars, info(f))
          (sp:CheckStack) : stack-extension-prelude(arg-vars, info(f))
          
        ;Body
        load-free()
        return(cexp(body(f)))

  ;Compile multiple functions, checking arity for each            
  defn cfns (closure:False|Int, freetypes:List<Int>, freevars:List<Int>,
             fs:List<KFn>) :
    for f in fs do :
      val fail-lbl = fresh-id()
      val arity = TGInt(length(args(f)))
      emit(TGUnaCmp(fail-lbl, TGArityNeOp(), arity))
      cfn(closure, freetypes, freevars, f, false)
      emit(TGLabel(fail-lbl))
    emit(TGArgs(List()))
    emit(TGArityError(info(head(fs))))

  ;===================================
  ;===== Type Object Compilation =====
  ;===================================
  defn ctype-obj (free:List<Int>, type:KType) :
    val parts-lbl = fresh-id()
    emit(TGUnaCmp(parts-lbl, TGArityNeOp(), TGInt(2)))
    compile-ctype-test(free, type)
    emit(TGLabel(parts-lbl))
    compile-ctype-printer(free, type)
  
  defn compile-ctype-test (free:List<Int>, type:KType) :
    ;Arguments
    val tobj = make-var(TGRefT())
    val arg = make-var(TGRefT())

    ;Prelude
    new-stack-prelude(List(tobj,arg), false)

    ;Load free
    for (v in free, i in 0 to false) do :
      val x = make-var(TGRefT())
      imm-table[v] = List(x)
      type-table[v] = List(TGRefT())
      emit(TGLoad(x, tobj, 8 * i + foffset(TYPE-FREE-FIELD-ID)))
      
    ;Compile predicate
    val true-lbl = fresh-id()
    val false-lbl = fresh-id()
    compile-typeof(arg, type, true-lbl, false-lbl, head{imm-table[_]})
    emit(TGLabel(false-lbl))
    emit(TGReturn(List(TGInt(0))))
    emit(TGLabel(true-lbl))
    emit(TGReturn(List(TGInt(1))))

  defn compile-ctype-printer (free:List<Int>, type:KType) :
    ;Arguments
    val tobj = make-var(TGRefT())
    
    ;Prelude
    new-stack-prelude(List(tobj), false)

    ;Load free
    for (v in free, i in 0 to false) do :
      val x = make-var(TGRefT())
      imm-table[v] = List(x)
      type-table[v] = List(TGRefT())
      emit(TGLoad(x, tobj, 8 * i + foffset(TYPE-FREE-FIELD-ID)))

    ;Compile parts
    val parts = for x in type-parts(type) map :
      match(x) :
        (x:KTVar) :
          TGVar(n(x))
        (x:String) :
          val n* = fresh-id()
          emit(TGDefData(n*, x))
          val s = make-var(TGRefT())
          val make-str = TGMem(MAKE-STRING-ID)
          emit(TGCall(1, List(s), make-str, List(TGMem(n*)), false, false))
          s
          
    ;Allocate tuple
    emit(TGReturn(imms(ctuple(parts, false))))

  defn type-parts (t:KType) -> List<String|KTVar> :
    ;Yield all parts
    val parts = generate<String|KTVar> :
      defn lvl (t:KType) :
        match(t:KOr|KTVar) : 0
        else : 1
      let loop (t:KType = t) :
        defn recur (t2:KType) :
          val paren? = lvl(t2) < lvl(t)
          yield("(") when paren?
          loop(t2)
          yield(")") when paren?
        match(t) :
          (t:KTVar) :
            yield(t)
          (t:KOf) :
            yield(to-string(name(dec-table, n(t))))
          (t:KAnd) :
            recur(a(t))
            yield("&")
            recur(b(t))
          (t:KOr) : 
            recur(a(t))
            yield("|")
            recur(b(t))
          (t:KTop) :
            yield("?")
          (t:KBot) :
            yield("Void")
    ;Merge string parts
    to-list $ repeat-while $ fn () :
      if empty?(parts) :
        None()
      else :
        match(next(parts)) :
          (x:String) :
            val xs = take-while({_ is String}, parts)
            One(string-join(cat([x], xs)))
          (x:KTVar) : One(x)

  ;=====================
  ;===== Interface =====
  ;=====================
  new Compiler :
    defmethod compile-function (this, lbl:Int|Symbol,
                                closure:False|Int, freetypes:List<Int>, freevars:List<Int>,
                                f:KFn|KMultifn, extern?:True|False, check-arity?:True|False) :
      val body = emit-to-buffer $ fn () :
        if check-arity? :
          fatal("Extern function cannot check arity.") when extern?
          val fs = match(f) :
            (f:KFn) : List(f)
            (f:KMultifn) : funcs(f) as List<KFn>
          cfns(closure, freetypes, freevars, fs)
        else :
          cfn(closure, freetypes, freevars, f as KFn, extern?)
      TGDefCode(lbl, body)
      
    defmethod compile-type-obj (this, lbl:Int, args:List<Int>, type:KType) :
      val body = emit-to-buffer(ctype-obj{args, type})
      TGDefCode(lbl, body)

    defmethod compile-main (this, exps:List<KTExp>) :
      val body = emit-to-buffer $ fn () :
        emit(TGArgs(List()))
        for e in exps do :
          match(e) :
            (e:KDef) :
              ignore(cexp(KSet(n(e), type(e), value(e))))
            (e:KDefVar) :
              attempt: ignore(cexp(KSet(n(e), type(e), value(e) as? KExp)))
            (e:KInit) :
              ignore(cexp(exp(e)))
            (e) :
              false
      TGDefCode(fresh-id(), body)

;============================================================
;================ Compilation Utilities =====================
;============================================================

defn tcall (f:Int, args:List<TGImm>, i:False|FileInfo) :
  emit(TGCall(length(args), List(), TGMem(f,0), args, i, true))
defn tcall (f:Int, i:False|FileInfo) :
  tcall(f, List(), i)
defn call (f:Int, args:List<TGImm>, i:False|FileInfo) :
  emit(TGCall(length(args), List(), TGMem(f,0), args, i, false))
defn call (f:Int, i:False|FileInfo) :
  call(f, List(), i)
  
defn global-mem (dt:DecTable, n:Int) :
  match(extern-label(dt, n)) :
    (lbl:Symbol) : TGExMem(lbl,0)
    (lbl:False) : TGMem(n,0)

defn bit-representation (value) :
  match(value) :
    (value:Byte) : to-long(value) << 3L + to-long(BYTE-TAG-BITS)
    (value:Char) : to-long(to-int(value) << 3 + CHAR-TAG-BITS)
    (value:Int) : to-long(value) << 32L
    (value:Float) : to-long(bits(value)) << 3L + to-long(FLOAT-TAG-BITS)
    (value:True) : 1L << 3L + to-long(MARKER-TAG-BITS)
    (value:False) : to-long(MARKER-TAG-BITS)

val BINARY-OPS = [ADD-OP, SUB-OP, MUL-OP, DIV-OP, MOD-OP, AND-OP,
                  OR-OP, XOR-OP, SHL-OP, SHR-OP, ASHR-OP, EQ-OP, NE-OP,
                  LT-OP, GT-OP, LE-OP, GE-OP, IDENTICAL-OP, AGET-OP,
                  CHAR-AGET-OP, STRING-GET-OP]
val UNARY-OPS = [NOT-OP, NEG-OP, ALEN-OP, STRING-LEN-OP]
val EFFECTFUL-TERNARY-OPS = [ASET-OP, CHAR-ASET-OP]

val LS-BINARY-OPS = [LS-ADD-OP, LS-SUB-OP, LS-MUL-OP, LS-DIV-OP, LS-MOD-OP,
                     LS-AND-OP, LS-OR-OP, LS-XOR-OP, LS-SHL-OP, LS-SHR-OP,
                     LS-ASHR-OP, LS-EQ-OP, LS-NE-OP, LS-LT-OP, LS-GT-OP,
                     LS-LE-OP, LS-GE-OP, LS-ULT-OP, LS-UGT-OP, LS-ULE-OP, LS-UGE-OP]
val LS-UNARY-OPS = [LS-NOT-OP, LS-NEG-OP, LS-BITS-OP, LS-FNUM-OP]