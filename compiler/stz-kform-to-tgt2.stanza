defpackage stz/kform-to-tgt2 :
  import core
  import collections
  import stz/kl2-ir
  import stz/pl-ir
  import stz/tgt-ir
  import stz/tgt-utils
  import stz/tl-ir with :
    prefix(CExp, CLSExp) => TL
  import stz/ids
  import stz/khier
  import stz/primitives
  import stz/utils
  import stz/dec-table2

;<STRUCTURE>
=============================================================
=================== Declaration Table =======================
=============================================================

==== Entry Types ====
FnEntry
VarEntry
ClosureEntry
ObjectEntry
TypeEntry
StructEntry
FieldEntry
MultifnEntry

==== Desired Queries ====
defn tgt-types (t:DecTable, n:Int) -> List<TGType>
defn tgt-types (t:DecTable, t:KType) -> List<TGType>
  Returns the list of TGTypes corresponding to a type, or identifier
  of a struct. Used by expression compilation, for example to get
  types of corresponding to val declaration.

defn extern-label (t:DecTable, n:Int) -> Symbol|False
  Returns the external label, if there is one, of the given function
  or variable. Used during compilation for extern functions and
  variables.

defn field-offsets (t:DecTable, n:Int) -> List<Int>
defn field-offsets (t:DecTable, t:KType) -> List<Int>
  Returns the offsets of all subelements within the given type. Used
  for, example, loading the fields of a global struct variable at the
  proper offsets.

defn field-type (t:DecTable, n:Int) -> KType
  Retrieves the type of the field with the given id. Used for
  retrieving the type of a KField expression.

defn field-index (t:DecTable, n:Int) -> Int
  Retrieves the index of the first subelement of the given field. Used
  for, example, retrieving the subelements corresponding to a field
  within a struct.

defn field-offset (t:DecTable, n:Int) -> Int
  Retrieves the offset of the first subelement of the given field.
  Used for loading the subelements corresponding to a field within a
  struct.

defn field-size (t:DecTable, n:Int) -> Int
  Retrieves the size of the field n. Used for computing field offsets.

defn rest-size (t:DecTable, n:Int) -> Int
  Retrieves the size of the rest field in the given struct. The struct
  must have a rest field.

defn field+rest-offsets (t:DecTable, n:Int) -> Seqable<Int>
  Retrieves a sequence containing all offsets of all subelements in
  the struct. If the struct has a rest field, then the offsets may be
  infinite.

defn length (t:DecTable, n:Int) -> Int
defn length (dt:DecTable, t:KLSType) -> Int
  Returns the number of subelements within the given type. Used for,
  example, retrieving the appropriate elements in a field expression.

defn closure? (t:DecTable, n:Int) -> True|False
defn closure-code (t:DecTable, n:Int) -> Int
  Returns whether the given id refers to a closure object. If it does,
  closure-code returns the id of its code.

defn inlined-type (t:DecTable, t:KType) -> KType
  The given type must be either a KTVar or a KTypeObject. If it is a
  KTypeObject, it returns its inlined definition. Used for efficient
  compilation of KCheck expressions.

defn object-tarity (t:DecTable, n:Int) -> Int
  Returns the tarity of the object corresponding to the given id. Used
  for compiling KObjectGet and KObjectTGet expressions.

=============================================================
=================== Expression Compilation ==================
=============================================================

==== Allocation Utilities ====
defn calloc (fields:List<TGImm|CExp>, info:False|FileInfo)
  Word sized allocation
defn calloc (#size:Int, offsets:List<Int>, fields:List<TGImm|CExp>, info:False|FileInfo)
  Explicit offsets allocation
defn carray (size:Int, rest-size:Int, offsets:Seqable<Int>, fields:List<TGImm|CLSExp>, info:False|FileInfo)
  Array allocation
defn ctuple (args:List<CExp|TGImm>, info:False|FileInfo)
  Tuple allocation

==== Context ====
val imm-table:IntTable<List<TGImm>>
  Stores the list of immediates corresponding to every binder.
val type-table:IntTable<List<TGType>>
  Stores the list of types corresponding to every binder.
val block-arg-table:IntTable<List<List<Int>>>
  Stores the name of the arguments for labeled blocks.
var use-tail-calls?:True|False
  Set to true when compiling TCO functions.
<STRUCTURE>

;============================================================
;======================== Driver ============================
;============================================================

public defn to-tgpackage (dec-table:DecTable, pkg:KPackage) -> TGPackage :
  fatal("Not yet implemented.")

;============================================================
;================= Expression Compilation ===================
;============================================================

;=======================
;===== Convenience =====
;=======================

;Convenience functions
defn imm (c:CExp) :
  val xs = imms(c)
  fatal("Not a single immediate.") when length(xs) != 1
  head(xs)

defn imm? (c:TGImm|CExp) :
  match(c) :
    (c:TGImm) : c
    (c:CExp) : imm(c)

defn imms? (c:TGImm|CExp) :
  match(c) :
    (c:TGImm) : List(c)
    (c:CExp) : imms(c)

defn set (n:Int, c:CExp) :
  set(List(n), c)

;======================================
;===== Compiled Expression System =====
;======================================
;Minimum implementation: set, ignore, types
;Custom return behaviour: implement return

deftype CExp
defmulti set (ns:List<Int>, c:CExp) -> False
defmulti ignore (c:CExp) -> False
defmulti types (c:CExp) -> List<TGType>
defmulti return (c:CExp) -> False
defmulti imms (c:CExp) -> List<TGImm>

;Default implementation of imms defined in terms of set
defmethod imms (c:CExp) :
  val ts = types(c)
  val ns = map(fresh-id{}, ts)
  do(emit{TGDef(_, _)}, ns, ts)
  set(ns, c)
  map(TGVar, ns)

;Default implementation of return in terms of imms
defmethod return (c:CExp) :
  emit(TGReturn(imms(c)))

;======================
;===== Immediates =====
;======================
;Minimum implementation: imms, types
deftype CImm <: CExp

defmethod set (ns:List<Int>, c:CImm) :
  for (n in ns, x in imms(c)) do :
    emit(TGSet(TGVar(n), x))

defmethod ignore (c:CImm) :
  imms(c)
  false

;======================
;===== Ignorables =====
;======================
;Implements: ignore

deftype Ignorable
defmethod ignore (c:CExp&Ignorable) : false

;===========================================
;===== Compiled Body Expression System =====
;===========================================
;Minimum implementation: body

;Compile the environment and then return the compiled body
deftype CBody <: CExp
defmulti body (c:CBody) -> CExp

defmethod set (ns:List<Int>, c:CBody) : set(ns, body(c))
defmethod ignore (c:CBody) : ignore(body(c))
defmethod return (c:CBody) : return(body(c))
defmethod types (c:CBody) : types(body(c))
defmethod imms (c:CBody) : imms(body(c))

;=============================================
;===== Compiled Bodies Expression System =====
;=============================================
;Minimum implementation: compile, types

deftype CBodies <: CExp
defmulti compile (c:CBodies, kont: CExp -> False, end?:True|False) -> False

defmethod set (ns:List<Int>, c:CBodies) : compile(c, set{ns, _}, false)
defmethod ignore (c:CBodies) : compile(c, ignore, false)
defmethod return (c:CBodies) : compile(c, return, true)

;====================================
;===== Compiled Location System =====
;====================================
deftype CLoc
defstruct PtrLoc <: CLoc :
  base: CExp
  offset: Int
defstruct VarLoc <: CLoc :
  n: Int
  index: Int
defstruct ExpLoc <: CLoc :
  base: CExp
  index: Int

;====================
;===== Compiler =====
;====================

deftype Compiler

defn Compiler (dec-table:DecTable) :
  ;Context
  val imm-table = IntTable<List<TGImm>>()
  val type-table = IntTable<List<TGType>>()
  val block-arg-table = IntTable<List<List<Int>>>()
  var use-tail-calls? = false

  ;Commonly used quantities
  val false-marker = TGLong(bit-representation(false))

  ;Utilities
  ;Allocate a structure to store a list of word quantities.
  defn calloc (fields:List<TGImm|CExp>, info:False|FileInfo) :
    val n = length(fields)
    calloc(8 * n, to-list(0 to 8 * n by 8), fields, info)

  ;Allocate a structure to store fields with given total size and offsets.
  defn calloc (#size:Int, offsets:List<Int>, fields:List<TGImm|CExp>, info:False|FileInfo) :
    new CExp :
      defmethod types (this) :
        List(TGRefT())
      defmethod set (ns:List<Int>, this) :
        fatal("Not a single immediate.") when length(ns) != 1
        val n = head(ns)
        val fs = seq-append(imms?,fields)
        val size = ceil8(#size)
        allocate-ref(n, size, info)
        for (f in fs, o in offsets) do :
          emit(TGStore(TGVar(n), f, o - REF-TAG-BITS))
      defmethod ignore (this) :
        do(ignore, filter-by<CExp>(fields))

  ;Allocate an array to store fields with given size and offsets.
  ;Tag of the array must be in fields[0]. Length must be fields[1].
  defn carray (size:Int, rest-size:Int, offsets:Seqable<Int>, fields:List<TGImm|CExp>, info:False|FileInfo) :
    new CExp :
      defmethod types (this) :
        List(TGRefT())
      defmethod set (ns:List<Int>, this) :
        fatal("Not a single immediate.") when length(ns) != 1
        val n = head(ns)
        ;Evaluate fields
        val fs = seq-append(imms?,fields)
        ;Compute length
        val len = make-var(TGLongT())
        emit(TGBinOp(len, TGMulOp(), fs[1], TGLong(to-long(rest-size))))
        emit(TGBinOp(len, TGAddOp(), len, TGLong(to-long(size + 7))))
        emit(TGBinOp(len, TGAndOp(), len, TGLong(-8L)))
        ;Allocate array
        allocate-ref(n, len, info)
        ;Store fields
        for (f in fs, o in offsets) do :
          emit(TGStore(TGVar(n), f, o - REF-TAG-BITS))
      defmethod ignore (this) :
        do(ignore, filter-by<CExp>(fields))

  ;Allocate a tuple
  defn ctuple (args:List<CExp|TGImm>, info:False|FileInfo) :
    val len = length(args)
    calloc{_, info} $ qquote(
      ~ TGTag(TUPLE-TYPE-ID)
      ~ TGLong(to-long(len))
      ~@ args)

  ;Get the offset of a field
  defn foffset (n:Int) :
    field-offset(dec-table, n) + 8 - REF-TAG-BITS


  ;==================================
  ;===== Expression Compilation =====
  ;==================================
  defn cexp (e:KExp) -> CExp :
    match(e) :
      (e:KLet) :
        new CBody :
          defmethod body (this) :
            val v = cexp(value(e))
            val ts = types(v)
            imm-table[n(e)] = imms(v)
            type-table[n(e)] = ts
            cexp(body(e))
      (e:KLetVar) :
        new CBody :
          defmethod body (this) :
            val ts = tgt-types(dec-table, type(e))
            val xs = map(make-var, ts)
            imm-table[n(e)] = xs
            type-table[n(e)] = ts
            attempt: set(map(n,xs), cexp(value(e) as? KExp))
            cexp(body(e))
      (e:KLetRec) :
        new CBody :
          defmethod body (this) :
            ;Compile all arguments to closures
            val argss = for c in values(e) as List<KClosure> map :
              to-list $ cat-all $ [
               [TGTag(FN-TYPE-ID)
                TGLong(to-long(length(targs(c)) + length(args(c))))
                TGMem(n(c), 0)]
                seq(imm{ctype(_)}, targs(c))
                seq(imm{cexp(_)}, args(c))]
            ;Allocate closures
            do(emit{TGDef(_, TGRefT())}, ns(e))
            val sizes = map({8 * length(_)}, argss)
            allocate-refs(ns(e), sizes, info(c0)) where :
              val c0 = head(values(e)) as KClosure
            ;Store arguments
            for (n in ns(e), args in argss) do :
              for (x in args, i in 0 to false) do :
                emit(TGStore(TGVar(n), x, 8 * i - REF-TAG-BITS))
            ;Continue with body
            cexp(body(e))
      (e:KVar) :
        if global?(dec-table, n(e)) :
          val t = var-type(dec-table, n(e))
          new CExp & Ignorable :
            defmethod types (this) :
              tgt-types(dec-table,t)
            defmethod set (xs:List<Int>, this) :
              for (x in xs, o in field-offsets(dec-table,t)) do :
                val m = global-mem(dec-table, n(e))
                emit(TGLoad(TGVar(x), m, o))
        else :
          new CImm & Ignorable :
            defmethod types (this) : type-table[n(e)]
            defmethod imms (this) : imm-table[n(e)]
      (e:KSet) :
        val type = fatal("Huh?")
        new CImm :
          defmethod types (this) :
            List(TGRefT())
          defmethod imms (this) :
            match(cloc(exp(e))) :
              (l:PtrLoc) :
                val p = imm(base(loc))
                val vs = imms(cexp(value(e)))
                val os = field-offsets(dec-table, type)
                for (v in vs, o in os) do :
                  emit(TGStore(p, y, o + offset(l)))
              (l:VarLoc) :
                val base = imm-table[n(l)] as List<TGVar>
                val len = length(dec-table, type)
                val xs = headn(tailn(base, index(l)), len)
                set(map(n,xs), cexp(value(e)))
            List(false-marker)
      (e:KTuple) :
        ;Big Tuples
        val len = length(exps(e))
        if len > 32 :
          new CExp :
            defmethod types (this) :
              List(TGRefT())
            defmethod set (ns:List<Int>, this) :
              val n = head(ns)
              emit(TGCall(1, ret, f, len, info(e), false)) where :
                val ret = List(TGVar(n))
                val f = TGMem(VOID-TUPLE-ID)
                val len = List(TGLong(to-long(len)))
              for (e in exps(e), i in 0 to false) do :
                val offset = 8 * i + foffset(TUPLE-ITEMS-FIELD-ID)
                emit(TGStore(TGVar(n), imm(cexp(e)), offset))
            defmethod ignore (this) :
              do(ignore{cexp(_)}, exps(e))
        ;Small Tuples
        else :
          ctuple(map(cexp,exps(e)), info(e))
      (e:KTupleGet) :
        val o = cexp(exp(e))
        new CExp :
          defmethod types (this) :
            List(TGRefT())
          defmethod set (ns:List<Int>, this) :
            val offset = 8 * index(e) + foffset(TUPLE-ITEMS-FIELD-ID)
            emit(TGLoad(TGVar(n), imm(o), offset))
          defmethod ignore (this) :
            ignore(o)
      (e:KEnsureLength) :
        new CImm :
          defmethod types (this) :
            List(TGRefT())
          defmethod imms (this) :
            val lbl = fresh-id()
            val o = imm(cexp(exp(e)))
            val len = make-var(TGLongT())
            val exp-len = TGLong(to-long(length(e)))
            emit(TGLoad(len, o, 8 - REF-TAG-BITS))
            emit(TGBinCmp(lbl, TGEqOp(), len, exp-len))
            emit(TGCall(2, List(), TGMem(TUPLE-LENGTH-ERROR-ID), List(len, exp-len), info(e), true))
            emit(TGLabel(lbl))
            List(o)
      (e:KObject) : ;(n:Int, args:List<KExp>, info:False|FileInfo)
        ;Marker object
        if empty?(args(e)) :
          new CImm :
            defmethod types (this) :
              List(TGRefT())
            defmethod imms (this) :
              List(TGTag(n(e), true))
        ;Allocated object
        else :
          val size = 8 + size(dec-table, n(e))
          val offsets = cons(0, map({8 + _}, field-offsets(dec-table, n(e))))
          val fields = cons(TGTag(n(e)), map(cexp, args(e)))
          calloc(size, offsets, fields, info(e))
      (e:KArray) :
        val size = 8 + size(dec-table, n(e))
        val rest-size = rest-size(dec-table, n(e))
        val offsets = cat([0], seq({8 + _}, field+rest-offsets(dec-table, n(e))))
        val fields = cons(TGTag(n(e)), map(cexp, args(e)))
        carray(size, rest-size, offsets, fields, info(e))
      (e:KStruct) :
        new CImm :
          defmethod types (this) :
            tgt-types(dec-table, n(e))
          defmethod imms (this) :
            seq-append(imms{cexp(_)}, args(e))
      (e:KPtr) : 
        val l = cloc(loc(e)) as PtrLoc
        if offset(l) == 0 :
          base(l)
        else :
          new CExp :
            defmethod types (this) :
              List(TGLongT())
            defmethod set (ns:List<Int>, this) :
              set(ns, base(l))
              val x = TGVar(head(ns))
              val off = TGLong(to-long(offset(l)))
              emit(TGBinOp(x, TGAddOp(), x, off))
            defmethod ignore (this) :
              ignore(base(l))
      (e:KDo) :
        ;Utilities
        defn code (f:TGImm) :
          val x = make-var(TGLongT())
          emit(TGLoad(x, f, foffset(FN-CODE-FIELD-ID)))
          x
        defn make-call (f:TGImm|CExp, arity:Int, args:List<TGImm|CExp>) :
          new CExp :
            defmethod types (this) :
              tgt-types(dec-table, type(e))
            defmethod set (ns:List<Int>, this) :
              val xs = map(TGVar, ns)
              val args* = seq-append(imms?,args)
              emit(TGCall(arity, xs, imm?(f), args*, info(e), false))
            defmethod return (this) :
              if use-tail-calls? :
                val args* = seq-append(imms?,args)
                emit(TGTCall(arity, imm?(f), args*))                
              else :
                emit(TGReturn(imms(this)))
            defmethod ignore (this) :
              set(List(), this)
        ;Cases
        defn call-pointer (p:KExp, args:List<KExp>) :
          make-call(p, map(cexp, args))
        defn call-closure-w-code (c:KExp, n:Int, targs:List<KType>, args:List<KExp>) :
          val args* = append-all $ [[cexp(c)], map(cexp, targs), map(cexp, args)]
          make-call(global-mem(dec-table,n), length(args), args*)
        defn call-closure-wo-code (c:KExp, targs:List<KType>, args:List<KExp>) :
          val c* = imm(cexp(c))
          val args* = append-all $ [[c*], map(cexp,targs), map(cexp,args)]
          make-call(code(c*), length(args), args*)        
        defn call-label (n:Int, targs:List<KType>, args:List<KExp>) :
          val args* = append(map(cexp,targs), map(cexp,args))
          make-call(global-mem(dec-table,n), length(args), args*)
        ;Categorize
        match(func(e)) :
          (f:KVar) :
            if function?(dec-table, n(f)) :
              call-label(n(f), targs(e), args(e))
            else if closure?(dec-table, n(f)) :
              val n = closure-code(dec-table, n(f))
              call-closure-w-code(n, targs(e), args(e))
            else :
              call-closure-wo-code(f, targs(e), args(e))
          (f:KDeptr) : call-pointer(exp(f), args(e))
          (f:KExp) : call-closure-wo-code(f, targs(e), args(e))        
      (e:KDoC) :
        defn make-call (f:TGImm|CExp, args:List<TGImm|CExp>, varargs:List<TGImm|CExp>) :
          new CExp :
            defmethod types (this) :
              tgt-types(dec-table, type(e))
            defmethod set (ns:List<Int>, this) :
              val xs = map(TGVar, ns)
              val args* = seq-append(imms?, args)
              val varargs* = seq-append(imms?, varargs)
              emit(TGCallC(xs, imm?(f), args*, varargs*))
            defmethod ignore (this) :
              set(List(), this)
        ;Categorize
        val f* = match(func(e)) :
          (f:KDeptr) : cexp(exp(f))
          (f:KVar) : global-mem(dec-table, n(f))
        make-call(f*, map(cexp,args(e)), map(cexp,varargs(e)))            
      (e:KLSLiteral) : 
        match(value(e)) :
          (v:Char|Byte|Int|Long|True|False|String) :
            new CImm & Ignorable :
              defmethod types (this) :
                List $ match(v) :
                  (v:Byte) : TGByteT()
                  (v:Char) : TGByteT()
                  (v:Int) : TGIntT()
                  (v:Long) : TGLongT()
                  (v:String) : TGLongT()
              defmethod imms (this) :
                List $ match(v) :
                  (v:Char) : TGByte(to-byte(v))
                  (v:Byte) : TGByte(v)
                  (v:Int) : TGInt(v)
                  (v:Long) : TGLong(v)
                  (v:True) : TGLong(bit-representation(v))
                  (v:False) : TGLong(bit-representation(v))
                  (v:String) :
                    val c = fresh-id()
                    emit(TGDefData(c, v))
                    TGMem(c,0)
          (v:Float|Double) :
            new CExp & Ignorable :
              defmethod types (this) :
                List $ match(v) :
                  (v:Float) : TGFloatT()
                  (v:Double) : TGDoubleT()
              defmethod set (ns:List<Int>, this) :
                val x = TGVar(head(ns))
                match(v) :
                  (v:Float) :
                    emit(TGInterpret(x, TGInt(bits(v))))
                  (v:Double) :
                    val c = fresh-id()
                    emit(TGDefData(c, v))
                    emit(TGLoad(x, TGMem(c,0), 0))
      (e:KLiteral) :
        new CImm & Ignorable :
          defmethod types (this) :
            List(TGRefT())
          defmethod imms (this) :
            List(TGLong(bit-representation(value(e))))            
      (e:KInterpret) :
        new CExp :
          defmethod types (this) :
            List $ match(type(e)) :
              (t:KByteT) : TGByteT()
              (t:KIntT) : TGIntT()
              (t:KLongT) : TGLongT()
              (t:KFloatT) : TGFloatT()
              (t:KDoubleT) : TGDoubleT()
              (t:KPtrT) : TGLongT()
              (t) : TGRefT()
          defmethod set (ns:List<Int>, this) :
            set(ns, cexp(exp(e)))
          defmethod ignore (this) :
            ignore(cexp(exp(e)))
      (e:KConv) :
        new CExp :
          defmethod types (this) :
            List $ match(type(e)) :
              (t:KByteT) : TGByteT()
              (t:KIntT) : TGIntT()
              (t:KLongT) : TGLongT()
              (t:KFloatT) : TGFloatT()
              (t:KDoubleT) : TGDoubleT()
              (t:KPtrT) : TGLongT()
              (t) : TGRefT()
          defmethod set (ns:List<Int>, this) :
            val x = TGVar(head(ns))
            emit(TGConv(x, imm(cexp(exp(e)))))
          defmethod ignore (this) :
            ignore(cexp(exp(e)))
      (e:KCheck) : 
        new CImm :
          defmethod types (this) :
            List(TGRefT())
          defmethod imms (ns:List<Int>, this) :
            val pass-lbl = fresh-id()
            val fail-lbl = fresh-id()
            val obj = imm(cexp(exp(e)))
            val t = inlined-type(dec-table, type(e))
            compile-typeof(obj, t, pass-lbl, fail-lbl, head{imm-table[_]})
            ;Emit fail code
            emit(TGLabel(fail-lbl))
            val targ* = imm(cexp(type(e)))
            tcall(CAST-ERROR-ID, List(TGInt(option(e)), obj, targ*), info(e))
            ;Emit pass code
            emit(TGLabel(pass-lbl))
            List(obj)            
      (e:KAndExp) : 
        new CExp :
          defmethod types (this) :
            List(TGLongT())
          defmethod set (ns:List<Int>, this) :
            val x = TGVar(head(ns))
            val done-lbl = fresh-id()
            set(ns, cexp(a(e)))
            emit(TGBinCmp(done-lbl, TGEqOp(), x, TGLong(0L)))
            set(ns, cexp(b(e)))
            emit(TGLabel(done-lbl))            
      (e:KOrExp) :
        new CExp :
          defmethod types (this) :
            List(TGLongT())
          defmethod set (ns:List<Int>, this) :
            val x = TGVar(head(ns))
            val done-lbl = fresh-id()
            set(ns, cexp(a(e)))
            emit(TGBinCmp(done-lbl, TGNeOp(), x, TGLong(0L)))
            set(ns, cexp(b(e)))
            emit(TGLabel(done-lbl))
      (e:KIf) :
        val conseq-exp = cexp(conseq(e))
        val alt-exp = cexp(alt(e))
        new CBodies :
          defmethod types (this) :
            types(conseq-exp)
          defmethod compile (this, kont:CExp -> False, end?:True|False) :
            val false-lbl = fresh-id()
            val done-lbl = fresh-id()
            val p = imm(cexp(pred(e)))
            emit(TGBinCmp(false-lbl, TGEqOp(), p, TGLong(0L)))
            kont(conseq-exp)
            emit(TGGoto(done-lbl)) when not end?
            emit(TGLabel(false-lbl))
            kont(alt-exp)
            emit(TGLabel(done-lbl)) when not end?
      (e:KPrim) :
        ;Utilities
        defn binop (x:TGVar, op:TGOp, a:TGImm, b:TGImm) :
          emit(TGBinOp(x, op, a, b))
        defn binop (n:Int, op:TGOp, a:TGImm, b:TGImm) :
          binop(TGVar(n), op, a, b)
        defn unaop (x:TGVar, op:TGOp, a:TGImm) :
          emit(TGUnaOp(x, op, a))
        defn unaop (n:Int, op:TGOp, a:TGImm) :
          unaop(TGVar(n), op, a)
        defn detag-int (y:TGImm) :
          val x = make-var(TGLongT())
          binop(x, TGAshrOp(), y, TGLong(32L))
          x
        defn detag-char (y:TGImm) :
          val x = make-var(TGLongT())
          val b = make-var(TGByteT())
          binop(x, TGShrOp(), y, TGLong(3L))
          emit(TGConv(b,x))
          b
        defn tag-as-bool (x:TGVar, y:TGImm) :
          binop(x, TGShlOp(), y, TGLong(3L))
          binop(x, TGAddOp(), x, TGLong(to-long(MARKER-TAG-BITS)))
        defn tag-as-char (x:TGVar, y:TGImm) :
          emit(TGConv(x,y))
          binop(x, TGShlOp(), x, TGLong(3L))
          binop(x, TGAddOp(), x, TGLong(to-long(CHAR-TAG-BITS)))

        ;Dispatch
        match(op(e)) :
          (op:Primitive) :
            switch contains?{_, op} :
              BINARY-OPS :
                val a = cexp(args(e)[0])
                val b = cexp(args(e)[1])
                new CExp :
                  defmethod types (this) :
                    List(TGRefT())
                  defmethod set (ns:List<Int>, this) :
                    val n = head(ns)
                    val a = imm(a)
                    val b = imm(b)
                    switch(op) :
                      ADD-OP :
                        binop(n, TGAddOp(), a, b)
                      SUB-OP :
                        binop(n, TGSubOp(), a, b)
                      MUL-OP :
                        binop(n, TGMulOp(), detag-int(a), b)
                      DIV-OP :
                        val x = make-var(TGLongT())
                        binop(x, TGDivOp(), a, b)
                        binop(n, TGShlOp(), x, TGLong(32L))
                      MOD-OP :
                        binop(n, TGModOp(), a, b)
                      AND-OP :
                        binop(n, TGAndOp(), a, b)
                      OR-OP :
                        binop(n, TGOrOp(), a, b)
                      XOR-OP :
                        binop(n, TGXorOp(), a, b)
                      SHL-OP :
                        binop(n, TGShlOp(), a, detag-int(b))
                      SHR-OP :
                        val x = make-var(TGLongT())
                        binop(x, TGShrOp(), a, detag-int(b))
                        binop(x, TGShrOp(), x, TGLong(32L))
                        binop(n, TGShlOp(), x, TGLong(32L))
                      ASHR-OP :
                        val x = make-var(TGLongT())
                        binop(x, TGAshrOp(), a, detag-int(b))
                        binop(x, TGShrOp(), x, TGLong(32L))
                        binop(n, TGShlOp(), x, TGLong(32L))
                      EQ-OP :
                        binop(n, TGEqOp(), a, b)
                        tag-as-bool(TGVar(n), TGVar(n))
                      NE-OP :
                        binop(n, TGNeOp(), a, b)
                        tag-as-bool(TGVar(n), TGVar(n))
                      LT-OP :
                        binop(n, TGLtOp(), a, b)
                        tag-as-bool(TGVar(n), TGVar(n))
                      GT-OP :
                        binop(n, TGGtOp(), a, b)
                        tag-as-bool(TGVar(n), TGVar(n))
                      LE-OP :
                        binop(n, TGLeOp(), a, b)
                        tag-as-bool(TGVar(n), TGVar(n))
                      GE-OP :
                        binop(n, TGGeOp(), a, b)
                        tag-as-bool(TGVar(n), TGVar(n))
                      IDENTICAL-OP :
                        binop(n, TGEqOp(), a, b)
                        tag-as-bool(TGVar(n), TGVar(n))
                      AGET-OP :
                        val o = make-var(TGLongT())
                        binop(o, TGAshrOp(), b, TGLong(32L - 3L))
                        binop(o, TGAddOp(), o, a)
                        emit(TGLoad(TGVar(n), o, foffset(RAWARRAY-ITEMS-FIELD-ID)))
                      CHAR-AGET-OP :
                        val o = make-var(TGLongT())
                        val c = make-var(TGByteT())
                        binop(o, TGAshrOp(), b, TGLong(32L))
                        binop(o, TGAddOp(), o, a)
                        emit(TGLoad(c, o, foffset(CHARARRAY-CHARS-FIELD-ID)))
                        tag-as-char(TGVar(n), c)
                      STRING-GET-OP :
                        val o = make-var(TGLongT())
                        val c = make-var(TGByteT())
                        binop(o, TGAshrOp(), b, TGLong(32L))
                        binop(o, TGAddOp(), o, a)
                        emit(TGLoad(c, o, foffset(STRING-CHARS-FIELD-ID)))
                        tag-as-char(TGVar(n), c)
                  defmethod ignore (this) :
                    ignore(a)
                    ignore(b)
              UNARY-OPS :
                val a = cexp(head(args(e)))
                new CExp :
                  defmethod types (this) :
                    List(TGRefT())
                  defmethod set (ns:List<Int>, this) :
                    val n = head(ns)
                    val a = imm(a)
                    switch(op) :
                      NOT-OP :
                        val x = make-var(TGLongT())
                        unaop(x, TGNotOp(), a)
                        binop(x, TGShrOp(), x, TGLong(32L))
                        binop(n, TGShlOp(), x, TGLong(32L))
                      NEG-OP :
                        unaop(n, TGNegOp(), a)
                      ALEN-OP :
                        emit(TGLoad(TGVar(n), a, 8 - REF-TAG-BITS))
                        binop(n, TGShlOp(), TGVar(n), TGLong(32L))
                      STRING-LEN-OP :
                        emit(TGLoad(TGVar(n), a, 8 - REF-TAG-BITS))
                        binop(n, TGShlOp(), TGVar(n), TGLong(32L))
                  defmethod ignore (this) :
                    ignore(a)
              EFFECTFUL-TERNARY-OPS :
                val a = cexp(args(e)[0])
                val b = cexp(args(e)[1])
                val c = cexp(args(e)[2])
                new CImm :
                  defmethod types (this) :
                    List(TGRefT())
                  defmethod imms (this) :
                    val a = imm(a)
                    val b = imm(b)
                    val c = imm(c)
                    switch(op) :
                      ASET-OP :
                        val o = make-var(TGLongT())
                        binop(o, TGAshrOp(), b, TGLong(32L - 3L))
                        binop(o, TGAddOp(), o, a)
                        emit(TGStore(o, c, foffset(RAWARRAY-ITEMS-FIELD-ID)))
                      CHAR-ASET-OP :
                        val o = make-var(TGLongT())
                        binop(o, TGAshrOp(), b, TGLong(32L))
                        binop(o, TGAddOp(), o, a)
                        emit(TGStore(o, detag-char(c), foffset(CHARARRAY-CHARS-FIELD-ID)))
                    List(false-marker)
          (op:GetterPrimitive) :
            if op == GET-SP-OP :
              new CImm & Ignorable :
                defmethod types (this) : List(TGLongT())
                defmethod imms (this) : List(TGRegSP())
            else :
              new CExp & Ignorable :
                defmethod types (this) :
                  tgt-types(dec-table, type(e))
                defmethod set (ns:List<Int>, this) :
                  val x = TGVar(head(ns))
                  val p = TGMem(lbl(op),0)
                  emit(TGLoad(x, p, 0))               
          (op:AddrPrimitive) :
            new CImm & Ignorable :
              defmethod types (this) : List(TGLongT())
              defmethod imms (this) : List(TGMem(lbl(op),0))
          (op:SetterPrimitive) :
            val a = cexp(head(args(e)))
            new CImm :
              defmethod types (this) :
                List(TGLongT())
              defmethod imms (this) :
                val p = TGMem(lbl(op),0)
                emit(TGStore(p, imm(a), 0))
                List(TGLong(0L))
          (op:LSPrimitive) :
            if op == LS-YIELD-OP :
              val s = cexp(args(e)[0])
              val y = cexp(args(e)[1])
              new CExp :
                defmethod types (this) :
                  List(TGRefT())
                defmethod set (ns:List<Int>, this) :
                  val x = TGVar(head(ns))
                  emit(TGSwitchStack(x, imm(s), imm(y)))
                defmethod ignore (this) :
                  val x = make-var(TGRefT())
                  set(n(x), this)
            else :
              switch contains?{_, op} :
                LS-BINARY-OPS :
                  val a = cexp(args(e)[0])
                  val b = cexp(args(e)[1])
                  new CExp :
                    defmethod types (this) :
                      switch(op) :
                        LS-ADD-OP : types(a)
                        LS-SUB-OP : types(a)
                        LS-MUL-OP : types(a)
                        LS-DIV-OP : types(a)
                        LS-MOD-OP : types(a)
                        LS-AND-OP : types(a)
                        LS-OR-OP : types(a)
                        LS-XOR-OP : types(a)
                        LS-SHL-OP : types(a)
                        LS-SHR-OP : types(a)
                        LS-ASHR-OP : types(a)
                        LS-EQ-OP : List(TGLongT())
                        LS-NE-OP : List(TGLongT())
                        LS-LT-OP : List(TGLongT())
                        LS-GT-OP : List(TGLongT())
                        LS-LE-OP : List(TGLongT())
                        LS-GE-OP : List(TGLongT())
                        LS-ULT-OP : List(TGLongT())
                        LS-UGT-OP : List(TGLongT())
                        LS-ULE-OP : List(TGLongT())
                        LS-UGE-OP : List(TGLongT())
                    defmethod set (ns:List<Int>, this) :
                      val op* = switch(op) :
                        LS-ADD-OP : TGAddOp()
                        LS-SUB-OP : TGSubOp()
                        LS-MUL-OP : TGMulOp()
                        LS-DIV-OP : TGDivOp()
                        LS-MOD-OP : TGModOp()
                        LS-AND-OP : TGAndOp()
                        LS-OR-OP : TGOrOp()
                        LS-XOR-OP : TGXorOp()
                        LS-SHL-OP : TGShlOp()
                        LS-SHR-OP : TGShrOp()
                        LS-ASHR-OP : TGAshrOp()
                        LS-EQ-OP : TGEqOp()
                        LS-NE-OP : TGNeOp()
                        LS-LT-OP : TGLtOp()
                        LS-GT-OP : TGGtOp()
                        LS-LE-OP : TGLeOp()
                        LS-GE-OP : TGGeOp()
                        LS-ULT-OP : TGUltOp()
                        LS-UGT-OP : TGUgtOp()
                        LS-ULE-OP : TGUleOp()
                        LS-UGE-OP : TGUgeOp()
                      val x = TGVar(head(ns))
                      emit(TGBinOp(x, op*, imm(a), imm(b)))
                    defmethod ignore (this) :
                      ignore(a)
                      ignore(b)
                LS-UNARY-OPS :
                  val a = cexp(head(args(e)))
                  new CExp :
                    defmethod types (this) :
                      switch(op) :
                        LS-NOT-OP : types(a)
                        LS-NEG-OP : types(a)
                        LS-BITS-OP : List(TGIntegerT(head(types(a)) as TGRealT))
                        LS-FNUM-OP : List(TGRealT(head(types(a)) as TGIntegerT))
                    defmethod set (ns:List<Int>, this) :
                      val t = head(types(this))
                      val x = TGVar(head(ns))
                      switch(op) :
                        LS-NOT-OP :
                          emit(TGUnaOp(x, TGNotOp(), imm(a)))
                        LS-NEG-OP :
                          emit(TGUnaOp(x, TGNegOp(), imm(a)))
                        LS-BITS-OP :
                          emit(TGInterpret(x, imm(a)))
                        LS-FNUM-OP :
                          emit(TGInterpret(x, imm(a)))
                    defmethod ignore (this) :
                      ignore(a)
      (e:KSizeof) : 
        new CImm & Ignorable :
          defmethod types (this) :
            List(TGLongT())
          defmethod imms (this) :
            val size = size(dec-table, type(e))
            List(TGLong(to-long(size)))
      (e:KTagof) : 
        new CImm & Ignorable :
          defmethod types (this) : List(TGLongT())
          defmethod imms (this) : List(TGTag(n(e)))
      (e:KMatch|KDispatch) :
        ;Compiled bodies
        val bexps = map(cexp{body(_)}, branches(e))        
        new CBodies :
          defmethod types (this) :
            types(head(bexps))
          defmethod compile (this, kont:CExp -> False, end?:True|False) :
            val m-args = seq-append(imms{cexp(_)}, args(e))
            val bs = map(TGBranch{tags(_), fresh-id()}, branches(e))
            val done = fresh-id()
            val no-branch = fresh-id()            
            ;Emit error paths
            defn arg-tuple () : ctuple(m-args, info(e))
            match(e) :
              (e:KMatch) :
                emit(TGMatch(m-args, bs, no-branch))
                emit(TGLabel(no-branch))
                tcall(NO-BRANCH-ERROR-ID, imms(arg-tuple()), info(e))
              (e:KDispatch) :
                val amb-branch = fresh-id()
                emit(TGDispatch(m-args, bs, no-branch, amb-branch))
                ;Error branches
                emit(TGLabel(no-branch))
                tcall(NO-BRANCH-ERROR-ID, imms(arg-tuple()), info(e))
                emit(TGLabel(amb-branch))
                tcall(AMB-BRANCH-ERROR-ID, imms(arg-tuple()), info(e))
            ;Emit branch paths
            for (b in branches(e), id in seq(n,bs), body in bexps) do :
              emit(TGLabel(id))
              for (a in args(b), ma in m-args) do :
                imm-table[a] = List(TGVar(a))
                type-table[a] = List(TGRefT())
                emit(TGDef(a, TGRefT()))
                emit(TGSet(TGVar(a), ma))
              kont(body)
              emit(TGGoto(done)) when not end?
            emit(TGLabel(done)) when not end?
      (e:KLabels) :
        ;Create block args
        for b in blocks(e) do :
          val tss = map(tgt-types{dec-table, _}, types(b))
          val xss = map(map{make-var, _}, tss)
          for (a in args(b), xs in xss, ts in tss) do :
            imm-table[a] = xs
            type-table[a] = ts
          block-arg-table[n(b)] = map(map{n, _}, xss)
        ;Compile blocks
        val bexps = map(cexp{body(_)}, blocks(e))
        new CBodies :
          defmethod types (this) :
            types(head(bexps))
          defmethod compile (this, kont:CExp -> False, end?:True|False) :
            val end-lbl = fresh-id()
            for (b in blocks(e), body in bexps) do :
              emit(TGLabel(n(b)))
              kont(body)
              emit(TGGoto(end-lbl)) when not end?
            emit(TGLabel(end-lbl)) when not end?        
      (e:KSeq) : 
        new CBody :
          defmethod body (this) :
            ignore(cexp(a(e)))
            cexp(b(e))
      (e:KGoto) : 
        new CExp :
          defmethod types (this) :
            List(TGLongT())
          defmethod set (ns:List<Int>, this) :
            ignore(this)
          defmethod ignore (this) :
            val nss = block-arg-table[n(e)]
            val vs = seq(cexp, args(e))
            do(set, nss, vs)
            emit(TGGoto(n(e)))
      (e:KReturn) : 
        new CExp :
          defmethod types (this) :
            List(TGLongT())
          defmethod set (ns:List<Int>, this) :
            ignore(this)
          defmethod ignore (this) :
            return(cexp(exp(e)))            
      (e:KDeref|KDeptr|KField|KSlot) :
        match(cloc(e)) :
          (l:PtrLoc) :
            new CExp :
              defmethod types (this) :
                tgt-types(dec-table, type)
              defmethod set (ns:List<Int>, this) :
                val p = imm(base(l))
                for (n in ns, o in field-offsets(dec-table, type)) do :
                  emit(TGLoad(TGVar(n), p, offset(l) + o))
              defmethod ignore (this) :
                ignore(base(l))
          (l:ExpLoc) :
            new CImm :
              defmethod types (this) :
                tgt-types(dec-table, type)
              defmethod imms (this) :
                val xs = imms(base(l))
                val len = length(dec-table, type)
                headn(tailn(xs, index(l)), len)                
          (l:VarLoc) :
            new CImm & Ignorable :
              defmethod types (this) :
                tgt-types(dec-table, type)
              defmethod imms (this) :
                val xs = imm-table[n(l)]
                val len = length(dec-table, type)
                headn(tailn(xs, index(l)), len)
      (e:KEnsureSet) : 
        new CImm :
          defmethod types (this) :
            List(TGRefT())
          defmethod imms (this) :
            val lbl = fresh-id()
            val o = imm(cexp(exp(e)))
            emit(TGBinCmp(lbl, TGNeOp(), o, TGLong(to-long(VOID-TAG))))            
            emit(TGCall(0, List(), TGMem(VARIABLE-UNINITIALIZED-ERROR-ID), List(), info(e), true))
            emit(TGLabel(lbl))
            List(o)
      (e:KNewObject) : 
        if empty?(targs(e)) and empty?(args(e)) :
          new CImm & Ignorable :
            defmethod types (this) :
              List(TGRefT())
            defmethod imms (this) :
              List(TGTag(n(e), true))
        else :
          calloc{_, info(e)} $ qquote(
            ~ TGTag(n(e))
            ~@ map(cexp, targs(e))
            ~@ map(cexp, args(e)))
      (e:KObjectGet) : 
        val o = cexp(exp(e))
        new CExp :
          defmethod types (this) :
            List(TGRefT())
          defmethod set (ns:List<Int>, this) :
            val num-targs = object-tarity(dec-table, n(e))
            val x = TGVar(head(ns))
            val offset = 8 * (num-targs + index(e)) + 8 - REF-TAG-BITS
            emit(TGLoad(x, imm(o), offset))
          defmethod ignore (this) :
            ignore(o)          
      (e:KObjectTGet) : 
        val o = cexp(exp(e))
        new CExp :
          defmethod types (this) :
            List(TGRefT())
          defmethod set (ns:List<Int>, this) :
            val x = TGVar(head(ns))
            val offset = 8 * index(e) + 8 - REF-TAG-BITS
            emit(TGLoad(x, imm(o), offset))
          defmethod ignore (this) :
            ignore(o)                  
      (e:KLetType) : 
        new CBody :
          defmethod body (this) :
            val v = imm(cexp(value(e)))
            imm-table[n(e)] = List(v)
            cexp(body(e))
      (e:KBox) : 
        val v = match(exp(e)) :
          (e:KExp) : cexp(e)
          (e:False) : TGLong(to-long(VOID-TAG))
        calloc(List(TGTag(BOX-TYPE-ID), v), false)
      (e:KBoxGet) : 
        val box = cexp(exp(e))
        new CExp :
          defmethod types (this) :
            List(TGRefT())
          defmethod set (ns:List<Int>, this) :
            val x = TGVar(head(ns))
            emit(TGLoad(x, imm(box), foffset(BOX-ITEM-FIELD-ID)))
          defmethod ignore (this) :
            ignore(box)            
      (e:KBoxSet) :
        val box = cexp(exp(e))
        val value = cexp(value(e))
        new CImm :
          defmethod types (this) :
            List(TGRefT())
          defmethod imms (this) :
            emit(TGStore(imm(box), imm(value), foffset(BOX-ITEM-FIELD-ID)))
            List(false-marker)
      (e:KClosure) : 
        calloc{_, info(e)} $ qquote(
          ~ TGTag(FN-TYPE-ID)
          ~ TGLong(to-long(length(args(e))))
          ~ TGMem(n(e))
          ~@ map(cexp, targs(e))
          ~@ map(cexp, args(e)))
      (e:KTagPrim) : 
        val v = cexp(exp(e))
        new CExp :
          defmethod types (this) :
            List(TGRefT())
          defmethod set (ns:List<Int>, this) :
            val x = TGVar(head(ns))
            switch(n(e)) :
              BYTE-TYPE-ID :
                val y = make-var(TGLongT())
                emit(TGConv(y, imm(v)))
                emit(TGBinOp(y, TGShlOp(), y, TGLong(3L)))
                emit(TGBinOp(x, TGAddOp(), y, TGLong(to-long(BYTE-TAG-BITS))))
              CHAR-TYPE-ID :
                val y = make-var(TGLongT())
                emit(TGConv(y, imm(v)))
                emit(TGBinOp(y, TGShlOp(), y, TGLong(3L)))
                emit(TGBinOp(x, TGAddOp(), y, TGLong(to-long(CHAR-TAG-BITS))))
              INT-TYPE-ID :
                val y = make-var(TGLongT())
                emit(TGConv(y, imm(v)))
                emit(TGBinOp(x, TGShlOp(), y, TGLong(32L)))
              FLOAT-TYPE-ID :
                val y1 = make-var(TGIntT())
                emit(TGInterpret(y1, imm(v)))
                val y2 = make-var(TGLongT())
                emit(TGConv(y2, y1))
                emit(TGBinOp(y2, TGShlOp(), y2, TGLong(3L)))
                emit(TGBinOp(x, TGAddOp(), y2, TGLong(to-long(FLOAT-TAG-BITS))))            
          defmethod ignore (this) :
            ignore(v)
      (e:KDetagPrim) :
        val v = cexp(exp(e))
        new CExp :
          defmethod types (this) :
            List $ switch(n(e)) :
              BYTE-TYPE-ID : TGByteT()
              CHAR-TYPE-ID : TGByteT()
              INT-TYPE-ID : TGIntT()
              FLOAT-TYPE-ID : TGFloatT()
          defmethod set (ns:List<Int>, this) :
            val x = TGVar(head(ns))
            val y = make-var(TGLongT())
            set(List(n(y)), v)
            switch(n(e)) :
              BYTE-TYPE-ID :
                emit(TGBinOp(y, TGAshrOp(), y, TGLong(3L)))
                emit(TGConv(x, y))
              CHAR-TYPE-ID :
                emit(TGBinOp(y, TGAshrOp(), y, TGLong(3L)))
                emit(TGConv(x, y))
              INT-TYPE-ID :
                emit(TGBinOp(y, TGAshrOp(), y, TGLong(32L)))
                emit(TGConv(x, y))
              FLOAT-TYPE-ID :
                emit(TGBinOp(y, TGAshrOp(), y, TGLong(3L)))
                val y2 = make-var(TGIntT())
                emit(TGConv(y2, y))
                emit(TGInterpret(x, y2))            
          defmethod ignore (this) :
            ignore(v)

  ;============================
  ;===== Type Compilation =====
  ;============================
  defn ctype (t:KType) -> CExp :
    fatal("Not yet implemented.")

  ;================================
  ;===== Location Compilation =====
  ;================================
  defn cloc (e:KExp) -> CExp :
    fatal("Not yet implemented.")

  ;================================
  ;===== Function Compilation =====
  ;================================
  ;Compile function

  ;Return compiler
  new Compiler

;============================================================
;================ Compilation Utilities =====================
;============================================================

defn tcall (f:Int, args:List<TGImm>, i:False|FileInfo) :
  emit(TGCall(length(args), List(), TGMem(f,0), args, i, true))
defn tcall (f:Int, i:False|FileInfo) :
  tcall(f, List(), i)
defn call (f:Int, args:List<TGImm>, i:False|FileInfo) :
  emit(TGCall(length(args), List(), TGMem(f,0), args, i, false))
defn call (f:Int, i:False|FileInfo) :
  call(f, List(), i)
  
defn global-mem (dt:DecTable, n:Int) :
  match(extern-label(dt, n)) :
    (lbl:Symbol) : TGExMem(lbl,0)
    (lbl:False) : TGMem(n,0)

defn bit-representation (value) :
  match(value) :
    (value:Byte) : to-long(value) << 3L + to-long(BYTE-TAG-BITS)
    (value:Char) : to-long(to-int(value) << 3 + CHAR-TAG-BITS)
    (value:Int) : to-long(value) << 32L
    (value:Float) : to-long(bits(value)) << 3L + to-long(FLOAT-TAG-BITS)
    (value:True) : 1L << 3L + to-long(MARKER-TAG-BITS)
    (value:False) : to-long(MARKER-TAG-BITS)

val BINARY-OPS = [ADD-OP, SUB-OP, MUL-OP, DIV-OP, MOD-OP, AND-OP,
                  OR-OP, XOR-OP, SHL-OP, SHR-OP, ASHR-OP, EQ-OP, NE-OP,
                  LT-OP, GT-OP, LE-OP, GE-OP, IDENTICAL-OP, AGET-OP,
                  CHAR-AGET-OP, STRING-GET-OP]
val UNARY-OPS = [NOT-OP, NEG-OP, ALEN-OP, STRING-LEN-OP]
val EFFECTFUL-TERNARY-OPS = [ASET-OP, CHAR-ASET-OP]

val LS-BINARY-OPS = [LS-ADD-OP, LS-SUB-OP, LS-MUL-OP, LS-DIV-OP, LS-MOD-OP,
                     LS-AND-OP, LS-OR-OP, LS-XOR-OP, LS-SHL-OP, LS-SHR-OP,
                     LS-ASHR-OP, LS-EQ-OP, LS-NE-OP, LS-LT-OP, LS-GT-OP,
                     LS-LE-OP, LS-GE-OP, LS-ULT-OP, LS-UGT-OP, LS-ULE-OP, LS-UGE-OP]
val LS-UNARY-OPS = [LS-NOT-OP, LS-NEG-OP, LS-BITS-OP, LS-FNUM-OP]