defpackage stz/kform :
  import core
  import collections
  import stz/pl-ir
  import stz/kl-ir
  import stz/type-to-kform
  import stz/ids
  import stz/utils

;============================================================
;=================== Driver =================================
;============================================================

public defn compile (pkgs:List<KPackage>) :
  val dec-table = compute-declaration-table(pkgs)
  for input-pkg in pkgs do :
    var pkg = input-pkg
    vheader("Package %_" % [name(pkg)])
    println(pkg)
    pkg = map-method-targs(pkg)
    vheader("Package %_ : After Mapping Method Targs" % [name(pkg)])
    println(pkg)
    pkg = create-closures(dec-table, pkg)
    vheader("Package %_ : After Creating Closures" % [name(pkg)])
    println(pkg)
    ;pkg = convert-mixes(dec-table, pkg)
    ;vheader("Package %_ : After Converting Mixes" % [name(pkg)])
    ;println(pkg)
    ;pkg = guard-boundary(dec-table, pkg)
    ;vheader("Package %_ : After Guarding Boundaries" % [name(pkg)])
    ;println(pkg)

;============================================================
;=================== Method Targ Mapping ====================
;============================================================

defn inverse-solve (input-xs:List<Int>, input-targs:List<KTag>) ->
                   [List<Int>, Vector<KeyValue<Int,KTag>>] :
  ;Created targs
  val ys = map(fresh-id{}, input-targs)
  ;Simplify
  val targs = map(trivial-simplify, input-targs)
  ;Gather Solutions
  val solved = HashTable<Int,Int>()
  defn put (x:Int, y:Int) :
    (solved[x] = y) when not key?(solved, x)
  ;Precise Solutions
  for (t in targs, y in ys) do :
    match(t:KTVar) : put(n(t), y)
  ;Approximate Solutions
  for (t in targs, y in ys) do :
    let loop (t:KTag = t) :
      match(t) :
        (t:KTVar) : put(n(t), y)
        (t:KOr) : do(loop, t)
        (t) : false
  ;Track substitutions
  val subs = Vector<KeyValue<Int,KTag>>()
  ;Invert table
  for entry in solved do :
    val [x, y] = [key(entry), value(entry)]
    match(get?(solved, y)) :
      (x*:Int) : add(subs, x => KTVar(x*))
      (x*:False) : solved[y] = x
  ;Substitute unsolved targs
  for x in input-xs do :
    if not key?(solved, x) :
      add(subs, x => KTop())
  ;Compute new targs
  val output-ys = for y in ys map :
    get?(solved, y, y)
  ;Return
  [output-ys, subs]

defn replace-tvars (t:KTag, entries:Table<Int,KTag>) :
  defn ft (t:KTag) :
    match(t:KTVar) : get?(entries, n(t), t)
    else : map(ft,t)
  trivial-simplify(ft(t))

defn replace-tvars (t:KLSType, entries:Table<Int,KTag>) :
  defn ft (t:KLSType|KTag) :
    match(t) :
      (t:KTag) : replace-tvars(t, entries)
      (t:KLSType) : map-all(ft, t)
  ft(t) as KLSType

defn replace-tvars (e:KExp|KLSComm, entries:Table<Int,KTag>) -> KExp|KLSComm :
  defn ft (t:KTag|KLSType) :
    replace-tvars(t, entries)
  defn f (e:KComm|KExp|KLSComm|KLSExp|KLoc) :
    map-all(f, map-all(ft, e))
  f(e) as KExp|KLSComm

defn replace-tvars (f:KFn, entries:Vector<KeyValue<Int,KTag>>) :
  if empty?(entries) :
    f
  else :
    val entries = to-hashtable<Int,KTag>(entries)
    KFn(
      tail?(f),
      targs(f),
      map(replace-tvars{_, entries}, a1(f)),
      replace-tvars(a2(f), entries),
      args(f),
      replace-tvars(body(f), entries) as KExp)

defn replace-tvars (f:KLSFn, entries:Vector<KeyValue<Int,KTag>>) :
  if empty?(entries) :
    f
  else :
    val entries = to-hashtable<Int,KTag>(entries)
    KLSFn(
      tail?(f),
      targs(f),
      map(replace-tvars{_, entries}, a1(f)),
      replace-tvars(a2(f), entries),
      args(f),
      replace-tvars(body(f), entries) as KLSComm)

defn map-method (f:KDefmethod -> KDefmethod,
                 lsf:KLSDefmethod -> KLSDefmethod,
                 pkg:KPackage) -> KPackage :
  defn fm (c:KComm|KExp|KLSComm|KLSExp|KLoc) :
    match(map-all(fm,c)) :
      (c:KDefmethod) : f(c)
      (c:KLSDefmethod) : lsf(c)
      (c) : c
  KPackage(
    name(pkg)
    ids(pkg)
    map({fm(_) as KComm}, comms(pkg)))

defn map-method-targs (pkg:KPackage) :
  defn fm (m:KDefmethod) :
    val v = value(m)
    if empty?(targs(m)) and empty?(targs(v)) :
      m
    else :
      val [targs*, unsolved] = inverse-solve(targs(v), targs(m))
      val v* = let :
        val v = replace-tvars(v, unsolved)
        KFn(tail?(v), targs*, a1(v), a2(v), args(v), body(v))
      KDefmethod(multi(m), targs(m), thisn(m), v*)
  defn flm (m:KLSDefmethod) :
    val v = value(m)
    if empty?(targs(m)) and empty?(targs(v)) :
      m
    else :
      val [targs*, unsolved] = inverse-solve(targs(v), targs(m))
      val v* = let :
        val v = replace-tvars(v, unsolved)
        KLSFn(tail?(v), targs*, a1(v), a2(v), args(v), body(v))
      KLSDefmethod(multi(m), targs(m), v*)
  map-method(fm, flm, pkg)

;============================================================
;==================== Declaration Table =====================
;============================================================

deftype DecTable
defmulti global-function? (t:DecTable, n:Int) -> True|False
defmulti global? (t:DecTable, n:Int) -> True|False
defmulti function? (t:DecTable, n:Int) -> True|False
defmulti arity (t:DecTable, n:Int) -> Int
defmulti fn-types (t:DecTable, n:Int, targs:List<KTag>) -> [List<KTag>, KTag]
defmulti ls-fn-types (t:DecTable, n:Int, targs:List<KTag>) -> [List<KLSType>, KLSType]
defmulti lostanza? (t:DecTable, n:Int) -> True|False
defmulti tail? (t:DecTable, n:Int) -> True|False
defmulti voidable? (t:DecTable, n:Int) -> True|False

defn compute-declaration-table (pkgs:List<KPackage>) :
  val globals = HashTable<Int,True>()
  val table = HashTable<Int,KComm>()

  defn declaration? (c:KComm) -> Int|False :
    match(c:KDef|KDefVar|KDefn|KDefmulti|
            KLSDef|KLSDefVar|KLSDefn|KLSExternFn|KLSExtern) :
      n(c)
  defn scan (c:KComm|KExp|KLSComm|KLSExp|KLoc) :
    do-all(scan, c)
    match(c:KComm) :
      match(declaration?(c)) :
        (n:Int) : table[n] = c
        (n:False) : false

  ;Scan through commands
  for comm in seq-cat(comms, pkgs) do :
    scan(comm)
    match(declaration?(comm)) :
      (n:Int) : globals[n] = true
      (n:False) : false

  new DecTable :  
    defmethod global-function? (this, n:Int) :
      global?(this, n) and function?(this, n)
    defmethod global? (this, n:Int) :
      key?(globals,n)
    defmethod function? (this, n:Int) :
      get?(table,n) is KDefn|KDefmulti|KLSDefn
    defmethod tail? (this, n:Int) :
      match(table[n]) :
        (d:KDefn) : tail?(value(d))
        (d:KLSDefn) : tail?(value(d))
        (d:KDefmulti) : tail?(d)
    defmethod arity (this, n:Int) :
      match(table[n]) :
        (d:KDefn) : length(a1(value(d)))
        (d:KLSDefn) : length(a1(value(d)))
        (d:KDefmulti) : length(a1(d))
    defmethod fn-types (this, n:Int, type-args:List<KTag>) :
      val [tvars, a1, a2] = match(table[n]) :
        (d:KDefn) :
          val v = value(d)
          [targs(v), a1(v), a2(v)]            
        (d:KDefmulti) :
          [targs(d), a1(d), a2(d)]
        (d:KLSDefn) :
          val v = value(d)
          [targs(v), map(tag!, a1(v)), tag!(a2(v))]            
      val sub-table = to-hashtable<Int,KTag>(tvars,type-args)
      val a1* = map(replace-tvars{_, sub-table}, a1)
      val a2* = replace-tvars(a2, sub-table)
      [a1*, a2*]
    defmethod ls-fn-types (this, n:Int, type-args:List<KTag>) :
      val [tvars, a1, a2] = match(table[n]) :
        (d:KDefn) :
          val v = value(d)
          [targs(v), KRefTs(a1(v)), KRefT(a2(v))]            
        (d:KDefmulti) :
          [targs(d), KRefTs(a1(d)), KRefT(a2(d))]
        (d:KLSDefn) :
          val v = value(d)
          [targs(v), a1(v), a2(v)]
      val sub-table = to-hashtable<Int,KTag>(tvars,type-args)
      val a1* = map(replace-tvars{_, sub-table}, a1)
      val a2* = replace-tvars(a2, sub-table)
      [a1*, a2*]
    defmethod lostanza? (this, n:Int) :
      get?(table,n) is KLSDef|KLSDefVar|KLSDefn
    defmethod voidable? (this, n:Int) :
      match(get?(table, n)) :
        (d:KDef|KLSDef) : global?(this, n)
        (d:KDefVar|KLSDefVar) : global?(this, n) or value(d) is False
        (d) : false

;============================================================
;===================== Closure Creation =====================
;============================================================

defn map-closures (dec-table: DecTable
                   f: KMix|KCurry|KVar -> KAFn,
                   lf: KLSMix|KLSCurry|KLSVar -> KLSAFn,
                   pkg: KPackage) -> KPackage :
  defn f* (x:KComm|KExp|KLSComm|KLSExp|KLoc) :
    match(x) :
      (x:KMix|KCurry) :
        f(x)
      (x:KVar) :
        f(x) when global-function?(dec-table, n(x)) else x
      (x:KDo) :
        match(func(x)) :
          (f:KMix|KCurry|KVar) :
            KDo(f, map({f*(_) as KExp}, args(x)), a1(x), a2(x))
          (f) : map-all(f*,x)
      (x:KLSMix|KLSCurry) :
        lf(x)
      (x:KLSVar) :
        lf(x) when global-function?(dec-table, n(x)) else x
      (x:KLSCall) :
        match(func(x)) :
          (f:KLSMix|KLSCurry|KLSVar) : KLSCall(f, map({f*(_) as KLSExp}, args(x)), a1(x), a2(x))
          (f) : map-all(f*, x)
      (x) :
        map-all(f*, x)
  KPackage(
    name(pkg),
    ids(pkg),
    map({f*(_) as KComm}, comms(pkg)))      

defn mix-fn (dec-table: DecTable, f:KMix|KCurry|KVar) :
  defn make-fn (f:KExp, n:Int) :
    val args* = map(fresh-id{}, 0 to n)
    val body = KDo(f, KVars(args*), KTops(args*), KTop())
    KFn(true, List(), KTops(args*), KTop(), args*, body)

  match(f) :
    (f:KCurry|KVar) :
      make-fn(f, arity(dec-table, n(f)))
    (f:KMix) :
      val groups = to-hashtable<Int,List<KCurry|KVar>>(List())
      for exp in exps(f) do :
        val n = arity(dec-table, n(exp))
        groups[n] = cons(exp, groups[n])
      KMultifn{to-list(_)} $ for entry in groups seq :
        val [n, fs] = [key(entry), value(entry)]
        if length(fs) == 1 : make-fn(head(fs), n)
        else : make-fn(KMix(fs), n)

defn create-closures (dec-table: DecTable, pkg:KPackage) -> KPackage :
  defn to-exp (f:KLSExp) :
    match(f) :
      (f:KLSMix) : KMix(map({to-exp(_) as KCurry}, exps(f)))
      (f:KLSCurry) : KCurry(n(f), targs(f))
      (f:KLSVar) : KVar(n(f))
  map-closures(
    dec-table,
    fn (e) : KAFn(mix-fn(dec-table, e))
    fn (e) : KLSAFn(mix-fn(dec-table, to-exp(e)))
    pkg)

;;============================================================
;;==================== Mix Conversion ========================
;;============================================================
;
;defn map-mixes (f: KDo -> KExp,
;                lf: KLSCall -> KLSExp,
;                pkg: KPackage) -> KPackage :
;  defn fexp (e:KExp) -> KExp :
;    match(mapr(fexp, e)) :
;      (e:KDo) :
;        match(func(e):KMix) : f(e)
;        else : e
;      (e) : e
;  defn flsexp (e:KLSExp) -> KLSExp :
;    match(mapr(flsexp,e)) :
;      (e:KLSCall) :
;        match(func(e):KLSMix) : lf(e)
;        else : e
;      (e) : e
;  defn fcomm (c:KComm) -> KComm :
;    mapr(fexp, mapr(flsexp, c))
;  KPackage(
;    name(pkg),
;    ids(pkg),
;    map(fcomm, comms(pkg)))
;
;defn convert (dec-table:DecTable, e:KDo) :
;  ;Retrieve argument types for given function
;  defn arg-types (f:KCurry|KVar) :
;    val [a1, a2] = match(f) :
;      (f:KVar) : fn-types(dec-table, n(f), List())
;      (f:KCurry) : fn-types(dec-table, n(f), targs(f))
;    a1  
;  ;Create branches    
;  val bs = for f in exps(func(e) as KMix) map :
;    val args* = map(fresh-id{}, args(e))
;    val ts = arg-types(f)
;    KBranch(args*, ts, KDo(f, KVars(args*), KTops(args*), KTop()))
;  ;Create dispatch
;  KDispatch(args(e), bs)
;
;defn convert (dec-table:DecTable, e:KLSCall) :
;  defn pull-out-defs (e:KLSCall) :
;    val defs = Vector<KLSDefLocal>()
;    val args* = Vector<KLSVar>()
;    for (x in args(e), t in a1(e)) do :
;      match(x) :
;        (x:KLSVar) :
;          add(args*, x)
;        (x) :
;          val id = fresh-id()
;          add(defs, KLSDefLocal(id, t, x))
;          add(args*, KLSVar(id))
;    KLSLet(defs, make-dispatch(func(e) as KLSMix, to-list(args*), a1(e)))
;  defn make-dispatch (func:KLSMix, args:List<KLSVar>, ts:List<KLSType>) :
;    ;Splice ys into xs according to mask  
;    defn splice (mask:List<True|False>, xs:List<KLSVar>, ys:List<KLSVar>) :
;      val ys-seq = to-seq(ys)
;      for (x in xs, m in mask) map :
;        if m : next(ys-seq)
;        else : x
;    ;Retrieve argument types for given function
;    defn fn-types (f:KLSCurry|KLSVar) :
;      match(f) :
;        (f:KLSVar) : ls-fn-types(dec-table, n(f), List())
;        (f:KLSCurry) : ls-fn-types(dec-table, n(f), targs(f))
;    ;Compute mask
;    val refmask = map({_ is KRefT}, ts)
;    val refargs = select(args, refmask)
;    ;Create branches
;    val bs = for f in exps(func) map :
;      val args* = map(fresh-id{}, refargs)
;      val [a1, a2] = fn-types(f)
;      val tags = map(tag!,select(a1, refmask))
;      val call = KLSCall(f, splice(refmask, args, KLSVars(args*)), a1, a2)
;      KLSBranchExp(args*, tags, call)
;    ;Create dispatch
;    KLSDispatch(refargs, bs)
;  pull-out-defs(e)  
;
;defn convert-mixes (dec-table:DecTable, pkg:KPackage) -> KPackage :
;  map-mixes(
;    fn (e) : convert(dec-table, e)
;    fn (e) : convert(dec-table, e)
;    pkg)
;
;;============================================================
;;================= Boundary Guards ==========================
;;============================================================
;
;defn map-guards (fv: KVar -> KExp,
;                 fel: KEnsureLength -> KExp,
;                 fdef:KDef|KDefVar -> KDef|KDefVar,
;                 fdo:(KDo, True|False) -> KExp,
;                 fb:KBranch -> KBranch,
;                 ff:KFn -> KFn,
;                 pkg:KPackage) -> KPackage :
;  defn map-tail (f: (KExp, True|False) -> KExp, e:KExp, tailcall?:True|False) :
;    defn fb (b:KBranch) :
;      KBranch(args(b), tags(b), f(body(b), tailcall?))
;    match(e) :
;      (e:KLet) : KLet(def(e), f(body(e), tailcall?))
;      (e:KLetRec) : KLetRec(defs(e), f(body(e), tailcall?))
;      (e:KSeq) : KSeq(f(a(e), false), f(b(e), tailcall?))
;      (e:KMatch) : KMatch(map(f{_, false}, args(e)), map(fb, branches(e)))
;      (e:KDispatch) : KDispatch(map(f{_, false}, args(e)), map(fb, branches(e)))
;      (e) : map(f{_, false}, e)
;  defn ffunc (f:KFunc) :
;    match(f) :
;      (f:KFn) :
;        val body* = fexp(body(f), tail?(f))
;        ff(KFn(tail?(f), targs(f), a1(f), a2(f), args(f), body*))
;      (f:KMultifn) :
;        KMultifn $
;        map({ffunc(_) as KFn}, funcs(f))
;  defn fexp (e:KExp, t:True|False) :
;    match(map(fcomm, map-tail(fexp, e, t))) :
;      (e:KVar) : fv(e)
;      (e:KEnsureLength) : fel(e)
;      (e:KDo) : fdo(e, t)
;      (e:KMatch) : KMatch(args(e), map(fb,branches(e)))
;      (e:KDispatch) : KDispatch(args(e), map(fb, branches(e)))
;      (e) : e
;  defn flsexp (e:KLSExp) :
;    match(e) :
;      (e:KLSAFn) : KLSAFn(ffunc(value(e)))
;      (e) : mapr(flsexp, e)
;  defn flscomm (c:KLSComm) :
;    mapr(flsexp, c)
;  defn fcomm (c:KComm) :
;    match(c) :
;      (c:KDef) :
;        fdef(KDef(n(c), tag(c), fexp(value(c), false)))
;      (c:KDefVar) :
;        match(value(c)) :
;          (v:KExp) : fdef(KDefVar(n(c), tag(c), fexp(v, false)))
;          (v:False) : c
;      (c:KDefn) :
;        KDefn(n(c), ffunc(value(c)) as KFn)
;      (c:KDefmethod) :
;        KDefmethod(multi(c), targs(c), thisn(c), ffunc(value(c)) as KFn)
;      (c) :
;        map(fexp{_, false},
;        map(flsexp,
;        map(flscomm,
;        c)))
;  KPackage(
;    name(pkg),
;    ids(pkg),
;    map(fcomm, comms(pkg)))
;
;;Insert guards around the given KDo expression to
;;enforce declared contracts.
;defn guard (dec-table:DecTable, e:KDo, tailcall?:True|False) -> KExp :
;  ;Guard call to known function
;  defn guard (n:Int, targs:List<KTag>, args:List<KExp>) :
;    val [a1, a2] = fn-types(dec-table, n, targs)
;    ;Guard arguments when necessary
;    val args* =
;      if lostanza?(dec-table, n) : map(KCast, args, a1)
;      else : args
;    ;Make call
;    val call = KDo!(KVar(n), targs, args*)
;    ;Guard return when necessary
;    if tailcall? : call
;    else if lostanza?(dec-table, n) : KCast(call, a2)
;    else if tail?(dec-table, n) : KCast(call, a2)
;    else : call
;
;  ;Guard call to expression
;  defn guard (e:KDo) :
;    val args* = map(KCast, args(e), a1(e))
;    val func* = KCast(func(e), KOf(FN-TYPE-ID))
;    val call = KDo!(func*, List(), args*)
;    if tailcall? : call
;    else : KCast(call, a2(e))
;
;  match(func(e)) :
;    (f:KVar) :
;      if function?(dec-table, n(f)) : guard(n(f), List(), args(e))
;      else : guard(e)
;    (f:KCurry) : guard(n(f), targs(f), args(e))
;    (f) : guard(e)
;
;defn guard-boundary (dec-table:DecTable, pkg:KPackage) :
;  map-guards(
;    ;References to variables check for void
;    fn (v) :
;      if voidable?(dec-table, n(v)) : KEnsureSet(v)
;      else : v
;    ;Destructuring tuples ensures its a tuple first
;    fn (e) :
;      val exp* = KCast(exp(e), KOf(TUPLE-TYPE-ID))
;      KEnsureLength(exp*, length(e))
;    ;Definitions check type before assignments
;    fn (c) :
;      match(c) :
;        (c:KDef) : KDef(n(c), tag(c), KCast(value(c), tag(c)))
;        (c:KDefVar) : KDefVar(n(c), tag(c), KCast(value(c) as KExp, tag(c)))
;    ;Calls have contracts enforced    
;    fn (e, t) :
;      guard(dec-table, e, t)
;    ;Branches check their arguments (in case of unmatched parameters)  
;    fn (b) :
;      val guards = seq(KCast{KVar(_), _}, args(b), tags(b))
;      val body = KSeq(guards, body(b))
;      KBranch(args(b), tags(b), body)
;    ;Functions check arguments and return  
;    fn (f) :
;      val guards = seq(KCast{KVar(_), _}, args(f), a1(f))
;      var body:KExp = KSeq(guards, body(f))
;      if not tail?(f) : body = KCast(body, a2(f))
;      KFn(tail?(f), targs(f), a1(f), a2(f), args(f), body),
;    pkg)


;============================================================
;==================== Utilities =============================
;============================================================

;=================================
;==== Sequence Utilities =========
;=================================

defn select<?T> (xs:List<?T>, mask:List<True|False>) -> List<T> :
  to-list(filter(xs, mask))

;=================================
;==== Convenient Getters =========
;=================================

defn tag! (t:KLSType) :
  tag(t as KRefT)

;=================================
;==== Convenient Constructors ====
;=================================

defn KLSLet (d:KLSDefLocal, e:KLSExp) :
  KLSLet(n(d), type(d), value(d), e)

defn KLSLet (defs:Seqable<KLSDefLocal>, e:KLSExp) :
  reduce-right(KLSLet, defs, e)

defn KSeq (es:Seqable<KExp>, e:KExp) :
  reduce-right(KSeq, es, e)

defn KTops (xs:List) :
  map(KTop{}, xs)
  
defn KVars (xs:List<Int>) :
  map(KVar, xs)

defn KLSVars (xs:List<Int>) :
  map(KLSVar, xs)

defn KRefTs (xs:List<KTag>) :
  map(KRefT, xs)

;================================
;==== Trivial Simplification ====
;================================

;Trivial Simplifications
defn trivial-simplify (t:KTag) :
  match(map(trivial-simplify, t)) :
    (t:KAnd) :
      match(a(t), b(t)) :
        (a:KBot, b) : a
        (a, b:KBot) : b
        (a:KTop, b) : b
        (a, b:KTop) : a
        (a, b) : t
    (t:KOr) :
      match(a(t), b(t)) :
        (a:KBot, b) : b
        (a, b:KBot) : a
        (a:KTop, b) : a
        (a, b:KTop) : b
        (a, b) : t
    (t) : t

;===========================
;==== Initialized Table ====
;===========================

defn to-hashtable<K,V> (es:Seqable<KeyValue<K,V>>) -> HashTable<K,V> :
  to-hashtable<K,V>(seq(key, es), seq(value, es))

defn to-hashtable<K,V> (ks:Seqable<K>, vs:Seqable<V>) -> HashTable<K,V> :
  val t = HashTable<K,V>()
  do({t[_] = _}, ks, vs)
  t
