defpackage stz/kform :
  import core
  import collections
  import stz/pl-ir
  import stz/kl-ir
  import stz/tgt-ir
  import stz/type-to-kform
  import stz/kform-to-tgt
  import stz/ids
  import stz/utils
  import stz/primitives
  import stz/padder
  import stz/khier
  import stz/dec-table
  import stz/algorithms
  import stz/params

;============================================================
;=================== Driver =================================
;============================================================

public defn compile (pkgs:List<KPkgComm>) -> List<TGPackage> :
  val dec-table = compute-declaration-table(pkgs)
  val hier = compute-hierarchy(pkgs)
  for pkg in pkgs map :
    match(pkg) :
      (pkg:TGPackage) :
        pkg
      (#pkg:KPackage) :
        var pkg:KPackage = #pkg
        ;vheader("Package %_" % [name(pkg)])
        ;println(pkg)
        pkg = map-method-targs(dec-table, pkg)
        ;vheader("Package %_ : After Mapping Method Targs" % [name(pkg)])
        ;println(pkg)
        pkg = create-closures(dec-table, pkg)
        ;vheader("Package %_ : After Creating Closures" % [name(pkg)])
        ;println(pkg)
        pkg = convert-mixes(dec-table, pkg)
        ;vheader("Package %_ : After Converting Mixes" % [name(pkg)])
        ;println(pkg)
        pkg = guard-boundary(dec-table, pkg)
        ;vheader("Package %_ : After Guarding Boundaries" % [name(pkg)])
        ;println(pkg)
        pkg = lift-constants(dec-table, pkg)
        ;vheader("Package %_ : After Lifting Constants" % [name(pkg)])
        ;println(pkg)
        pkg = detect-loops(pkg)        
        ;vheader("Package %_ : After Detecting Loops" % [name(pkg)])
        ;println(pkg)
        pkg = simple-inlining(pkg)
        ;vheader("Package %_ : After Simple Inlining" % [name(pkg)])
        ;println(pkg)
        pkg = infer-types(dec-table, hier, pkg)
        ;vheader("Package %_ : After Inferring Types" % [name(pkg)])
        ;println(pkg)
        pkg = elide-checks(hier, pkg)
        ;vheader("Package %_ : After Eliding Checks" % [name(pkg)])
        ;println(pkg)
        pkg = reify-types(dec-table, pkg)
        ;vheader("Package %_ : After Reifying Types" % [name(pkg)])
        ;println(pkg)
        pkg = box-mutables(pkg)
        ;vheader("Package %_ : After Boxing Mutables" % [name(pkg)])
        ;println(pkg)
        pkg = lambda-lift(dec-table, pkg)
        ;vheader("Package %_ : After Lambda Lifting" % [name(pkg)])
        ;println(pkg)
        pkg = compute-freevars(dec-table, pkg)
        ;vheader("Package %_ : After Computing Freevars" % [name(pkg)])
        ;println(pkg)
        pkg = lift-objects(dec-table, pkg)
        ;vheader("Package %_ : After Lifting Objects" % [name(pkg)])
        ;println(pkg)
        pkg = compute-freevars(dec-table, pkg)
        ;vheader("Package %_ : After Computing Freevars Again" % [name(pkg)])
        ;println(pkg)
        pkg = lift-closures(dec-table, pkg)
        ;vheader("Package %_ : After Lifting Closures" % [name(pkg)])
        ;println(pkg)
        pkg = primitive-tagging(pkg)
        ;vheader("Package %_ : After Tagging Primitives" % [name(pkg)])
        ;println(pkg)
        pkg = analyze-new-stack(pkg)
        ;vheader("Package %_ : After Analyzing New Stack" % [name(pkg)])
        ;println(pkg)
        to-tgpackage(dec-table, pkg)

;============================================================
;=================== Optimized Mode =========================
;============================================================

public defn compile-optimized (#pkg:KPackage) :
  var pkg:KPackage = #pkg
  val dec-table = compute-declaration-table(List(pkg))
  val hier = compute-hierarchy(List(pkg))
  pkg = map-method-targs(dec-table, pkg)
  ;vheader("Package %_ : After Mapping Method Targs" % [name(pkg)])
  ;println(pkg)
  pkg = create-closures(dec-table, pkg)
  ;vheader("Package %_ : After Creating Closures" % [name(pkg)])
  ;println(pkg)
  pkg = convert-mixes(dec-table, pkg)
  ;vheader("Package %_ : After Converting Mixes" % [name(pkg)])
  ;println(pkg)
  pkg = guard-boundary(dec-table, pkg)
  ;vheader("Package %_ : After Guarding Boundaries" % [name(pkg)])
  ;println(pkg)
  pkg = lift-constants(dec-table, pkg)
  ;vheader("Package %_ : After Lifting Constants" % [name(pkg)])
  ;println(pkg)
  pkg = detect-loops(pkg)        
  ;vheader("Package %_ : After Detecting Loops" % [name(pkg)])
  ;println(pkg)
  pkg = simple-inlining(pkg)
  ;vheader("Package %_ : After Simple Inlining" % [name(pkg)])
  ;println(pkg)
  pkg = inlining(pkg)
  ;vheader("Package %_ : After Full Inlining" % [name(pkg)])
  ;println(pkg)  
  pkg = type-erasure(pkg)
  ;vheader("Package %_ : After Reifying Types" % [name(pkg)])
  ;println(pkg)
  pkg = box-mutables(pkg)
  ;vheader("Package %_ : After Boxing Mutables" % [name(pkg)])
  ;println(pkg)
  pkg = lambda-lift(dec-table, pkg)
  ;vheader("Package %_ : After Lambda Lifting" % [name(pkg)])
  ;println(pkg)
  pkg = compute-freevars(dec-table, pkg)
  ;vheader("Package %_ : After Computing Freevars" % [name(pkg)])
  ;println(pkg)
  pkg = lift-objects(dec-table, pkg)
  ;vheader("Package %_ : After Lifting Objects" % [name(pkg)])
  ;println(pkg)
  pkg = compute-freevars(dec-table, pkg)
  ;vheader("Package %_ : After Computing Freevars Again" % [name(pkg)])
  ;println(pkg)
  pkg = lift-closures(dec-table, pkg)
  ;vheader("Package %_ : After Lifting Closures" % [name(pkg)])
  ;println(pkg)
  pkg = primitive-tagging(pkg)
  ;vheader("Package %_ : After Tagging Primitives" % [name(pkg)])
  ;println(pkg)
  pkg = analyze-new-stack(pkg)
  ;vheader("Package %_ : After Analyzing New Stack" % [name(pkg)])
  ;println(pkg)
  to-tgpackage(dec-table, pkg)


;============================================================
;==================== Flatten ===============================
;============================================================

public defn flatten (pkgs:List<KPackage>) -> KPackage :  
  val ids* = PkgIds(decls*, List()) where :
    val decls* = for pkg in pkgs seq-append :
      declarations(ids(pkg))
  val comms* = seq-append(comms, pkgs)
  KPackage(`program, ids*, comms*, false)

;============================================================
;============== Compute Declaration Table ===================
;============================================================

defn compute-declaration-table (pkgs:List<KPkgComm>) :
  val table = DecTable()
  defn scan (c:KNode) :
    let loop (c:KNode = c, g?:True|False = true) :
      do-all(loop{_, false}, c)
      match(c:KComm) : register(table, c, g?)
  defn scan (ids:PkgIds) :
    for d in declarations(ids) do :
      register(table, d)
  for pkg in pkgs do :
    match(pkg) :
      (pkg:KPackage) : do(scan, comms(pkg))
      (pkg:TGPackage) : scan(ids(pkg))
  table

;============================================================
;================== Compute Hierarchy =======================
;============================================================

defn compute-hierarchy (pkgs:List<KPkgComm>) :
  KHierarchy $ for pkg in pkgs seq-cat :
    match(pkg) :
      (pkg:KPackage) : hier-entries(ids(pkg))
      (pkg:TGPackage) : hier-entries(pkg)

;============================================================
;=================== Method Targ Mapping ====================
;============================================================

defn inverse-solve (input-xs:List<Int>, input-targs:List<KTag>) ->
                   [List<Int>, Vector<KeyValue<Int,KTag>>] :
  ;Created targs
  val ys = map(fresh-id{}, input-targs)
  ;Simplify
  val targs = map(trivial-simplify, input-targs)
  ;Gather Solutions
  val solved = HashTable<Int,Int>()
  defn put (x:Int, y:Int) :
    if contains?(input-xs, x) and not key?(solved, x) :
      solved[x] = y
  ;Precise Solutions
  for (t in targs, y in ys) do :
    match(t:KTVar) : put(n(t), y)
  ;Approximate Solutions
  for (t in targs, y in ys) do :
    let loop (t:KTag = t) :
      match(t) :
        (t:KTVar) : put(n(t), y)
        (t:KOr) : do(loop, t)
        (t) : false
  ;Track substitutions
  val subs = Vector<KeyValue<Int,KTag>>()
  ;Invert table
  for entry in solved do :
    val [x, y] = [key(entry), value(entry)]
    match(get?(solved, y)) :
      (x*:Int) : add(subs, x => KTVar(x*))
      (x*:False) : solved[y] = x
  ;Substitute unsolved targs
  for x in input-xs do :
    if not key?(solved, x) :
      add(subs, x => KTop())
  ;Compute new targs
  val output-ys = for y in ys map :
    get?(solved, y, y)
  ;Return
  [output-ys, subs]

defn replace-tvars (e:KExp|KLSComm, entries:Table<Int,KTag>) -> KExp|KLSComm :
  defn ft (t:KTag|KLSType) :
    replace-tvars(t, entries)
  defn f (e:KNode) :
    map-all(f, map-all(ft, e))
  f(e) as KExp|KLSComm

defn replace-tvars (f:KFn, entries:Vector<KeyValue<Int,KTag>>) :
  if empty?(entries) :
    f
  else :
    val entries = to-hashtable<Int,KTag>(entries)
    KFn(
      tail?(f),
      targs(f),
      map(replace-tvars{_, entries}, a1(f)),
      replace-tvars(a2(f), entries),
      args(f),
      replace-tvars(body(f), entries) as KExp,
      info(f))

defn replace-tvars (f:KLSFn, entries:Vector<KeyValue<Int,KTag>>) :
  if empty?(entries) :
    f
  else :
    val entries = to-hashtable<Int,KTag>(entries)
    KLSFn(
      tail?(f),
      targs(f),
      map(replace-tvars{_, entries}, a1(f)),
      replace-tvars(a2(f), entries),
      args(f),
      replace-tvars(body(f), entries) as KLSComm,
      info(f))

defn map-method (f:KDefmethod -> KDefmethod,
                 lsf:KLSDefmethod -> KLSDefmethod,
                 pkg:KPackage) -> KPackage :
  defn fm (c:KNode) :
    match(map-all(fm,c)) :
      (c:KDefmethod) : f(c)
      (c:KLSDefmethod) : lsf(c)
      (c) : c
  map({fm(_) as KComm}, pkg)

defn map-method-targs (dec-table:DecTable, pkg:KPackage) :
  defn fm (m:KDefmethod) :
    val v = value(m) as KFn
    val [targs*, unsolved] = inverse-solve(targs(v), targs(m))
    val [multi-a1, multi-a2] = fn-types(dec-table, multi(m), map(KTVar, targs*))
    val v* = let :
      val v = replace-tvars(v, unsolved)
      val a1* = map(KAnd, multi-a1, a1(v))
      val a2* = KAnd(multi-a2, a2(v))
      KFn(tail?(v), targs*, a1*, a2*, args(v), body(v), info(v))
    KDefmethod(multi(m), List(), thisn(m), v*)
  defn flm (m:KLSDefmethod) :
    val v = value(m) as KLSFn
    val [targs*, unsolved] = inverse-solve(targs(v), targs(m))
    val [multi-a1, multi-a2] = fn-types(dec-table, multi(m), map(KTVar, targs*))
    val v* = let :
      val v = replace-tvars(v, unsolved)
      defn KAnd! (a:KTag, b:KLSType) : KRefT(KAnd(a, tag!(b)))
      val a1* = map(KAnd!, multi-a1, a1(v))
      val a2* = KAnd!(multi-a2, a2(v))
      KLSFn(tail?(v), targs*, a1*, a2*, args(v), body(v), info(v))
    KLSDefmethod(multi(m), List(), v*)
  map-method(fm, flm, pkg)

;============================================================
;===================== Closure Creation =====================
;============================================================

defn map-closures (dec-table: DecTable
                   f: KMix|KCurry|KVar -> KAFn,
                   lf: KLSMix|KLSCurry -> KLSAFn,
                   pkg: KPackage) -> KPackage :
  val global-functions = HashTable<Int,KDefConst>()
  defn lift-function (func:Int) :
    if not key?(global-functions, func) :
      val n* = fresh-id()
      global-functions[func] = KDefConst(n*, f(KVar(func)))
    n(global-functions[func])
  defn prepend-defs (pkg:KPackage) :
    do(register{dec-table, _}, values(global-functions))
    attach-comms(pkg, append(values(global-functions), comms(pkg)))

  defn flsexp (e:KLSExp) :
    fnode(e) as KLSExp
  defn fnode (x:KNode) :
    match(x) :
      (x:KMix|KCurry) :
        f(x)
      (x:KVar) :
        if global-function?(dec-table, n(x)) :
          KVar(lift-function(n(x)))
        else : x
      (x:KDo) :
        match(func(x)) :
          (f:KMix|KCurry|KVar) :
            KDo(f, map({fnode(_) as KExp}, args(x)), a1(x), a2(x), info(x))
          (f) : map-all(fnode,x)
      (x:KLSMix|KLSCurry) :
        lf(x)
      (x:KLSVar) :
        if global-function?(dec-table, n(x)) : KLSVar(lift-function(n(x)))
        else : x
      (x:KLSDo) :
        match(func(x)) :
          (f:KLSMix|KLSCurry|KLSVar) : KLSDo(f, map(flsexp, args(x)), a1(x), a2(x), info(x))
          (f) : map-all(fnode, x)
      (x:KLSDoC) :
        match(func(x)) :
          (f:KLSMix|KLSCurry|KLSVar) : KLSDoC(f, map(flsexp, args(x)), map(flsexp, varargs(x)), type(x))
          (f) : map-all(fnode, x)
      (x) :
        map-all(fnode, x)
  prepend-defs(map({fnode(_) as KComm}, pkg))

defn mix-fn (dec-table: DecTable, f:KMix|KCurry|KVar) :
  defn make-fn (f:KExp, n:Int) :
    val args* = map(fresh-id{}, 0 to n)
    val body = KDo(f, KVars(args*), KTops(args*), KTop(), false)
    KFn(true, List(), KTops(args*), KTop(), args*, body, false)

  match(f) :
    (f:KCurry|KVar) :
      make-fn(f, arity(dec-table, n(f)))
    (f:KMix) :
      val groups = HashTable<Int,List<KCurry|KVar>>(List())
      for exp in exps(f) do :
        val n = arity(dec-table, n(exp))
        groups[n] = cons(exp, groups[n])
      KMultifn{to-list(_)} $ for entry in groups seq :
        val [n, fs] = [key(entry), value(entry)]
        if length(fs) == 1 : make-fn(head(fs), n)
        else : make-fn(KMix(fs), n)

defn create-closures (dec-table: DecTable, pkg:KPackage) -> KPackage :
  defn to-exp (f:KLSExp) :
    match(f) :
      (f:KLSMix) : KMix(map({to-exp(_) as KCurry}, exps(f)))
      (f:KLSCurry) : KCurry(n(f), targs(f))
      (f:KLSVar) : KVar(n(f))
  map-closures(
    dec-table,
    fn (e) : KAFn(mix-fn(dec-table, e))
    fn (e) : KLSAFn(mix-fn(dec-table, to-exp(e)))
    pkg)

;============================================================
;==================== Mix Conversion ========================
;============================================================

defn map-mixes (f: KDo -> KExp,
                lf: KLSDo -> KLSExp,
                pkg: KPackage) -> KPackage :
  defn fnode (x:KNode) :
    match(map-all(fnode, x)) :
      (x:KDo) :
        match(func(x):KMix) : f(x)
        else : x
      (x:KLSDo) :
        match(func(x):KLSMix) : lf(x)
        else : x
      (x) : x
  map({fnode(_) as KComm}, pkg)

defn convert (dec-table:DecTable, e:KDo) :
  ;Retrieve argument types for given function
  defn arg-types (f:KCurry|KVar) :
    val [a1, a2] = match(f) :
      (f:KVar) : fn-types(dec-table, n(f), List())
      (f:KCurry) : fn-types(dec-table, n(f), targs(f))
    a1
  ;Create branches
  val bs = for f in exps(func(e) as KMix) map :
    val args* = map(fresh-id{}, args(e))
    val ts = arg-types(f)
    KBranch(args*, ts, KDo(f, KVars(args*), KTops(args*), KTop(), info(e)), info(e))
  ;Create dispatch
  KDispatch(args(e), bs, info(e))

defn convert (dec-table:DecTable, e:KLSDo) :
  defn pull-out-defs (e:KLSDo) :
    val defs = Vector<KLSDefLocal>()
    val args* = Vector<KLSVar>()
    for (x in args(e), t in a1(e)) do :
      match(x) :
        (x:KLSVar) :
          add(args*, x)
        (x) :
          val id = fresh-id()
          add(defs, KLSDefLocal(id, t, x))
          add(args*, KLSVar(id))
    KLSLet(defs, make-dispatch(func(e) as KLSMix, to-list(args*), a1(e)))
  defn make-dispatch (func:KLSMix, args:List<KLSVar>, ts:List<KLSType>) :
    ;Splice ys into xs according to mask
    defn splice (mask:List<True|False>, xs:List<KLSVar>, ys:List<KLSVar>) :
      val ys-seq = to-seq(ys)
      for (x in xs, m in mask) map :
        if m : next(ys-seq)
        else : x
    ;Retrieve argument types for given function
    defn fn-types (f:KLSCurry|KLSVar) :
      match(f) :
        (f:KLSVar) : ls-fn-types(dec-table, n(f), List())
        (f:KLSCurry) : ls-fn-types(dec-table, n(f), targs(f))
    ;Compute mask
    val refmask = map({_ is KRefT}, ts)
    val refargs = select(args, refmask)
    ;Create branches
    val bs = for f in exps(func) map :
      val args* = map(fresh-id{}, refargs)
      val [a1, a2] = fn-types(f)
      val tags = map(tag!,select(a1, refmask))
      val call = KLSDo(f, splice(refmask, args, KLSVars(args*)), a1, a2, info(e))
      KLSBranchExp(args*, tags, call)
    ;Create dispatch
    KLSDispatch(refargs, bs, info(e))
  pull-out-defs(e)

defn convert-mixes (dec-table:DecTable, pkg:KPackage) -> KPackage :
  map-mixes(
    fn (e) : convert(dec-table, e)
    fn (e) : convert(dec-table, e)
    pkg)

;============================================================
;================= Boundary Guards ==========================
;============================================================

defn map-guards (fv: KVar -> KExp,
                 fel: KEnsureLength -> KExp,
                 fdef:KDef|KDefVar -> KDef|KDefVar,
                 fdo:(KDo, True|False) -> KExp,
                 fb:KBranch -> KBranch,
                 flb:KLSBranch -> KLSBranch,
                 flbe:KLSBranchExp -> KLSBranchExp,
                 ff:(KFn, True|False) -> KFn,
                 flf:KLSFn -> KLSFn,
                 pkg:KPackage) -> KPackage :
  defn map-tail (f: (KExp, True|False) -> KExp, e:KExp, tailcall?:True|False) :
    defn fb (b:KBranch) :
      KBranch(args(b), tags(b), f(body(b), tailcall?), info(b))
    match(e) :
      (e:KLet) : KLet(def(e), f(body(e), tailcall?))
      (e:KLetRec) : KLetRec(defs(e), f(body(e), tailcall?))
      (e:KSeq) : KSeq(f(a(e), false), f(b(e), tailcall?))
      (e:KMatch) : KMatch(map(f{_, false}, args(e)), map(fb, branches(e)), info(e))
      (e:KDispatch) : KDispatch(map(f{_, false}, args(e)), map(fb, branches(e)), info(e))
      (e) : map(f{_, false}, e)
  defn fexp (e:KExp, t:True|False) :
    match(map(fcomm, map-tail(fexp, e, t))) :
      (e:KVar) : fv(e)
      (e:KEnsureLength) : fel(e)
      (e:KDo) : fdo(e, t)
      (e:KMatch) : KMatch(args(e), map(fb,branches(e)), info(e))
      (e:KDispatch) : KDispatch(args(e), map(fb, branches(e)), info(e))
      (e:KAFn) : KAFn(ffunc(value(e),false))
      (e) : e
  defn ffunc<?T> (f:?T&KFunc, method?:True|False) -> T :
    {_ as T&KFunc} $ match(f) :
      (f:KFn) :
        val body* = fexp(body(f), tail?(f))
        ff(KFn(tail?(f), targs(f), a1(f), a2(f), args(f), body*, info(f)), method?)
      (f:KMultifn) :
        KMultifn $
        map({ffunc(_, method?) as KFn}, funcs(f))
  defn fnode (x:KNode) :
    match(x) :
      (x:KExp) :
        fexp(x, false)
      (x:KLSAFn) :
        KLSAFn(ffunc(value(x),false))
      (x:KLSMatch) :
        val x* = map-all(fnode, x) as KLSMatch
        KLSMatch(args(x*), map(flb, branches(x*)), info(x))
      (x:KLSDispatch) :
        val x* = map-all(fnode, x) as KLSDispatch
        KLSDispatch(args(x*), map(flbe, branches(x*)), info(x))
      (x:KDef) :
        fdef(KDef(n(x), tag(x), fexp(value(x), false), info(x)))
      (x:KDefVar) :
        match(value(x)) :
          (v:KExp) : fdef(KDefVar(n(x), tag(x), fexp(v, false), info(x)))
          (v:False) : x
      (x:KDefn) :
        KDefn(n(x), ffunc(value(x),false))
      (x:KDefmethod) :
        val f0 = value(x) as KFn
        val f = ffunc(f0,true)
        val thisn* = match(thisn(x)) :
          (thisn:Int) :
            for (a in args(f), a0 in args(f0)) find! :
              a0 == thisn
          (thisn:False) : false
        KDefmethod(multi(x), targs(x), thisn*, f)
      (x:KLSDefmethod) :
        val x* = map-all(fnode, x) as KLSDefmethod
        val f* = flf(value(x*) as KLSFn)
        KLSDefmethod(multi(x), targs(x), f*)
      (x) :
        map-all(fnode, x)
  defn fcomm (c:KComm) :
    fnode(c) as KComm
  map(fcomm, pkg)

defn map-return (f: KLSExp -> KLSExp, c:KLSComm) -> KLSComm :
  defn fnode (x:KNode) :
    match(x) :
      (x:KLSReturn) : KLSReturn(f(exp(x)))
      (x:KLSComm) : map-all(fnode, x)
      (x) : x
  fnode(c) as KLSComm

;Insert guards around the given KDo expression to
;enforce declared contracts.
defn guard (dec-table:DecTable, e:KDo, tailcall?:True|False) -> KExp :
  ;Guard call to known function
  defn guard (n:Int, targs:List<KTag>, args:List<KExp>) :
    val [a1, a2] = fn-types(dec-table, n, targs)
    ;Guard arguments when necessary
    val args* =
      if lostanza-function?(dec-table, n) : map(KCast{_, _, info(e)}, args, a1)
      else : args
    ;Make call
    val call = KDo!(length(args*), KCurry?(n,targs), args*, info(e))
    ;Guard return when necessary
    if tailcall? : call
    else if lostanza-function?(dec-table, n) : KCast(call, a2, info(e))
    else if tail?(dec-table, n) : KCast(call, a2, info(e))
    else : call

  ;Guard call to expression
  defn guard (e:KDo) :
    val args* = map(KCast{_, _, info(e)}, args(e), a1(e))
    val func* = KCast(func(e), KOf(FN-TYPE-ID), info(e))
    val call = KDo!(length(args*), func*, args*, info(e))
    if tailcall? : call
    else : KCast(call, a2(e), info(e))

  match(func(e)) :
    (f:KVar) :
      if function?(dec-table, n(f)) : guard(n(f), List(), args(e))
      else : guard(e)
    (f:KCurry) : guard(n(f), targs(f), args(e))
    (f) : guard(e)

defn KCastTVar (e:KExp, t:KTag, i:False|FileInfo) :
  defn strip (t:KTag) :
    if has-var?(t) :
      match(t:KOr) : t
      else : map(strip, t)
    else : KTop()
  match(trivial-simplify(strip(t))) :
    (t:KTop) : e
    (t) : KCast(e, t, i)

defn guard-boundary (dec-table:DecTable, pkg:KPackage) :
  map-guards(
    ;References to variables check for void
    fn (v) :
      if voidable?(dec-table, n(v)) : KEnsureSet(v, info(v))
      else : v
    ;Destructuring tuples ensures its a tuple first
    fn (e) :
      val exp* = KCast(exp(e), KOf(TUPLE-TYPE-ID), info(e))
      KEnsureLength(exp*, length(e), info(e))
    ;Definitions check type before assignments
    fn (c) :
      match(c) :
        (c:KDef) : KDef(n(c), tag(c), KCast(value(c), tag(c), info(c)))
        (c:KDefVar) : KDefVar(n(c), tag(c), KCast(value(c) as KExp, tag(c), info(c)), info(c))
    ;Calls have contracts enforced
    fn (e, t) :
      guard(dec-table, e, t)
    ;Branches check their arguments (in case of unmatched parameters)
    fn (b) :
      val args* = map(fresh-id{}, args(b))
      val guards = for (a* in args*, a in args(b), t in tags(b)) map :
        KDef(a, t, KCastTVar(KVar(a*), t, info(b)))
      val body = KLet(guards, body(b))
      KBranch(args*, map(remove-tvars,tags(b)), body, info(b))
    ;LoStanza branches erase their type variables
    fn (b) :
      KLSBranch(args(b), map(remove-tvars,tags(b)), body(b))
    fn (b) :
      KLSBranchExp(args(b), map(remove-tvars,tags(b)), exp(b))
    ;Functions check arguments and return
    fn (f, m?) :
      val args* = map(fresh-id{}, args(f))
      val guards = for (a* in args*, a in args(f), t in a1(f)) map :
        if m? : KDef(a, t, KCastTVar(KVar(a*), t, info(f)))
        else : KDef(a, t, KCast(KVar(a*), t, info(f)))
      var body:KExp = KLet(guards, body(f))
      if not tail?(f) : body = KCast(body, a2(f), info(f))
      val [a1*, a2*] =
        if m? : [map(remove-tvars, a1(f)), remove-tvars(a2(f))]
        else : [a1(f), a2(f)]
      KFn(tail?(f), targs(f), a1*, a2*, args*, body, info(f))
    ;LoStanza methods check arguments and return
    fn (f) :
      val guards = seq(KLSExec{KLSGuard(KLSVar(_), tag!(_), info(f))}, args(f), a1(f))
      val body = if tail?(f) : body(f)
                 else : map-return(KLSGuard{_, tag!(a2(f)), info(f)}, body(f))
      KLSFn(tail?(f), targs(f), a1(f), a2(f), args(f), KLSSeq(guards, body), info(f))
    pkg)

;============================================================
;=================== Type Inference =========================
;============================================================
defn map-types (dec-table:DecTable, pkg:KPackage,
                fdef:(Int, KTag) -> False,
                f:KExp -> KTag) :
  defn tag! (e:KExp) : tag(e as KTypedExp)
  defn tags! (es:List<KExp>) : map(tag!, es)
  defn fexp (e:KExp) : fnode(e) as KExp
  defn fexps (es:List<KExp>) : map(fexp, es)
  defn fnode (e:KNode) -> KNode :
    ;Definitions
    match(e) :
      (e:KLet) : fdef(n(def(e)), tag(def(e)))
      (e:KLetRec) : do(fdef{n(_), KOf(FN-TYPE-ID)}, defs(e))
      (e:KLetLoop) : do(fdef, args(e), tags(e))
      (e:KDefn) : ffunc(value(e),false)
      (e:KDefmethod) : ffunc(value(e),true)
      (e:KAFn) : ffunc(value(e),false)
      (e:KLSAFn) : ffunc(value(e),false)
      (e) : false
    ;Recursing
    val e* = match(e) :
      (e:KDo!) : KDo!(arity(e), fexp?(func(e)), fexps(args(e)), info(e))
      (e:KMatch) : KMatch(args*, branches*, info(e)) where :
        val args* = fexps(args(e))
        val branches* = fbranches(branches(e), tags!(args*))
      (e:KDispatch) : KDispatch(args*, branches*, info(e)) where :
        val args* = fexps(args(e))
        val branches* = fbranches(branches(e), tags!(args*))
      (e) : map-all(fnode, e)
    ;Wrapping
    match(e*) :
      (e:KExp) : KTypedExp(e, f(e))
      (e) : e
  defn fexp? (e:KExp) :
    match(e) :
      (e:KVar) :
        if function?(dec-table, n(e)) : e
        else : fexp(e)
      (e:KCurry) : e
      (e) : fexp(e)
  defn fbranch (b:KBranch, arg-tags:List<KTag>) :
    do(fdef{_, KAnd(_, _)}, args(b), tags(b), arg-tags)
    val body* = fexp(body(b))
    KBranch(args(b), tags(b), body*, info(b))
  defn fbranches (bs:List<KBranch>, arg-tags:List<KTag>) :
    map(fbranch{_, arg-tags}, bs)
  defn ffunc (v:KFunc, m?:True|False) :
    match(v) :
      (v:KFn) :
        if m? : do(fdef, args(v), a1(v))
        else : do(fdef{_, KTop()}, args(v))        
      (v:KMultifn) : do(ffunc{_, m?}, funcs(v))
  map({fnode(_) as KComm}, pkg)

defn infer-types (dec-table:DecTable, hier:KHierarchy, pkg:KPackage) -> KPackage :
  ;===================
  ;==== Utilities ====
  ;===================
  defn tag! (e:KExp) :
    tag(e as KTypedExp)

  ;==============================
  ;==== Function Return Type ====
  ;==============================
  defn fn-ret-type (n:Int, targs:List<KTag>) :
    if function?(dec-table, n) :
      val [a1, a2] = fn-types(dec-table, n, targs)
      if lostanza-function?(dec-table, n) : KTop()
      else if tail?(dec-table, n) : KTop()
      else : a2
    else : KTop()
  defn fn-ret-type (e:KDo!) :
    match(func(e)) :
      (f:KCurry) : fn-ret-type(n(f), targs(f))
      (f:KVar) : fn-ret-type(n(f), List())
      (f) : KTop()

  ;======================
  ;==== Literal Type ====
  ;======================
  defn literal-type (v) :
    KOf $ match(v) :
      (v:Char) : CHAR-TYPE-ID
      (v:Byte) : BYTE-TYPE-ID
      (v:Int) : INT-TYPE-ID
      (v:Long) : LONG-TYPE-ID
      (v:Float) : FLOAT-TYPE-ID
      (v:Double) : DOUBLE-TYPE-ID
      (v:String) : STRING-TYPE-ID
      (v:Symbol) : SYMBOL-TYPE-ID
      (v:List) : LIST-TYPE-ID
      (v:True) : TRUE-TYPE-ID
      (v:False) : FALSE-TYPE-ID

  ;========================
  ;==== Primitive Type ====
  ;========================
  defn primitive-type (op:Primitive) :
    defn bool-type () : KOr(KOf(TRUE-TYPE-ID), KOf(FALSE-TYPE-ID))
    switch(op) :
      ADD-OP : KOf(INT-TYPE-ID)
      SUB-OP : KOf(INT-TYPE-ID)
      MUL-OP : KOf(INT-TYPE-ID)
      DIV-OP : KOf(INT-TYPE-ID)
      MOD-OP : KOf(INT-TYPE-ID)
      AND-OP : KOf(INT-TYPE-ID)
      OR-OP : KOf(INT-TYPE-ID)
      XOR-OP : KOf(INT-TYPE-ID)
      SHL-OP : KOf(INT-TYPE-ID)
      SHR-OP : KOf(INT-TYPE-ID)
      ASHR-OP : KOf(INT-TYPE-ID)
      EQ-OP : bool-type()
      NE-OP : bool-type()
      LT-OP : bool-type()
      GT-OP : bool-type()
      LE-OP : bool-type()
      GE-OP : bool-type()
      NOT-OP : KOf(INT-TYPE-ID)
      NEG-OP : KOf(INT-TYPE-ID)
      IDENTICAL-OP : bool-type()
      AGET-OP : KTop()
      ASET-OP : KOf(FALSE-TYPE-ID)
      ALEN-OP : KOf(INT-TYPE-ID)
      CHAR-AGET-OP : KOf(CHAR-TYPE-ID)
      CHAR-ASET-OP : KOf(FALSE-TYPE-ID)
      STRING-GET-OP : KOf(CHAR-TYPE-ID)
      STRING-LEN-OP : KOf(INT-TYPE-ID)

  ;===========================
  ;==== Local Environment ====
  ;===========================
  val local-table = HashTable<Int,KTag>()

  ;===================
  ;==== Algorithm ====
  ;===================
  map-types(dec-table, pkg,
    fn (n:Int, t:KTag) :
      local-table[n] = t
    fn (e:KExp) :
      match(e) :
        (e:KVar) :
          match(get?(local-table, n(e))) :
            (t:KTag) : t
            (t:False) : hs-var-type(dec-table, n(e))
        (e:KDo!) : fn-ret-type(e)
        (e:KSet) : KOf(FALSE-TYPE-ID)
        (e:KCast) : KAnd(tag!(exp(e)), tag(e))
        (e:KLet) : tag!(body(e))
        (e:KLetRec) : tag!(body(e))
        (e:KLetLoop) : tag!(body(e))
        (e:KSeq) : tag!(b(e))
        (e:KMatch) : KOr(map(tag!{body(_)}, branches(e)))
        (e:KNew) : tag(e)
        (e:KLiteral) : literal-type(value(e))
        (e:KTuple) : KOf(TUPLE-TYPE-ID)
        (e:KTupleGet) : KTop()
        (e:KEnsureLength) : KOf(TUPLE-TYPE-ID)
        (e:KAFn) : KOf(FN-TYPE-ID)
        (e:KPrim) : primitive-type(op(e))
        (e:KDispatch) : KOr(map(tag!{body(_)}, branches(e)))
        (e:KEnsureSet) : tag!(exp(e))
        (e:KGoto) : KBot()
        (e) : fatal("Not yet supported: %_" % [e]))

;============================================================
;==================== Check Elision =========================
;============================================================

defn elide-checks (hier:KHierarchy, pkg:KPackage) :
  defn tag! (e:KExp) :
    tag(e as KTypedExp)
  defn fnode (e:KNode) :
    match(e) :
      (e:KCast) :
        if subtype?(hier, tag!(exp(e)), tag(e)) :
          fnode(exp(e))
        else :
          map-all(fnode, e)
      (e:KTypedExp) : fnode(exp(e))
      (e) : map-all(fnode, e)
  map({fnode(_) as KComm}, pkg)

;============================================================
;=================== Constant Lifting =======================
;============================================================

defn lift-constants (dec-table:DecTable, pkg:KPackage) -> KPackage :
  val defs = Vector<KDefConst>()
  defn prepend-defs (pkg:KPackage) :
    do(register{dec-table, _}, defs)
    attach-comms(pkg, append(defs, comms(pkg)))
  defn make-const (v) :
    val n = fresh-id()
    add(defs, KDefConst(n, v))
    KVar(n)
  defn fnode (x:KNode) :
    match(x) :
      (x:KLiteral) :
        match(value(x)) :
          (v:Long|Double|String|Symbol|List) : make-const(v)
          (v) : x
      (x) :
        map-all(fnode, x)
  prepend-defs(map({fnode(_) as KComm}, pkg))

;============================================================
;==================== Renaming ==============================
;============================================================

defn rename-binders (e:KExp) -> KExp :
  ;Mapping functions
  defn map-tag (f:KTag -> KTag, e:KNode) -> KNode :
    defn f! (t:KTag|KLSType) : f(t as KTag)
    val e1 = map-all(f!, e)
    for sube in e1 map-all :
      match(sube:KExp) : sube
      else : map-tag(f, sube)
      
  defn map-exp (f:KExp -> KExp, e:KNode) -> KNode :
    for sube in e map-all :
      match(sube) :
        (sube:KExp) : f(sube)
        (sube) : map-exp(f, sube)
        
  ;Rename table      
  val table = HashTable<Int,Int>()
  defn make-id (n:Int) :
    val n* = fresh-id()
    table[n] = n*
    n*  
  defn rename-id (n:Int) :    
    get?(table, n, n)
  defn rename-tag (t:KTag) :
    match(t) :
      (t:KTVar) : KTVar(rename-id(n(t)))
      (t) : map(rename-tag, t)
  defn rename-exp (e0:KExp) -> KExp :
    var e:KExp = e0
    e = map-defined(make-id, e)
    e = map-binders(rename-id, e)
    e = map-tag(rename-tag, e) as KExp
    map-exp(rename-exp, e) as KExp

  ;Driver
  rename-exp(e)

;============================================================
;================== Detect Loops ============================
;============================================================

defn map-all-tail (f: (KNode, True|False) -> KNode, e:KNode, t:True|False) :
  ;Helpers
  defn fexp (e:KExp) : f(e, false) as KExp
  defn ftail (e:KExp) : f(e, t) as KExp
  defn fexps (es:List<KExp>) : map(fexp, es)
  defn fdef (e:KDef|KDefVar) : f(e,false) as KDef|KDefVar
  defn fdefn (e:KDefn) : f(e,false) as KDefn
  defn fdefns (es:List<KDefn>) : map(fdefn,es)
  defn fbranch (b:KBranch) : KBranch(args(b), tags(b), ftail(body(b)), info(b))
  defn fbranches (bs:List<KBranch>) : map(fbranch, bs)
  ;Dispatch
  match(e) :
    (e:KLet) : KLet(fdef(def(e)), ftail(body(e)))
    (e:KLetRec) : KLetRec(fdefns(defs(e)), ftail(body(e)))
    (e:KSeq) : KSeq(fexp(a(e)), ftail(b(e)))
    (e:KMatch) : KMatch(fexps(args(e)), fbranches(branches(e)), info(e))
    (e:KDispatch) : KDispatch(fexps(args(e)), fbranches(branches(e)), info(e))
    (e) : map-all(f{_, false}, e)

defn detect-loops (pkg:KPackage) :
  ;State of current function
  var current-loop:False|Int = false
  var has-loop:True|False = false

  ;Detect loops in the given function
  defn detect-ffunc (ctxt:False|Int, f:KFunc) :
    match(f) :
      (f:KFn) :
        if tail?(f) :
          let-var current-loop = fresh-id() :
            let-var has-loop = false :
              val body* = detect-exp(ctxt, body(f), tail?(f))
              if has-loop :
                val targs* = map(fresh-id{}, targs(f))
                val tenv = to-hashtable<Int,KTVar>(targs(f), KTVars(targs*))
                val a1* = map(replace-tvars{_, tenv}, a1(f))
                val a2* = replace-tvars(a2(f), tenv)
                val args* = map(fresh-id{}, args(f))
                val body* = KSeq(guards, loop) where :
                  val guards = seq(KCast{KVar(_), _, info(f)}, args*, a1*)
                  val loop = KLetLoop(current-loop as Int, targs(f), args(f), a1(f)
                                      KTVars(targs*), KVars(args*), body*)
                KFn(tail?(f), targs*, a1*, a2*, args*, body*, info(f))
              else :
                map({body*}, f)
        else :
          map(detect-exp{false, _, tail?(f)}, f)
      (f:KMultifn) :
        KMultifn(map(detect-ffunc{ctxt, _}, funcs(f)))

  ;Detect loops in the given expression
  defn detect-exp (ctxt:False|Int, e:KExp, t:True|False) :
    detect-node(ctxt, e, t) as KExp
    
  ;Detect loops in the given expression
  defn detect-node (ctxt:False|Int, e:KNode, t:True|False) :
    defn ffunc (n:False|Int, f:KFunc) : detect-ffunc(n,f)
    match(e) :
      ;Detect loops in sub-functions
      (e:KDefn) : KDefn(n(e), ffunc(n(e),value(e)))
      (e:KDefmethod) : KDefmethod(multi(e), targs(e), thisn(e), ffunc(false, value(e)))
      (e:KAFn) : KAFn(ffunc(false, value(e)))
      ;Transform expressions
      (e) :
        match(map-all-tail(detect-node{ctxt, _, _}, e, t)) :
          (e:KDo!) :
            ;Helpers
            defn loop-name! (f:KExp) :
              fail() when not t
              fail() when f is-not KVar|KCurry
              val n = n(f as KVar|KCurry)
              fail() when n != ctxt
              current-loop as Int
            defn targs! (f:KExp) :
              match(f) :
                (f:KCurry) : targs(f)
                (f:KVar) : List()
            ;Attempt transformation
            attempt :
              val l = loop-name!(func(e))
              has-loop = true
              KGoto(l, targs!(func(e)), args(e))
            else : e
          (e) : e  

  ;Driver
  for c:KComm in pkg map :
    detect-node(false, c, false) as KComm

;============================================================
;================== Simple Inlining =========================
;============================================================

;Construct the call graph
defn call-graph (ctxt:Int, f:KFunc) :
  val graph = HashTable<KeyValue<Int,Int>,Int>(0)
  defn add-edge (src:Int, dst:Int) :
    val k = src => dst
    graph[k] = graph[k] + 1
  defn scan-node (ctxt:Int, e:KNode) -> False :
    match(e) :
      (e:KVar|KCurry) : add-edge(ctxt, n(e))
      (e:KDefn) : do-all(scan-node{n(e), _}, e)
      (e) : do-all(scan-node{ctxt, _}, e)
  do(scan-node{ctxt, _}, f)
  graph

;Check if dst is reachable from src through the given graph
val VISITED = HashTable<Int,True>()
defn reachable? (succs: HashTable<Int,List<Int>>, src:Int, dst:Int) :
  val result = let dst? (n:Int = src) :
    if not key?(VISITED, n) :
      if n == dst :
        true
      else :
        VISITED[n] = true
        any?(dst?, succs[n])
  clear(VISITED)      
  result

;Compute successor graph
defn succ-graph (graph:HashTable<KeyValue<Int,Int>,Int>) :
  val succs = HashTable<Int,List<Int>>(List())
  defn add-succ (n:Int, succ:Int) :
    succs[n] = cons(succ, succs[n])
  for entry in graph do :
    val [k, n] = [key(entry), value(entry)]
    val [src, dst] = [key(k), value(k)]
    add-succ(src, dst)
  succs

;Compute predecessor graph
defn pred-graph (graph:HashTable<KeyValue<Int,Int>,Int>) :
  val preds = HashTable<Int,List<KeyValue<Int,Int>>>(List())
  defn add-pred (n:Int, pred:Int, weight:Int) :
    preds[n] = cons(pred => weight, preds[n])
  for entry in graph do :
    val [k, n] = [key(entry), value(entry)]
    val [src, dst] = [key(k), value(k)]
    add-pred(dst, src, n)
  preds

;Inline
defn inline (func:KFunc, call-targs:List<KTag>, call-args:List<KExp>) :
  defn same-length? (xs:List, ys:List) : length(xs) == length(ys)
  ;Retrieve appropriate function or fail    
  val f = match(func) :
    (f:KFn) :
      fail() when not
        same-length?(targs(f), call-targs) and
        same-length?(args(f), call-args)
      f
    (f:KMultifn) :
      val f* = for f0 in funcs(f) find :
        val f = f0 as KFn
        same-length?(targs(f), call-targs) and
        same-length?(args(f), call-args)
      fail() when f* is False
      f* as KFn
      
  ;Rename the body
  val tenv = to-hashtable<Int,KTag>(targs(f), call-targs)
  val body* = replace-tvars(body(f), tenv) as KExp
  KLet(map(KDef{_, _, _, false}, args(f), a1(f), call-args), body*)

defn simple-inline (function:KFunc) -> KFunc :
  ;Compute call graphs
  val top = fresh-id()
  val graph = call-graph(top, function)
  val preds = pred-graph(graph)
  val succs = succ-graph(graph)

  ;Inline table
  val inline-table = HashTable<Int,KFunc>()

  ;Returns the type args of the function reference
  defn targs! (e:KExp) :
    match(e) :
      (e:KCurry) : targs(e)
      (e) : List()

  ;Returns KFunc to be inlined or fails otherwise
  defn inline-func (e:KExp) :
    match(e) :
      (e:KVar|KCurry) :
        match(get?(inline-table, n(e))) :
          (f:KFunc) : f
          (f:False) : fail()
      (e:KAFn) : value(e)
      (e) : fail()

  ;A function is inlined if it is only referenced once
  defn inlined? (def:KDefn) :
    val ps = preds[n(def)]
    if length(ps) == 1 :
      value(head(ps)) == 1

  ;Retrieve id of caller
  defn caller! (def:KDefn) :
    val ps = preds[n(def)]
    key(head(ps))

  ;Perform all simple inlining of node e,
  ;which is defined in context ctxt
  defn inline-node (ctxt:Int, e:KNode) -> KNode :
    ;Helpers
    defn inline-exp (e:KExp) : inline-node(ctxt, e) as KExp
    defn inline-defn (def:KDefn) : map-all(inline-node{n(def), _}, def) as KDefn
    ;A function is called if it is reachable from the body
    defn called? (def:KDefn) :
      reachable?(succs, ctxt, n(def))
    ;Add to inline-table
    defn add-inline-entries (defs:Collection<KDefn>) :
      defn add (def:KDefn) :
        ;Add successors first
        for f in succs[n(def)] do :
          val succ = find({n(_) == f}, defs)
          match(succ:KDefn) : add(succ)
        ;Add inlined definition to table
        val def* = inline-defn(def)
        inline-table[n(def*)] = value(def*)
      ;Add all defs to table
      for def in defs do :
        add(def) when not key?(inline-table, n(def))
    ;Algorithm
    match(e) :
      (e:KLetRec) :
        val called-defs = to-list(filter(called?, defs(e)))
        val [inlined-defs, not-inlined-defs] = split(inlined?, called-defs)
        add-inline-entries(inlined-defs)
        ;Perform inlining
        val defs* = to-list(seq(inline-defn, not-inlined-defs))
        val body* = inline-exp(body(e))
        if empty?(defs*) : body*
        else : KLetRec(defs*, body*)
      (e:KVar) :
        match(get?(inline-table, n(e))) :
          (f:KFunc) : KAFn(f)
          (f:False) : e
      (e:KDo!) :
        attempt :
          val f = inline-func(func(e))
          val args* = map(inline-exp, args(e))
          attempt : inline(f, targs!(func(e)), args*)
          else : fatal("Not inlinable")
        else :
          map(inline-exp, e)
      (e) :
        map-all(inline-node{ctxt, _}, e)

  ;Perform inlining on function
  for body:KExp in function map :
    inline-node(top, body) as KExp

defn simple-inlining (pkg:KPackage) :
  defn fnode (e:KNode) :
    match(e) :
      (e:KDefn) :
        KDefn(n(e), simple-inline(value(e)))
      (e:KDefmethod) :
        KDefmethod(multi(e), targs(e), thisn(e), simple-inline(value(e)))
      (e:KAFn) :
        KAFn(simple-inline(value(e)))
      (e:KLSExp|KLSComm) :
        e
      (e) :
        map-all(fnode, e)
  for c:KComm in pkg map :
    fnode(c) as KComm

;============================================================
;=================== Full Inlining ==========================
;============================================================
;Inline all functions whose size is below this threshold
val INLINE-THRESHOLD = 5

deftype InlineEntry
defmulti size (n:InlineEntry) -> Int
defmulti func (n:InlineEntry) -> KFunc

defn InlineEntry (f:KFunc) :
  defn size (e:KNode) :
    ;Count number of subnodes
    var counter:Int = 0
    for e:KNode in e do-all :
      counter = counter + size(e)
    ;Add cost of node
    counter + match(e) :
      (e:KVar|KCast|KLet|KLetRec|KSeq|KLiteral|KCurry|KLetLoop|KGoto) : 0
      (e:KDo!) : 2
      (e) : 1
  defn size (f:KFunc) :
    match(f) :
      (f:KFn) : size(body(f))
      (f:KMultifn) : sum(seq(size, funcs(f)))
      
  val entry-size = size(f)
  new InlineEntry :
    defmethod size (this) : entry-size
    defmethod func (this) : f
    defmethod print (o:OutputStream, this) :
      if entry-size <= INLINE-THRESHOLD :
        print(o, "Function of size %_ = %_" % [entry-size, f])
      else :
        print(o, "Function of size %_" % [entry-size])

defn scan-functions (pkg:KPackage) :
  val table = HashTable<Int,InlineEntry>()
  defn scan (e:KNode) :
    do-all(scan, e)
    match(e:KDefn) :
      table[n(e)] = InlineEntry(value(e))
  do(scan, pkg)
  table

defn inlining (e:KNode, ctxt:List<Int>, table:HashTable<Int,InlineEntry>, progress:() -> ?) :
  ;Recursion
  defn inline-exp (e:KExp) : inlining(e, ctxt, table, progress) as KExp
  defn inline-node (e:KNode) : inlining(e, ctxt, table, progress)
  defn inline-in-ctxt (c:Int, e:KNode) : inlining(e, cons(c, ctxt), table, progress)  

  ;Retrieve the func to inline given its id or fail otherwise
  defn inline-func (n:Int) :
    fail() when contains?(ctxt, n)
    fail() when not key?(table, n)
    val e = table[n]
    fail() when size(e) > INLINE-THRESHOLD
    func(e)

  ;Retrieve the func to inline or fail otherwise
  defn inline-func (e:KExp) :
    match(e) :
      (e:KVar) : inline-func(n(e))
      (e:KCurry) : inline-func(n(e))
      (e:KAFn) : value(e)
      (e) : fail()
      
  ;Retrieve the type arguments in the given function expression
  defn targs! (e:KExp) :
    match(e) :
      (e:KCurry) : targs(e)
      (e:KVar) : List()
      
  match(e) :
    (e:KDefn) :
      map-all(inline-in-ctxt{n(e), _}, e)
    (e:KVar) :
      attempt : KAFn(inline-func(e))
      else : e
    (e:KDo!) :
      val args* = map(inline-exp, args(e))
      attempt :
        val inlined = inline(inline-func(func(e)), targs!(func(e)), args*)
        println("inlined %_ = %_" % [e, inlined])
        progress()
        rename-binders(inlined)
      else :
        val func* = inline-exp(func(e))
        KDo!(arity(e), func*, args*, info(e))        
    (e) :
      map-all(inline-node, e)

defn inlining (#pkg:KPackage) :
  var pkg:KPackage = #pkg
  fixpoint{5, _} $ fn (progress) :    
    val table = scan-functions(pkg)
    pkg = for comm in pkg map :
      inlining(comm, List(), table, progress) as KComm
    pkg

;deftype CallNode
;defmulti weight (n:CallNode) -> Int
;defmulti func (n:CallNode) -> KFunc
;
;;Construct a CallNode
;defn CallNode (f:KFunc) :
;  new CallNode :
;    defmethod weight (this) : 0
;    defmethod func (this) : f
;
;deftype WeightedCallGraph
;defmulti set (cg:WeightedCallGraph, id:Int, n:CallNode) -> False
;defmulti node (cg:WeightedCallGraph, id:Int) -> CallNode
;defmulti set (cg:WeightedCallGraph, src:Int, dst:Int, weight:Int) -> False
;defmulti edge (cg:WeightedCallGraph, src:Int, dst:Int) -> Int|False
;
;;Construct a weighted call graph
;defn WeightedCallGraph () :
;  val nodes = HashTable<Int,CallNode>()
;  val edges = HashTable<KeyValue<Int,Int>, Int>()
;  new WeightedCallGraph :
;    defmethod set (this, id:Int, n:CallNode) : nodes[id] = n
;    defmethod node (this, id:Int) : nodes[id]
;    defmethod set (this, src:Int, dst:Int, weight:Int) : edges[src => dst] = weight
;    defmethod edge (this, src:Int, dst:Int) : get?(edges, src => dst)
;    defmethod print (o:OutputStream, this) :
;      print(o, "WeightedCallGraph:")
;      print(o, "\n  Nodes: %," % [keys(nodes)])
;      print(o, "\n  Edges: %," % [edges])
;
;defn add-edge (cg:WeightedCallGraph, src:Int, dst:Int) :
;  match(edge(cg, src, dst)) :
;    (i:Int) : cg[src,dst] = i + 1
;    (i:False) : cg[src,dst] = 1
;
;;Scan for entries in given function
;defn scan-entries (cg:WeightedCallGraph, ctxt:Int, f:KFunc) :
;  defn scan-node (ctxt:Int, e:KNode) -> False :
;    match(e) :
;      (e:KVar|KCurry) : add-edge(cg, ctxt, n(e))
;      (e:KDefn) : scan-entries(cg, n(e), value(e))
;      (e) : do-all(scan-node{ctxt, _}, e)
;  cg[ctxt] = CallNode(f)  
;  do(scan-node{ctxt, _}, f)
;
;;Scan for entries in package
;defn weighted-call-graph (pkg:KPackage) :
;  val cg = WeightedCallGraph()
;  defn scan-node (e:KNode) :
;    match(e) :
;      (e:KDefn) : scan-entries(cg, n(e), value(e))      
;      (e:KLSComm|KLSExp) : e
;      (e) : do-all(scan-node, e)
;  do(scan-node, pkg)
;  cg
;
;defn inlining (cg:WeightedCallGraph, f:KFunc, to-inline:List<Int>) :
;  defn fnode (e:KNode) :
;    match(e) :
;      (e:KVar) :
;      (e:KDo!) :
;      (e) : map-all(fnode, e)
;

;============================================================
;=================== Type Erasure ===========================
;============================================================
defn type-erasure (pkg:KPackage) :
  defn erase (t:KLSType) :
    match(t:KRefT) : KRefT(KTop())
    else : map(erase, t)
  defn erase (ts:List<KLSType>) :
    map(erase, ts)
  defn ffn (x:KFn) :
    KFn(tail?(x), List(), KTops(args(x)), KTop(), args(x), body(x), info(x))
  defn flfunc (#x:KLSFunc) :
    val x = #x as KLSFn
    KLSFn(tail?(x), List(), erase(a1(x)), erase(a2(x)), args(x), body(x), info(x))
  defn ffunc (f:KFunc) :
    match(f) :
      (f:KFn) : ffn(f)
      (f:KMultifn) : KMultifn(map(ffunc, funcs(f)))
  defn fnode (x:KNode) :
    match(map-all(fnode, x)) :
      (x:KCurry) :
        KVar(n(x))
      (x:KCast) :
        exp(x)      
      (x:KLetLoop) :
        KLetLoop(n(x), List(), args(x), KTops(args(x)), List(), init-args(x), body(x))
      (x:KGoto) :
        KGoto(loop(x), List(), args(x))
      (x:KAFn) :
        KAFn(ffunc(value(x)))
      (x:KLSAFn) :
        KLSAFn(ffunc(value(x)))
      (x:KDefn) :
        KDefn(n(x), ffunc(value(x)))
      (x:KDefmethod) :
        KDefmethod(multi(x), targs(x), thisn(x), ffunc(value(x)))
      (x:KLSDefn) :
        KLSDefn(n(x), flfunc(value(x)))
      (x:KLSDefmethod) :
        KLSDefmethod(multi(x), List(), flfunc(value(x)))
      (x:KLSExternFn) :
        KLSExternFn(n(x), lbl(x), flfunc(value(x)))
      (x) :
        x
  for c in pkg map :
    fnode(c) as KComm

;============================================================
;=================== Type Reification =======================
;============================================================

defn normalize (t:KTag) :
  val counter = to-seq(0 to false)
  val ids = IdPool(next{counter})
  let loop (t:KTag = t) :
    match(t) :
      (t:KTVar) : KTVar(ids[n(t)])
      (t) : map(loop, t)

defn freevars (t:KTag) :
  unique $ generate<Int> :
    let loop (t:KTag = t) :
      match(t:KTVar) : yield(n(t))
      else : do(loop, t)

defn remove-tvars (t:KTag) :
  trivial-simplify $
    let loop (t:KTag = t) :
      match(t:KTVar) : KTop()
      else : map(loop, t)

defn remove-tvars (t:KLSType) :
  defn f (t:KLSType|KTag) :
    match(t:KTag) : remove-tvars(t)
    else : map-all(f, t)
  f(t) as KLSType

defn map-type-args (fdo:KDo! -> KDo!,
                    fcall:KLSDo -> KLSDo!,
                    fcast:KCast -> KReifiedCast,
                    floop: KLetLoop -> KLetLoop,
                    fgoto: KGoto -> KGoto
                    ff:KFn -> KFn!,
                    flf:KLSFn -> KLSFn!,
                    pkg:KPackage) -> KPackage :
  defn ffunc (f:KFunc) :
    match(f) :
      (f:KFn) : ff(f)
      (f:KMultifn) : KMultifn(map(ff, funcs(f) as List<KFn>))
  defn fnode (x:KNode) :
    match(map-all(fnode, x)) :
      (x:KDo!) :
        match(func(x):KCurry) : fdo(x)
        else : x
      (x:KCast) :
        fcast(x)
      (x:KLSDo) :
        fcall(x)
      (x:KLetLoop) :
        floop(x)
      (x:KGoto) :
        fgoto(x)
      (x:KAFn) :
        KAFn(ffunc(value(x)))
      (x:KLSAFn) :
        KLSAFn(ffunc(value(x)))
      (x:KDefn) :
        KDefn(n(x), ffunc(value(x)))
      (x:KDefmethod) :
        KDefmethod(multi(x), targs(x), thisn(x), ffunc(value(x)))
      (x:KLSDefn) :
        KLSDefn(n(x), flf(value(x) as KLSFn))
      (x:KLSDefmethod) :
        KLSDefmethod(multi(x), targs(x), flf(value(x) as KLSFn))
      (x:KLSExternFn) :
        KLSExternFn(n(x), lbl(x), flf(value(x) as KLSFn))
      (x) :
        x
  map({fnode(_) as KComm}, pkg)

defn reify-types (dec-table:DecTable, pkg:KPackage) -> KPackage :
  ;Define a type object
  val defs = Vector<KComm>()
  defn prepend-defs (pkg:KPackage) :
    do(register{dec-table, _}, defs)
    attach-comms(pkg, append(defs, comms(pkg)))

  ;Table of types
  val type-table = HashTable<KTag,Int>()
  defn create-type-object (t:KTag, vs:List<Int>, ls?:True|False) :
    defn Var (n:Int) :
      if ls?: KLSVar(n)
      else : KVar(n)
    defn TypeObject (n:Int, vs:List<Int>) :
      if ls?: KLSTypeObject(n, KLSVars(vs))
      else : KTypeObject(n, KVars(vs))
    match(t:KTVar) :
      Var(n(t))
    else :
      val nt = normalize(t)
      match(get?(type-table, nt)) :
        (n:Int) :
          if empty?(vs) : Var(n)
          else : TypeObject(n, vs)
        (_:False) :
          val type-id = fresh-id()
          add(defs, KDefTypeObject(type-id, vs, t))
          if empty?(vs) :
            val obj-id = fresh-id()
            add(defs, KDefConst(obj-id, KTypeObject(type-id, List())))
            type-table[nt] = obj-id
            Var(obj-id)
          else :
            type-table[nt] = type-id
            TypeObject(type-id, vs)

  ;Creating type objects
  defn type-objects (ts:List<KTag>) :
    for t in ts map :
      create-type-object(t, freevars(t), false) as KExp
  defn ls-type-objects (ts:List<KTag>) :
    for t in ts map :
      create-type-object(t, freevars(t), true) as KLSExp

  prepend-defs $ map-type-args(
    ;Remove type args
    fn (e) :
      val f = func(e) as KCurry
      val args* = append(type-objects(targs(f)), args(e))
      KDo!(arity(e), KVar(n(f)), args*, info(e))
    ;Remove type args
    fn (e) :
      match(func(e)) :
        (f:KLSCurry) :
          val args* = append(ls-type-objects(targs(f)), args(e))
          KLSDo!(length(args(e)), KLSVar(n(f)), args*, a2(e), info(e))
        (f) :
          KLSDo!(length(args(e)), f, args(e), a2(e), info(e))
    ;Reify casts
    fn (e) :
      KReifiedCast(exp(e), tag(e), info(e))
    ;Reify loops
    fn (e:KLetLoop) :
      val args* = append(targs(e), args(e))
      val tags* = append(map(KOf{TYPE-TYPE-ID}, targs(e)), tags(e))
      val init-args* = append(type-objects(init-targs(e)), init-args(e))
      KLetLoop(n(e), List(), args*, tags*, List(), init-args*, body(e))
    ;Reified Gotos
    fn (e:KGoto) :
      val args* = append(type-objects(targs(e)), args(e))
      KGoto(loop(e), List(), args*)
    ;Reify type arguments
    fn (f) :
      val a1* = append(map(KOf{TYPE-TYPE-ID}, targs(f)),
                       map(remove-tvars, a1(f)))
      val a2* = remove-tvars(a2(f))
      val args* = append(targs(f), args(f))
      KFn!(tail?(f), length(args(f)), a1*, a2*, args*, body(f), info(f))
    ;Reify type arguments
    fn (f) :
      val a1* = append(map(KRefT{KOf(TYPE-TYPE-ID)}, targs(f))
                       map(remove-tvars, a1(f)))
      val a2* = remove-tvars(a2(f))
      val args* = append(targs(f), args(f))
      KLSFn!(CheckStack(), tail?(f), length(args(f)), a1*, a2*, args*, body(f), info(f))
    pkg)

;============================================================
;=================== Box Mutables ===========================
;============================================================

defn map-boxes (fmutable:Int -> False,
                fdefvar:KDefVar -> KComm,
                fset:KSet -> KExp,
                fvar:KVar -> KExp,
                pkg:KPackage) :
  defn fnode (x:KNode) :
    ;Find mutable variables
    match(x:KLet) :
      match(def(x)) :
        (def:KDefVar) : fmutable(n(def))
        (def) : false
    ;Map
    match(map-all(fnode, x)) :
      (x:KDefVar) : fdefvar(x)
      (x:KSet) : fset(x)
      (x:KVar) : fvar(x)
      (x) : x
  map({fnode(_) as KComm}, pkg)

defn box-mutables (pkg:KPackage) :
  val mutables = HashTable<Int,True>()
  defn boxed? (n:Int) : key?(mutables, n)  
  map-boxes(
    ;Record mutable variables
    fn (n) :
      mutables[n] = true
    ;Create boxes for defvars
    fn (c) :
      if boxed?(n(c)) : KDef(n(c), KOf(BOX-TYPE-ID), KBox(value(c)))
      else : c
    ;Assign into boxes
    fn (e) :
      if boxed?(n(e)) : KBoxSet(KVar(n(e)), value(e))
      else : e
    ;Retrieve from boxes
    fn (e) :
      if boxed?(n(e)) : KBoxGet(e)
      else : e
    pkg)

;============================================================
;=============== Free Variable Computation ==================
;============================================================

defn attach-free (f:KFunc, vs:List<Int>) :
  match(f) :
    (f:KFn!) :
      KFn!(tail?(f), arity(f), a1(f), a2(f), args(f), body(f), info(f), vs)
    (f:KMultifn) :
      KMultifn(funcs(f), vs)

defn compute-freevars (dec-table:DecTable, pkg:KPackage) :
  ;Track variable binding
  var vars = HashTable<Int,True|False>()
  defn mark-bound (v:Int) : vars[v] = false
  defn mark-free (v:Int) : vars[v] = true
  defn all-free () : to-list(seq(key, filter(value, vars)))

  ;Mapping functions
  defn markexp (e:KExp) :
    markn(e) as KExp
  defn markb (b:KBranch) :
    val body* = markexp(body(b))
    do(mark-bound, args(b))
    KBranch(args(b), tags(b), body*, info(b))
  defn markn (x:KNode) :
    match(x) :
      ;Branches
      (x:KMatch) :
        val args* = map(markexp, args(x))
        KMatch(args*, map(markb, branches(x)), info(x))
      (x:KDispatch) :
        val args* = map(markexp, args(x))
        KDispatch(args*, map(markb, branches(x)), info(x))
      ;Bound
      (x:KLet) :
        val body* = markexp(body(x))
        mark-bound(n(def(x)))
        val def* = markn(def(x)) as KDef|KDefVar
        KLet(def*, body*)
      (x:KLetRec) :
        val x* = map-all(markn, x)
        do(mark-bound{n(_)}, defs(x))
        x*
      (x:KLetLoop) :
        val body* = markexp(body(x))
        do(mark-bound, args(x))
        val init-args* = map(markexp, init-args(x))
        KLetLoop(n(x), targs(x), args(x), tags(x), init-targs(x), init-args*, body*)        
      ;Free
      (x:KVar) :
        mark-free(n(x)) when not global?(dec-table, n(x))
        x
      (x:KReifiedCast) :
        for v in freevars(tag(x)) do :
          mark-free(v) when not global?(dec-table, v)
        map-all(markn, x)
      ;Funcs
      (x:KLSAFn) :
        KLSAFn(markf(value(x)))
      (x:KAFn) :
        KAFn(markf(value(x)))
      (x:KDefn) :
        KDefn(n(x), markf(value(x)))
      (x:KDefmethod) :
        KDefmethod(multi(x), targs(x), thisn(x), markf(value(x)))
      ;Recurse
      (x) :
        map-all(markn, x)
  defn markf (f:KFunc) :
    match(f) :
      (f:KFn!) :
        val f* = let-var vars = HashTable<Int,True|False>() :
          val body* = markexp(body(f))
          do(mark-bound, args(f))
          val f* = KFn!(tail?(f), arity(f), a1(f), a2(f), args(f), body*, info(f))
          val vs = all-free()
          attach-free(f*, all-free())
        do(mark-free, freevars(f*))
        f*
      (f:KMultifn) :
        val fs* = map(markf, funcs(f))
        val vs = unique(seq-cat(freevars, fs*))
        attach-free(KMultifn(fs*), vs)

  ;Driver
  map({markn(_) as KComm}, pkg)


;============================================================
;=================== Lambda Lifting =========================
;============================================================

;Compute usage table
defn usage-table (pkg:KPackage) :
  val used = HashTable<Int,True|False>(false)
  defn scan-node (e:KNode, call-pos?:True|False) :
    match(e) :
      (e:KVar) :
        (used[n(e)] = true) when not call-pos?
      (e:KDo!) :
        scan-node(func(e), true)
        do(scan-node{_, false}, args(e))
      (e:KLSComm|KLSExp) : false
      (e) : do-all(scan-node{_, false}, e)
  do(scan-node{_, false}, pkg)
  used

;Compute lifting table
defn lift-table (used:HashTable<Int,True|False>, pkg:KPackage) :
  ;Gather all functions
  val functions = Vector<KDefn>()
  do(scan, pkg) where :
    defn scan (e:KNode) :
      do-all(scan, e)
      match(e:KLetRec) :
        add-all(functions, defs(e))

  ;Anchors are functions that have been determined to not be lifted
  val anchors = HashTable<Int, True|False>(false)

  ;Populate lift table with all functions that can be lifted
  ;in the given function group
  to-hashtable<Int,List<Int>> $ fixpoint $
    fn (assumptions-changed) :
      ;Maximum lift
      val max-args = 6

      ;Compute lifting args
      val argss = bipartite-closure $
        for def in functions seq? :
          defn free! (def:KDefn) : freevars(value(def) as KFn!)
          if anchors[n(def)] :
            None()
          else :
            val vs = free!(def)
            if length(vs) > max-args : None()
            else : One(n(def) => vs)
      ;Verify assumptions
      for entry in argss do :
        val [f, args] = [key(entry), value(entry)]
        if (used[f] and not empty?(args)) or
           (length(args) > max-args) :
          anchors[f] = true
          assumptions-changed()
      ;Return lifting arguments
      argss

defn lambda-lift (dt:DecTable, pkg0:KPackage) :
  ;Compute free variables of pkg
  val pkg = compute-freevars(dt, pkg0)

  ;Compute usage and lift tables
  val used = usage-table(pkg)
  val lift-table = lift-table(used, pkg)

  ;A function can be lifted if there is an entry
  ;in the lift table.
  defn lift? (n:Int) : key?(lift-table, n)
  defn lift? (def:KDefn) : lift?(n(def))

  ;Ids of lifted closures
  val closure-ids = HashTable<Int,Int>()
  defn closure-id (n:Int) :
    if not key?(closure-ids, n) :
      closure-ids[n] = fresh-id()
    closure-ids[n]

  ;Def Tables
  val lift-defs = Vector<KComm>()
  defn prepend-defs (pkg:KPackage) :
    do(register{dt, _}, lift-defs)
    attach-comms(pkg, append(lift-defs, comms(pkg)))

  ;Binder renaming
  defn rename-binders (table:HashTable<Int,Int>, e:KExp) :
    defn rename-tag (t:KTag) -> KTag :
      match(map(rename-tag, t)) :
        (t:KTVar) : KTVar(get?(table, n(t), n(t)))
        (t) : t
    defn rename (e:KNode) -> KNode :
      match(map-all(rename, e)) :
        (e:KVar) : KVar(get?(table, n(e), n(e)))
        (e:KReifiedCast) : KReifiedCast(exp(e), rename-tag(tag(e)), info(e))
        (e) : e
    rename(e) as KExp

  defn rename-binders (dst:Seqable<Int>, src:Seqable<Int>, e:KExp) :
    rename-binders(to-hashtable<Int,Int>(src, dst), e)

  ;Lifting a function
  defn lift-fn (def:KDefn) :
    val lift-args = lift-table[n(def)]

    defn lift (f:KFunc) :
      match(f) :
        (f:KFn!) :
          val lift-args* = map(fresh-id{}, lift-args)
          val args* = append(lift-args*, args(f))
          val a1* = append(KTops(lift-args), a1(f))
          val arity* = arity(f) + length(lift-args)
          val body* = rename-binders(lift-args*, lift-args, body(f))
          KFn!(tail?(f), arity*, a1*, a2(f), args*, body*, info(f), freevars?(f))
        (f:KMultifn) :
          KMultifn(map(lift, funcs(f)), freevars?(f))

    ;Push to top level
    val f* = lift(value(def))
    add(lift-defs, KDefn(n(def), f*))

  ;Lifting a closure
  defn lift-closure? (def:KDefn) :
    if used[n(def)] :
      val f = value(def) as KFn!
      val args* = map(fresh-id{}, args(f))
      val body* = KDo!(arity(f), KVar(n(def)), KVars(args*), false)
      val f* = KFn!(true, arity(f), KTops(args*), KTop(), args*, body*, false)
      add(lift-defs, KDefConst(closure-id(n(def)), KAFn(f*)))

  ;Lifting a call
  defn lift-call (e:KDo!) :
    val f = func(e) as KVar
    val lift-args = lift-table[n(f)]
    val args* = append(KVars(lift-args), args(e))
    val arity* = arity(e) + length(lift-args)
    KDo!(arity*, f, args*, info(e))

  ;Lifting an anonymous function
  defn lift-afn (f:KFunc) :
    fatal("Cannot lift closure.") when not empty?(freevars(f))
    val n* = fresh-id()
    add(lift-defs, KDefConst(n*, KAFn(f)))
    n*

  ;Scan for and lift functions
  defn lift-node (e:KNode) :
    match(e) :
      (e0:KAFn) :
        val e = map-all(lift-node, e0) as KAFn
        if empty?(freevars(value(e))) : KVar(lift-afn(value(e)))
        else : e
      (e0:KLSAFn) :
        val e = map-all(lift-node, e0) as KLSAFn
        if empty?(freevars(value(e))) : KLSVar(lift-afn(value(e)))
        else : e
      (e:KDefConst) :
        val v* = match(value(e)) :
          (v:KExp) : map-all(lift-node, v)
          (v) : v
        KDefConst(n(e), v*)
      (e:KLetRec) :
        val [lift-defs, keep-defs] = split(lift?,
          map(lift-node, defs(e)) as List<KDefn>)
        do(lift-fn, lift-defs)
        do(lift-closure?, lift-defs)
        val body* = lift-node(body(e)) as KExp
        if length(keep-defs) == 0 : body*
        else : KLetRec(to-list(keep-defs), body*)
      (e:KDo!) :
        ;Is it a call to a lifted function?
        val lifted? =
          match(func(e)) :
            (f:KVar) : lift?(n(f))
            (f) : false
        ;Lift the call if it is
        if lifted? :
          val e* = KDo!(arity(e), func(e), args*, info(e)) where :
            val args* = map({lift-node(_) as KExp}, args(e))
          lift-call(e*)
        else :
          map-all(lift-node, e)
      (e:KVar) :
        if lift?(n(e)) and used[n(e)] : KVar(closure-id(n(e)))
        else : e
      (e) :
        map-all(lift-node, e)

  ;Driver
  prepend-defs(map({lift-node(_) as KComm}, pkg))

;============================================================
;==================== Object Lifting ========================
;============================================================

defn freevars (e:KNew) :
  unique $ for m in methods(e) seq-cat :
    freevars(value(m))

defn lift-objects (dec-table:DecTable, pkg:KPackage) :
  val defs = Vector<KComm>()
  defn prepend-defs (pkg:KPackage) :
    do(register{dec-table, _}, defs)
    attach-comms(pkg, append(defs, comms(pkg)))

  defn create-object (e:KNew) :
    val id = fresh-id()
    val obj-vs = freevars(e)
    ;Define Object
    add(defs, KDefObject(id, tag(e), length(obj-vs)))
    ;Pull out Methods
    for m in methods(e) do :
      val obj = thisn(m) as Int
      val f = value(m) as KFn!
      val defs* = for v in freevars(f) seq :
        val i = index-of!(obj-vs, v)
        KDef(v, KTop(), KObjectGet(KVar(obj), i))
      val body* = KLet(defs*, body(f))
      val a1* = for (v in args(f), t in a1(f)) map :
        KOf(id) when v == obj else t
      val f* = KFn!(tail?(f), arity(f), a1*, a2(f), args(f), body*, info(f))
      add(defs, KDefmethod(multi(m), targs(m), false, f*))
    ;Create Object
    KObject(id, KVars(obj-vs), info(e))

  ;Scanner
  defn fnode (x:KNode) :
    match(map-all(fnode, x)) :
      (x:KNew) : create-object(x)
      (x) : x

  ;Driver
  prepend-defs(map({fnode(_) as KComm}, pkg))

;============================================================
;================== Closure Lifting =========================
;============================================================

defn map-closures (fdef:KDefn -> KDef,
                   ffn:KAFn -> KClosure,
                   flsfn:KLSAFn -> KLSClosure,
                   fdo:KDo! -> KCall|KDo!,
                   pkg:KPackage) :
  defn fnode (x:KNode) :
    match(x) :
      (x:KLetRec) :
        val defs* = for d in defs(x) map :
          fdef(map-all(fnode, d) as KDefn)
        val body* = fnode(body(x)) as KExp
        KLetClosures(
          map(n, defs*),
          map(value, defs*) as List<KClosure>,
          body*)
      (x) :
        match(map-all(fnode, x)) :
          (x:KAFn) : ffn(x)
          (x:KLSAFn) : flsfn(x)
          (x:KDo!) : fdo(x)
          (x) : x
  map({fnode(_) as KComm}, pkg)

defn lift-closures (dec-table:DecTable, pkg:KPackage) :
  ;Code Ids
  val code-ids = IdPool(fresh-id)
  defn code-id (n:Int) :
    fatal("Globals have no code id.") when global?(dec-table, n)
    code-ids[n]

  ;Removing an int
  defn minus (xs:List<Int>, y:Int) :
    to-list(filter({_ != y}, xs))

  ;Infos
  defn info! (x:KFunc) :
    match(x) :
      (x:KFn!) : info(x)
      (x:KMultifn) : info!(head(funcs(x)))
  defn info! (x:KLSFunc) :
    info(x as KLSFn!)

  ;Create the closure code
  defn closure-code (func:KFunc, closure:Int, vs:List<Int>) -> KFunc :
    defn make-code (f:KFn!, closure:Int, free:Seqable<KeyValue<Int,Int>>) :
      val defs* = for e in free seq :
        KDef(key(e), KTop(), KClosureGet(KVar(closure), value(e)))
      val body* = KLet(defs*, body(f))
      val a1* = cons(KOf(FN-TYPE-ID), a1(f))
      val args* = cons(closure, args(f))
      KFn!(tail?(f), arity(f), a1*, a2(f), args*, body*, info(f))
    match(func) :
      (func:KFn!) :
        val free = seq(KeyValue, vs, 0 to false)
        make-code(func, closure, free)
      (func:KMultifn) :
        val fs* = for f in funcs(func) map :
          val free = for v in (freevars(f) - closure) seq :
            v => index-of!(vs, v)
          make-code(f as KFn!, closure, free)
        KMultifn(fs*)

  ;New Definitions
  val defs = Vector<KComm>()
  defn prepend-defs (pkg:KPackage) :
    do(register{dec-table, _}, defs)
    attach-comms(pkg, append(defs, comms(pkg)))

  prepend-defs $ map-closures(
    fn (c:KDefn) :
      val f = value(c)
      val vs = freevars(f) - n(c)
      val id = code-id(n(c))
      add(defs, KDefn(id, closure-code(f, n(c), vs)))
      KDef(n(c), KTop(), KClosure(id, KVars(vs), info!(f)))
    fn (e:KAFn) :
      val f = value(e)
      val id = fresh-id()
      add(defs, KDefn(id, closure-code(f, fresh-id(), freevars(f))))
      KClosure(id, KVars(freevars(f)), info!(f))
    fn (e:KLSAFn) :
      val f = value(e)
      val id = fresh-id()
      add(defs, KDefn(id, closure-code(f, fresh-id(), freevars(f))))
      KLSClosure(id, KLSVars(freevars(f)), info!(f))
    fn (e:KDo!) :
      match(func(e)) :
        (f:KVar) :
          if function?(dec-table, n(f)) :
            if global?(dec-table, n(f)) : KCall(arity(e), n(f), args(e), info(e))
            else : KCall(arity(e), code-id(n(f)), cons(f, args(e)), info(e))
          else : e
        (f) : e
    pkg)

;============================================================
;================== Primitive Tagging =======================
;============================================================

defn primitive-tagging (pkg:KPackage) :
  ;Match against [e].value
  defn detag? (e:KLSRead) :
    attempt :
      val loc = loc(e)
      val [base, field] = match(loc:KField) : [exp(loc), n(loc)]
                          else : fail()
      val n = switch(field) :
        BYTE-VALUE-FIELD-ID : BYTE-TYPE-ID
        CHAR-VALUE-FIELD-ID : CHAR-TYPE-ID
        INT-VALUE-FIELD-ID : INT-TYPE-ID
        FLOAT-VALUE-FIELD-ID : FLOAT-TYPE-ID
        else : fail()
      KDetagPrim(n, exp(base as KDeref))
    else : e

  ;Match against new T{e}
  defn tag? (e:KLSRef) :
    attempt :
      val [n, args] = [n(e), args(e)]
      val ns = [BYTE-TYPE-ID, CHAR-TYPE-ID, INT-TYPE-ID, FLOAT-TYPE-ID]
      if contains?(ns, n) : KTagPrim(n, head(args))
      else : fail()
    else : e

  defn fnode (x:KNode) :
    match(x) :
      (x:KLSRead) : map-all(fnode, detag?(x))
      (x:KLSRef) : map-all(fnode, tag?(x))
      (x:KExp) : x
      (x) : map-all(fnode, x)

  map({fnode(_) as KComm}, pkg)

;============================================================
;================= New Stack Analysis =======================
;============================================================

defn analyze-new-stack (pkg:KPackage) :
  defn prefixed? (comm:KLSComm) -> [StackProperties KLSComm] :
    defn first+rest (c:KLSComm) -> [KLSComm, KLSComm] :
      match(c) :
        (c:KLSSeq) :
          val [a1, a2] = first+rest(a(c))
          [a1, KLSSeq?(a2, b(c))]
        (c) : [c, KLSSkip()]
    defn prim-op? (c:KLSComm) :
      match(c:KLSExec) :
        val exp = exp(c)
        match(exp:KLSPrim) :
          op(exp)
    val [a1, a2] = first+rest(comm)
    switch(prim-op?(a1)) :
      LS-NEW-STACK-OP : [NewStack(), a2]
      LS-LAST-STACK-OP : [LastStack(), a2]
      false : [CheckStack(), comm]

  defn ffunc (input-f:KLSFunc) :
    val f = input-f as KLSFn!
    val [sp, body*] = prefixed?(body(f))
    KLSFn!(sp, tail?(f), arity(f), a1(f), a2(f), args(f), body*, info(f))

  defn fcomm (c:KComm) :
    match(c) :
      (c:KLSDefn) : KLSDefn(n(c), ffunc(value(c)))
      (c:KLSDefmethod) : KLSDefmethod(multi(c), targs(c), ffunc(value(c)))
      (c:KLSExternFn) : KLSExternFn(n(c), lbl(c), ffunc(value(c)))
      (c) : c

  map(fcomm, pkg)

;============================================================
;==================== Utilities =============================
;============================================================

;=================
;==== Id Pool ====
;=================

deftype IdPool <: Collection<Int>
defmulti get (p:IdPool, n:Int) -> Int

defn IdPool (genid: () -> Int) :
  val table = HashTable<Int,Int>()
  new IdPool :
    defmethod get (this, n:Int) :
      if not key?(table, n) :
        table[n] = genid()
      table[n]
    defmethod to-seq (this) :
      to-seq(values(table))

;=======================
;==== Fancy Mappers ====
;=======================
defn map-defined (f:Int -> Int, e:KExp) :
  defn fs (ns:List<Int>) :
    map(f, ns)
  defn fdef (e:KDef|KDefVar) :
    match(e) :
      (e:KDef) : KDef(f(n(e)), tag(e), value(e), info(e))
      (e:KDefVar) : KDefVar(f(n(e)), tag(e), value(e), info(e))      
  defn fbranch (b:KBranch) :
    KBranch(fs(args(b)), tags(b), body(b), info(b))
  defn fdefn (c:KDefn) :
    KDefn(f(n(c)), ffunc(value(c)))
  defn fmethod (c:KDefmethod) :
    KDefmethod(multi(c), targs(c), thisn(c), ffunc(value(c)))
  defn ffunc (f:KFunc) :
    match(f) :
      (f:KFn) : KFn(tail?(f), fs(targs(f)), a1(f), a2(f), fs(args(f)), body(f), info(f))
      (f:KMultifn) : KMultifn(map(ffunc,funcs(f)), freevars?(f))
  match(e) :
    (e:KLet) : KLet(fdef(def(e)), body(e))
    (e:KLetRec) : KLetRec(map(fdefn, defs(e)), body(e))
    (e:KLetLoop) : KLetLoop(f(n(e)), fs(targs(e)), fs(args(e)), tags(e), init-targs(e), init-args(e), body(e))
    (e:KMatch) : KMatch(args(e), map(fbranch, branches(e)), info(e))
    (e:KDispatch) : KDispatch(args(e), map(fbranch, branches(e)), info(e))
    (e:KNew) : KNew(tag(e), map(fmethod, methods(e)), info(e))
    (e:KAFn) : KAFn(ffunc(value(e)))
    (e) : e

defn map-binders (f:Int -> Int, e:KExp) :
  defn f? (n:False|Int) :
    match(n:Int) : f(n)
  defn fdef (e:KDefmethod) :
    KDefmethod(f(multi(e)), targs(e), f?(thisn(e)), value(e))
  match(e) :
    (e:KSet) : KSet(f(n(e)), tag(e), value(e))
    (e:KGoto) : KGoto(f(loop(e)), targs(e), args(e))
    (e:KVar) : KVar(f(n(e)))
    (e:KCurry) : KCurry(f(n(e)), targs(e))
    (e:KNew) : KNew(tag(e), map(fdef,methods(e)), info(e))
    (e) : e

