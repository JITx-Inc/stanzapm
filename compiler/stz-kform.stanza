defpackage stz/kform :
  import core
  import collections
  import stz/pl-ir
  import stz/kl-ir
  import stz/type-to-kform
  import stz/ids

;============================================================
;=================== Driver =================================
;============================================================

public defn compile (pkgs:List<KPackage>) :
  do(println, map(map-method-targs, pkgs))

;============================================================
;=================== Method Targ Mapping ====================
;============================================================

defn inverse-solve (input-xs:List<Int>, input-targs:List<KTag>) ->
                   [List<Int>, Vector<KeyValue<Int,KTag>>] :
  ;Created targs
  val ys = map(fresh-id{}, input-targs)
  ;Simplify
  val targs = map(trivial-simplify, input-targs)
  ;Gather Solutions
  val solved = HashTable<Int,Int>()
  defn put (x:Int, y:Int) :
    (solved[x] = y) when not key?(solved, x)
  ;Precise Solutions
  for (t in targs, y in ys) do :
    match(t:KTVar) : put(n(t), y)
  ;Approximate Solutions
  for (t in targs, y in ys) do :
    let loop (t:KTag = t) :
      match(t) :
        (t:KTVar) : put(n(t), y)
        (t:KOr) : do(loop, t)
        (t) : false
  ;Track substitutions
  val subs = Vector<KeyValue<Int,KTag>>()  
  ;Invert table
  for entry in solved do :
    val [x, y] = [key(entry), value(entry)]
    match(get?(solved, y)) :
      (x*:Int) : add(subs, x => KTVar(x*))
      (x*:False) : solved[y] = x
  ;Substitute unsolved targs
  for x in input-xs do :
    if not key?(solved, x) :
      add(subs, x => KTop())
  ;Compute new targs
  val output-ys = for y in ys map :
    get?(solved, y, y)
  ;Return
  [output-ys, subs]    

defn replace-tvars (t:KTag, entries:Table<Int,KTag>) :
  defn ft (t:KTag) :
    match(t:KTVar) : get?(entries, n(t), t)
    else : map(ft,t)
  trivial-simplify(ft(t))

defn replace-tvars (t:KLSType, entries:Table<Int,KTag>) :
  mapr(replace-tvars{_, entries}, t)

defn replace-tvars (f:KFn, entries:Vector<KeyValue<Int,KTag>>) :
  if empty?(entries) :
    f
  else :
    val entries = HashTable<Int,KTag>(entries)
    KFn(
      tail?(f),
      targs(f),
      map(replace-tvars{_, entries}, a1(f)),
      replace-tvars(a2(f), entries),
      args(f),
      mapr(replace-tvars{_:KTag, entries}, body(f)))

defn replace-tvars (f:KLSFn, entries:Vector<KeyValue<Int,KTag>>) :
  if empty?(entries) :
    f
  else :
    val entries = HashTable<Int,KTag>(entries)
    KLSFn(
      tail?(f),
      targs(f),
      map(replace-tvars{_, entries}, a1(f)),
      replace-tvars(a2(f), entries),
      args(f),
      mapr(replace-tvars{_:KTag, entries}, body(f)))

defn map-method (f:KDefmethod -> KDefmethod,
                 lsf:KLSDefmethod -> KLSDefmethod,
                 pkg:KPackage) -> KPackage :
  defn fm (c:KComm) :
    match(mapr(fm, c)) :
      (c:KDefmethod) : f(c)
      (c:KLSDefmethod) : lsf(c)
      (c) : c
  KPackage(
    name(pkg)
    ids(pkg)
    map(fm, comms(pkg)))

defn map-method-targs (pkg:KPackage) :
  defn fm (m:KDefmethod) :
    val v = value(m)
    if empty?(targs(m)) and empty?(targs(v)) :
      m
    else :
      val [targs*, unsolved] = inverse-solve(targs(v), targs(m))      
      val v* = let :
        val v = replace-tvars(v, unsolved)
        KFn(tail?(v), targs*, a1(v), a2(v), args(v), body(v))
      KDefmethod(multi(m), targs(m), thisn(m), v*)
  defn flm (m:KLSDefmethod) :
    val v = value(m)
    if empty?(targs(m)) and empty?(targs(v)) :
      m
    else :  
      val [targs*, unsolved] = inverse-solve(targs(v), targs(m))
      val v* = let :
        val v = replace-tvars(v, unsolved)
        KLSFn(tail?(v), targs*, a1(v), a2(v), args(v), body(v))
      KLSDefmethod(multi(m), targs(m), v*)
  map-method(fm, flm, pkg)

;============================================================
;===================== Tag Analysis =========================
;============================================================

;============================================================
;================= Boundary Guard Insertion =================
;============================================================

;============================================================
;==================== Utilities =============================
;============================================================

;================================
;==== Trivial Simplification ====
;================================

;Trivial Simplifications
defn trivial-simplify (t:KTag) :
  match(map(trivial-simplify, t)) :
    (t:KAnd) :
      match(a(t), b(t)) :
        (a:KBot, b) : a
        (a, b:KBot) : b
        (a:KTop, b) : b
        (a, b:KTop) : a
        (a, b) : t
    (t:KOr) :
      match(a(t), b(t)) :
        (a:KBot, b) : b
        (a, b:KBot) : a
        (a:KTop, b) : a
        (a, b:KTop) : b
        (a, b) : t
    (t) : t

;===========================
;==== Initialized Table ====
;===========================

defn HashTable<K,V> (es:Seqable<KeyValue<K,V>>) -> HashTable<K,V> :
  val t = HashTable<K,V>()
  for e in es do : t[key(e)] = value(e)
  t
