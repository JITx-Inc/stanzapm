defpackage stz/kform :
  import core
  import collections
  import stz/pl-ir
  import stz/kl-ir
  import stz/type-to-kform
  import stz/ids
  import stz/utils

;============================================================
;=================== Driver =================================
;============================================================

public defn compile (pkgs:List<KPackage>) :
  val dec-table = compute-declaration-table(pkgs)
  for pkg in pkgs do :
    vheader("Package %_" % [name(pkg)])
    println(pkg)
    val pkg1 = map-method-targs(pkg)
    vheader("Package %_ : After Mapping Method Targs" % [name(pkg)])
    println(pkg1)
    val pkg2 = create-closures(dec-table, pkg1)
    vheader("Package %_ : After Creating Closures" % [name(pkg)])
    println(pkg2)

;============================================================
;=================== Method Targ Mapping ====================
;============================================================

defn inverse-solve (input-xs:List<Int>, input-targs:List<KTag>) ->
                   [List<Int>, Vector<KeyValue<Int,KTag>>] :
  ;Created targs
  val ys = map(fresh-id{}, input-targs)
  ;Simplify
  val targs = map(trivial-simplify, input-targs)
  ;Gather Solutions
  val solved = HashTable<Int,Int>()
  defn put (x:Int, y:Int) :
    (solved[x] = y) when not key?(solved, x)
  ;Precise Solutions
  for (t in targs, y in ys) do :
    match(t:KTVar) : put(n(t), y)
  ;Approximate Solutions
  for (t in targs, y in ys) do :
    let loop (t:KTag = t) :
      match(t) :
        (t:KTVar) : put(n(t), y)
        (t:KOr) : do(loop, t)
        (t) : false
  ;Track substitutions
  val subs = Vector<KeyValue<Int,KTag>>()
  ;Invert table
  for entry in solved do :
    val [x, y] = [key(entry), value(entry)]
    match(get?(solved, y)) :
      (x*:Int) : add(subs, x => KTVar(x*))
      (x*:False) : solved[y] = x
  ;Substitute unsolved targs
  for x in input-xs do :
    if not key?(solved, x) :
      add(subs, x => KTop())
  ;Compute new targs
  val output-ys = for y in ys map :
    get?(solved, y, y)
  ;Return
  [output-ys, subs]

defn replace-tvars (t:KTag, entries:Table<Int,KTag>) :
  defn ft (t:KTag) :
    match(t:KTVar) : get?(entries, n(t), t)
    else : map(ft,t)
  trivial-simplify(ft(t))

defn replace-tvars (t:KLSType, entries:Table<Int,KTag>) :
  mapr(replace-tvars{_, entries}, t)

defn replace-tvars (f:KFn, entries:Vector<KeyValue<Int,KTag>>) :
  if empty?(entries) :
    f
  else :
    val entries = to-hashtable<Int,KTag>(entries)
    KFn(
      tail?(f),
      targs(f),
      map(replace-tvars{_, entries}, a1(f)),
      replace-tvars(a2(f), entries),
      args(f),
      mapr(replace-tvars{_:KTag, entries}, body(f)))

defn replace-tvars (f:KLSFn, entries:Vector<KeyValue<Int,KTag>>) :
  if empty?(entries) :
    f
  else :
    val entries = to-hashtable<Int,KTag>(entries)
    KLSFn(
      tail?(f),
      targs(f),
      map(replace-tvars{_, entries}, a1(f)),
      replace-tvars(a2(f), entries),
      args(f),
      mapr(replace-tvars{_:KTag, entries}, body(f)))

defn map-method (f:KDefmethod -> KDefmethod,
                 lsf:KLSDefmethod -> KLSDefmethod,
                 pkg:KPackage) -> KPackage :
  defn fm (c:KComm) :
    match(mapr(fm, c)) :
      (c:KDefmethod) : f(c)
      (c:KLSDefmethod) : lsf(c)
      (c) : c
  KPackage(
    name(pkg)
    ids(pkg)
    map(fm, comms(pkg)))

defn map-method-targs (pkg:KPackage) :
  defn fm (m:KDefmethod) :
    val v = value(m)
    if empty?(targs(m)) and empty?(targs(v)) :
      m
    else :
      val [targs*, unsolved] = inverse-solve(targs(v), targs(m))
      val v* = let :
        val v = replace-tvars(v, unsolved)
        KFn(tail?(v), targs*, a1(v), a2(v), args(v), body(v))
      KDefmethod(multi(m), targs(m), thisn(m), v*)
  defn flm (m:KLSDefmethod) :
    val v = value(m)
    if empty?(targs(m)) and empty?(targs(v)) :
      m
    else :
      val [targs*, unsolved] = inverse-solve(targs(v), targs(m))
      val v* = let :
        val v = replace-tvars(v, unsolved)
        KLSFn(tail?(v), targs*, a1(v), a2(v), args(v), body(v))
      KLSDefmethod(multi(m), targs(m), v*)
  map-method(fm, flm, pkg)

;============================================================
;==================== Declaration Table =====================
;============================================================

deftype DecTable
defmulti global-function? (t:DecTable, n:Int) -> True|False
defmulti arity (t:DecTable, n:Int) -> Int

defn compute-declaration-table (pkgs:List<KPackage>) :
  val globals = HashTable<Int,True>()
  val table = HashTable<Int,KComm>()
  
  defn declaration? (c:KComm) -> Int|False :
    match(c:KDef|KDefVar|KDefn|KDefmulti|
            KLSDef|KLSDefVar|KLSDefn|KLSExternFn|KLSExtern) :
      n(c)
  defn scan (c:KComm) :
    dor(scan, c)
    match(declaration?(c)) :
      (n:Int) : table[n] = c
      (n:False) : false

  ;Scan through commands
  for comm in seq-cat(comms, pkgs) do :
    scan(comm)
    match(declaration?(comm)) :
      (n:Int) : globals[n] = true
      (n:False) : false      
      
  new DecTable :
    defmethod global-function? (this, n:Int) :
      key?(globals,n) and
      get?(table,n) is KDefn|KDefmulti|KLSDefn
    defmethod arity (this, n:Int) :
      match(table[n]) :
        (d:KDefn) : length(a1(value(d)))
        (d:KLSDefn) : length(a1(value(d)))
        (d:KDefmulti) : length(a1(d))

;============================================================
;===================== Closure Creation =====================
;============================================================

defn map-closures (dec-table: DecTable
                   f: KMix|KCurry|KVar -> KAFn,
                   lf: KLSMix|KLSCurry|KLSVar -> KLSAFn,
                   pkg: KPackage) -> KPackage :
  defn fe (e:KExp) -> KExp :
    match(e) :
      (e:KMix|KCurry) :
        f(e)
      (e:KVar) :
        f(e) when global-function?(dec-table, n(e)) else e
      (e:KDo) :
        match(func(e)) :
          (f:KMix|KCurry|KVar) : KDo(f, map(fe,args(e)), a1(e), a2(e))
          (f) : mapr(fe, e)
      (e) : mapr(fe, e)
  defn fle (e:KLSExp) -> KLSExp :
    match(e) :
      (e:KLSMix|KLSCurry) :
        lf(e)
      (e:KLSVar) :
        lf(e) when global-function?(dec-table, n(e)) else e
      (e:KLSCall) :
        match(func(e)) :
          (f:KLSMix|KLSCurry|KLSVar) : KLSCall(f, map(fle,args(e)), type(e))
          (f) : mapr(fle, e)
      (e) : mapr(fle, e)    
  defn fc (c:KComm) :
    mapr(fle, mapr(fe, c))
  KPackage(
    name(pkg),
    ids(pkg),
    map(fc, comms(pkg)))

defn mix-fn (dec-table: DecTable, f:KMix|KCurry|KVar) :
  defn make-fn (f:KExp, n:Int) :
    val args* = map(fresh-id{}, 0 to n)
    val a1* = map(KTop{}, args*)
    val body = KDo(f, map(KVar,args*), a1*, KTop())
    KFn(true, List(), a1*, KTop(), args*, body)

  match(f) :
    (f:KCurry|KVar) :
      make-fn(f, arity(dec-table, n(f)))
    (f:KMix) :
      val groups = to-hashtable<Int,List<KCurry|KVar>>(List())
      for exp in exps(f) do :
        val n = arity(dec-table, n(exp))
        groups[n] = cons(exp, groups[n])
      KMultifn{to-list(_)} $ for entry in groups seq :
        val [n, fs] = [key(entry), value(entry)]
        if length(fs) == 1 : make-fn(head(fs), n)
        else : make-fn(KMix(fs), n)

defn create-closures (dec-table: DecTable, pkg:KPackage) -> KPackage :
  defn to-exp (f:KLSExp) :
    match(f) :
      (f:KLSMix) : KMix(map({to-exp(_) as KCurry}, exps(f)))
      (f:KLSCurry) : KCurry(n(f), targs(f))
      (f:KLSVar) : KVar(n(f))    
  map-closures(
    dec-table,
    fn (e) : KAFn(mix-fn(dec-table, e))
    fn (e) : KLSAFn(mix-fn(dec-table, to-exp(e)))
    pkg)
        
;============================================================
;===================== Tag Analysis =========================
;============================================================

;============================================================
;================= Boundary Guard Insertion =================
;============================================================

;============================================================
;==================== Utilities =============================
;============================================================

;================================
;==== Trivial Simplification ====
;================================

;Trivial Simplifications
defn trivial-simplify (t:KTag) :
  match(map(trivial-simplify, t)) :
    (t:KAnd) :
      match(a(t), b(t)) :
        (a:KBot, b) : a
        (a, b:KBot) : b
        (a:KTop, b) : b
        (a, b:KTop) : a
        (a, b) : t
    (t:KOr) :
      match(a(t), b(t)) :
        (a:KBot, b) : b
        (a, b:KBot) : a
        (a:KTop, b) : a
        (a, b:KTop) : b
        (a, b) : t
    (t) : t

;===========================
;==== Initialized Table ====
;===========================

defn to-hashtable<K,V> (es:Seqable<KeyValue<K,V>>) -> HashTable<K,V> :
  val t = HashTable<K,V>()
  for e in es do : t[key(e)] = value(e)
  t
