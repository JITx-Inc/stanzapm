defpackage stz/kform :
  import core
  import collections
  import stz/pl-ir
  import stz/kl-ir
  import stz/khier
  import stz/ids
  import stz/dec-table
  import stz/tgt-ir
  import stz/utils
  import stz/primitives
  import stz/kform-to-tgt
  import stz/algorithms
  import stz/params

;============================================================
;======================= Driver =============================
;============================================================

public defn compile (pkgs:List<KPkgComm>) -> List<TGPackage> :
  var dec-table = compute-declaration-table(pkgs)
  val hier = KHierarchy(seq-cat(hier-entries, pkgs))

  var pkgs*:List<KPkgComm> = pkgs
  defn map-pkgs (f:KPackage -> KPackage|TGPackage) :
    pkgs* = for pkg in pkgs* map :
      match(pkg) :
        (pkg:TGPackage) : pkg
        (pkg:KPackage) : f(pkg)

  map-pkgs $ fn (#pkg) :
    var pkg:KPackage = #pkg
    vheader("Package %_" % [name(pkg)])
    vprintln(pkg)
    pkg = analyze-stack-properties(pkg)
    vheader("Package %_ : After Analyzing Stack Properties" % [name(pkg)])
    vprintln(pkg)
    pkg = map-method-targs(dec-table, pkg)
    vheader("Package %_ : After Mapping Method Targs" % [name(pkg)])
    vprintln(pkg)
    pkg = create-closures(dec-table, pkg)
    vheader("Package %_ : After Creating Closures" % [name(pkg)])
    vprintln(pkg)
    pkg = convert-mixes(dec-table, pkg)
    vheader("Package %_ : After Converting Mixes" % [name(pkg)])
    vprintln(pkg)
    pkg = guard-boundary(dec-table, pkg)
    vheader("Package %_ : After Guarding Boundary" % [name(pkg)])
    vprintln(pkg)

    ;Package is done here.
    pkg = normalize-kform(pkg)
    vheader("Package %_ : After Normalizing KForm" % [name(pkg)])
    vprintln(pkg)    
    pkg = lift-constants(dec-table, pkg)
    vheader("Package %_ : After Lifting Constants" % [name(pkg)])
    vprintln(pkg)
    pkg = box-mutables(dec-table, pkg)
    vheader("Package %_ : After Boxing Mutables" % [name(pkg)])
    vprintln(pkg)
    pkg = detect-loops(pkg)
    vheader("Package %_ : After Detecting Loops" % [name(pkg)])
    vprintln(pkg)
    pkg = simple-inline(pkg)
    vheader("Package %_ : After Simple Inlining" % [name(pkg)])
    vprintln(pkg)
    pkg

  dec-table = compute-declaration-table(pkgs*)
  map-pkgs $ fn (#pkg) :
    var pkg:KPackage = #pkg
    pkg = elide-checks(dec-table, hier, pkg)
    vheader("Package %_ : After Eliding Checks" % [name(pkg)])
    vprintln(pkg)
    pkg = lambda-lift(dec-table, pkg)
    vheader("Package %_ : After Lambda Lifting" % [name(pkg)])
    vprintln(pkg)
    pkg = lift-objects(dec-table, pkg)
    vheader("Package %_ : After Lifting Objects" % [name(pkg)])
    vprintln(pkg)
    pkg = lift-closures(dec-table, pkg)
    vheader("Package %_ : After Lifting Closures" % [name(pkg)])
    vprintln(pkg)
    pkg = primitive-tagging(pkg)
    vheader("Package %_ : After Tagging Primitives" % [name(pkg)])
    vprintln(pkg)
    pkg = reify-types(pkg)
    vheader("Package %_ : After Reifying Types" % [name(pkg)])
    vprintln(pkg)
    pkg

  dec-table = compute-declaration-table(pkgs*)
  map-pkgs $ fn (pkg) :
    to-tgpackage(dec-table, pkg)

  ;Return packages
  pkgs* as List<TGPackage>

;============================================================
;================== Optimized Mode ==========================
;============================================================

public defn compile-optimized (#pkg:KPackage) :
  ;Package, Declaration Table, and Hierarchy
  var pkg:KPackage = #pkg
  var dec-table = compute-declaration-table(List(pkg))
  var hier:KHierarchy
  
  defn @update-pkg (update-name:String, f: () -> KPackage) :
    vheader("Package %_ : %_" % [name(pkg), update-name])
    val t0 = current-time-ms()
    pkg = f()
    val t1 = current-time-ms()
    vprintln("(%_) Time elapsed = %_" % [update-name, t1 - t0])
    vprintln(pkg)    
  defn update-pkg (update-name:String, f:KPackage -> KPackage) :
    @update-pkg(update-name, f{pkg})
  defn update-pkg (update-name:String, f:(DecTable, KPackage) -> KPackage) :
    @update-pkg(update-name, f{dec-table, pkg})
  defn update-pkg (update-name:String, f:(DecTable, KHierarchy, KPackage) -> KPackage) :
    @update-pkg(update-name, f{dec-table, hier, pkg})
  defn update-dec-table () :
    dec-table = compute-declaration-table(List(pkg))
  defn update-hier () :
    hier = KHierarchy(seq-cat(hier-entries, List(pkg)))

  ;Pretransformations
  update-pkg("Analyze Stack Properties", analyze-stack-properties)
  update-pkg("Map Method Targs", map-method-targs)
  update-pkg("Create Closures", create-closures)
  update-pkg("Convert Mixes", convert-mixes)
  update-pkg("Guard Boundary", guard-boundary)

  ;Transformation Pipeline
  update-pkg("Normalize KForm", normalize-kform)
  update-pkg("Lift Constants", lift-constants)
  update-pkg("Box Mutables", box-mutables)
  update-pkg("Detect Loops", detect-loops)
  update-pkg("Simple Inline", simple-inline)
  update-dec-table()
  update-hier()
  update-pkg("Resolve Methods", resolve-methods)
  update-pkg("Full Inline", full-inline)
  update-dec-table()
  update-hier()
  update-pkg("Elide Checks", elide-checks)
  update-pkg("Lambda Lift", lambda-lift)
  update-pkg("Lift Objects", lift-objects)
  update-pkg("Lift Closures", lift-closures)
  update-pkg("Primitive Tagging", primitive-tagging)
  update-dec-table()
  update-hier()
  update-pkg("Resolve Methods", resolve-methods)
  update-pkg("Full Inline", full-inline)
  update-dec-table()
  update-hier()
  update-pkg("Erase Types", erase-types)

  ;Return
  update-dec-table()
  to-tgpackage(dec-table, pkg)

;============================================================
;==================== Flatten ===============================
;============================================================

public defn flatten (pkgs:List<KPackage>) -> KPackage :
  val ids* = PkgIds(STANZA-VERSION, OUTPUT-PLATFORM, decls*, List()) where :
    val decls* = for pkg in pkgs seq-append :
      declarations(ids(pkg))
  val exps* = seq-append(exps, pkgs)
  KPackage(`program, ids*, exps*, false)

;============================================================
;============== Compute Declaration Table ===================
;============================================================

defn compute-declaration-table (pkgs:List<KPkgComm>) :
  val table = DecTable()
  defn scan (e:KTExp) :
    defn scan-e (e:KExp) :
      do(scan-e, e)
      register(table, e)
    register(table, e)
    do(scan-e, e)
  for pkg in pkgs do :
    match(pkg) :
      (pkg:KPackage) : do(scan, exps(pkg))
      (pkg:TGPackage) : do(register{table, _}, declarations(ids(pkg)))
  table

;============================================================
;=================== Stack Properties =======================
;============================================================

;TODO: This is not a good way of exposing this feature.
defn analyze-stack-properties (pkg:KPackage) :
  ;Returns analyzed stack properties and new body.
  ;(If the body it's not the checkstack)
  defn stack-properties (e:KExp) -> [StackProperties, KExp] :
    match(e) :
      (e:KSeq) :
        val [sp, a*] = stack-properties(a(e))
        [sp, KSeq(a*, b(e))]
      (e:KPrim) :
        switch(op(e) as? LSPrimitive) :
          LS-NEW-STACK-OP : [NewStack(), KLiteral(false)]
          LS-LAST-STACK-OP : [LastStack(), KLiteral(false)]
          else : fail()
      (e) :
        fail()

  defn fe (e:KExp) :
    match(map(fe,e)) :
      (e:KFn) :
        attempt :
          val [sp, body*] = stack-properties(body(e))
          attach-sp-body(e, sp, body*)
        else : e
      (e) : e
  defn fte (e:KTExp) : print-if-annotated(map(fe,e))
  map(fte, pkg)

;============================================================
;================== Method TArg Mapping =====================
;============================================================

defn inverse-solve (input-xs:List<Int>, targs:List<KType>) -> [List<Int>, List<KType>] :
  ;Created targs
  val ys = map(fresh-id{}, targs)
  ;Initialize solved table
  val solved = IntTable<Int>()
  defn update (x:Int, y:Int) :
    set?(solved, x, {y})
  ;Precise Solutions
  for (t in targs, y in ys) do :
    match(t:KTVar) : update(n(t), y)
  ;Approximate Solutions
  for (t in targs, y in ys) do :
    let loop (t:KType = t) :
      match(t) :
        (t:KTVar) : update(n(t), y)
        (t:KOr) : do(loop, t)
        (t) : false
  ;Invert solutions
  val solns = for x in input-xs map :
    match(get?(solved,x)) :
      (y:Int) : KTVar(y)
      (y:False) : KTop()
  ;Return solutions
  [ys, solns]

defn map-methods (pkg:KPackage, dec-table:DecTable, f:(KFn|KFn*, Int, List<KType>) -> KFn|KFn*) :
  defn registered (e:KTExp) : (register(dec-table,e), e)
  defn fe (e:KExp) :
    match(map(fe,e)) :
      (e:KMethod*) :
        val value* = f(value(e) as KFn|KFn*, multi(e), targs(e))
        KMethod(props(e), multi(e), thisn(e), value*)
      (e) : e
  defn fte (e:KTExp) :
    print-if-annotated $ match(map(fe,e)) :
      (e:KDefmethod*) :
        val value* = f(value(e) as KFn|KFn*, multi(e), targs(e))
        registered(KDefmethod(props(e), fresh-id(), multi(e), value*))
      (e) : e
  map(fte, pkg)

defn replace-tvars (e:KExp, xs:List<Int>, ts:List<KType>) :
  val table = to-hashtable<Int,KType>(xs,ts)
  defn fe (e:KExp) :
    val e* = map(fe, e)
    map(replace-tvars{_:KType, table}, e*)
  fe(e)

defn attach (f:KFn|KFn*, targs:List<Int>, a1:List<KType>, a2:KType) :
  match(f) :
    (f:KFn) : KFn(tail?(f), stack-properties(f), targs, a1, a2, args(f), body(f), info(f))
    (f:KFn*) : KFn*(tail?(f), targs, a1, a2, args(f), body(f), info(f))

defn map-method-targs (dec-table:DecTable, pkg:KPackage) :
  map-methods(pkg, dec-table
    fn (f:KFn|KFn*, m:Int, targ-types:List<KType>) :
      val [targs*, targ-types*] = inverse-solve(targs(f), targ-types)
      val [multi-a1, multi-a2] = fn-types(dec-table, m, map(KTVar,targs*))
      val f* = replace-tvars(f, targs(f), targ-types*) as KFn|KFn*
      val a1* = map(KAnd, multi-a1, a1(f*))
      val a2* = KAnd(multi-a2, a2(f*))
      attach(f*, targs*, a1*, a2*))

;============================================================
;===================== Closure Creation =====================
;============================================================

defn map-closures (pkg: KPackage, dec-table: DecTable
                   f: KMix|KCurry|KVar -> KFn|KMultifn) -> KPackage :
  ;Track newly introduced global functions
  val global-functions = HashTable-init<Int,KDefConst> $
    KDefConst{fresh-id(), f(KVar(_))}
  defn lift-function (func:Int) :
    n(global-functions[func])
  defn prepend-defs (pkg:KPackage) :
    do(register{dec-table, _}, values(global-functions))
    attach-exps(pkg, append(values(global-functions), exps(pkg)))

  ;Map over expressions
  defn fe (e:KExp) :
    match(e) :
      (e:KMix|KCurry) :
        defn remove-var* (e:KExp) :
          match(e:KVar*) : KVar(n(e))
          else : map(remove-var*,e)
        f(remove-var*(e) as KMix|KCurry)
      (e:KVar|KVar*) :
        if global?(dec-table,n(e)) and function?(dec-table, n(e)) :
          KVar(lift-function(n(e)))
        else : e
      (e) :
        map-without-functions(fe, e)
  defn fte (e:KTExp) :
    print-if-annotated(map(fe, e))
  prepend-defs(map(fte,pkg))

defn create-closures (dec-table:DecTable, pkg:KPackage) -> KPackage :
  defn mix-fn (dec-table:DecTable, f:KMix|KCurry|KVar) :
    defn make-fn (f:KExp, arity:Int) :
      val args* = map(fresh-id{}, 0 to arity)
      val body = KDo(f, KVars(args*), KTop(), false)
      val info = let loop (f:KExp = f) :
        match(f) :
          (f:KVar|KCurry) : info(dec-table, n(f))
          (f:KMix) : loop(head(exps(f)))
      KFn(true, CheckStack(), List(), KTops(args*), KTop(), args*, body, info)

    match(f) :
      (f:KCurry|KVar) :
        make-fn(f, arity(dec-table, n(f)))
      (f:KMix) :
        val groups = IntTable<List<KCurry|KVar|KVar*>>(List())
        for exp in exps(f) as List<KCurry|KVar|KVar*> do :
          val n = arity(dec-table, n(exp))
          update(groups, cons{exp, _}, n)
        KMultifn{to-list(_)} $ for entry in groups seq :
          val [n, fs] = [key(entry), value(entry)]
          if length(fs) == 1 : make-fn(head(fs), n)
          else : make-fn(KMix(fs), n)

  map-closures(pkg, dec-table, mix-fn{dec-table, _})

;============================================================
;===================== Mix Conversion =======================
;============================================================

defn map-mixes (pkg:KPackage, f: KDo|KDo* -> KExp) :
  defn fe (e:KExp) :
    match(map(fe,e)) :
      (e:KDo|KDo*) :
        match(func(e):KMix) : f(e)
        else : e
      (e) : e
  defn fte (e:KTExp) :
    print-if-annotated(map(fe, e))
  map(fte, pkg)

defn convert (dec-table:DecTable, e:KDo|KDo*) :
  ;===== Utilities =====
  ;Construct a call to f with given arguments and return type
  defn Do (f:KExp, args:List<KExp>, a2:KType) :
    match(e) :
      (e:KDo) : KDo(f, args, a2, info(e))
      (e:KDo*) : KDo*(f, args, a1(e), a2, info(e))

  ;Retrieve argument types for function
  defn arg-types (e:KExp) :
    val n = n(e as KVar|KVar*|KCurry)
    fst(/fn-types(dec-table, n))

  ;Retrieve argument types for given function
  defn fn-types (f:KCurry|KVar|KVar*) :
    match(f) :
      (f:KVar|KVar*) : /fn-types(dec-table, n(f), List())
      (f:KCurry) : /fn-types(dec-table, n(f), targs(f))

  ;===== Stages =====
  ;Pull out definitions to before call
  defn pull-out-defs (e:KDo|KDo*) :
    val defs = Vector<KeyValue<Int,KExp>>()
    val args* = Vector<KVar>()
    for x in args(e) do :
      match(x) :
        (x:KVar) :
          add(args*, x)
        (x) :
          val id = fresh-id()
          add(defs, id => x)
          add(args*, KVar(id))
    KLet(defs, make-dispatch(func(e) as KMix, to-list(args*)))

  ;Make a call to func with given args
  defn make-dispatch (func:KMix, args:List<KExp>) :
    if all?(histanza?, arg-types(head(exps(func)))) :
      val bs = for f in exps(func) as List<KCurry|KVar|KVar*> map :
        val args* = map(fresh-id{}, args)
        val [a1, a2] = fn-types(f)
        KBranch(args*, a1, Do(f, KVars(args*), a2))
      KDispatch(args, bs, info(e))
    else :
      ;Compute mask
      val refmask = map(histanza?, arg-types(head(exps(func))))
      val refargs = select(args, refmask)
      ;Create branches
      val bs = for f in exps(func) as List<KCurry|KVar|KVar*> map :
        val refargs* = map(fresh-id{}, refargs)
        val args* = replace(args, refmask, KVars(refargs*))
        val [a1, a2] = fn-types(f)
        KBranch(refargs*, select(a1,refmask), Do(f,args*,a2))
      ;Create dispatch
      KDispatch(refargs, bs, info(e))

  ;Driver
  pull-out-defs(e)

defn convert-mixes (dec-table:DecTable, pkg:KPackage) -> KPackage :
  map-mixes(pkg, convert{dec-table, _})

;============================================================
;=================== Boundary Guards ========================
;============================================================

defn guard-boundary (dec-table:DecTable, pkg:KPackage) :
  ;Guard a call to a known function
  defn guard-call-to-known (e:KDo*, tail-pos?:True|False) :
    val [n, targs] = n+targs(func(e))
    val [a1, a2] = fn-types(dec-table, n, targs)
    ;Guard arguments when necessary
    val args* =
      if guarded?(dec-table, n) :
        args(e)
      else :
        map(KCheck{_, _, ARG-ERROR-TYPE, info(e)}, args(e), a1)
    ;Make call
    val call = KDo(func(e), args*, a2, info(e))
    ;Determine whether return should be guarded
    val guard-return? =
      if tail-pos? : false
      else if not guarded?(dec-table, n) : true
      else if tail?(dec-table, n) : true
      else : false
    ;Guard return when necessary
    if guard-return? : KCheck(call, a2, RETURN-ERROR-TYPE, info(e))
    else : call

  ;Guard a call to an unknown function
  defn guard-call-to-unknown (e:KDo*, tail-pos?:True|False) :
    val args* = map(KCheck{_, _, ARG-ERROR-TYPE, info(e)}, args(e), a1(e))
    val func* = guard-func(func(e), info(e))
    val call = KDo(func*, args*, a2(e), info(e))
    if tail-pos? : call
    else : KCheck(call, a2(e), RETURN-ERROR-TYPE, info(e))

  ;Guard a function
  defn guard-func (e:KExp, info:FileInfo|False) :
    for f in e map-inwards :
      match(f) :
        (f:KVar|KVar*) :
          if function?(dec-table, n(f)) : f
          else : KCheck(f, KOf(FN-TYPE-ID), CALL-ERROR-TYPE, info)
        (f:KCurry) : f
        (f) : KCheck(f, KOf(FN-TYPE-ID), CALL-ERROR-TYPE, info)

  ;Cast expression to just the variables tvars in the type
  defn KCheckTVar (e:KExp, t:KType, i:False|FileInfo) :
    defn strip (t:KType) :
      if has-var?(t) :
        match(t:KOr) : t
        else : map(strip, t)
      else : KTop()
    KCheck(e, strip(t), ARG-ERROR-TYPE, i)

  ;Add boundary guards
  defn guard (e:KExp, tail-pos?:True|False, method-pos?:True|False) -> KExp :
    defn recur (e:KExp) :
      map-tail(guard{_, _, e is KMethod}, e, tail-pos?)
    match(e) :
      (e:KMethod) :
        defn args! (e:KExp) : args(e as KFn|KFn*)
        val i = index-of!(args!(value(e)), thisn(e))
        val e* = recur(e) as KMethod
        val thisn* = args!(value(e*))[i]
        KMethod(props(e), multi(e*), thisn*, value(e*))
      (e0:KFn*) :
        val e = recur(e0) as KFn*
        ;Check arguments
        val args* = map(fresh-id{}, args(e))
        val defs = for (a in args(e), a* in args*, t in a1(e)) map :
          if method-pos? : a => KCheckTVar(KVar(a*), t, info(e))
          else : a => KCheck(KVar(a*), t, ARG-ERROR-TYPE, info(e))
        ;Check return
        val body* =
          if tail?(e) : body(e)
          else : map-return(KCheck{_, a2(e), RETURN-ERROR-TYPE, info(e)}, body(e))
        ;Create function
        KFn(tail?(e), CheckStack(), targs(e), a1(e), a2(e),
            args*, KLet(defs, body*), info(e))
      (e:KDo*) :
        recur $ match(func(e)) :
          (f:KVar|KVar*) :
            if function?(dec-table, n(f)) : guard-call-to-known(e, tail-pos?)
            else : guard-call-to-unknown(e, tail-pos?)
          (f:KCurry) : guard-call-to-known(e, tail-pos?)
          (f) : guard-call-to-unknown(e, tail-pos?)
      (e:KVar*) :
        val check? =
          (not function?(dec-table, n(e))) and  ;Not a function and
          guarded?(dec-table, n(e)) and (       ;Guarded and
            global?(dec-table, n(e)) or           ;Global or
            mutable?(dec-table, n(e)) and         ;Mutable and
            not initialized?(dec-table, n(e)))    ;not initialized
        if check? : KEnsureSet(KVar(n(e)), info(e))
        else : KVar(n(e))
      (e:KLet*) :
        val v* = KCheck(value(e), type(e), DEF-ERROR-TYPE, info(e))
        recur(KLet(n(e), v*, body(e)))
      (e:KLetVar*) :
        val v* = attempt: KCheck(value(e) as? KExp, type(e), DEF-ERROR-TYPE, info(e))
        recur(KLetVar(n(e), type(e), v*, body(e)))
      (e:KSet*) :
        val loc = mapr(guard{_, false, false}, loc(e))
        val v = guard(value(e), false, false)
        val v* = match(loc) :
          (loc:KVarLoc) :
            if guarded?(dec-table, n(loc)) :
              KCheck(v, type(e), SET-ERROR-TYPE, info(e))
            else : v
          (loc) : v
        KSet(loc, type(e), v*)
      (e0:KBranch*) :
        val e = recur(e0) as KBranch*
        val guards = for (a in args(e), t in types(e)) map :
          KCheckTVar(KVar(a), t, info(e))
        val body* = KSeq(guards, body(e))
        KBranch(args(e), types(e), body*)
      (e0:KEnsureLength) :
        val e = recur(e0) as KEnsureLength
        val v = KCheck(exp(e), KOf(TUPLE-TYPE-ID), TUPLE-ERROR-TYPE, info(e))
        KEnsureLength(v, length(e), info(e))
      (e) :
        recur(e)

  ;Add guards
  defn guard (e:KTExp) :
    defn recur (e:KTExp) :
      map(guard{_, false, e is KDefmethod}, e)
    print-if-annotated $ match(recur(e)) :
      (e:KDef*) :
        val v* = KCheck(value(e), type(e), DEF-ERROR-TYPE, info(e))
        KDef(n(e), type(e), v*)
      (e:KDefVar*) :
        val v* = attempt: KCheck(value(e) as? KExp, type(e), DEF-ERROR-TYPE, info(e))
        KDefVar(n(e), type(e), v*)
      (e) : e

  map(guard, pkg)

;============================================================
;=================== KForm Normalization ====================
;============================================================
defn mutable-globals (pkg:KPackage) -> IntSet :
  val mutables = IntSet()
  for import in seq-cat(imports, imports(ids(pkg))) do :
    match(id(import):VarId|LSVarId) :
      add(mutables, n(import))
  for te in pkg do :
    match(te:KDefVar) :
      add(mutables, n(te))
  mutables

defn normalize-kform (pkg:KPackage) :
  ;Mutable Table
  val mutables = mutable-globals(pkg)

  ;Convert all expressions to KForm
  defn to-kform (e:KExp) :
    ;Holds the wrapper
    var wrapper: KExp -> KExp = {_}
    defn add-wrapper (f:KExp -> KExp) :
      val current-wrapper = wrapper
      wrapper = current-wrapper{f(_)}

    ;Returns an atom for representing the result of e
    defn atomize (e:KExp) -> KExp :
      val atomic? = match(e) :
        (e:KLiteral|KLSLiteral) : true
        (e:KVar) : not mutables[n(e)]
        (e) : false
      if atomic? :
        e
      else :
        val n = fresh-id()
        remove-compound-exps(KLet(n, e, KVar(n)))

    ;Returns an atom for representing e (assuming e is in function position)
    defn atomize-func (e:KExp) :
      match(e) :
        (e:KCurry) : e
        (e:KRead) : map(atomize, e)
        (e) : atomize(e)

    ;Returns an expression without nested expressions
    defn remove-compound-exps (e:KExp) -> KExp :
      match(e) :
        ;These expressions introduce wrappers
        (e:KLet) :
          val value* = remove-compound-exps(value(e))
          add-wrapper(KLet{n(e), value*, _})
          remove-compound-exps(body(e))
        (e:KLetVar) :          
          val value* = attempt: atomize(value(e) as? KExp)
          add(mutables, n(e))
          add-wrapper(KLetVar{n(e), type(e), value*, _})
          remove-compound-exps(body(e))
        (e:KLetRec) :
          val values* = map(to-kform, values(e))
          add-wrapper(KLetRec{ns(e), values*, _})
          remove-compound-exps(body(e))
        (e:KLetType) :
          val value* = atomize(value(e))
          add-wrapper(KLetType{n(e), value*, _})
          remove-compound-exps(body(e))
        (e:KSeq) :
          val a* = remove-compound-exps(a(e))
          add-wrapper(KSeq{a*, _})
          remove-compound-exps(b(e))

        ;These expressions have special invariants
        (e:KReturn) :
          match(exp(e)) :
            (f:KDo) : map(remove-compound-exps, e)
            (f) : map(atomize, e)
        (e:KDo) :          
          val args* = map(atomize, args(e))
          match(push-call-inwards(func(e), KDo{_, args*, type(e), info(e)})) :
            (e:KDo) : KDo(atomize-func(func(e)), args(e), type(e), info(e))
            (e) : remove-compound-exps(e)
        (e:KDoC) :
          val args* = map(atomize, args(e))
          val varargs* = map(atomize, varargs(e))
          match(push-call-inwards(func(e), KDoC{_, args*, varargs*, type(e)})) :
            (e:KDoC) : KDoC(atomize-func(func(e)), args(e), varargs(e), type(e))
            (e) : remove-compound-exps(e)
          
        ;These expressions contain a mix of atomizable and structured sub-exps
        (e:KMatch) : KMatch(map(atomize,args(e)), map(to-kform,branches(e)), info(e))
        (e:KDispatch) : KDispatch(map(atomize,args(e)), map(to-kform,branches(e)), info(e))
        (e:KIf) : KIf(atomize(pred(e)), to-kform(conseq(e)), to-kform(alt(e)))

        ;These expressions are structured
        (e:KBranch|KLabels|KBlock|KFn|KMultifn|KNew|KMethod|KAndExp|KOrExp) : map(to-kform, e)
        
        ;All other expressions are unrestricted
        (e) : map(atomize, e)

    ;Push call into structured func
    defn push-call-inwards (e:KExp, call:KExp -> KExp) -> KExp :
      for f in e map-inwards :
        match(f) :
          (f:KReturn|KGoto) : f   ;Ignore call
          (f) : call(f)           ;Make call

    ;Launcher
    wrapper(remove-compound-exps(e))

  ;Convert all expressions in pkg
  for te in pkg map :
    map(to-kform, te)

;============================================================
;================== Free Variable Analysis ==================
;============================================================
defn compute-freevars (dec-table:DecTable, pkg:KPackage) :
  ;Variable tracking
  var vars = IntSet()
  var tvars = IntSet()
  defn use-var (v:Int) : add(vars, v)
  defn def-var (v:Int) : remove(vars, v)
  defn use-tvar (v:Int) : add(tvars, v)
  defn def-tvar (v:Int) : remove(tvars, v)
  defn all-vars () : to-list(vars)
  defn all-tvars () : to-list(tvars)

  ;Mapping function
  defn scan (e:KExp) -> KExp :
    match(e) :
      (e:KFn) :
        val e* =
          let-var vars = IntSet() :
            let-var tvars = IntSet() :
              val e* = map-bound-rev(scan, def-var, def-tvar, scan, e) as KFn
              attach(e*, KFnStat(all-vars(), all-tvars()))
        do(use-var, freevars(e*))
        do(use-tvar, freetypes(e*))
        e*
      (e) :
        for v in e do-used-vars :
          use-var(v) when not global?(dec-table, v)
        do-used-tvars(use-tvar, e)
        map-bound-rev(scan, def-var, def-tvar, scan, e)

  ;Scanning a top level expression
  defn scan (e:KTExp) : map(scan, e)
  map(scan, pkg)

;============================================================
;==================== Constant Lifting ======================
;============================================================

defn lift-constants (dec-table:DecTable, pkg:KPackage) :
  val defs = Vector<KDefConst>()
  defn prepend-defs (pkg:KPackage) :
    do(register{dec-table, _}, defs)
    attach-exps(pkg, append(defs, exps(pkg)))
  defn make-const (v) :
    val n = fresh-id()
    add(defs, KDefConst(n,v))
    KVar(n)
  defn fe (e:KExp) :
    match(map(fe,e)) :
      (e:KLiteral) :
        match(value(e)) :
          (v:Long|Double|String|Symbol|List) : make-const(v)
          (v) : e
      (e) : e
  defn fte (e:KTExp) : print-if-annotated(map(fe,e))
  prepend-defs(map(fte,pkg))

;============================================================
;================ Mutable Variable Lifting ==================
;============================================================
defn box-mutables (dec-table:DecTable, pkg:KPackage) :
  ;Compute closed over set
  val [closed-over, local-vars] = let :
    val cset = IntSet()
    val vset = IntSet()
    defn scan (e:KExp) :
      do(scan, e)
      match(e) :
        (e:KFn) : add-all(cset, freevars(e))
        (e:KLetVar) : add(vset, n(e))
        (e) : false
    defn scan (e:KTExp) : do(scan, e)
    do(scan, compute-freevars(dec-table, pkg))
    [cset, vset]

  ;Box a variable
  defn box? (n:Int) :
    local-vars[n] and closed-over[n]
  defn box? (e:KLoc) :
    match(e:KVarLoc) : box?(n(e))

  ;Algorithm
  defn lift (e:KExp) :
    defn recur (e:KExp) : map(lift, e)
    match(e) :
      (e:KLetVar) :
        recur $
          if box?(n(e)) : KLet(n(e), KBox(value(e)), body(e))
          else : e
      (e:KVar) :
        if box?(n(e)) : KBoxGet(e)
        else : e
      (e:KSet) :
        if box?(loc(e)) :
          val v = KVar(n(loc(e) as KVarLoc))
          KBoxSet(v, lift(value(e)))
        else : recur(e)
      (e) :
        recur(e)

  defn lift (e:KTExp) : print-if-annotated(map(lift, e))
  map(lift, pkg)

;============================================================
;======================= Renaming ===========================
;============================================================

defn rename (e:KExp, vs:Seqable<Int>) :
  rename(e, seq({_ => fresh-id()}, vs))

defn rename (e:KExp, vs:Seqable<KeyValue<Int,Int>>) :
  ;Rename table
  val table = to-hashtable<Int,Int>(vs)

  defn fi (i:Int) :
    get?(table, i, i)
  defn ft (t:KType) :
    match(map(ft,t)) :
      (t:KTVar) : KTVar(fi(n(t)))
      (t:KStructT) : KStructT(fi(n(t)))
      (t:KOf) : KOf(fi(n(t)))
      (t:KTypeObject) : KTypeObject(fi(n(t)), targs(t))
      (t) : t
  defn fe (e:KExp) :
    map-ids(fi,map(fe,map(ft,e)))
  fe(e)

defn rename-binders (e:KExp) :
  val table = HashTable<Int,Int>()

  defn fi (i:Int) :
    get?(table, i, i)
  defn ft (t:KType) :
    match(map(ft,t)) :
      (t:KTVar) : KTVar(fi(n(t)))
      (t:KStructT) : KStructT(fi(n(t)))
      (t:KOf) : KOf(fi(n(t)))
      (t:KTypeObject) : KTypeObject(fi(n(t)), targs(t))
      (t) : t
  defn fe (e:KExp) :
    defn make-var (n:Int) : table[n] = fresh-id()
    map-ids(fi,
    map(ft,
    map-bound(fe, make-var, make-var, fe, e)))
  fe(e)

;============================================================
;==================== Detect Loops ==========================
;============================================================
defn detect-loops (pkg:KPackage) :
  ;Function for retrieving the id of the current loop
  var loop-id! : () -> Int = fatal{"Uninitialized."}

  ;Transform function
  defn transform-fn (ctxt:False|Int, e:KFn|KMultifn) -> KFn|KMultifn :
    match(e) :
      (e:KFn) :
        ;New loop id for this function
        ;Function for creating loop id
        val loop-id = fresh-id()
        var has-loop? = false
        defn make-loop-id () :
          has-loop? = true
          loop-id
        ;Create new loop
        let-var loop-id! = make-loop-id :
          val body* = transform-exp(ctxt, body(e), tail?(e))
          if has-loop? :
            val targs* = map(fresh-id{}, targs(e))
            val tenv = to-hashtable<Int,KTVar>(targs(e), KTVars(targs*))
            val a1* = map(replace-tvars{_, tenv}, a1(e))
            val a2* = replace-tvars(a2(e), tenv)
            val args* = map(fresh-id{}, args(e))
            val body* = KLabels(List(start-block, loop-block)) where :
              val loop-block = KBlock(loop-id, targs(e), args(e), a1(e), body*)
              val start-block = KBlock(fresh-id(), List(), List(), List(),
                KGoto(loop-id, KTVars(targs*), KVars(args*)))
            KFn(tail?(e), stack-properties(e), targs*, a1*, a2*, args*, body*, info(e))
          else :
            map({body*}, e)
      (e:KMultifn) :
        map(transform-fn{false, _ as KFn}, e) as KMultifn

  ;Transform tail calls to loops
  defn transform-exp (ctxt:False|Int, e:KExp, tail-pos?:True|False) -> KExp :
    match(e) :
      (e:KFn|KMultifn) :
        transform-fn(false, e)
      (e:KLetRec) :
        val values* = for (n in ns(e), v in values(e)) map :          
          transform-fn(n, v as KFn|KMultifn)
        val body* = transform-exp(ctxt, body(e), tail-pos?)
        KLetRec(ns(e), values*, body*)
      (e) :
        match(map-tail(transform-exp{ctxt, _, _}, e, tail-pos?)) :
          (e:KDo) :
            ;Retrieve id given function reference (if appropriate)
            defn get-loop-id! (f:KExp) :
              fail() when not tail-pos?
              val n = n(f as? KVar|KCurry)
              fail() when n != ctxt
              loop-id!()
            ;Retrieve type arguments
            defn targs! (f:KExp) :
              match(f) :
                (f:KCurry) : targs(f)
                (f:KVar) : List()
            ;Attempt transformation
            attempt :
              val l = get-loop-id!(func(e))
              KGoto(l, targs!(func(e)), args(e))
            else : e
          (e) :
            e

  ;Transform top level expression
  defn transform-texp (e:KTExp) :
    match(e) :
      (e:KDefn) :
        val value* = transform-fn(n(e), value(e) as KFn|KMultifn)
        KDefn(props(e), private?(e), n(e), value*)
      (e:KDefmethod) : 
        val value* = transform-fn(n(e), value(e) as KFn|KMultifn)
        KDefmethod(props(e), n(e), multi(e), value*)
      (e) : map(transform-exp{false, _, false}, e)

  ;Driver
  map(transform-texp, pkg)

;============================================================
;=================== Call Graph =============================
;============================================================
deftype CallGraph
defmulti num-references (g:CallGraph, n:Int) -> Int
defmulti reachable? (g:CallGraph, src:Int, dst:Int) -> True|False
defmulti successors (g:CallGraph, n:Int) -> List<Int>

;Construct call graph
defn call-graph (pkg:KPackage) :
  ;Discover edges
  val graph = HashTable<KeyValue<Int,Int>,Int>(0)
  defn add-edge (src:Int, dst:Int) :
    update(graph, {_ + 1}, src => dst)
    false
  ;Discover children
  val children = HashTable<Int,List<Int>>(List())
  defn add-child (n:Int, c:Int) :
    update(children, cons{c, _}, n)
    false
  defn scan (ctxt:Int, e:KExp) :
    match(e) :
      (e:KVar|KCurry) :
        add-edge(ctxt, n(e))
      (e:KLetRec) :
        for (n in ns(e), v in values(e)) do :
          match(v:KFn|KMultifn) :
            scan(n, v)
            add-child(ctxt, n)
          else :
            scan(ctxt,v)
        scan(ctxt, body(e))
      (e) :
        do(scan{ctxt, _}, e)
  for e in exps(pkg) do :
    match(e) :
      (e:KDefn) :
        scan(n(e), value(e))
      (e:KDefmethod) :
        scan(n(e), value(e))
      (e:KExternFn) :
        scan(n(e), value(e))
      (e) :
        do(scan{0, _}, e)

  ;Compute successor graph
  val succ-graph = IntTable<List<Int>>(List())
  defn add-succ (n:Int, succ:Int) :
    update(succ-graph, cons{succ, _}, n)
  for entry in graph do :
    val [k, n] = [key(entry), value(entry)]
    val [src, dst] = [key(k), value(k)]
    add-succ(src, dst)

  ;Compute predecessor graph
  val pred-graph = IntTable<List<KeyValue<Int,Int>>>(List())
  defn add-pred (n:Int, pred:Int, weight:Int) :
    update(pred-graph, cons{pred => weight, _}, n)
  for entry in graph do :
    val [k, n] = [key(entry), value(entry)]
    val [src, dst] = [key(k), value(k)]
    add-pred(dst, src, n)

  ;Compute reachability
  val VISITED = IntSet()
  defn reachable? (src:Int, dst:Int) :
    val result = let dst? (n:Int = src) :
      if not VISITED[n] :
        if n == dst :
          true
        else :
          add(VISITED,n)
          any?(dst?, succ-graph[n])
    clear(VISITED)
    result

  new CallGraph :
    defmethod num-references (this, n:Int) -> Int :
      sum $ seq(value, pred-graph[n])
    defmethod reachable? (this, src:Int, dst:Int) -> True|False :
      reachable?(src, dst)
    defmethod successors (this, n:Int) -> List<Int> :
      defn loop (n:Int) :
        cat(
          seq-cat(loop, children[n])
          succ-graph[n])
      unique(loop(n))

;Call f on successors first
defn do-successors (f:Int -> ?, edge?:Int -> True|False, ns:List<Int>, graph:CallGraph) :
  val remaining = IntSet()
  add-all(remaining, ns)
  defn loop (n:Int) :
    if remaining[n] :
      remove(remaining, n)
      do(loop, filter(edge?, successors(graph, n)))
      f(n)
  do(loop, ns)

defn do-successors (f:Int -> ?, ns:List<Int>, graph:CallGraph) :
  do-successors(f, {true}, ns, graph)

;============================================================
;================== Simple Inlining =========================
;============================================================

;Inline
defn inline (f:KFn, call-targs:List<KType>, call-args:List<KExp>) :
  ;Verify input arity, fail otherwise
  defn same-length? (xs:List, ys:List) : length(xs) == length(ys)
  if not (same-length?(targs(f), call-targs) and
          same-length?(args(f), call-args)) :
    fail()
  ;Substitute type variables
  var body* = replace-tvars(body(f), targs(f), call-targs)
  ;Create identifier for ending block
  var end-block = false
  defn end-label () :
    match(end-block) :
      (id:Int) :
        id
      (id:False) :
        end-block = fresh-id()
        end-block as Int
  ;Remove return expressions
  defn remove-returns (body:KExp) :
    ;Return the expression e
    defn return (e:KExp) :
      match(e) :
        (e:KReturn) :
          jump(exp(e))
        (e) :
          map-tail{_, e, true} $ fn (e, ret?) :
            if ret? : return(e)
            else : jump(e)
    ;Jump to ending block for any return expression
    defn jump (e:KExp) :
      match(map(jump, e)) :
        (e:KReturn) :
          KGoto(end-label(), List(), List(exp(e)))
        (e) : e
    ;Body is initially in return position
    return(body)
  ;Bind arguments
  body* =
    KLet(map(KeyValue, args(f), call-args),
         remove-returns(body*))
  ;Create labeled blocks if necessary
  match(end-block) :
    (end-block-id:False) :
      body*
    (end-block-id:Int) :
      ;Body block
      val body-block = KBlock(fresh-id(), List(), List(), List(), body*)
      ;End block
      val ret-arg = fresh-id()
      val end-block = KBlock(end-block-id, List(), List(ret-arg), List(a2(f)), KVar(ret-arg))
      ;Label construct
      KLabels(List(body-block, end-block))

defn inline (f:KMultifn, call-targs:List<KType>, call-args:List<KExp>) :
  defn same-length? (xs:List, ys:List) : length(xs) == length(ys)
  val f* = for f in funcs(f) as List<KFn> find :
    same-length?(targs(f), call-targs) and
    same-length?(args(f), call-args)
  match(f*) :
    (f*:KFn) : inline(f*, call-targs, call-args)
    (f*:False) : fail()

defn simple-inline (pkg:KPackage) :
  ;Compute call graph
  val graph = call-graph(pkg)

  ;Preserve inline table
  val inline-table = IntTable<KFn|KMultifn>()

  ;Erase the body of a function
  defn erase-body (e:KFn|KMultifn) -> KFn|KMultifn :
    match(e) :
      (e:KFn) :
        val body* = KDo(KVar(UNREACHABLE-ERROR-ID), List(), KBot(), false)
        KFn(false, stack-properties(e), targs(e), a1(e), a2(e), args(e), body*, info(e))
      (e:KMultifn) :
        map(erase-body{_ as KFn|KMultifn}, e)
  defn erase-body (e:KTExp) :
    map(erase-body{_ as KFn|KMultifn}, e) as KDefn

  ;A function is inlined if it is only referenced once
  defn inlined? (n:Int) :
    num-references(graph, n) == 1

  ;Divide top-level expressions into inlinable entries (inline)
  ;and non-inlinable entries (accum).
  defn inlined? (e:KTExp) :
    defn check-stack? (f:KExp) :
      match(f) :
        (f:KFn) : stack-properties(f) is CheckStack
        (f:KMultifn) : all?(check-stack?, funcs(f))
    match(e:KDefn) :
      private?(e) and check-stack?(value(e)) and inlined?(n(e))

  ;Inline recursively a group of functions
  defn inline-group (ns:List<Int>, vs:List<KFn|KMultifn>) ->
                     [List<Int>, List<KFn|KMultifn>] :
    val table = to-hashtable<Int,KFn|KMultifn>(ns,vs)
    do-successors{_, inlined?, ns, graph} $ fn (n) :
      val f* = inline-calls(n, table[n]) as KFn|KMultifn
      if inlined?(n) :
        inline-table[n] = f*
        table[n] = erase-body(f*)
      else :
        table[n] = f*
    [ns, map({table[_]}, ns)]

  ;Perform all simple inlining
  defn inline-calls (ctxt:Int|False, e:KExp) -> KExp :
    ;Is function n reachable from current context
    defn referenced? (n:Int) :
      match(ctxt:Int) : reachable?(graph, ctxt, n)
      else : true
    ;Recursively inline sub expression in current context
    defn recur (e:KExp) : inline-calls(ctxt, e)
    ;Retrieve function to inline or fail
    defn inline-func (e:KExp) :
      match(e) :
        (e:KVar|KCurry) :
          match(get?(inline-table,n(e))) :
            (f:KFn|KMultifn) : f
            (f:False) : fail()
        (e:KFn|KMultifn) : e
        (e) : fail()
    ;Retrieve the type arguments given the function expression
    defn targs! (e:KExp) :
      match(e:KCurry) : targs(e)
      else : List()
    ;Dispatch based on type of expression
    match(e) :
      (e:KLetRec) :
        ;Inline referenced entries
        val [ns*, vs*] = let :
          val mask = map(referenced?, ns(e))
          val ns* = to-list(filter(ns(e), mask))
          val vs* = to-list(filter(values(e), mask))
          inline-group(ns*, vs* as List<KFn|KMultifn>)
        ;Recurse upon non-inline entries
        if empty?(ns*) : recur(body(e))
        else : KLetRec(ns*, vs*, recur(body(e)))
      (e:KVar) :
        match(get?(inline-table, n(e))) :
          (f:KFn|KMultifn) : rename-binders(f)
          (f:False) : e
      (e:KDo) :
        attempt :
          val f = inline-func(recur(func(e)))
          val args* = map(recur, args(e))
          rename-binders(inline(f, targs!(func(e)), args*))
        else :
          map(recur, e)
      (e) :
        map(recur, e)

  ;Inline all top level exps
  defn inline-exps (es:Seqable<KTExp>) -> List<KTExp> :
    ;Retrieve id and function from expression
    defn id (e:KTExp) : n(e as KDefn)
    defn func (e:KTExp) : value(e as KDefn) as KFn|KMultifn

    ;Find all entries to be inlined
    val table = HashTable<Int,KTExp>()
    val accum = Vector<KTExp>()
    for e in es do :
      if inlined?(e) : table[id(e)] = e
      else : add(accum, e)

    ;Inline in call-graph order
    defn inline-texp (e:KTExp) :
      val ctxt = match(e:KDefn|KDefmethod|KExternFn) : n(e)
      map(inline-calls{ctxt, _}, e)
    do-successors{_, to-list(keys(table)), graph} $ fn (n) :
      val e* = inline-texp(table[n])
      if inlined?(e*) :
        table[n] = erase-body(e*)
        inline-table[n] = func(e*)
      else :
        table[n] = e*
    to-list $ cat(
      values(table)
      seq(inline-texp, accum))

  attach-exps(pkg, inline-exps(exps(pkg)))

;============================================================
;================== Type Inference ==========================
;============================================================

;Wrap up every expression in a KTypedExp (preserving implicit structure).
defn map-types (dec-table:DecTable,
                pkg:KPackage,
                bindvar: (Int, KType) -> ?,
                infer:KExp -> KType) :
  defn type-exp (e:KExp, structured?:True|False) :
    defn type-false (e:KExp) : type-exp(e,false)
    val e* = match(e) :
      (e:KLet) :
        val v* = type-false(value(e)) as KTypedExp
        bindvar(n(e), type(v*))
        KLet(n(e), v*, type-false(body(e)))
      (e:KLetVar) :
        val v* = attempt: type-false(value(e) as? KExp)
        bindvar(n(e), type(e))
        KLetVar(n(e), type(e), v*, type-false(body(e)))
      (e:KLetRec) :
        do(bindvar{_, KOf(FN-TYPE-ID)}, ns(e))
        map-structure(dec-table, type-exp, e)
      (e:KBranch) :
        do(bindvar, args(e), types(e))
        map-structure(dec-table, type-exp, e)
      (e:KBlock) :
        do(bindvar, args(e), types(e))
        map-structure(dec-table, type-exp, e)
      (e:KFn) :
        do(bindvar{_, KTop()}, args(e)) ;Do not assume inputs are valid
        map-structure(dec-table, type-exp, e)
      (e) :
        map-structure(dec-table, type-exp, e)
    if structured? : e*
    else : KTypedExp(e*, infer(e*))
  for te in pkg map :
    map-structure(type-exp, te)

defn infer-types (dec-table:DecTable, pkg:KPackage) :
  ;Utilities
  defn type! (e:KExp) : type(e as KTypedExp)
  defn body! (e:KExp) : body(e as KBranch|KBlock)

  ;LoStanza literal type
  defn ls-literal-type (v) :
    match(v) :
      (v:Byte) : KByteT()
      (v:Char) : KByteT()
      (v:Int) : KIntT()
      (v:Long) : KLongT()
      (v:Float) : KFloatT()
      (v:Double) : KDoubleT()
      (v:String) : KPtrT(KByteT())
      (v:True) : KOf(TRUE-TYPE-ID)
      (v:False) : KOf(FALSE-TYPE-ID)

  ;HiStanza literal type
  defn hs-literal-type (v) :
    KOf $ match(v) :
      (v:Byte) : BYTE-TYPE-ID
      (v:Char) : CHAR-TYPE-ID
      (v:Int) : INT-TYPE-ID
      (v:Long) : LONG-TYPE-ID
      (v:Float) : FLOAT-TYPE-ID
      (v:Double) : DOUBLE-TYPE-ID
      (v:String) : STRING-TYPE-ID
      (v:Symbol) : SYMBOL-TYPE-ID
      (v:List) : LIST-TYPE-ID
      (v:True) : TRUE-TYPE-ID
      (v:False) : FALSE-TYPE-ID

  ;Detag a HiStanza type
  defn ls-detag-type (n) :
    switch(n) :
      BYTE-TYPE-ID : KByteT()
      CHAR-TYPE-ID : KByteT()
      INT-TYPE-ID : KIntT()
      FLOAT-TYPE-ID : KFloatT()

  ;Local Environment
  val local-table = IntTable<KType>()

  ;Algorithm
  map-types(dec-table, pkg,
    fn (n:Int, t:KType) :
      local-table[n] = t
    fn (e:KExp) :
      match(e) :
        (e:KLet) : type!(body(e))
        (e:KLetVar) : type!(body(e))
        (e:KLetRec) : type!(body(e))
        (e:KVar) :
          match(get?(local-table, n(e))) :
            (t:KType) : t
            (t:False) : var-type(dec-table, n(e))
        (e:KSet) : KOf(FALSE-TYPE-ID)
        (e:KNew) : type(e)
        (e:KTuple) : KOf(TUPLE-TYPE-ID)
        (e:KTupleGet) : KTop()
        (e:KEnsureLength) : KOf(TUPLE-TYPE-ID)
        (e:KObject) : KOf(n(e))
        (e:KArray) : KOf(n(e))
        (e:KStruct) : KStructT(n(e))
        (e:KPtr) : KPtrT(KUnknownT())
        (e:KDo) : type(e)
        (e:KDoC) : type(e)
        (e:KLSLiteral) : ls-literal-type(value(e))
        (e:KLiteral) : hs-literal-type(value(e))
        (e:KInterpret) : type(e)
        (e:KCheck) : KAnd(type!(exp(e)), type(e))
        (e:KConv) : type(e)
        (e:KAndExp) : KLongT()
        (e:KOrExp) : KLongT()
        (e:KPrim) : type(e)
        (e:KSizeof) : KLongT()
        (e:KTagof) : KLongT()
        (e:KMatch) : KOr(map(type!{body!(_)}, branches(e)))
        (e:KLabels) : KOr(map(type!{body!(_)}, blocks(e)))
        (e:KIf) : KOr(type!(conseq(e)), type!(alt(e)))
        (e:KSeq) : type!(b(e))
        (e:KGoto) : KBot()
        (e:KReturn) : KBot()
        (e:KRead) : type(e)
        (e:KFn) : KOf(FN-TYPE-ID)
        (e:KMultifn) : KOf(FN-TYPE-ID)
        (e:KDispatch) : KOr(map(type!{body!(_)}, branches(e)))
        (e:KEnsureSet) : type!(exp(e))
        (e:KNewObject) : KOf(n(e))
        (e:KObjectGet) : KTop()
        (e:KObjectTGet) : KOf(TYPE-TYPE-ID)
        (e:KLetType) : type!(body(e))
        (e:KBox) : KOf(BOX-TYPE-ID)
        (e:KBoxGet) : KTop()
        (e:KBoxSet) : KOf(FALSE-TYPE-ID)
        (e:KClosure) : KOf(FN-TYPE-ID)
        (e:KTagPrim) : KOf(n(e))
        (e:KDetagPrim) : ls-detag-type(n(e)))

;============================================================
;================== Elide Checks ============================
;============================================================

defn elide-checks (dec-table:DecTable, hier:KHierarchy, pkg:KPackage) :
  defn type! (e:KExp) : type(e as KTypedExp)
  defn elide (e:KExp) :
    match(e) :
      (e:KCheck) :
        if subtype?(hier, type!(exp(e)), type(e)) : elide(exp(e))
        else : map(elide, e)
      (e:KTypedExp) : elide(exp(e))
      (e) : map(elide, e)
  val pkg* = infer-types(dec-table, pkg)
  for e in pkg* map : map(elide,e)

;============================================================
;================== Method Resolution =======================
;============================================================

;=====================
;==== MethodEntry ====
;=====================
defstruct MethodEntry :
  n: Int|False
  types: List<KType>

defstruct MethodBitEntry :
  n: Int|False
  bits: List<KBits>

;=====================
;==== MethodTable ====
;=====================
deftype MethodTable
defmulti get (t:MethodTable, n:Int, ts:List<KType>) -> Int

defn method-table (khier:KHierarchy, pkg:KPackage) :
  val table = IntTable<List<MethodEntry>>(List())
  defn add-entry (multi:Int, e:MethodEntry) : update(table, cons{e, _}, multi)

  ;Scan for internal methods
  defn scan (e:KExp) :
    do(scan, e)
    match(e:KMethod) :
      val v = value(e) as KFn
      add-entry(multi(e), MethodEntry(false, a1(v)))

  ;Scan top level expressions
  for e in exps(pkg) do :
    do(scan, e)
    match(e:KDefmethod) :
      val v = value(e) as KFn
      add-entry(multi(e), MethodEntry(n(e), a1(v)))

  ;Create ordered bit entries
  val bit-table = IntTable<List<MethodBitEntry>>(List())
  for entry in table do :
    val methods = to-tuple(value(entry))
    val ordering = dispatch-ordering(khier, seq(types,methods))
    bit-table[key(entry)] = for e in ordering map :      
      match(value(e)) :
        (i:Int) : MethodBitEntry(n(methods[i]), key(e))
        (i:List<Int>) : MethodBitEntry(false, key(e))
        
  ;Is xs a subset of ys?
  defn subset? (xs:List<KBits>, ys:List<KBits>) :
    all?(/subset?, xs, ys)
  defn overlap? (xs:List<KBits>, ys:List<KBits>) :
    for (x in xs, y in ys) none? :
      bottom?(intersect(x, y))

  ;Scan for appropriate method entry
  defn bit-entry (es:List<MethodBitEntry>, ts:List<KBits>) :
    label<MethodBitEntry|False> return :
      ;Track first applicable method
      var applicable = false
      for e in es do :
        ;If no applicable methods before this, then return
        ;entry if it covers the given types.
        if subset?(ts, bits(e)) :
          if applicable is False : return(e)
          else : return(false)
        ;If two applicable methods, then fail
        if overlap?(ts,bits(e)) :
          return(false) when applicable is-not False
          applicable = e
      applicable
  
  ;Return table
  new MethodTable :
    defmethod get (this, func:Int, ts:List<KType>) -> Int :
      fail() when not key?(bit-table,func)
      val ys = map(kbits{khier, _}, ts)
      match(bit-entry(bit-table[func], ys)) :
        (e:MethodBitEntry) : n(e) as? Int
        (e:False) : fail()

;===================
;==== Algorithm ====
;===================
defn resolve-methods (dt:DecTable, khier:KHierarchy, pkg:KPackage) :
  ;Build method table
  val mtable = method-table(khier, pkg)
  ;Utilities
  defn type! (e:KExp) : type(e as KTypedExp)
  defn n! (e:KExp) : n((e as? KVar|KCurry) as KVar|KCurry)
  defn attach-n (e:KExp, n:Int) :
    match(e) :
      (e:KVar) : KVar(n)
      (e:KCurry) : KCurry(n, targs(e))
  ;Resolve methods in expression
  defn resolve (e:KExp) :
    match(e) :
      (e:KDo) :
        attempt :
          val f = n!(func(e))
          val ts = map(type!, args(e))
          val f* = mtable[f,ts]
          val args* = map(resolve, args(e))
          KDo(attach-n(func(e), f*), args*, type(e), info(e))
        else :
          map(resolve, e)
          
      (e:KTypedExp) : resolve(exp(e))
      (e) : map(resolve, e)
  defn resolve (e:KTExp) :
    map(resolve, e)
  ;Driver
  val pkg* = infer-types(dt, pkg)
  map(resolve, pkg*)

;============================================================
;================== Full Inlining ===========================
;============================================================
val INLINE-THRESHOLD = 5

defn size+used? (ctxt:Int, e:KExp) -> [Int, True|False] :
  val counter = to-seq(0 to false)
  var used?:True|False = false
  defn loop (e:KExp) :
    do(loop, e)
    match(e) :
      (e:KSet|KNew|KTuple|KTupleGet|KObject|KArray|KDo|
          KDoC|KInterpret|KConv|KAndExp|KOrExp|KPrim|KMatch|
          KIf|KDeref|KDeptr|KField|KSlot|KDispatch|KNewObject|
          KObjectGet|KObjectTGet|KBox|KBoxGet|KBoxSet|
          KClosure|KTagPrim|KDetagPrim) :
        next(counter)
      (e:KVar|KCurry) :
        if n(e) == ctxt :
          used? = true
      (e) :
        false
  loop(e)
  [next(counter), used?]

defn full-inline (pkg:KPackage) :
  ;Compute call graph
  val call-graph = call-graph(pkg)

  ;Inline table
  val inline-table = HashTable<Int,KFn|KMultifn>()

  ;Determine whether to inline
  defn inline? (n:Int, e:KFn|KMultifn) :
    val [s, recursive?] = size+used?(n, e)
    (not recursive?) and s < INLINE-THRESHOLD
  defn inline? (e:KTExp) :
    defn check-stack? (f:KExp) :
      match(f) :
        (f:KFn) : stack-properties(f) is CheckStack
        (f:KMultifn) : all?(check-stack?, funcs(f))
    match(e:KDefn|KDefmethod) :
      val v = value(e) as KFn|KMultifn
      check-stack?(v) and inline?(n(e), v)

  ;Add entries to inline table
  ;Returns all entries not added
  defn add-inline-entries (ns:List<Int>, values:List<KFn|KMultifn>) ->
                           [List<Int>, List<KFn|KMultifn>] :
    val table = to-hashtable<Int,KFn|KMultifn>(ns, values)
    do-successors{_, ns, call-graph} $ fn (n) :
      val f* = inline-calls(table[n]) as KFn|KMultifn
      if inline?(n, f*) : inline-table[n] = f*
      table[n] = f*
    [ns, map({table[_]}, ns)]

  ;Inline all calls in expression
  defn inline-calls (e:KExp) -> KExp :
    ;Retrieve function to inline and targs
    defn fn-targs (e:KExp) :
      val [n, targs] = match(e) :
        (e:KVar) : [n(e), List()]
        (e:KCurry) : [n(e), targs(e)]
        (e) : fail()
      match(get?(inline-table, n)) :
        (f:KFn|KMultifn) : [f, targs]
        (f:False) : fail()

    match(e) :
      (e:KLetRec) :
        defn closures? (es:List<KExp>) :
          (not empty?(es)) and head(es) is KClosure
        if closures?(values(e)) :
          map(inline-calls, e)
        else :
          val [ns*, values*] = add-inline-entries(ns(e), values(e) as List<KFn|KMultifn>)
          val body* = inline-calls(body(e))
          if empty?(ns*) : body*
          else : KLetRec(ns*, values*, body*)
      (e:KDo) :
        attempt :
          val [f, targs] = fn-targs(func(e))
          val args* = map(inline-calls, args(e))
          rename-binders(inline(f, targs, args*))
        else :
          map(inline-calls, e)
      (e) :
        map(inline-calls, e)

  ;Inline top-level expressions
  defn inline-exps (tes:Seqable<KTExp>) :
    ;Retrieve id and function from expression
    defn func (e:KTExp) : value(e as KDefn|KDefmethod) as KFn|KMultifn

    ;Find entries to inline
    val table = HashTable<Int,KTExp>()
    val accum = Vector<KTExp>()
    for e in tes do :
      match(e:KDefn|KDefmethod) : table[n(e)] = e
      else : add(accum, e)

    ;Inline inlinable entries
    defn inline-texp (e:KTExp) : map(inline-calls, e)
    do-successors{_, to-list(keys(table)), call-graph} $ fn (n) :
      val e* = inline-texp(table[n])
      if inline?(e*) : inline-table[n] = func(e*)
      table[n] = e*

    ;Return all exps
    to-list $ cat(
      values(table)
      seq(inline-texp, accum))

  ;Attach expressions to package
  attach-exps(pkg, inline-exps(exps(pkg)))

;============================================================
;=================== Lambda Lifting =========================
;============================================================

;Compute usage table
defn usage-table (pkg:KPackage) :
  val used = IntSet()
  for e in pkg do :
    defn scan (e:KExp, call-pos?:True|False) :
      match(e) :
        (e:KVar) :
          add(used, n(e)) when not call-pos?
        (e:KDo) :
          scan(func(e), true)
          do(scan-false, args(e))
        (e) :
          do(scan-false, e)
    defn scan-false (e:KExp) : scan(e, false)
    do(scan-false, e)
  used

;Returns a hashtable that maps n => [vs ..., ts ...].
;  Where vs,ts is the list of all freevars,freetypes that need to be
;  passed in to n for lifting.
defn lift-table (used:IntSet, pkg:KPackage) :
  ;Utilities
  defn freevars (f:KFn|KMultifn) :
    match(f) :
      (f:KFn) : /freevars(f)
      (f:KMultifn) : unique(seq-cat(/freevars, funcs(f) as List<KFn>))
  defn freevars+freetypes (f:KFn|KMultifn) :
    match(f) :
      (f:KFn) : append(/freevars(f), freetypes(f))
      (f:KMultifn) : unique(seq-cat(freevars+freetypes, funcs(f) as List<KFn>))

  ;Gather all functions
  val functions = Vector<KeyValue<Int,KFn|KMultifn>>()
  val var-table = IntSet()
  for e in pkg do :
    defn scan (e:KExp) :
      do(scan,e)
      match(e:KLetRec) :
        val vs = values(e) as List<KFn|KMultifn>
        add-all(var-table, seq-cat(freevars,vs))
        add-all(functions, map(KeyValue,ns(e),vs))
    do(scan, e)

  ;Anchors are functions that have been determined to not be lifted
  val anchors = IntSet()

  ;Populate lift table with all functions that can be lifted
  ;in the given function group
  val argss = fixpoint $
    fn (assumptions-changed) :
      ;Maximum lift
      val max-args = 6
      ;Compute lifting args
      val argss = bipartite-closure $
        for entry in functions seq? :
          val [n, f] = [key(entry), value(entry)]
          ;Lift if not anchor, and if less freevars than max-args
          if anchors[n] :
            None()
          else :
            val vs = freevars+freetypes(f)
            if length(vs) > max-args : None()
            else : One(n => vs)
      ;Verify assumptions
      for entry in argss do :
        val [f, args] = [key(entry), value(entry)]
        ;It's an anchor if:
        ;  1. It has freevars and it's used as first-class value, or
        ;  2. The number of freevars exceeds max-args
        if (used[f] and not empty?(args)) or
           (length(args) > max-args) :
          add(anchors, f)
          assumptions-changed()
      ;Return lifting arguments
      argss

  ;Return as table
  to-hashtable<Int,[List<Int>,List<Int>]> $
    for entry in argss seq :
      defn var? (n:Int) : var-table[n]
      val [vars,types] = split!(var?, value(entry))
      key(entry) => [to-list(vars), to-list(types)]

defn lambda-lift (dt:DecTable, pkg0:KPackage) :
  ;Compute free variables
  val pkg = compute-freevars(dt, pkg0)

  ;Compute lift tables
  val used = usage-table(pkg)
  val lift-table = lift-table(used, pkg)
  defn lift? (n:Int) : key?(lift-table, n)

  ;Top level lifted definitions
  val lift-defs = Vector<KTExp>()
  defn prepend-defs (pkg:KPackage) :
    do(register{dt, _}, lift-defs)
    attach-exps(pkg, append(lift-defs, exps(pkg)))

  ;===== Helpers =====
  ;Returns true if function closes over no free variables/types
  defn no-freevars? (e:KFn|KMultifn) :
    match(e) :
      (e:KFn) : empty?(freevars(e)) and empty?(freetypes(e))
      (e:KMultifn) : all?(no-freevars?, funcs(e) as List<KFn>)

  ;Lift an anonymous function with no freevars to the top level
  defn lift-afn (e:KFn|KMultifn) :
    val n* = fresh-id()
    add(lift-defs, KDefConst(n*, e))
    n*

  ;Lift a function to the top level
  defn lift-fn (n:Int, e:KFn|KMultifn) :
    defn lifted (e:KFn|KMultifn) :
      match(e) :
        (e:KFn) :
          val [freevars, freetypes] = lift-table[n]
          val args* = append(freevars, args(e))
          val targs* = append(freetypes, targs(e))
          val a1* = append(KTops(freevars), a1(e))
          val e* = KFn(tail?(e), stack-properties(e), targs*, a1*, a2(e), args*, body(e), info(e))
          rename(e*, cat(freevars, freetypes))
        (e:KMultifn) :
          map(lifted{_ as KFn}, e)
    val e* = lifted(e)
    add(lift-defs, KDefn(KFnProperties(false), true, n, lifted(e)))

  ;Create a forwarding closure at the top level
  val closure-ids = HashTable-init<Int,Int>(fresh-id{})
  defn lift-closure (n:Int, e:KFn|KMultifn) :
    defn forward (e:KFn|KMultifn) :
      match(e) :
        (e:KFn) :
          val args = map(fresh-id{}, args(e))
          val body = KDo(KVar(n), KVars(args), a2(e), info(e))
          KFn(true, CheckStack(), List(), KTops(args), KTop(), args, body, info(e))
        (e:KMultifn) :
          map(forward{_ as KFn}, e) as KMultifn
    add(lift-defs, KDefConst(closure-ids[n], forward(e)))

  ;Recursively Perform all required lifting in the expression
  ;Helpers: lift-afn
  defn lift-exp? (e:KExp, structured?:True|False) :
    defn lift-exp (e:KExp) : lift-exp?(e, false)
    defn recur-exp (e:KExp) : lift-exp?(e, true)
    if structured? :
      map-structure(dt, lift-exp?, e)
    else :
      match(e) :
        ;Lift anonymous functions with no free variables
        (#e:KFn|KMultifn) :
          val e = map-structure(dt, lift-exp?, #e) as KFn|KMultifn
          if no-freevars?(e) : KVar(lift-afn(e))
          else : e
        ;Move lifted functions to top-level
        (e:KLetRec) :
          val [ns*, vs*] = [Vector<Int>(), Vector<KFn|KMultifn>()]
          for (n in ns(e), v in values(e)) do :
            val v* = recur-exp(v) as KFn|KMultifn
            if lift?(n) :
              lift-fn(n, v*)
              lift-closure(n, v*) when used[n]
            else :
              add(ns*, n)
              add(vs*, v*)
          val body* = lift-exp(body(e))
          if empty?(ns*) : body*
          else : KLetRec(to-list(ns*), to-list(vs*), body*)
        ;Add extra arguments to calls
        (e:KDo) :
          attempt :
            ;Helper: Make a KVar/KCurry
            defn make-func (n:Int, targs:List<KType>) :
              if empty?(targs) : KVar(n)
              else : KCurry(n, targs)
            ;Retrieve lifting id and type args
            val [n, targs] = match(func(e)) :
              (f:KVar) : [n(f), List()]
              (f:KCurry) : [n(f), targs(f)]
              (f) : fail()
            fail() when not lift?(n)
            ;Lift call
            val [freevars, freetypes] = lift-table[n]
            val args* = append(KVars(freevars), map(lift-exp,args(e)))
            val targs* = append(KTVars(freetypes), targs)
            KDo(make-func(n,targs*), args*, type(e), info(e))
          else :
            map-structure(dt, lift-exp?, e)
        (e:KVar) :
          if lift?(n(e)) and used[n(e)] : KVar(closure-ids[n(e)])
          else : e
        (e) :
          map-structure(dt, lift-exp?, e)

  prepend-defs $
    for e in pkg map :
      map-structure(lift-exp?, e)

;============================================================
;=================== Object Lifting =========================
;============================================================

defn lift-objects (dec-table:DecTable, pkg:KPackage) :
  ;Track lifts
  val defs = Vector<KTExp>()
  defn prepend-defs (pkg:KPackage) :
    attach-exps(pkg, append(defs, exps(pkg)))

  defn free (e:KNew) -> [List<Int>, List<Int>] :
    val vs = Vector<Int>()
    val ts = Vector<Int>()
    for m in methods(e) as List<KMethod> do :
      val f = value(m) as KFn
      add-all(vs, freevars(f))
      add-all(ts, freetypes(f))
    [unique(vs), unique(ts)]

  defn create-object (e:KNew) :
    val id = fresh-id()
    val [vs,ts] = free(e)
    ;Define object
    add(defs, KDefObject(id, name(e), type(e), length(ts), length(vs)))
    ;Pull out methods
    for m in methods(e) as List<KMethod> do :
      val f = value(m) as KFn
      val def-vars = for v in freevars(f) seq :
        val i = index-of!(vs,v)
        v => KObjectGet(KVar(thisn(m)), id, i)
      val def-tvars = for v in freetypes(f) seq :
        val i = index-of!(ts,v)
        v => KObjectTGet(KVar(thisn(m)), id, i)
      val body* = KLet(cat(def-vars, def-tvars),body(f))
      val a1* = for (a in args(f), t in a1(f)) map :
        if a == thisn(m) : KOf(id)
        else : erase-tvars(t,ts)
      val a2* = erase-tvars(a2(f),ts)
      val f* = attach-a1-a2-body(f, a1*, a2*,
                 rename(body*,append(vs,ts)))
      add(defs, KDefmethod(props(m), fresh-id(), multi(m), f*))
    ;Create object
    KNewObject(id, KTVars(ts), KVars(vs), info(e))

  defn fe (e:KExp) :
    match(map(fe,e)) :
      (e:KNew) : create-object(e)
      (e) : e
  defn fte (e:KTExp) : print-if-annotated(map(fe,e))
  prepend-defs(map(fte, compute-freevars(dec-table,pkg)))

;============================================================
;==================== Closure Lifting =======================
;============================================================

defn lift-closures (dec-table:DecTable, pkg:KPackage) :
  ;Track lifts
  val defs = Vector<KTExp>()
  defn prepend-defs (pkg:KPackage) :
    attach-exps(pkg, append(defs, exps(pkg)))

  ;Removing an int
  defn minus (xs:List<Int>, y:Int) :
    to-list(filter({_ != y}, xs))

  defn free (closure:Int, e:KFn|KMultifn) -> [List<Int>, List<Int>] :
    match(e) :
      (e:KFn) :
        [freevars(e) - closure, freetypes(e)]
      (e:KMultifn) :
        val vs = Vector<Int>()
        val ts = Vector<Int>()
        for f in funcs(e) as List<KFn> do :
          add-all(vs, freevars(f))
          add-all(ts, freetypes(f))
        [unique(vs) - closure, unique(ts)]

  defn create-closure (closure:Int, e:KFn|KMultifn) :
    val id = fresh-id()
    val [vs,ts] = free(closure, e)
    val closure* = fresh-id()
    val vs* = map(fresh-id{}, vs)
    val ts* = map(fresh-id{}, ts)
    val subs = cat-all $ [
                [closure => closure*]
                 seq(KeyValue,vs,vs*)
                 seq(KeyValue,ts,ts*)]
    val e* = rename(e, subs)
    ;Define closure
    add(defs, KDefClosure(id, closure*, ts*, vs*, e*))
    ;Make closure object
    val info = match(e) :
      (e:KFn) : info(e)
      (e:KMultifn) : info(head(funcs(e)) as KFn)
    KClosure(id, KTVars(ts), KVars(vs), info)

  defn fe (e:KExp) :
    defn recur (e:KExp) :
      match(e) :
        (e:KLetRec) : KLetRec(ns(e), map(recur,values(e)), fe(body(e)))
        (e:KMultifn) : map(recur,e)
        (e) : map(fe, e)
    match(recur(e)) :
      (e:KLetRec) :
        val vs* = for (n in ns(e), v in values(e)) map :
          create-closure(n, v as KFn|KMultifn)
        KLetRec(ns(e), vs*, body(e))
      (e:KMultifn|KFn) : create-closure(fresh-id(), e)
      (e) : e

  defn fte (e:KTExp) :
    print-if-annotated $ match(e) :
      (e:KDefn|KExternFn|KDefmethod) : map(map{fe, _:KExp}, e)
      (e) : map(fe, e)
  prepend-defs(map(fte,compute-freevars(dec-table,pkg)))

;============================================================
;================== Type Reification ========================
;============================================================

defn reify-types (pkg:KPackage) :
  val defs = Vector<KTExp>()
  defn prepend-defs (pkg:KPackage) :
    attach-exps(pkg, append(defs, exps(pkg)))

  ;Table of types
  val type-table = HashTable<KType,Int>(normalized-hash, normalized-equal?)
  defn create-type-object (t:KType) :
    match(t:KTVar) :
      t
    else :
      val ts = freevars(t)
      match(get?(type-table, t)) :
        (n:Int) :
          if empty?(ts) : KTVar(n)
          else : KTypeObject(n, KTVars(ts))
        (_:False) :
          val n = fresh-id()
          add(defs, KDefTypeObject(n, ts, t))
          if empty?(ts) :
            val obj-n = fresh-id()
            type-table[t] = obj-n
            add(defs, KDefConst(obj-n, KTypeObject(n, List())))
            KTVar(obj-n)
          else :
            type-table[t] = n
            KTypeObject(n, KTVars(ts))

  defn fe (e:KExp) :
    match(map(fe,e)) :
      (e:KCheck) :
        val tobj = create-type-object(type(e))
        KCheck(exp(e), type(e), tobj, option(e), info(e))
      (e) :
        map-used-types(create-type-object,e)
  defn fte (e:KTExp) : print-if-annotated(map(fe,e))
  prepend-defs(map(fte, pkg))

;============================================================
;==================== Type Erasure ==========================
;============================================================

defn erase-types (pkg:KPackage) :
  defn erase (e:KExp) :
    match(map(erase,e)) :
      (e:KCurry) : KVar(n(e))
      (e:KCheck) : exp(e)
      (e:KFn) : KFn(tail?(e), stack-properties(e), List(),
                    map(erase-tvars,a1(e)), erase-tvars(a2(e)),
                    args(e), body(e), info(e), stats(e))
      (e:KBlock) : KBlock(n(e), List(), args(e), types(e), body(e))
      (e:KEnsureLength) : exp(e)
      (e:KEnsureSet) : exp(e)
      (e:KNewObject) : KNewObject(n(e), List(), args(e), info(e))
      (e:KObjectTGet) : KLiteral(false)
      (e:KClosure) : KClosure(n(e), List(), args(e), info(e))
      (e:KGoto) : KGoto(n(e), List(), args(e))
      (e) : e
  defn erase (e:KTExp) :
    match(map(erase,e)) :
      (e:KDefmulti) : KDefmulti(private?(e), n(e), tail?(e), List(),
                                map(erase-tvars,a1(e)), erase-tvars(a2(e)), info(e))
      (e:KDefObject) : KDefObject(n(e), name(e), parent(e), 0, arity(e))
      (e:KDefClosure) : KDefClosure(n(e), closure(e), List(), freevars(e), func(e))
      (e:KDefTypeObject) : KInit(KLiteral(false))
      (e) : e
  map(erase, pkg)

;============================================================
;================== Primitive Tagging =======================
;============================================================

defn primitive-tagging (pkg:KPackage) :

  ;Detag a field expression or fail otherwise
  defn detag (e:KField) :
    val n = switch(n(e)) :
      BYTE-VALUE-FIELD-ID : BYTE-TYPE-ID
      CHAR-VALUE-FIELD-ID : CHAR-TYPE-ID
      INT-VALUE-FIELD-ID : INT-TYPE-ID
      FLOAT-VALUE-FIELD-ID : FLOAT-TYPE-ID
      else : fail()
    val de = exp(e) as? KDeref
    KDetagPrim(n, exp(de))

  ;Tag an object expression or fail otherwise
  defn tag (e:KObject) :
    val ns = [BYTE-TYPE-ID, CHAR-TYPE-ID, INT-TYPE-ID, FLOAT-TYPE-ID]
    fail() when not contains?(ns, n(e))
    KTagPrim(n(e), head(args(e)))

  defn fe (e:KExp) :
    match(map(fe,e)) :
      (e:KRead) :
        attempt : detag(loc(e) as? KField)
        else : e
      (e:KObject) :
        attempt: tag(e)
        else : e
      (e) :
        e

  defn fte (e:KTExp) : print-if-annotated(map(fe,e))
  map(fte, pkg)


;============================================================
;===================== Fancy Mappers ========================
;============================================================

defn print-if-annotated (e:KTExp) -> KTExp :
  defn annotated? (e:KTExp) :
    match(e:KDefmethod*|KDefn|KDefmethod|KExternFn) :
      show-optimization?(props(e))
  println(e) when annotated?(e)
  e

defn map-inwards (f:KExp -> KExp, e:KExp) :
  defn recur (e:KExp) : map-inwards(f, e)
  match(e) :
    ;Input nodes
    (e:KLet*) : KLet*(n(e), type(e), value(e), recur(body(e)), info(e))
    (e:KLetVar*) : KLetVar*(n(e), type(e), value(e), recur(body(e)), info(e))
    (e:KBranch*) : KBranch*(args(e), types(e), recur(body(e)), info(e))
    ;Regular nodes
    (e:KLet) : KLet(n(e), value(e), recur(body(e)))
    (e:KLetVar) : KLetVar(n(e), type(e), value(e), recur(body(e)))
    (e:KLetRec) : KLetRec(ns(e), values(e), recur(body(e)))
    (e:KLetType) : KLetType(n(e), value(e), recur(body(e)))
    (e:KSeq) : KSeq(a(e), recur(b(e)))    
    (e:KMatch) : KMatch(args(e), map(recur,branches(e)), info(e))
    (e:KDispatch) : KDispatch(args(e), map(recur,branches(e)), info(e))
    (e:KIf) : KIf(pred(e), recur(conseq(e)), recur(alt(e)))
    (e:KBranch|KLabels|KBlock|KAndExp|KOrExp) : map(recur, e)
    ;Simple call
    (e) : f(e)  

defn map-without-functions (f:KExp -> KExp, e:KExp) :
  defn ff (e:KExp) :
    match(e:KVar|KCurry|KMix|KVar*) : e
    else : f(e)
  defn fs (es:List<KExp>) :
    map(f, es)
  match(e) :
    (e:KDo*) : KDo*(ff(func(e)), fs(args(e)), a1(e), a2(e), info(e))
    (e:KDo) : KDo(ff(func(e)), fs(args(e)), type(e), info(e))
    (e:KDoC) : KDoC(ff(func(e)), fs(args(e)), fs(varargs(e)), type(e))
    (e) : map(f,e)

defn map-tail (f:(KExp, True|False) -> KExp, e:KExp, tail-pos?:True|False) :
  defn ftail (e:KExp) : f(e, true)
  defn farg (e:KExp) : f(e, false)
  defn fcont (e:KExp) : f(e, tail-pos?)
  defn fargs (e:List<KExp>) : map(farg, e)
  defn fconts (e:List<KExp>) : map(fcont, e)
  defn farg? (e:KExp|False) : match(e:KExp) : farg(e)

  match(e) :
    ;Input Expressions
    (e:KFn*) :
      val body* = f(body(e), tail?(e))
      KFn*(tail?(e), targs(e), a1(e), a2(e), args(e), body*, info(e))
    (e:KLet*) :
      val value* = farg(value(e))
      val body* = fcont(body(e))
      KLet*(n(e), type(e), value*, body*, info(e))
    (e:KLetVar*) :
      val value* = farg?(value(e))
      val body* = fcont(body(e))
      KLetVar*(n(e), type(e), value*, body*, info(e))
    (e:KBranch*) :
      val body* = fcont(body(e))
      KBranch*(args(e), types(e), body*, info(e))
    ;Standard Expressions
    (e:KLet) :
      val value* = farg(value(e))
      val body* = fcont(body(e))
      KLet(n(e), value*, body*)
    (e:KLetVar) :
      val value* = farg?(value(e))
      val body* = fcont(body(e))
      KLetVar(n(e), type(e), value*, body*)
    (e:KLetRec) :
      val values* = fargs(values(e))
      val body* = fcont(body(e))
      KLetRec(ns(e), values*, body*)
    (e:KMatch) :
      val args* = fargs(args(e))
      val branches* = fconts(branches(e))
      KMatch(args*, branches*, info(e))
    (e:KBranch) :
      val body* = fcont(body(e))
      KBranch(args(e), types(e), body*)
    (e:KLabels) :
      KLabels(fconts(blocks(e)))
    (e:KBlock) :
      KBlock(n(e), targs(e), args(e), types(e), fcont(body(e)))
    (e:KIf) :
      KIf(farg(pred(e)), fcont(conseq(e)), fcont(alt(e)))
    (e:KSeq) :
      KSeq(farg(a(e)), fcont(b(e)))
    (e:KReturn) :
      KReturn(ftail(exp(e)))
    (e:KFn) :
      val body* = f(body(e), tail?(e))
      KFn(tail?(e), stack-properties(e), targs(e), a1(e), a2(e), args(e), body*, info(e))
    ;Working Expressions
    (e:KDispatch) :
      val args* = fargs(args(e))
      val branches* = fconts(branches(e))
      KDispatch(args*, branches*, info(e))
    ;Otherwise
    (e) :
      map(farg, e)

defn map-return (f:KExp -> KExp, e:KExp) :
  defn scan (e:KExp, ret-pos?:True|False) :
    match(e:KReturn) :
      map(scan{_, true}, e)
    else: if has-body?(e) :
      map-tail(scan, e, ret-pos?)
    else if ret-pos? :
      f(map(scan{_, false}, e))
    else :
      map(scan{_, false}, e)
  scan(e, true)

defn map-ids (f:Int -> Int, e:KExp) -> KExp :
  defn fs (xs:List<Int>) :
    map(f,xs)
  defn fl (x:KLoc) :
    match(x) :
      (x:KValue) : x
      (x:KDeref) : x
      (x:KDeptr) : x
      (x:KField) : KField(fl(exp(x)), f(n(x)))
      (x:KSlot) : KSlot(fl(exp(x)), type(x), index(x))
      (x:KVarLoc) : KVarLoc(f(n(x)))
  match(e) :
    (e:KLet) : KLet(f(n(e)), value(e), body(e))
    (e:KLetVar) : KLetVar(f(n(e)), type(e), value(e), body(e))
    (e:KLetRec) : KLetRec(fs(ns(e)), values(e), body(e))
    (e:KVar) : KVar(f(n(e)))
    (e:KObject) : KObject(f(n(e)), args(e), info(e))
    (e:KArray) : KArray(f(n(e)), args(e), info(e))
    (e:KStruct) : KStruct(f(n(e)), args(e))
    (e:KCurry) : KCurry(f(n(e)), targs(e))
    (e:KTagof) : KTagof(f(n(e)))
    (e:KBranch) : KBranch(fs(args(e)), types(e), body(e))
    (e:KBlock) : KBlock(f(n(e)), fs(targs(e)), fs(args(e)), types(e), body(e))
    (e:KGoto) : KGoto(f(n(e)), targs(e), args(e))
    (e:KFn) : KFn(tail?(e), stack-properties(e), fs(targs(e)), a1(e), a2(e),
                  fs(args(e)), body(e), info(e), stats(e))
    (e:KMethod) : KMethod(props(e), f(multi(e)), f(thisn(e)), value(e))
    (e:KNewObject) : KNewObject(f(n(e)), targs(e), args(e), info(e))
    (e:KObjectGet) : KObjectGet(object(e), f(n(e)), index(e))
    (e:KObjectTGet) : KObjectTGet(object(e), f(n(e)), index(e))
    (e:KLetType) : KLetType(f(n(e)), value(e), body(e))
    (e:KClosure) : KClosure(f(n(e)), targs(e), args(e), info(e))
    (e:KTagPrim) : KTagPrim(f(n(e)), exp(e))
    (e:KDetagPrim) : KDetagPrim(f(n(e)), exp(e))
    (e:KSet) : KSet(fl(loc(e)), type(e), value(e))
    (e:KPtr) : KPtr(fl(loc(e)))
    (e:KRead) : KRead(fl(loc(e)), type(e))
    (e) : e

defn map-structure (dec-table:DecTable, f: (KExp, True|False) -> KExp, e:KExp) :
  defn ftrue (e:KExp) : f(e,true)
  defn ffalse (e:KExp) : f(e,false)
  defn ffunc (e:KExp) :
    match(e) :
      (e:KVar) : f(e, function?(dec-table, n(e)))
      (e:KCurry) : f(e,true)
      (e) : f(e,false)
  match(e) :
    (e:KLetRec) : KLetRec(ns(e), map(ftrue, values(e)), ffalse(body(e)))
    (e:KMatch) : KMatch(map(ffalse,args(e)), map(ftrue, branches(e)), info(e))
    (e:KDispatch) : KDispatch(map(ffalse,args(e)), map(ftrue, branches(e)), info(e))
    (e:KLabels) : map(ftrue,e)
    (e:KDo) : KDo(ffunc(func(e)), map(ffalse,args(e)), type(e), info(e))
    (e:KDoC) : KDoC(ffunc(func(e)), map(ffalse,args(e)), map(ffalse,varargs(e)), type(e))
    (e:KMultifn) : map(ftrue,e)
    (e:KNew) : map(ftrue,e)
    (e:KMethod) : map(ftrue,e)
    (e) : map(ffalse,e)

defn map-structure (f: (KExp, True|False) -> KExp, e:KTExp) :
  defn ftrue (e:KExp) : f(e,true)
  defn ffalse (e:KExp) : f(e,false)
  match(e) :
    (e:KDefn|KDefmethod|KExternFn|KDefClosure|KDefConst) : map(ftrue, e)
    (e) : map(ffalse, e)

defn map-bound (before:KExp -> KExp, bindvar:Int -> ?, bindtvar:Int -> ?, after:KExp -> KExp, e:KExp) :
  match(e) :
    (e:KLet) :
      val v* = before(value(e))
      bindvar(n(e))
      KLet(n(e), v*, after(body(e)))
    (e:KLetVar) :
      val v* = attempt: before(value(e) as? KExp)
      bindvar(n(e))
      KLetVar(n(e), type(e), v*, after(body(e)))
    (e:KLetRec) :
      do(bindvar,ns(e))
      map(after,e)
    (e:KBranch) :
      do(bindvar,args(e))
      map(after,e)
    (e:KLabels) :
      do(bindvar{n(_ as KBlock)}, blocks(e))
      map(after, e)
    (e:KBlock) :
      do(bindvar,args(e))
      do(bindtvar,targs(e))
      map(after,e)
    (e:KFn) :
      do(bindtvar, targs(e))
      do(bindvar, args(e))
      map(after,e)
    (e:KLetType) :
      val value* = before(value(e))
      bindtvar(n(e))
      val body* = after(body(e))
      KLetType(n(e), value*, body*)
    (e) :
      map(after, e)

defn map-bound-rev (before:KExp -> KExp, bindvar:Int -> ?, bindtvar:Int -> ?, after:KExp -> KExp, e:KExp) :
  match(e) :
    (e:KLet) :
      val body* = after(body(e))
      bindvar(n(e))
      val v* = before(value(e))
      KLet(n(e), v*, body*)
    (e:KLetVar) :
      val body* = after(body(e))
      bindvar(n(e))
      val v* = attempt: before(value(e) as? KExp)
      KLetVar(n(e), type(e), v*, body*)
    (e:KLetRec) :
      val e* = map(after,e)
      do(bindvar,ns(e))
      e*
    (e:KBranch) :
      val e* = map(after,e)
      do(bindvar,args(e))
      e*
    (e:KLabels) :
      val e* = map(after, e)
      do(bindvar{n(_ as KBlock)}, blocks(e))
      e*
    (e:KBlock) :
      val e* = map(after,e)
      do(bindtvar, targs(e))
      do(bindvar,args(e))
      e*
    (e:KFn) :
      val e* = map(after,e)
      do(bindtvar, targs(e))
      do(bindvar, args(e))
      e*
    (e:KLetType) :
      val body* = after(body(e))
      bindtvar(n(e))
      val value* = before(value(e))
      KLetType(n(e), value*, body*)
    (e) :
      map(after, e)

defn do-used-vars (use:Int -> ?, l:KLoc) :
  match(l) :
    (l:KValue) : false
    (l:KDeref) : false
    (l:KDeptr) : false
    (l:KField) : do-used-vars(use, exp(l))
    (l:KSlot) : do-used-vars(use, exp(l))
    (l:KVarLoc) : use(n(l))

defn do-used-vars (use:Int -> ?, e:KExp) :
  match(e) :
    (e:KPtr) : do-used-vars(use, loc(e))
    (e:KRead) : do-used-vars(use, loc(e))
    (e:KSet) : do-used-vars(use, loc(e))
    (e:KVar) : use(n(e))
    (e:KCurry) : use(n(e))
    (e) : false

defn map-used-types (f:KType -> KType, e:KExp) :
  match(e:KCurry|KCheck|KNewObject|KClosure|KGoto) : map(f,e)
  else : e

defn do-used-types (f:KType -> ?, e:KExp) :
  match(e:KCurry|KCheck|KNewObject|KClosure|KGoto) : do(f,e)

defn do-used-tvars (use:Int -> ?, e:KExp) :
  defn use-tvars (t:KType) :
    match(t) :
      (t:KTVar) : use(n(t))
      (t) : do(use-tvars, t)
  do-used-types(use-tvars, e)
