defpackage stz/kform :
  import core
  import collections
  import stz/pl-ir
  import stz/kl-ir
  import stz/type-to-kform
  import stz/kform-to-tgt
  import stz/ids
  import stz/utils
  import stz/primitives
  import stz/padder

;============================================================
;=================== Driver =================================
;============================================================

public defn compile (input-pkgs:List<KPackage>) :
  var pkgs:List<KPackage> = input-pkgs
  val dec-table = compute-declaration-table(pkgs)
  analyze-types(dec-table)
  pkgs = for input-pkg in pkgs map :
    var pkg:KPackage = input-pkg
    vheader("Package %_" % [name(pkg)])
    println(pkg)
    pkg = map-method-targs(pkg)
    vheader("Package %_ : After Mapping Method Targs" % [name(pkg)])
    println(pkg)
    pkg = create-closures(dec-table, pkg)
    vheader("Package %_ : After Creating Closures" % [name(pkg)])
    println(pkg)
    pkg = convert-mixes(dec-table, pkg)
    vheader("Package %_ : After Converting Mixes" % [name(pkg)])
    println(pkg)
    pkg = guard-boundary(dec-table, pkg)
    vheader("Package %_ : After Guarding Boundaries" % [name(pkg)])
    println(pkg)
    pkg = lift-constants(dec-table, pkg)
    vheader("Package %_ : After Lifting Constants" % [name(pkg)])
    println(pkg)
    pkg = reify-types(dec-table, pkg)
    vheader("Package %_ : After Reifying Types" % [name(pkg)])
    println(pkg)
    pkg = box-mutables(dec-table, pkg)
    vheader("Package %_ : After Boxing Mutables" % [name(pkg)])
    println(pkg)
    pkg = compute-freevars(dec-table, pkg)
    vheader("Package %_ : After Computing Freevars" % [name(pkg)])
    println(pkg)
    pkg = lift-objects(dec-table, pkg)
    vheader("Package %_ : After Lifting Objects" % [name(pkg)])
    println(pkg)
    pkg = compute-freevars(dec-table, pkg)
    vheader("Package %_ : After Computing Freevars Again" % [name(pkg)])
    println(pkg)
    pkg = lift-closures(dec-table, pkg)
    vheader("Package %_ : After Lifting Closures" % [name(pkg)])
    println(pkg)
    pkg = convert-c-calls(pkg)
    vheader("Package %_ : After Converting C Calls" % [name(pkg)])
    println(pkg)
    pkg = primitive-tagging(pkg)
    vheader("Package %_ : After Tagging Primitives" % [name(pkg)])
    println(pkg)
    pkg = analyze-new-stack(pkg)
    vheader("Package %_ : After Analyzing New Stack" % [name(pkg)])
    println(pkg)
    pkg = swap-structs(dec-table, pkg)
    vheader("Package %_ : After Swapping Structs" % [name(pkg)])
    println(pkg)
    pkg

  ;Compile
  for pkg in pkgs do :
    defn cfn (f:KFunc) :
      println("Compiling: %_" % [f])
      println("Compiled:")
      do(println, compile(dec-table, f))
          
    for comm in comms(pkg) do :
      match(comm) :
        (comm:KDefn) :
          cfn(value(comm))
        (comm:KDefmethod) :
          cfn(value(comm))
        (comm) :
          false

;============================================================
;==================== Declaration Table =====================
;============================================================

public deftype DecTable
public defmulti register (this, global?:True|False c:KComm) -> False
public defmulti global? (t:DecTable, n:Int) -> True|False
public defmulti function? (t:DecTable, n:Int) -> True|False
public defmulti arity (t:DecTable, n:Int) -> Int
public defmulti fn-types (t:DecTable, n:Int, targs:List<KTag>) -> [List<KTag>, KTag]
public defmulti ls-fn-types (t:DecTable, n:Int, targs:List<KTag>) -> [List<KLSType>, KLSType]
public defmulti ls-var-type (t:DecTable, n:Int) -> KLSType
public defmulti lostanza? (t:DecTable, n:Int) -> True|False
public defmulti tail? (t:DecTable, n:Int) -> True|False
public defmulti voidable? (t:DecTable, n:Int) -> True|False
public defmulti mutable? (t:DecTable, n:Int) -> True|False
public defmulti field-offset (this, n:Int) -> Int
public defmulti field-index (this, n:Int) -> Int
public defmulti field-type (this, n:Int) -> KLSType
public defmulti extern-label (this, n:Int) -> False|Symbol
public defmulti ls-structs (this) -> Seqable<KLSDefStruct|KLSDefAnalyzedStruct>
public defmulti ls-struct (this, n:Int) -> KLSDefStruct|KLSDefAnalyzedStruct

public defn global-function? (t:DecTable, n:Int) :
  global?(t, n) and function?(t, n)

defn DecTable () :
  val globals = HashTable<Int,True>()
  val table = HashTable<Int,KComm>()
  val fields-table = HashTable<Int,KStructField|KUserField>()
  
  new DecTable :
    defmethod register (this, global?:True|False, c:KComm) :
      match(c:KDef|KDefVar|KDefn|KDefmulti|KDefTag|
              KLSDef|KLSDefVar|KLSDefn|KLSDefStruct|KLSExternFn|KLSExtern|
              KDefConst|KDefTypeObject|KDefObject|KLSDefAnalyzedStruct) :
        table[n(c)] = c
        (globals[n(c)] = true) when global?
      match(c:KLSDefStruct|KLSDefAnalyzedStruct) :
        for f in cons(rfield(c), fields(c)) do :
          match(f:KStructField|KUserField) :
            fields-table[n(f)] = f
          
    defmethod global? (this, n:Int) :
      key?(globals,n)
    defmethod function? (this, n:Int) :
      match(get?(table,n)) :
        (def:KDefn|KDefmulti|KLSDefn|KLSExternFn) : true
        (def:KExtern) : type(def) is KFnT
        (def) : false
    defmethod tail? (this, n:Int) :
      match(table[n]) :
        (d:KDefn) : tail?(value(d) as KFn)
        (d:KLSDefn) : tail?(value(d) as KLSFn)
        (d:KDefmulti) : tail?(d)
    defmethod arity (this, n:Int) :
      match(table[n]) :
        (d:KDefn) : length(a1(value(d) as KFn))
        (d:KLSDefn) : length(a1(value(d) as KLSFn))
        (d:KDefmulti) : length(a1(d))
    defmethod fn-types (this, n:Int, type-args:List<KTag>) :
      val [tvars, a1, a2] = match(table[n]) :
        (d:KDefn) :
          val v = value(d) as KFn
          [targs(v), a1(v), a2(v)]
        (d:KDefmulti) :
          [targs(d), a1(d), a2(d)]
        (d:KLSDefn) :
          val v = value(d) as KLSFn
          [targs(v), map(tag!, a1(v)), tag!(a2(v))]
      val sub-table = to-hashtable<Int,KTag>(tvars,type-args)
      val a1* = map(replace-tvars{_, sub-table}, a1)
      val a2* = replace-tvars(a2, sub-table)
      [a1*, a2*]
    defmethod ls-fn-types (this, n:Int, type-args:List<KTag>) :
      val [tvars, a1, a2] = match(table[n]) :
        (d:KDefn) :
          val v = value(d) as KFn
          [targs(v), KRefTs(a1(v)), KRefT(a2(v))]
        (d:KDefmulti) :
          [targs(d), KRefTs(a1(d)), KRefT(a2(d))]
        (d:KLSDefn) :
          val v = value(d) as KLSFn
          [targs(v), a1(v), a2(v)]
      val sub-table = to-hashtable<Int,KTag>(tvars,type-args)
      val a1* = map(replace-tvars{_, sub-table}, a1)
      val a2* = replace-tvars(a2, sub-table)
      [a1*, a2*]
    defmethod ls-var-type (this, n:Int) :
      match(table[n]) :
        (d:KDef|KDefVar) : KRefT(tag(d))
        (d:KLSDef|KLSDefVar) : type(d)        
    defmethod lostanza? (this, n:Int) :
      get?(table,n) is KLSDef|KLSDefVar|KLSDefn
    defmethod mutable? (this, n:Int) :
      get?(table,n) is KDefVar|KLSDefVar
    defmethod voidable? (this, n:Int) :
      match(get?(table, n)) :
        (d:KDef|KLSDef) : global?(this, n)
        (d:KDefVar|KLSDefVar) : global?(this, n) or value(d) is False
        (d) : false
    defmethod field-offset (this, n:Int) :
      offset(fields-table[n] as KUserField)
    defmethod field-type (this, n:Int) :
      type(fields-table[n] as KUserField)
    defmethod field-index (this, n:Int) :
      index(fields-table[n] as KUserField)
    defmethod extern-label (this, n:Int) :
      match(table[n]) :
        (d:KLSExtern|KLSExternFn) : lbl(d)
        (d) : false
    defmethod ls-structs (this) :
      filter-by<KLSDefStruct|KLSDefAnalyzedStruct>(values(table))
    defmethod ls-struct (this, n:Int) :
      table[n] as KLSDefStruct|KLSDefAnalyzedStruct

;============================================================
;============== Compute Declaration Table ===================
;============================================================

defn compute-declaration-table (pkgs:List<KPackage>) :
  val table = DecTable()
  defn scan (c:KNode, g?:True|False) :
    do-all(scan{_, false}, c)
    match(c:KComm) : register(table, g?, c)        
  do(scan{_, true}, seq-cat(comms, pkgs))  
  table

;============================================================
;============ Analyze Declaration Table =====================
;============================================================

defn analyze-types (dec-table:DecTable) :
  ;Construct table
  val table = HashTable<Int,KLSDefStruct|KLSDefAnalyzedStruct>()
  for def in ls-structs(dec-table) do :
    table[n(def)] = def

  ;Retrieve analyzed record
  defn record (n:Int) :
    match(table[n]) :
      (s:KLSDefStruct) :
        val s* = analyze(s)
        table[n] = s*
        s*
      (s:KLSDefAnalyzedStruct) :
        s
  defn type-alignment (t:KLSType) :
    match(t) :
      (t:KStructT) : alignment(record(n(t)))
      (t) : prim-size(t)
  defn type-length (t:KLSType) :
    match(t) :
      (t:KStructT) : length(record(n(t)))
      (t) : 1
  defn type-size (t:KLSType) :
    match(t) :
      (t:KStructT) : size(record(n(t)))
      (t) : prim-size(t)

  ;Analyze record
  defn analyze (s:KLSDefStruct) -> KLSDefAnalyzedStruct :
    ;Make counters
    defn counter () :
      Coroutine<Int,Int> $ fn (co, sz) :
        let loop (accum:Int = 0, sz:Int = sz) :
          loop(accum + sz, suspend(co, accum))
    val offset-counter = counter()
    val index-counter = counter()
    
    ;Convert to analyzed field
    defn to-af (f:Padding|KStructField) :
      match(f) :
        (f:KStructField) :
          val o = resume(offset-counter, type-size(type(f)))
          val i = resume(index-counter, type-length(type(f)))
          KUserField(n(f), type(f), o, i)
        (f:Padding) :
          resume(offset-counter, size(f))
          KPadField(size(f))      
        
    match(rfield(s)) :
      (_:False) :        
        val [fs, aln] = pad(
          type-alignment{type(_)},
          type-size{type(_)}
          fields(s),
          1)
        val fs* = to-list(seq(to-af, fs))
        val size = resume(offset-counter, 0)
        val length = resume(index-counter, 0)                
        KLSDefAnalyzedStruct(n(s), parent(s), aln, size, length, fs*, false)
      (rf:KStructField) :
        defn not-rest? (f:Padding|KStructField) :
          match(f:KStructField) : n(f) != n(rf)
          else : true
        val [fs, aln] = pad(
          type-alignment{type(_)},
          type-size{type(_)},
          append(fields(s), List(rf)),
          1)          
        val fs* = to-list(seq(to-af, take-while(not-rest?, fs)))
        val size = resume(offset-counter, 0)
        val length = resume(index-counter, 0)        
        val rf* = to-af(next(fs) as KStructField)
        KLSDefAnalyzedStruct(n(s), parent(s), aln, size, length, fs*, rf*)  

  ;Analyze all records
  for n in keys(table) do :
    register(dec-table, true, record(n))

;============================================================
;=================== Method Targ Mapping ====================
;============================================================

defn inverse-solve (input-xs:List<Int>, input-targs:List<KTag>) ->
                   [List<Int>, Vector<KeyValue<Int,KTag>>] :
  ;Created targs
  val ys = map(fresh-id{}, input-targs)
  ;Simplify
  val targs = map(trivial-simplify, input-targs)
  ;Gather Solutions
  val solved = HashTable<Int,Int>()
  defn put (x:Int, y:Int) :
    (solved[x] = y) when not key?(solved, x)
  ;Precise Solutions
  for (t in targs, y in ys) do :
    match(t:KTVar) : put(n(t), y)
  ;Approximate Solutions
  for (t in targs, y in ys) do :
    let loop (t:KTag = t) :
      match(t) :
        (t:KTVar) : put(n(t), y)
        (t:KOr) : do(loop, t)
        (t) : false
  ;Track substitutions
  val subs = Vector<KeyValue<Int,KTag>>()
  ;Invert table
  for entry in solved do :
    val [x, y] = [key(entry), value(entry)]
    match(get?(solved, y)) :
      (x*:Int) : add(subs, x => KTVar(x*))
      (x*:False) : solved[y] = x
  ;Substitute unsolved targs
  for x in input-xs do :
    if not key?(solved, x) :
      add(subs, x => KTop())
  ;Compute new targs
  val output-ys = for y in ys map :
    get?(solved, y, y)
  ;Return
  [output-ys, subs]

defn replace-tvars (t:KTag, entries:Table<Int,KTag>) :
  defn ft (t:KTag) :
    match(t:KTVar) : get?(entries, n(t), t)
    else : map(ft,t)
  trivial-simplify(ft(t))

defn replace-tvars (t:KLSType, entries:Table<Int,KTag>) :
  defn ft (t:KLSType|KTag) :
    match(t) :
      (t:KTag) : replace-tvars(t, entries)
      (t:KLSType) : map-all(ft, t)
  ft(t) as KLSType

defn replace-tvars (e:KExp|KLSComm, entries:Table<Int,KTag>) -> KExp|KLSComm :
  defn ft (t:KTag|KLSType) :
    replace-tvars(t, entries)
  defn f (e:KNode) :
    map-all(f, map-all(ft, e))
  f(e) as KExp|KLSComm

defn replace-tvars (f:KFn, entries:Vector<KeyValue<Int,KTag>>) :
  if empty?(entries) :
    f
  else :
    val entries = to-hashtable<Int,KTag>(entries)
    KFn(
      tail?(f),
      targs(f),
      map(replace-tvars{_, entries}, a1(f)),
      replace-tvars(a2(f), entries),
      args(f),
      replace-tvars(body(f), entries) as KExp)

defn replace-tvars (f:KLSFn, entries:Vector<KeyValue<Int,KTag>>) :
  if empty?(entries) :
    f
  else :
    val entries = to-hashtable<Int,KTag>(entries)
    KLSFn(
      tail?(f),
      targs(f),
      map(replace-tvars{_, entries}, a1(f)),
      replace-tvars(a2(f), entries),
      args(f),
      replace-tvars(body(f), entries) as KLSComm)

defn map-method (f:KDefmethod -> KDefmethod,
                 lsf:KLSDefmethod -> KLSDefmethod,
                 pkg:KPackage) -> KPackage :
  defn fm (c:KNode) :
    match(map-all(fm,c)) :
      (c:KDefmethod) : f(c)
      (c:KLSDefmethod) : lsf(c)
      (c) : c
  map({fm(_) as KComm}, pkg)

defn map-method-targs (pkg:KPackage) :
  defn fm (m:KDefmethod) :
    val v = value(m) as KFn
    if empty?(targs(m)) and empty?(targs(v)) :
      m
    else :
      val [targs*, unsolved] = inverse-solve(targs(v), targs(m))
      val v* = let :
        val v = replace-tvars(v, unsolved)
        KFn(tail?(v), targs*, a1(v), a2(v), args(v), body(v))
      KDefmethod(multi(m), targs(m), thisn(m), v*)
  defn flm (m:KLSDefmethod) :
    val v = value(m) as KLSFn
    if empty?(targs(m)) and empty?(targs(v)) :
      m
    else :
      val [targs*, unsolved] = inverse-solve(targs(v), targs(m))
      val v* = let :
        val v = replace-tvars(v, unsolved)
        KLSFn(tail?(v), targs*, a1(v), a2(v), args(v), body(v))
      KLSDefmethod(multi(m), targs(m), v*)
  map-method(fm, flm, pkg)
  
;============================================================
;===================== Closure Creation =====================
;============================================================

defn map-closures (dec-table: DecTable
                   f: KMix|KCurry|KVar -> KAFn,
                   lf: KLSMix|KLSCurry|KLSVar -> KLSAFn,
                   pkg: KPackage) -> KPackage :
  defn fnode (x:KNode) :
    match(x) :
      (x:KMix|KCurry) :
        f(x)
      (x:KVar) :
        f(x) when global-function?(dec-table, n(x)) else x
      (x:KDo) :
        match(func(x)) :
          (f:KMix|KCurry|KVar) :
            KDo(f, map({fnode(_) as KExp}, args(x)), a1(x), a2(x))
          (f) : map-all(fnode,x)
      (x:KLSMix|KLSCurry) :
        lf(x)
      (x:KLSVar) :
        lf(x) when global-function?(dec-table, n(x)) else x
      (x:KLSDo) :
        match(func(x)) :
          (f:KLSMix|KLSCurry|KLSVar) : KLSDo(f, map({fnode(_) as KLSExp}, args(x)), a1(x), a2(x))
          (f) : map-all(fnode, x)
      (x) :
        map-all(fnode, x)
  map({fnode(_) as KComm}, pkg)

defn mix-fn (dec-table: DecTable, f:KMix|KCurry|KVar) :
  defn make-fn (f:KExp, n:Int) :
    val args* = map(fresh-id{}, 0 to n)
    val body = KDo(f, KVars(args*), KTops(args*), KTop())
    KFn(true, List(), KTops(args*), KTop(), args*, body)

  match(f) :
    (f:KCurry|KVar) :
      make-fn(f, arity(dec-table, n(f)))
    (f:KMix) :
      val groups = to-hashtable<Int,List<KCurry|KVar>>(List())
      for exp in exps(f) do :
        val n = arity(dec-table, n(exp))
        groups[n] = cons(exp, groups[n])
      KMultifn{to-list(_)} $ for entry in groups seq :
        val [n, fs] = [key(entry), value(entry)]
        if length(fs) == 1 : make-fn(head(fs), n)
        else : make-fn(KMix(fs), n)

defn create-closures (dec-table: DecTable, pkg:KPackage) -> KPackage :
  defn to-exp (f:KLSExp) :
    match(f) :
      (f:KLSMix) : KMix(map({to-exp(_) as KCurry}, exps(f)))
      (f:KLSCurry) : KCurry(n(f), targs(f))
      (f:KLSVar) : KVar(n(f))
  map-closures(
    dec-table,
    fn (e) : KAFn(mix-fn(dec-table, e))
    fn (e) : KLSAFn(mix-fn(dec-table, to-exp(e)))
    pkg)

;============================================================
;==================== Mix Conversion ========================
;============================================================

defn map-mixes (f: KDo -> KExp,
                lf: KLSDo -> KLSExp,
                pkg: KPackage) -> KPackage :
  defn fnode (x:KNode) :
    match(map-all(fnode, x)) :
      (x:KDo) :
        match(func(x):KMix) : f(x)
        else : x
      (x:KLSDo) :
        match(func(x):KLSMix) : lf(x)
        else : x
      (x) : x
  map({fnode(_) as KComm}, pkg)

defn convert (dec-table:DecTable, e:KDo) :
  ;Retrieve argument types for given function
  defn arg-types (f:KCurry|KVar) :
    val [a1, a2] = match(f) :
      (f:KVar) : fn-types(dec-table, n(f), List())
      (f:KCurry) : fn-types(dec-table, n(f), targs(f))
    a1
  ;Create branches
  val bs = for f in exps(func(e) as KMix) map :
    val args* = map(fresh-id{}, args(e))
    val ts = arg-types(f)
    KBranch(args*, ts, KDo(f, KVars(args*), KTops(args*), KTop()))
  ;Create dispatch
  KDispatch(args(e), bs)

defn convert (dec-table:DecTable, e:KLSDo) :
  defn pull-out-defs (e:KLSDo) :
    val defs = Vector<KLSDefLocal>()
    val args* = Vector<KLSVar>()
    for (x in args(e), t in a1(e)) do :
      match(x) :
        (x:KLSVar) :
          add(args*, x)
        (x) :
          val id = fresh-id()
          add(defs, KLSDefLocal(id, t, x))
          add(args*, KLSVar(id))
    KLSLet(defs, make-dispatch(func(e) as KLSMix, to-list(args*), a1(e)))
  defn make-dispatch (func:KLSMix, args:List<KLSVar>, ts:List<KLSType>) :
    ;Splice ys into xs according to mask
    defn splice (mask:List<True|False>, xs:List<KLSVar>, ys:List<KLSVar>) :
      val ys-seq = to-seq(ys)
      for (x in xs, m in mask) map :
        if m : next(ys-seq)
        else : x
    ;Retrieve argument types for given function
    defn fn-types (f:KLSCurry|KLSVar) :
      match(f) :
        (f:KLSVar) : ls-fn-types(dec-table, n(f), List())
        (f:KLSCurry) : ls-fn-types(dec-table, n(f), targs(f))
    ;Compute mask
    val refmask = map({_ is KRefT}, ts)
    val refargs = select(args, refmask)
    ;Create branches
    val bs = for f in exps(func) map :
      val args* = map(fresh-id{}, refargs)
      val [a1, a2] = fn-types(f)
      val tags = map(tag!,select(a1, refmask))
      val call = KLSDo(f, splice(refmask, args, KLSVars(args*)), a1, a2)
      KLSBranchExp(args*, tags, call)
    ;Create dispatch
    KLSDispatch(refargs, bs)
  pull-out-defs(e)

defn convert-mixes (dec-table:DecTable, pkg:KPackage) -> KPackage :
  map-mixes(
    fn (e) : convert(dec-table, e)
    fn (e) : convert(dec-table, e)
    pkg)

;============================================================
;================= Boundary Guards ==========================
;============================================================

defn map-guards (fv: KVar -> KExp,
                 fel: KEnsureLength -> KExp,
                 fdef:KDef|KDefVar -> KDef|KDefVar,
                 fdo:(KDo, True|False) -> KExp,
                 fb:KBranch -> KBranch,
                 flb:KLSBranch -> KLSBranch,
                 flbe:KLSBranchExp -> KLSBranchExp,
                 ff:KFn -> KFn,
                 pkg:KPackage) -> KPackage :
  defn map-tail (f: (KExp, True|False) -> KExp, e:KExp, tailcall?:True|False) :
    defn fb (b:KBranch) :
      KBranch(args(b), tags(b), f(body(b), tailcall?))
    match(e) :
      (e:KLet) : KLet(def(e), f(body(e), tailcall?))
      (e:KLetRec) : KLetRec(defs(e), f(body(e), tailcall?))
      (e:KSeq) : KSeq(f(a(e), false), f(b(e), tailcall?))
      (e:KMatch) : KMatch(map(f{_, false}, args(e)), map(fb, branches(e)))
      (e:KDispatch) : KDispatch(map(f{_, false}, args(e)), map(fb, branches(e)))
      (e) : map(f{_, false}, e)
  defn fexp (e:KExp, t:True|False) :
    match(map(fcomm, map-tail(fexp, e, t))) :
      (e:KVar) : fv(e)
      (e:KEnsureLength) : fel(e)
      (e:KDo) : fdo(e, t)
      (e:KMatch) : KMatch(args(e), map(fb,branches(e)))
      (e:KDispatch) : KDispatch(args(e), map(fb, branches(e)))
      (e) : e
  defn ffunc<?T> (f:?T&KFunc) -> T :
    {_ as T&KFunc} $ match(f) :
      (f:KFn) :
        val body* = fexp(body(f), tail?(f))
        ff(KFn(tail?(f), targs(f), a1(f), a2(f), args(f), body*))
      (f:KMultifn) :
        KMultifn $
        map({ffunc(_) as KFn}, funcs(f))
  defn fnode (x:KNode) :
    match(x) :
      (x:KExp) :
        fexp(x, false)
      (x:KLSAFn) :
        KLSAFn(ffunc(value(x)))
      (x:KLSMatch) :
        val x* = map-all(fnode, x) as KLSMatch
        KLSMatch(args(x*), map(flb, branches(x*)))
      (x:KLSDispatch) :
        val x* = map-all(fnode, x) as KLSDispatch
        KLSDispatch(args(x*), map(flbe, branches(x*)))
      (x:KDef) :
        fdef(KDef(n(x), tag(x), fexp(value(x), false)))
      (x:KDefVar) :
        match(value(x)) :
          (v:KExp) : fdef(KDefVar(n(x), tag(x), fexp(v, false)))
          (v:False) : x
      (x:KDefn) :
        KDefn(n(x), ffunc(value(x)))
      (x:KDefmethod) :
        KDefmethod(multi(x), targs(x), thisn(x), ffunc(value(x)))
      (x) :
        map-all(fnode, x)
  defn fcomm (c:KComm) :
    fnode(c) as KComm
  map(fcomm, pkg)

;Insert guards around the given KDo expression to
;enforce declared contracts.
defn guard (dec-table:DecTable, e:KDo, tailcall?:True|False) -> KExp :
  ;Guard call to known function
  defn guard (n:Int, targs:List<KTag>, args:List<KExp>) :
    val [a1, a2] = fn-types(dec-table, n, targs)
    ;Guard arguments when necessary
    val args* =
      if lostanza?(dec-table, n) : map(KCast, args, a1)
      else : args
    ;Make call
    val call = KDo!(length(args*), KCurry?(n,targs), args*)
    ;Guard return when necessary
    if tailcall? : call
    else if lostanza?(dec-table, n) : KCast(call, a2)
    else if tail?(dec-table, n) : KCast(call, a2)
    else : call

  ;Guard call to expression
  defn guard (e:KDo) :
    val args* = map(KCast, args(e), a1(e))
    val func* = KCast(func(e), KOf(FN-TYPE-ID))
    val call = KDo!(length(args*), func*, args*)
    if tailcall? : call
    else : KCast(call, a2(e))

  match(func(e)) :
    (f:KVar) :
      if function?(dec-table, n(f)) : guard(n(f), List(), args(e))
      else : guard(e)
    (f:KCurry) : guard(n(f), targs(f), args(e))
    (f) : guard(e)

defn guard-boundary (dec-table:DecTable, pkg:KPackage) :
  map-guards(
    ;References to variables check for void
    fn (v) :
      if voidable?(dec-table, n(v)) : KEnsureSet(v)
      else : v
    ;Destructuring tuples ensures its a tuple first
    fn (e) :
      val exp* = KCast(exp(e), KOf(TUPLE-TYPE-ID))
      KEnsureLength(exp*, length(e))
    ;Definitions check type before assignments
    fn (c) :
      match(c) :
        (c:KDef) : KDef(n(c), tag(c), KCast(value(c), tag(c)))
        (c:KDefVar) : KDefVar(n(c), tag(c), KCast(value(c) as KExp, tag(c)))
    ;Calls have contracts enforced
    fn (e, t) :
      guard(dec-table, e, t)
    ;Branches check their arguments (in case of unmatched parameters)
    fn (b) :
      val guards = seq(KCast{KVar(_), _}, args(b), tags(b))
      val body = KSeq(guards, body(b))
      KBranch(args(b), map(remove-tvars,tags(b)), body)
    ;LoStanza branches erase their type variables
    fn (b) :
      KLSBranch(args(b), map(remove-tvars,tags(b)), body(b))
    fn (b) :
      KLSBranchExp(args(b), map(remove-tvars,tags(b)), exp(b))
    ;Functions check arguments and return
    fn (f) :
      val guards = seq(KCast{KVar(_), _}, args(f), a1(f))
      var body:KExp = KSeq(guards, body(f))
      if not tail?(f) : body = KCast(body, a2(f))
      KFn(tail?(f), targs(f), a1(f), a2(f), args(f), body),
    pkg)

;============================================================
;=================== Constant Lifting =======================
;============================================================

defn lift-constants (dec-table:DecTable, pkg:KPackage) -> KPackage :
  val defs = Vector<KDefConst>()
  defn prepend-defs (pkg:KPackage) :
    do(register{dec-table, true, _}, defs)
    KPackage(name(pkg), ids(pkg), append(defs, comms(pkg)))
  defn make-const (v) :
    val n = fresh-id()
    add(defs, KDefConst(n, v))
    KVar(n)
  defn fnode (x:KNode) :
    match(x) :
      (x:KLiteral) :
        match(value(x)) :
          (v:Long|Double|String|Symbol|List) : make-const(v)
          (v) : x
      (x) :
        map-all(fnode, x)
  prepend-defs(map({fnode(_) as KComm}, pkg))

;============================================================
;=================== Type Reification =======================
;============================================================

defn normalize (t:KTag) :
  val counter = to-seq(0 to false)
  val ids = IdPool(next{counter})
  let loop (t:KTag = t) :
    match(t) :
      (t:KTVar) : KTVar(ids[n(t)])
      (t) : map(loop, t)

defn freevars (t:KTag) :
  unique $ generate<Int> :
    let loop (t:KTag = t) :
      match(t:KTVar) : yield(n(t))
      else : do(loop, t)

defn remove-tvars (t:KTag) :
  trivial-simplify $
    let loop (t:KTag = t) :
      match(t:KTVar) : KTop()
      else : map(loop, t)

defn remove-tvars (t:KLSType) :
  defn f (t:KLSType|KTag) :
    match(t:KTag) : remove-tvars(t)
    else : map-all(f, t)
  f(t) as KLSType

defn map-type-args (fdo:KDo! -> KDo!,
                    fcall:KLSDo -> KLSDo!,
                    fcast:KCast -> KReifiedCast,
                    ff:KFn -> KFn!,
                    flf:KLSFn -> KLSFn!,
                    pkg:KPackage) -> KPackage :
  defn ffunc (f:KFunc) :
    match(f) :
      (f:KFn) : ff(f)
      (f:KMultifn) : KMultifn(map(ff, funcs(f) as List<KFn>))
  defn fnode (x:KNode) :
    match(map-all(fnode, x)) :
      (x:KDo!) :
        match(func(x):KCurry) : fdo(x)
        else : x
      (x:KAFn) :
        KAFn(ffunc(value(x)))
      (x:KCast) :
        fcast(x)
      (x:KLSDo) :
        match(func(x):KLSCurry) : fcall(x)
        else : x
      (x:KLSAFn) :
        KLSAFn(ffunc(value(x)))
      (x:KDefn) :
        KDefn(n(x), ffunc(value(x)))
      (x:KDefmethod) :
        KDefmethod(multi(x), targs(x), thisn(x), ffunc(value(x)))
      (x:KLSDefn) :
        KLSDefn(n(x), flf(value(x) as KLSFn))
      (x:KLSDefmethod) :
        KLSDefmethod(multi(x), targs(x), flf(value(x) as KLSFn))
      (x:KLSExternFn) :
        KLSExternFn(n(x), lbl(x), flf(value(x) as KLSFn))
      (x) :
        x
  map({fnode(_) as KComm}, pkg)

defn reify-types (dec-table:DecTable, pkg:KPackage) -> KPackage :
  ;Define a type object
  val defs = Vector<KComm>()
  defn prepend-defs (pkg:KPackage) :
    do(register{dec-table, true, _}, defs)
    KPackage(name(pkg), ids(pkg), append(defs, comms(pkg)))

  ;Table of types
  val type-table = HashTable<KTag,Int>()
  defn create-type-object (t:KTag, vs:List<Int>, ls?:True|False) :
    defn Var (n:Int) :
      if ls?: KLSVar(n)
      else : KVar(n)
    defn TypeObject (n:Int, vs:List<Int>) :
      if ls?: KLSTypeObject(n, KLSVars(vs))
      else : KTypeObject(n, KVars(vs))
    match(t:KTVar) :
      Var(n(t))
    else :
      val nt = normalize(t)
      match(get?(type-table, nt)) :
        (n:Int) :
          if empty?(vs) : Var(n)
          else : TypeObject(n, vs)
        (_:False) :
          val type-id = fresh-id()
          add(defs, KDefTypeObject(type-id, vs, t))
          if empty?(vs) :
            val obj-id = fresh-id()
            add(defs, KDefConst(obj-id, KTypeObject(type-id, List())))
            type-table[nt] = obj-id
            Var(obj-id)
          else :
            type-table[nt] = type-id
            TypeObject(type-id, vs)

  ;Creating type objects
  defn type-objects (ts:List<KTag>) :
    for t in ts map :
      create-type-object(t, freevars(t), false) as KExp
  defn ls-type-objects (ts:List<KTag>) :
    for t in ts map :
      create-type-object(t, freevars(t), true) as KLSExp

  prepend-defs $ map-type-args(
    ;Remove type args
    fn (e) :
      val f = func(e) as KCurry
      val args* = append(type-objects(targs(f)), args(e))
      KDo!(arity(e), KVar(n(f)), args*)
    ;Remove type args
    fn (e) :
      val f = func(e) as KLSCurry
      val args* = append(ls-type-objects(targs(f)), args(e))
      KLSDo!(length(args(e)), KLSVar(n(f)), args*, a2(e))
    ;Reify casts
    fn (e) :
      KReifiedCast(exp(e), tag(e))
    ;Reify type arguments
    fn (f) :
      val a1* = append(map(KOf{TYPE-TYPE-ID}, targs(f)),
                       map(remove-tvars, a1(f)))
      val a2* = remove-tvars(a2(f))
      val args* = append(targs(f), args(f))
      KFn!(tail?(f), length(args(f)), a1*, a2*, args*, body(f))
    ;Reify type arguments
    fn (f) :
      val a1* = append(map(KRefT{KOf(TYPE-TYPE-ID)}, targs(f))
                       map(remove-tvars, a1(f)))
      val a2* = remove-tvars(a2(f))
      val args* = append(targs(f), args(f))
      KLSFn!(false, tail?(f), length(args(f)), a1*, a2*, args*, body(f))
    pkg)

;============================================================
;=================== Box Mutables ===========================
;============================================================

defn map-boxes (fdefvar:KDefVar -> KComm,
                fset:KSet -> KExp,
                fvar:KVar -> KExp,
                pkg:KPackage) :
  defn fnode (x:KNode) :
    match(map-all(fnode, x)) :
      (x:KDefVar) : fdefvar(x)
      (x:KSet) : fset(x)
      (x:KVar) : fvar(x)
      (x) : x
  map({fnode(_) as KComm}, pkg)

defn box-mutables (dec-table:DecTable, pkg:KPackage) :
  defn boxed? (n:Int) :
    mutable?(dec-table, n) and not global?(dec-table, n)
  map-boxes(
    ;Create boxes for defvars
    fn (c) :
      if global?(dec-table, n(c)) : c
      else : KDef(n(c), KOf(BOX-TYPE-ID), KBox(value(c)))
    ;Assign into boxes
    fn (e) :
      if boxed?(n(e)) : KBoxSet(KVar(n(e)), value(e))
      else : e
    ;Retrieve from boxes
    fn (e) :
      if boxed?(n(e)) : KBoxGet(e)
      else : e
    pkg)

;============================================================
;=============== Free Variable Computation ==================
;============================================================

defn attach-free (f:KFunc, vs:List<Int>) :
  match(f) :
    (f:KFn!) :
      KFn!(tail?(f), arity(f), a1(f), a2(f), args(f), body(f), vs)
    (f:KMultifn) :
      KMultifn(funcs(f), vs)

defn compute-freevars (dec-table:DecTable, pkg:KPackage) :
  ;Track variable binding
  var vars = HashTable<Int,True|False>()
  defn mark-bound (v:Int) : vars[v] = false
  defn mark-free (v:Int) : vars[v] = true
  defn all-free () : to-list(seq(key, filter(value, vars)))

  ;Mapping functions
  defn markexp (e:KExp) :
    markn(e) as KExp
  defn markb (b:KBranch) :
    val body* = markexp(body(b))
    do(mark-bound, args(b))
    KBranch(args(b), tags(b), body*)
  defn markn (x:KNode) :
    match(x) :
      ;Branches
      (x:KMatch) :
        val args* = map(markexp, args(x))
        KMatch(args*, map(markb, branches(x)))
      (x:KDispatch) :
        val args* = map(markexp, args(x))
        KDispatch(args*, map(markb, branches(x)))
      ;Bound
      (x:KLet) :
        val body* = markexp(body(x))
        mark-bound(n(def(x)))
        val def* = markn(def(x)) as KDef|KDefVar
        KLet(def*, body*)
      (x:KLetRec) :
        val x* = map-all(markn, x)
        do(mark-bound{n(_)}, defs(x))
        x*
      ;Free
      (x:KVar) :
        mark-free(n(x)) when not global?(dec-table, n(x))
        x
      (x:KReifiedCast) :
        for v in freevars(tag(x)) do :
          mark-free(v) when not global?(dec-table, v)
        map-all(markn, x)
      ;Funcs
      (x:KLSAFn) :
        KLSAFn(markf(value(x)))
      (x:KAFn) :
        KAFn(markf(value(x)))
      (x:KDefn) :
        KDefn(n(x), markf(value(x)))
      (x:KDefmethod) :
        KDefmethod(multi(x), targs(x), thisn(x), markf(value(x)))
      ;Recurse
      (x) :
        map-all(markn, x)
  defn markf (f:KFunc) :
    match(f) :
      (f:KFn!) :
        let-var vars = HashTable<Int,True|False>() :
          val body* = markexp(body(f))
          do(mark-bound, args(f))
          val f* = KFn!(tail?(f), arity(f), a1(f), a2(f), args(f), body*)
          val vs = all-free()
          do(mark-free, vs)
          attach-free(f*, vs)
      (f:KMultifn) :
        val fs* = map(markf, funcs(f))
        val vs = unique(seq-cat(freevars, fs*))
        do(mark-free, vs)
        attach-free(KMultifn(fs*), vs)

  ;Driver
  map({markn(_) as KComm}, pkg)

;============================================================
;==================== Object Lifting ========================
;============================================================

defn freevars (e:KNew) :
  unique $ for m in methods(e) seq-cat :
    freevars(value(m))

defn lift-objects (dec-table:DecTable, pkg:KPackage) :
  val defs = Vector<KComm>()
  defn prepend-defs (pkg:KPackage) :
    do(register{dec-table, true, _}, defs)
    KPackage(name(pkg), ids(pkg), append(defs, comms(pkg)))

  defn create-object (e:KNew) :
    val id = fresh-id()
    val obj-vs = freevars(e)
    ;Define Object
    add(defs, KDefObject(id, tag(e), length(obj-vs)))
    ;Pull out Methods
    for m in methods(e) do :
      val obj = thisn(m) as Int
      val f = value(m) as KFn!
      val defs* = for v in freevars(f) seq :
        val i = index-of!(obj-vs, v)
        KDef(v, KTop(), KObjectGet(KVar(obj), i))
      val body* = KLet(defs*, body(f))
      val a1* = for (v in args(f), t in a1(f)) map :
        KOf(id) when v == obj else t
      val f* = KFn!(tail?(f), arity(f), a1*, a2(f), args(f), body*)
      add(defs, KDefmethod(multi(m), targs(m), false, f*))
    ;Create Object
    KObject(id, KVars(obj-vs))

  ;Scanner
  defn fnode (x:KNode) :
    match(map-all(fnode, x)) :
      (x:KNew) : create-object(x)
      (x) : x

  ;Driver
  prepend-defs(map({fnode(_) as KComm}, pkg))

;============================================================
;================== Closure Lifting =========================
;============================================================

defn map-closures (fdef:KDefn -> KDef,
                   ffn:KAFn -> KClosure,
                   flsfn:KLSAFn -> KLSClosure,
                   fdo:KDo! -> KCall|KDo!,
                   flsdo:KLSDo! -> KLSCall|KLSDo!,
                   pkg:KPackage) :
  defn fnode (x:KNode) :
    match(x) :
      (x:KLetRec) :
        val defs* = for d in defs(x) map :
          fdef(map-all(fnode, d) as KDefn)
        val body* = fnode(body(x)) as KExp
        KLetClosures(
          map(n, defs*),
          map(value, defs*) as List<KClosure>,
          body*)
      (x) :
        match(map-all(fnode, x)) :
          (x:KAFn) : ffn(x)
          (x:KLSAFn) : flsfn(x)
          (x:KDo!) : fdo(x)
          (x:KLSDo!) : flsdo(x)
          (x) : x
  map({fnode(_) as KComm}, pkg)

defn lift-closures (dec-table:DecTable, pkg:KPackage) :
  ;Code Ids
  val code-ids = IdPool(fresh-id)
  defn code-id (n:Int) :
    fatal("Globals have no code id.") when global?(dec-table, n)
    code-ids[n]

  ;Removing an int
  defn minus (xs:List<Int>, y:Int) :
    to-list(filter({_ != y}, xs))

  ;Create the closure code
  defn closure-code (func:KFunc, closure:Int, vs:List<Int>) -> KFunc :
    defn make-code (f:KFn!, closure:Int, free:Seqable<KeyValue<Int,Int>>) :
      val defs* = for e in free seq :
        KDef(key(e), KTop(), KClosureGet(KVar(closure), value(e)))
      val body* = KLet(defs*, body(f))
      val a1* = cons(KOf(FN-TYPE-ID), a1(f))
      val args* = cons(closure, args(f))
      KFn!(tail?(f), arity(f), a1*, a2(f), args*, body*)
    match(func) :
      (func:KFn!) :
        val free = seq(KeyValue, vs, 0 to false)
        make-code(func, closure, free)
      (func:KMultifn) :
        val fs* = for f in funcs(func) map :
          val free = for v in (freevars(f) - closure) seq :
            v => index-of!(vs, v)
          make-code(f as KFn!, closure, free)
        KMultifn(fs*)

  ;New Definitions
  val defs = Vector<KComm>()
  defn prepend-defs (pkg:KPackage) :
    do(register{dec-table, true, _}, defs)
    KPackage(name(pkg), ids(pkg), append(defs, comms(pkg)))

  prepend-defs $ map-closures(
    fn (c:KDefn) :
      val f = value(c)
      val vs = freevars(f) - n(c)
      val id = code-id(n(c))
      add(defs, KDefn(id, closure-code(f, n(c), vs)))
      KDef(n(c), KTop(), KClosure(id, KVars(vs)))
    fn (e:KAFn) :
      val f = value(e)
      val id = fresh-id()
      add(defs, KDefn(id, closure-code(f, fresh-id(), freevars(f))))
      KClosure(id, KVars(freevars(f)))
    fn (e:KLSAFn) :
      val f = value(e)
      val id = fresh-id()
      add(defs, KDefn(id, closure-code(f, fresh-id(), freevars(f))))
      KLSClosure(id, KLSVars(freevars(f)))
    fn (e:KDo!) :
      match(func(e)) :
        (f:KVar) :
          if function?(dec-table, n(f)) :
            if global?(dec-table, n(f)) : KCall(arity(e), n(f), args(e))
            else : KCall(arity(e), code-id(n(f)), cons(f, args(e)))
          else : e
        (f) : e
    fn (e:KLSDo!) :
      match(func(e)) :
        (f:KLSVar) :
          if function?(dec-table, n(f)) :
            if not global?(dec-table, n(f)) :
              fatal("Direct call to non-global function.")
            KLSCall(arity(e), n(f), args(e), type(e))
          else : e
        (f) : e
    pkg)

;============================================================
;================== C Call Conversion =======================
;============================================================

defn convert-c-calls (dec-table:DecTable, pkg:KPackage) :
  defn fnode (x:KNode) :
    match(map-all(fnode,x)) :
      (e:KLSDoC) :
        match(func(e)) :
          (f:KLSVar) :
            fatal("Invalid call: %_" % [e]) when not function?(dec-table, n(f))
            KLSCallC(n(f), args(e), varargs(e), type(e))
          (f) : e
      (x) : x
  map({fnode(_) as KComm}, pkg)

;============================================================
;================== Primitive Tagging =======================
;============================================================

defn primitive-tagging (pkg:KPackage) :
  ;Match against [e].value
  defn detag? (e:KLSRead) :
    attempt :
      val loc = loc(e)
      val [base, field] = match(loc:KField) : [exp(loc), n(loc)]
                          else : fail()
      val n = switch(field) :
        BYTE-VALUE-FIELD-ID : BYTE-TYPE-ID
        CHAR-VALUE-FIELD-ID : CHAR-TYPE-ID
        INT-VALUE-FIELD-ID : INT-TYPE-ID
        FLOAT-VALUE-FIELD-ID : FLOAT-TYPE-ID
        else : fail()
      KDetagPrim(n, exp(base as KDeref))  
    else : e

  ;Match against new T{e}
  defn tag? (e:KLSRef) :
    attempt :
      val [n, args] = [n(e), args(e)]
      val ns = [BYTE-TYPE-ID, CHAR-TYPE-ID, INT-TYPE-ID, FLOAT-TYPE-ID]
      if contains?(ns, n) : KTagPrim(n, head(args))
      else : fail()
    else : e

  defn fnode (x:KNode) :
    match(x) :
      (x:KLSRead) : map-all(fnode, detag?(x))
      (x:KLSRef) : map-all(fnode, tag?(x))
      (x:KExp) : x
      (x) : map-all(fnode, x)

  map({fnode(_) as KComm}, pkg)

;============================================================
;================= New Stack Analysis =======================
;============================================================

defn analyze-new-stack (pkg:KPackage) :
  defn prefixed? (comm:KLSComm) -> False|KLSComm :
    defn first+rest (c:KLSComm) -> [KLSComm, KLSComm] :
      match(c) :
        (c:KLSSeq) :
          val [a1, a2] = first+rest(a(c))
          [a1, KLSSeq?(a2, b(c))]
        (c) : [c, KLSSkip()]
    defn new-stack-op? (c:KLSComm) :
      match(c:KLSExec) :
        val exp = exp(c)
        match(exp:KLSPrim) :
          op(exp) == LS-NEW-STACK-OP
    val [a1, a2] = first+rest(comm)
    a2 when new-stack-op?(a1)

  defn ffunc (input-f:KLSFunc) :
    val f = input-f as KLSFn!
    match(prefixed?(body(f))) :
      (body*:KLSComm) :
        KLSFn!(true, tail?(f), arity(f), a1(f), a2(f), args(f), body*)
      (_:False) : f
    
  defn fcomm (c:KComm) :
    match(c) :
      (c:KLSDefn) : KLSDefn(n(c), ffunc(value(c)))
      (c:KLSDefmethod) : KLSDefmethod(multi(c), targs(c), ffunc(value(c)))
      (c:KLSExternFn) : KLSExternFn(n(c), lbl(c), ffunc(value(c)))
      (c) : c

  map(fcomm, pkg)
                  
;============================================================
;=============== Swap out Structs ===========================
;============================================================

defn swap-structs (dec-table:DecTable, pkg:KPackage) -> KPackage :
  for c in pkg map :
    match(c:KLSDefStruct) : ls-struct(dec-table, n(c))
    else : c

;============================================================
;==================== Utilities =============================
;============================================================

;=================================
;==== Sequence Utilities =========
;=================================

defn select<?T> (xs:List<?T>, mask:List<True|False>) -> List<T> :
  to-list(filter(xs, mask))

;=================================
;==== Convenient Getters =========
;=================================

defn tag! (t:KLSType) :
  tag(t as KRefT)

;=================================
;==== Convenient Constructors ====
;=================================

defn KLSLet (d:KLSDefLocal, e:KLSExp) :
  KLSLet(n(d), type(d), value(d), e)

defn KLSLet (defs:Seqable<KLSDefLocal>, e:KLSExp) :
  reduce-right(KLSLet, defs, e)

defn KLet (es:Seqable<KDef|KDefVar>, e:KExp) :
  reduce-right(KLet, es, e)

defn KSeq (es:Seqable<KExp>, e:KExp) :
  reduce-right(KSeq, es, e)

defn KTops (xs:List) :
  map(KTop{}, xs)

defn KVars (xs:List<Int>) :
  map(KVar, xs)

defn KLSVars (xs:List<Int>) :
  map(KLSVar, xs)

defn KRefTs (xs:List<KTag>) :
  map(KRefT, xs)

defn KCurry? (n:Int, targs:List<KTag>) :
  if empty?(targs) : KVar(n)
  else : KCurry(n, targs)

defn KLSSeq? (a:KLSComm, b:KLSComm) :
  match(a, b) :
    (a:KLSSkip, b) : b
    (a, b:KLSSkip) : a
    (a, b) : KLSSeq(a, b)

;================================
;==== Trivial Simplification ====
;================================

;Trivial Simplifications
defn trivial-simplify (t:KTag) :
  match(map(trivial-simplify, t)) :
    (t:KAnd) :
      match(a(t), b(t)) :
        (a:KBot, b) : a
        (a, b:KBot) : b
        (a:KTop, b) : b
        (a, b:KTop) : a
        (a, b) : t
    (t:KOr) :
      match(a(t), b(t)) :
        (a:KBot, b) : b
        (a, b:KBot) : a
        (a:KTop, b) : a
        (a, b:KTop) : b
        (a, b) : t
    (t) : t

;===========================
;==== Initialized Table ====
;===========================

defn to-hashtable<K,V> (es:Seqable<KeyValue<K,V>>) -> HashTable<K,V> :
  to-hashtable<K,V>(seq(key, es), seq(value, es))

defn to-hashtable<K,V> (ks:Seqable<K>, vs:Seqable<V>) -> HashTable<K,V> :
  val t = HashTable<K,V>()
  do({t[_] = _}, ks, vs)
  t

;=================
;==== Id Pool ====
;=================

deftype IdPool <: Collection<Int>
defmulti get (p:IdPool, n:Int) -> Int

defn IdPool (genid: () -> Int) :
  val table = HashTable<Int,Int>()
  new IdPool :
    defmethod get (this, n:Int) :
      if not key?(table, n) :
        table[n] = genid()
      table[n]
    defmethod to-seq (this) :
      to-seq(values(table))