#use-added-syntax(dot-operator)
defpackage stz/defstruct-macro :
  import core
  import collections
  import macro-utils
  import stz/core-macros

;============================================================
;=================== Parsed Representation ==================
;============================================================

;Represents a Stanza 'defstruct' form.
;- name: The name of the struct itself.
;- targs: The type arguments of the struct.
;- parent: The core form representing the parent type, if provided.
;- fields: The fields in the structure.
;- constructor: The name of the generated constructor for the struct.
;   If not provided, the constructor will have the same name as the
;   struct itself.
;- printer?: True if a default printer should be autogenerated.
;- writer?: True if a default writer should be autogenerated.
;- equalable?: True if a default equal? method should be autogenerated.
;- hashable?: True if a default hash method should be autogenerated.
;- meta-utils?: True if meta-programming bindings should be autogenerated.
public defstruct DefStructForm :
  name:Token|Symbol
  targs:List
  parent:Maybe
  fields:List<StructField>
  constructor:Maybe<Token|Symbol>
  keyword-constructor:Maybe<Token|Symbol|True>
  printer?: True|False
  writer?: True|False
  equalable?: True|False
  hashable?: True|False
  meta-utils?: True|False

;Represents a field declaration in a DefStruct.
;- name: The name of the field.
;- type: The core form representing the type of the field.
;- doc-string: The $doc form containing the documentation string for
;  the field, if given.
;- as-method?: True if the field functions should be defined as
;  methods instead of functions.
;- setter: The name of the setter function, if provided.
;- updater: The name of the updater function, if provided.
;- ensure: The core form containing the invariant the field should
;  satisfy, if provided.
;- init: The core form containing the initial value of the field,
;  if provided. Supports the special 'void' value.
;- default: The core form containing the default value of the field,
;  if provided. Supports the special 'void' value.
public defstruct StructField :
  name:Token|Symbol
  type:?
  doc-string:Maybe
  as-method?:True|False
  setter:Maybe<Token|Symbol>
  updater:Maybe<Token|Symbol>
  ensure:Maybe
  init:Maybe
  default:Maybe

;============================================================
;====================== Parsing =============================
;============================================================

defsyntax defstruct-syntax :
  import (exp!, doc-string?, id!, type!) from core

  public defproduction defstruct-form: DefStructForm
  defrule defstruct-form = (defstruct ?name:#id! ?targs:#struct-targs ?parent:#struct-parent
                            ?fields:#struct-fields
                            ?options:#struct-options) :
    val constructor = lookup?(options, `constructor, None())
    val keyword-constructor = lookup?(options, `keyword-constructor, None())
    val printer = unwrap-token(value?(lookup?(options, `printer, None())))
    val writer = unwrap-token(value?(lookup?(options, `writer, None())))
    val equalable = unwrap-token(value?(lookup?(options, `equalable, None())))
    val hashable = unwrap-token(value?(lookup?(options, `hashable, None())))
    val meta-utils = unwrap-token(value?(lookup?(options, `meta-utils, None())))
    DefStructForm(name, targs, parent, fields,
                  constructor, keyword-constructor,
                  printer, writer, equalable, hashable, meta-utils)

  defproduction struct-targs:List
  defrule struct-targs = ((@of ?xs:#id! ...))
  defrule struct-targs = () : List()

  defproduction struct-fields:List<StructField>
  defrule struct-fields = (: (?fs:#struct-field! ...))
  defrule struct-fields = () : List()

  defproduction struct-parent:Maybe
  defrule struct-parent = (<: ?p:#type!) : One(p)
  defrule struct-parent = () : None()

  defproduction struct-options:List<KeyValue<Symbol,?>>
  defrule struct-options = (with: (?options:#struct-option! ...)) :
    ensure-no-duplicate-entries!(closest-info(), options)
    options
  defrule struct-options = () :
    List()

  defproduction struct-option!:KeyValue<Symbol,?>
  defrule struct-option! = (constructor => ?name:#id!) : `constructor => One(name)
  defrule struct-option! = (keyword-constructor => ?name:#id-or-true!) : `keyword-constructor => One(name)
  defrule struct-option! = (printer => ?v:#bool!) : `printer => One(v)
  defrule struct-option! = (writer => ?v:#bool!) : `writer => One(v)
  defrule struct-option! = (equalable => ?v:#bool!) : `equalable => One(v)
  defrule struct-option! = (hashable => ?v:#bool!) : `hashable => One(v)
  defrule struct-option! = (meta-utils => ?v:#bool!) : `meta-utils => One(v)
  fail-if struct-option! = () : CSE(closest-info(), "Expected struct option declaration here.")

  defproduction struct-field!:StructField
  defrule struct-field! = (?doc-string:#doc-string? ?name:#id! ?type:#field-type ?options:#field-options) :
    val init = lookup?(options, `init, None())
    val default = lookup?(options, `default, None())
    val setter = lookup?(options, `setter, None())
    val updater = lookup?(options, `updater, None())
    defn void? (x:Maybe) : unwrap-token(value?(x)) == `void
    match(init:One, default:One) :
      throw(CSE(closest-info(), "Field '%~' cannot have both an initialization and a default value." % [name]))
    if void?(init) and empty?(setter) and empty?(updater) :
      throw(CSE(closest-info(), "Field '%~' is uninitialized and has no setter or updater." % [name]))     
    StructField(
      name,
      type,
      doc-string,
      lookup?(options, `as-method),
      setter,
      updater,
      lookup?(options, `ensure, None()),
      init, default)
  fail-if struct-field! = () : CSE(closest-info(), "Expected a field declaration here.")

  defproduction field-type
  defrule field-type = (: ?t:#type!)
  defrule field-type = () : `?

  defproduction field-options:List<KeyValue<Symbol,?>>
  defrule field-options = (with: (?options:#field-option! ...)) :
    ensure-no-duplicate-entries!(closest-info(), options)
    options
  defrule field-options = () :
    List()

  defproduction field-option!:KeyValue<Symbol,?>
  defrule field-option! = (as-method => ?v:#bool!) : `as-method => unwrap-token(v)
  defrule field-option! = (setter => ?v:#id!) : `setter => One(v)
  defrule field-option! = (updater => ?v:#id!) : `updater => One(v)
  defrule field-option! = (init => ?v:#exp!) : `init => One(v)
  defrule field-option! = (default => ?v:#exp!) : `default => One(v)
  defrule field-option! = (ensure => ?v:#exp!) : `ensure => One(v)
  fail-if field-option! = () : CSE(closest-info(), "Expected a field option declaration here.")

  defproduction bool : Token|True|False
  defrule bool = (?v:true)
  defrule bool = (?v:false)

  defproduction bool! : Token|True|False
  defrule bool! = (?v:#bool)
  fail-if bool! = () : CSE(closest-info(), "Expected a true/false value here.")

  defproduction id-or-true! : Token|Symbol|True
  defrule id-or-true! = (?v:true)
  defrule id-or-true! = (?v:#id!)

;Shorthand for CoreSyntaxError
defn CSE (info:FileInfo|False, msg) :
  CoreSyntaxError(info,msg)

;Return all of the duplicate items in xs.
defn duplicates<?T> (xs:Seqable<?T&Equalable&Hashable>) -> Tuple<T> :
  val seen = HashSet<T>()
  val duplicates = HashSet<T>()
  for x in xs do :
    add(duplicates, x) when not add(seen, x)      
  to-tuple(duplicates)

;Ensure there are no duplicate entries.
defn ensure-no-duplicate-entries! (info:FileInfo|False, entries:Seqable<KeyValue<Symbol,?>>) :
  val keys = duplicates(seq(key,entries))
  if not empty?(keys) :
    val keystrs = for k in keys seq : "'%~'" % [k]
    val plural-s = "s" when length(keys) > 1 else ""
    val msg = "The option%_ %, cannot be used more than once." % [plural-s, keystrs]
    throw(CSE(info, msg))

;============================================================
;================= StructField Bindings =====================
;============================================================

;Generate the bindings for the given fields.
defn bindings (fields:List<StructField>,
               struct-name:Symbol|Token) -> Nested :

  ;Generate the bindings for the given field at index 'index'.
  defn bindings (field:StructField, index:Int) -> Tuple<KeyValue> :

    ;Compute the local name for the field. If the field has a setter,
    ;then the local name is the name of the 'var' variable, otherwise
    ;it is the same as the name.
    val local-name = if field.setter.empty? : field.name
                     else : gensym(field.name)

    ;Compute the name to use as the argument. This is used so that
    ;we can reserve the actual name for within the body of the
    ;constructor.
    val arg-name = gensym(field.name)

    ;Compute whether the field is voidable. It is voidable if it
    ;has either 'init => void' or 'default => void' options.
    defn void? (x:Maybe) : x.value?.unwrap-token == `void
    val voidable? = void?(field.init) or void?(field.default)

    ;Compute the local type of the field. If the field is voidable,
    ;then its type is Type|Uninitialized, otherwise it's just its
    ;declared type.
    val local-type =
      if voidable? :
        val field-type = field.type
        splice $ qquote(~ field-type | core/Uninitialized)
      else :
        field.type

    ;Compute whether a value is initialized by the initialization
    ;block of the positional constructor. There are three settings.
    val always-initialized = 0
    val never-initialized = 1
    val selectively-initialized = 2
    val initialized? =
      if not field.init.empty? :
        if voidable? : choice(never-initialized)
        else : choice(always-initialized)
      else if not field.default.empty? :
        if voidable? : choice(selectively-initialized)
        else : choice(always-initialized)
      else : choice(always-initialized)

    [`name => field.name
     `type => field.type
     `first? => choice(index == 0)
     `doc-string => field.doc-string.value?
     `doc-string? => choice(not field.doc-string.empty?)
     `description => to-string("field %_/%_" % [struct-name, field.name])
     `qualified-name => symbol-join([struct-name '/' field.name])
     `method? => choice(field.as-method?)
     `setter? => choice(not field.setter.empty?)
     `setter => field.setter.value?
     `updater? => choice(not field.updater.empty?)
     `updater => field.updater.value?
     `ensure? => choice(not field.ensure.empty?)
     `ensure => field.ensure.value?
     `local-name => local-name     
     `local-type => local-type
     `arg-name => arg-name
     `voidable? => choice(voidable?)
     `init? => choice(not field.init.empty?)
     `init-value => field.init.value?
     `default? => choice(not field.default.empty?)
     `default-value => field.default.value?
     `initialized? => initialized?]

  ;Generate the bindings for each field.
  nested $ to-tuple $
    for (field in fields, i in 0 to false) seq :
      bindings(field, i)

;============================================================
;================= Metaprogramming Utilities ================
;============================================================

;Generated methods for binding to meta-utilities.
defn meta-utils-methods (form:DefStructForm) -> ? :
  val template = `(
    meta-utils?{
      defmethod core/meta-utils/field-values (x:Struct) :
        [fields{name(x)}]
      defmethod core/meta-utils/field-names (x:Struct) :
        [fields{`name}]
      defmethod core/meta-utils/field-accessors (x:Struct) :
        val accessors = [fields{name upcast-as (Struct -> ?)}]
        accessors as Tuple<(core/meta-utils/HasMetaUtils -> ?)>
      defmethod core/meta-utils/field-entries (x:Struct) :
        [fields{`name => name(x)}]
    }{}
  )
  splice $ substitute(template, [
    `meta-utils? => choice(form.meta-utils?)])

;============================================================
;================= Hashable and Equalable ===================
;============================================================

;Generated methods for hashable and equalable.
defn hashable-equalable-methods (form:DefStructForm) -> ? :
  val template = `(
    equalable?{
      defmethod equal? (lhs:Struct, rhs:Struct) :
        has-fields?{
          fields{first?{}{and} equal?(name(lhs), name(rhs))}
        }{
          true
        }
    }{}

    hashable?{
      defmethod hash (x:Struct) :
        hash([Struct-name fields{name(x)}])
    }{}
  )
  
  splice $ substitute(template, [
    `equalable? => choice(form.equalable?)
    `hashable? => choice(form.hashable?)
    `equal? => `core/equal?
    `hash => `core/hash
    `lhs => gensym(`lhs)
    `rhs => gensym(`rhs)])

;============================================================
;=============== Field Multi Declarations ===================
;============================================================

;Generated deftype and multi declarations for struct fields.
defn deftype-and-multis (form:DefStructForm) -> ? :
  val template = `(

    ;Type declaration
    deftype Struct<targs{name}> meta-utils?{
                                  <: parent?{Parent &}{} core/meta-utils/HasMetaUtils
                                }{
                                  parent?{<: Parent}{}
                                }

    ;Field multis
    fields{
      method?{}{
        doc-string?{doc-string}{}
        defmulti name<targs{?name}> (x:Struct<targs{?name}>) -> type
        setter?{
          defmulti setter<targs{?name}> (x:Struct<targs{?name}>, v:type) -> False
        }{}
        updater?{
          defmulti updater<targs{?name}> (x:Struct<targs{?name}>, v:type) -> Struct<targs{name}>
        }{}
      }
    }
  )

  splice $ substitute(template, [
    `meta-utils? => choice(form.meta-utils?)
    `parent? => choice(not form.parent.empty?)
    `Parent => form.parent.value?])

;============================================================
;=============== Getters / Setters / Updaters ===============
;============================================================

;Generated instance methods for field getters, setters, and updaters.
;- main-constructor: The name of the "main constructor" used to
;  directly create an object.
defn getters-setters-updaters (main-constructor:Token|Symbol) -> ? :
  val template = `(

    ;Getters, setters, and updaters for each field.
    fields{
    
      ;Field getter.
      ;If voidable, then checks that the value is set.
      defmethod name (this) :
        voidable?{
          #if-not-defined(OPTIMIZE) :
            if local-name is Uninitialized :
              fatal("Field %_ has not been initialized." % [`qualified-name])
          local-name as type
        }{
          local-name
        }


      ;Field setter.
      ;Ensure that value satisfies preconditions.
      setter?{
        defmethod setter (this, value:type) :
          ensure?{
            #if-not-defined(OPTIMIZE) :
              ensure(description, value)
          }{}
          local-name = value
      }{}

      ;Field updater.
      ;Ensure that value satisfies preconditions.
      updater?{
        defmethod updater (this, local-name:type) :
          ensure?{
            #if-not-defined(OPTIMIZE) :
              ensure(description, local-name)
          }{}
          MainConstructor<targs{name}>(fields{local-name})
      }{}
      
    }    
  )

  splice $ substitute(template, [
    `MainConstructor => main-constructor
    `value => gensym(`value)
    `fatal => `core/fatal])

;============================================================
;================== Printer and Writer ======================
;============================================================

;Generate the print and write instance methods for the struct.
defn printer-and-writer (form:DefStructForm) -> ? :
  val template = `(
    printer?{
      defmethod print (o:OutputStream, this) :
        val print-items = [
          fields{
            voidable?{
              if local-name is Uninitialized : "%~ = void" % [`name]
              else : "%~ = %~" % [`name, local-name]
            }{
              "%~ = %~" % [`name, local-name]
            }
          }
        ]            
        print(o, "%~(%,)" % [`Struct, print-items])
    }{}
    writer?{
      defmethod write (o:OutputStream, this) :
        val write-items = Vector<?>()
        fields{
          init?{}{
            voidable?{
              if local-name is-not Uninitialized :
                collections/add(write-items, "%~" % [local-name])
            }{
              collections/add(write-items, "%~" % [local-name])
            }
          }
        }
        print(o, "%~(%,)" % [`Struct, write-items])
    }{}
  )

  splice $ substitute(template, [
    `printer? => choice(form.printer?)
    `writer? => choice(form.writer?)
    `OutputStream => `core/OutputStream
    `Vector => `collections/Vector
    `print => `core/print
    `write => `core/write
    `print-items => gensym(`print-items)
    `write-items => gensym(`write-items)
    `o => gensym(`o)])

;============================================================
;=================== Main Constructor =======================
;============================================================

;Generates the "main constructor" for the struct.
;The main constructor is the only constructor that makes the final
;call to 'new'. All other constructors just feed arguments
;to the main constructor.
;- Arguments are allowed to be Uninitialized if they are voidable.
;- Argument preconditions are assumed to be checked already.
;- Init fields are assumed initialized and passed in.

defn main-constructor (form:DefStructForm,
                       main-constructor:Token|Symbol) -> ? :
  val template = `(
    defn MainConstructor<targs{name}> (fields{name:local-type}) :

      ;Define mutable local variables.
      fields{setter?{
        var local-name:local-type = name
      }{}}

      ;Create struct.
      new Struct<targs{name}> :

        ;Getters, setters, and updaters for each field.
        getters-setters-updaters

        ;Printer and writer
        printer-and-writer      
  )

  splice $ substitute(template, [
    `MainConstructor => main-constructor,
    `getters-setters-updaters => getters-setters-updaters(main-constructor)
    `printer-and-writer => printer-and-writer(form)])

;============================================================
;=================== Simple Constructor =====================
;============================================================

;Generates the "simple constructor" for the struct.
;The simple constructor is used when the pattern satisfies
;the common case where the struct is extremely simple.
;Requirements:
;- No keyword constructor.
;- No fields with default values.
;- If any field has an updater then:
;  - No ensures.
;  - No inits.
defn simple-constructor (form:DefStructForm,
                         constructor:Symbol|Token) -> ? :

  val template = `(

    defn Constructor<targs{name}> (fields{init?{}{name:type}}) :
           
      ;Initialize 'init' fields.
      fields{
        init?{
          voidable?{
            var name:type
          }{
            val name:type = init-value
          }          
        }{}
      }

      ;Check preconditions.
      fields{
        ensure?{
          voidable?{}{
            ;If it is not void, then check it
            #if-not-defined(OPTIMIZE) :
              ensure(description, name)            
          }
        }{}
      }

      ;Define mutable local variables.
      fields{
        setter?{
          var local-name:type = name
        }{}
      }

      ;Create struct.
      new Struct<targs{name}> :

        ;Getters, setters, and updaters for each field.      
        getters-setters-updaters
        
        ;Printer and writer
        printer-and-writer
  )

  splice $ substitute(template, [
    `Constructor => constructor
    `getters-setters-updaters => getters-setters-updaters(constructor)
    `printer-and-writer => printer-and-writer(form)])

;============================================================
;================= Positional Constructor ===================
;============================================================

;Generate the positional constructor.
defn positional-constructor (constructor:Symbol|Token,
                             main-constructor:Symbol|Token) -> ? :

  val template = `(
    defn Constructor<targs{name}> (
           fields{
             init?{}{
               arg-name:type default?{= ?}{}
             }
           }) :

      ;Compute initial values for all fields.
      fields{
        init?{
          voidable?{
            var name:type
          }{
            val name:type = init-value
          }
        }{
          default?{
            voidable?{
              var name:type
              if not empty?(arg-name) :
                name = value!(arg-name)
            }{
              val name:type =
                if empty?(arg-name) : default-value
                else : value!(arg-name)
            }
          }{
            val name:type = arg-name
          }
        }
      }

      ;Check preconditions.
      #if-not-defined(OPTIMIZE) :
        fields{
          ensure?{
            initialized?{
              ;Case: Always initialized.
              ensure(description, name)
            }{
              ;Case: Never initialized.
            }{
              ;Case: Selectively initialized.
              if not empty?(arg-name) :
                ensure(description, name)
            }
          }{}
        }

      ;Call the main constructor.
      MainConstructor<targs{name}>(
        fields{
          initialized?{
            name
          }{
            uninitialized
          }{
            value?(arg-name, uninitialized)
          }
        }
      )
  )

  splice $ substitute(template, [
    `Constructor => constructor
    `MainConstructor => main-constructor
    `empty? => `core/empty?
    `value! => `core/value!
    `value? => `core/value?])

;============================================================
;================== Keyword Constructor =====================
;============================================================

;Generate the keyword constructor.
defn keyword-constructor (constructor:Symbol|Token,
                          main-constructor:Symbol|Token) -> ? :

  val template = `(
    defn Constructor<targs{name}> (--
           fields{
             init?{}{
               name:type default?{= ?}{}
             }
           }) :

      ;Store incoming arguments in arg-names.
      fields{
        init?{}{
          val arg-name = name
        }
      }

      ;Introduce new scope, so that names can be
      ;shadowed.
      let :

        ;Compute initial values for all fields.
        fields{
          init?{
            voidable?{
              var name:type
            }{
              val name:type = init-value
            }
          }{
            default?{
              voidable?{
                var name:type
                if not empty?(arg-name) :
                  name = value!(arg-name)
              }{
                val name:type =
                  if empty?(arg-name) : default-value
                  else : value!(arg-name)
              }
            }{
              val name:type = arg-name
            }
          }
        }

        ;Check preconditions.
        #if-not-defined(OPTIMIZE) :
          fields{
            ensure?{
              initialized?{
                ;Case: Always initialized.
                ensure(description, name)
              }{
                ;Case: Never initialized.
              }{
                ;Case: Selectively initialized.
                if not empty?(arg-name) :
                  ensure(description, name)
              }
            }{}
          }

        ;Call the main constructor.
        MainConstructor<targs{name}>(
          fields{
            initialized?{
              name
            }{
              uninitialized
            }{
              value?(arg-name, uninitialized)
            }
          }
        )
  )

  splice $ substitute(template, [
    `Constructor => constructor
    `MainConstructor => main-constructor
    `empty? => `core/empty?
    `value! => `core/value!
    `value? => `core/value?])

;============================================================
;============== Main Generation Algorithm ===================
;============================================================

;Compile the entire DefStruct form.
public defn compile (form:DefStructForm) -> ? :

  ;Accumulate bindings
  val bindings = Vector<KeyValue>()
  defn add-bindings (entries:KeyValue ...) :
    add-all(bindings, entries)

  ;Retrieve the desired name of the constructor.
  val constructor-name = form.constructor.value?(form.name)

  ;Fill default bindings.
  add-bindings(
    `Struct => deep(form.name)
    `targs => deep(repeated([`name => form.targs]))
    `fields => deep(/bindings(form.fields, form.name))
    `x => deep(gensym(`x))
    `Uninitialized => deep(`core/Uninitialized)
    `uninitialized => deep(`core/uninitialized)
    `deftype-and-multis => deftype-and-multis(form)
    `meta-utils-methods => meta-utils-methods(form)
    `hashable-equalable-methods => hashable-equalable-methods(form))

  ;Determine which form of the constructor to use.
  if use-simple-constructor?(form) :
    
    val template = `(
      deftype-and-multis
      meta-utils-methods
      hashable-equalable-methods
      simple-constructor
    )

    add-bindings(
      `simple-constructor => simple-constructor(form, constructor-name))      
    fill-template(template, bindings)
  
  else :

    ;Generate the name of the main constructor.
    val main-constructor-name = gensym(form.name)

    ;Retrieve the name of the keyword constructor.
    val keyword-constructor-name = match(form.keyword-constructor.value?.unwrap-token) :
      (c:Symbol) : form.keyword-constructor.value!
      (c:True) : form.name
      (c:False) : false

    val template = `(
      deftype-and-multis
      meta-utils-methods
      hashable-equalable-methods
      main-constructor
      positional-constructor
      keyword-constructor?
    )

    add-bindings(
      `main-constructor => main-constructor(form, main-constructor-name)
      `positional-constructor => positional-constructor(constructor-name, main-constructor-name))

    if keyword-constructor-name is False :
      add-bindings(
        `keyword-constructor? => splice(List()))
    else :
      add-bindings(
        `keyword-constructor? => keyword-constructor(
                                   keyword-constructor-name as Symbol|Token,
                                   main-constructor-name))

    fill-template(template, bindings)    

;Helper: Return true if the DefStruct form can use
;the simplified constructor.
defn use-simple-constructor? (form:DefStructForm) -> True|False :
  defn no-defaults () :
    all?({_.default.empty?}, form.fields)
  defn no-keyword-constructor () :
    form.keyword-constructor.empty?
  defn any-updaters () :
    any?({not _.updater.empty?}, form.fields)
  defn no-ensures () :
    all?({_.ensure.empty?}, form.fields)
  defn no-inits () :
    all?({_.init.empty?}, form.fields)

  if no-defaults() and no-keyword-constructor() :
    if any-updaters() : no-ensures() and no-inits()
    else : true