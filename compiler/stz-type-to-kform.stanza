defpackage stz/type-to-kform :
  import core
  import collections
  import stz/namemap
  import stz/ids
  import stz/tl-ir with :
    prefix(Child) => T
  import stz/kl-ir with :
    prefix(
      Tag, Of, TVar, And, Or, Top, Bot,
      Comm, Def, DefVar, Defn, Defmulti, Defmethod, DefTag, Init,
      Exp, Set, Cast, Let, LetRec, Seq, Dispatch, Match, New, Do, Var,
      Literal, Tuple, TupleGet, EnsureLength, Mix, Curry, AFn
      Func, Fn, Multifn,
      Child, Branch) => K
  import stz/pl-ir with :
    prefix(Private, Protected, Public) => P

public defn to-kform (p:TProg, nm:NameMap) :
  for pkg in packages(p) as List<TPackage> do :
    println("\n\nPackage %_" % [name(pkg)])
    val decls = to-declarations(comms(pkg), nm)
    println("Declarations:")
    do(println, decls)
    
    accumulate-used $ fn () :
      for comm in comms(pkg) do :
        println("Translate:")
        println(comm)
        val comm* = to-comms(comm)
        println("Translated to:")
        do(println, comm*)
        
    val used-ids = to-list(used())
    println("Used Ids: %," % [used-ids])

;============================================================
;=================== Declarations ===========================
;============================================================

defn to-declarations (cs:List<TComm>, nm:NameMap) -> List<Declare> :
  accumulate<Declare> $ fn (emit) :
    defn declare-targ (n:Int) :
      val e = nm[n]
      emit(Declare(n, TArgId(name(e)), info(e)))
    defn declare-targs (ns:List<Int>) :
      do(declare-targ, ns)
      
    for c in cs do :
      match(c) :
        (c:TDefType) :
          declare-targs(args(c))
          do(declare-targs{args(_)}, children(c))
          val e = nm[n(c)]
          val cs = for child in children(c) map :
            ChildId(n(child), args(child), parent(child))
          val id = TypeId(name(e), args(c), parent(c), cs, to-visibility(visibility(e)))
          emit(Declare(n(c), id, info(e)))
        (c:TDef) :
          val e = nm[n(c)]
          val id = ValId(name(e), type(c) as Type, to-visibility(visibility(e)))
          emit(Declare(n(c), id, info(e)))
        (c:TDefVar) :
          val e = nm[n(c)]
          val id = VarId(name(e), type(c) as Type, to-visibility(visibility(e)))
          emit(Declare(n(c), id, info(e)))      
        (c:TDefTuple) :
          for (n in ns(c), t in types(c)) do :
            val e = nm[n]
            val id = ValId(name(e), t as Type, to-visibility(visibility(e)))
            emit(Declare(n, id, info(e)))
        (c:TDefn) :
          declare-targs(targs(c))
          declare-targs(cargs(c))
          val e = nm[n(c)]
          val id = FnId(name(e), tail?(c), targs(c), cargs(c),
                        a1(c) as List<Type>, a2(c) as Type,
                        to-visibility(visibility(e)))
          emit(Declare(n(c), id, info(e)))         
        (c:TDefmulti) :
          declare-targs(targs(c))
          declare-targs(cargs(c))
          val e = nm[n(c)]
          val id = MultiId(name(e), false, targs(c), cargs(c),
                           a1(c) as List<Type>, a2(c) as Type,
                           to-visibility(visibility(e)))
          emit(Declare(n(c), id, info(e)))
        (c:TDefmethod) :
          false
        (c:TInit) :
          false
        (c) :
          println("Unsupported declaration: %_" % [c])

defn to-visibility (v:Vis) :
  match(v) :
    (v:Private) : PPrivate()
    (v:Protected) : PProtected()
    (v:Public) : PPublic()

;============================================================
;=================== Usages =================================
;============================================================

val USAGE-SET = HashTable<Int,True>()
defn used () : keys(USAGE-SET)
defn record-use (n:Int) : USAGE-SET[n] = true

defn accumulate-used<?T> (f: () -> ?T) -> T :
  clear(USAGE-SET)
  f()

;============================================================
;=================== Forms ==================================
;============================================================

defn to-comms (c:TComm) -> List<KComm> :      
  wrap-in-list<KComm> $ match(c) :
    (c:TDefType) :
      KDefTag(
        n(c),
        to-tag?(parent(c)),
        map(to-child, children(c)))
    (c:TDef) :
      KDef(
        n(c)
        to-tag!(type(c))
        to-exp(value(c)))
    (c:TDefVar) :
      KDefVar(
        n(c)
        to-tag!(type(c))
        to-exp?(value(c)))
    (c:TDefTuple) :
      to-tuple-defs(
        ns(c)
        types(c)
        value(c))
    (c:TDefn) :
      val func = KFn(
        tail?(c),
        append(targs(c), cargs(c))
        map(to-tag!, a1(c))
        to-tag!(a2(c))
        args(c)
        to-exp(body(c)))
      KDefn(n(c), func)
    (c:TDefmulti) :
      KDefmulti(
        n(c),
        false,
        append(targs(c), cargs(c)),
        map(to-tag!, a1(c)),
        to-tag!(a2(c)))
    (c:TDefmethod) :
      val func = KFn(
        tail?(c),
        append(targs(c), cargs(c)),
        map(to-tag!, a1(c)),
        to-tag!(a2(c)),
        args(c),
        to-exp(body(c)))
      val [multi, targs] = to-multi(multi(c))
      record-use(multi)
      KDefmethod(
        multi,
        targs,
        thisn(c),
        func)      
    (c:TInit) : 
      KInit(to-exp(exp(c)))
    (c) :
      println("Unsupported command: %_" % [c])
      KInit(KLiteral(false))      

defn to-exp (e:TExp) -> KExp :
  match(e) :
    (e:TLet) :
      val def = KDef(
        n(e),
        to-tag!(ntype(e)),
        to-exp(value(e)))
      val body = to-exp(body(e))
      KLet(def, body)
    (e:TLetVar) :
      val def = KDefVar(
        n(e),
        to-tag!(ntype(e)),
        to-exp?(value(e)))
      val body = to-exp(body(e))
      KLet(def, body)
    (e:TLetTuple) :
      KLet(
        to-tuple-defs(ns(e), ntypes(e), value(e))
        to-exp(body(e)))
    (e:TLetRec) :
      KLetRec(
        seq-append(to-comms, defns(e)) as List<KDefn>,
        to-exp(body(e)))
    (e:TSeq) :
      KSeq(to-exp(a(e)), to-exp(b(e)))
    (e:TMatch) :
      KMatch(map(to-exp, args(e)),
             map(to-branch, branches(e)))
    (e:TFn) :
      KAFn(to-fn(e))
    (e:TMulti) :
      KAFn(KMultifn(map(to-fn, funcs(e))))
    (e:TNew) :
      KNew(
        to-tag(class(e)),
        seq-append(to-comms, methods(e)) as List<KDefmethod>)
    (e:TRef) :
      record-use(n(e))
      KVar(n(e))
    (e:TCast|TUpCast) :
      KCast(to-exp(exp(e)),
            to-tag(targ(e)))
    (e:TSet) :
      record-use(n(ref(e)))
      KSet(n(ref(e)), 
           to-tag!(type(ref(e))),
           to-exp(value(e)))
    (e:TDo) :
      val a1 = map(to-tag!{type(ctxt(_) as CExp)}, args(e))
      val a2 = to-tag!(type(e))
      val f = to-exp(func(e))
      val args = map(to-exp, args(e))
      KDo(f, args, a1, a2)
    (e:TLiteral) :
      KLiteral(value(e))
    (e:TTupleExp) :
      KTuple(map(to-exp, exps(e)))
    (e:TMix) :
      val exps* = select-all(sel(e) as SSel, exps(e))
      if length(exps*) == 1 : to-exp(head(exps*))
      else : KMix(map(to-curry,exps*))
    (e:TCurry) :
      to-curry(e)
    (e:TPrim) :
      println("Unsupported expression: %_" % [e])
      KLiteral(false)
    (e) :
      fatal("Unsupported Expression: %_" % [e])

defn to-tag (t:Type) -> KTag :
  defn scan (t:Type) :
    do(scan, t)
    match(t) :
      (t:TOf) : record-use(n(t))
      (t:TTuple) : record-use(TUPLE-TYPE-ID)
      (t:TArrow) : record-use(FN-TYPE-ID)
      (t) : false      
  defn translate (t:Type) :
    match(t) :
      (t:TCap|TVar) : KTVar(n(t))
      (t:TOf) : KOf(n(t))
      (t:TTuple) : KOf(TUPLE-TYPE-ID)
      (t:TOr) : KOr(translate(a(t)), translate(b(t)))
      (t:TAnd) : KAnd(translate(a(t)), translate(b(t)))
      (t:TArrow) : KOf(FN-TYPE-ID)
      (t:TGradual) : KTop()
      (t:TBot) : KBot()
      (t) : fatal("No equivalent tag: %_" % [t])      
  scan(t)    
  translate(t)

defn to-tuple-defs (ns:List<Int>, ntypes:List<False|Type>, value:TExp) :
  ;Record use of tuple type
  record-use(TUPLE-TYPE-ID)
  ;Define the tuple
  val value* = KEnsureLength(to-exp(value), length(ntypes))
  val def1 = KDef(
               fresh-id(),
               KOf(TUPLE-TYPE-ID),
               value*)
  ;Destructure the tuple
  val def2 = let :
    val tuple = KVar(n(def1))
    for (n in ns, t in ntypes, i in 0 to false) map :
      KDef(n, to-tag!(t), KTupleGet(tuple, i))
  ;Translate let
  cons(def1, def2)

defn to-branch (e:TBranch) :
  KBranch(args(e), map(to-tag!, atypes(e)), to-exp(body(e)))

defn to-multi (e:TExp) -> [Int, List<KTag>] :
  match(e) :
    (e:TRef) : [n(e), List()]
    (e:TCurry) : [n(ref(e)), map(to-tag!, append(targs(e), cargs(e)))]
    (e:TMix) : to-multi(select-1(sel(e) as SSel, exps(e)))

defn to-child (c:TChild) :
  record-use(n(c))
  KChild(n(c),
         to-tag(parent(c)))

defn to-fn (e:TFn) :
  KFn(tail?(e),
      List(),
      map(to-tag!, a1(e)),
      to-tag!(a2(e)),
      args(e),
      to-exp(body(e)))

defn to-curry (e:TExp) :
  val a1 = types(a(type(e) as TArrow) as TTuple)
  val a2 = b(type(e) as TArrow)
  val a1* = map(to-tag, a1)
  val a2* = to-tag(a2)
  match(e) :
    (e:TCurry) :
      record-use(n(ref(e)))
      val targs = map(to-tag!, append(targs(e), cargs(e)))
      KCurry(n(ref(e)), targs, a1*, a2*)
    (e:TRef) :
      record-use(n(e))
      KCurry(n(e), List(), a1*, a2*)          

;Utilities
defn to-tag? (t:False|Type) : to-tag!(t) when t is Type
defn to-tag! (t:False|Type) : to-tag(t as Type)
defn to-exp? (e:False|TExp) : to-exp(e as TExp) when e is TExp

defn wrap-in-list<T> (c:T|List<T>) -> List<T> :
  match(c) :
    (c:List<T>) : c
    (c:T) : List(c)

defn accumulate<T> (f: (T -> False) -> ?) :
  val accum = Vector<T>()
  f(add{accum, _})
  to-list(accum)

defn KLet (defs:List<KDef|KDefVar>, body:KExp) :
  if empty?(defs) : body
  else : KLet(head(defs), KLet(tail(defs), body))
  
defn select-1<?T> (ss:SSel, xs:List<?T>) -> T :
  for (x in xs, s in sels(ss)) find! :
    s is-not False

defn select-all<?T> (ss:SSel, xs:List<?T>) -> List<T> :
  to-list $
  for (x in xs, s in sels(ss)) filter :
    s is-not False
    
