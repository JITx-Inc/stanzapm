defpackage stz/type-to-kform :
  import core
  import collections
  import stz/namemap
  import stz/ids
  import stz/tl-ir with :
    prefix(Child) => T
  import stz/kl-ir with :
    prefix(
      Tag, Of, TVar, And, Or, Top, Bot,
      Comm, Def, DefVar, Defn, Defmulti, Defmethod, DefTag, Init,
      Exp, Set, Cast, Let, LetRec, Seq, Dispatch, Match, New, Do, Var,
      Literal, Tuple, TupleGet, EnsureLength, Mix, Curry, AFn
      Func, Fn, Multifn,
      Child, Branch) => K

public defn to-kform (p:TProg, nm:NameMap) :
  for pkg in packages(p) as List<TPackage> do :
    for comm in comms(pkg) do :
      println("Translate:")
      println(comm)
      val comm* = to-comms(comm)
      println("Translated to:")
      do(println, comm*)
      ;println(to-comm(comm))

defn to-tag (t:Type) -> KTag :
  match(t) :
    (t:TCap|TVar) : KTVar(n(t))
    (t:TOf) : KOf(n(t))
    (t:TTuple) : KOf(TUPLE-TYPE-ID)
    (t:TOr) : KOr(to-tag(a(t)), to-tag(b(t)))
    (t:TAnd) : KAnd(to-tag(a(t)), to-tag(b(t)))
    (t:TArrow) : KOf(FN-TYPE-ID)
    (t:TGradual) : KTop()
    (t:TBot) : KBot()
    (t) : fatal("No equivalent tag: %_" % [t])

defn to-comms (c:TComm) -> List<KComm> :
  defn wrap (c:KComm|List<KComm>) :
    match(c) :
      (c:KComm) : List(c)
      (c:List<KComm>) : c
      
  wrap $ match(c) :
    (c:TDefType) :
      KDefTag(
        n(c),
        to-tag?(parent(c)),
        map(to-child, children(c)))
    (c:TDef) :
      KDef(
        n(c)
        to-tag!(type(c))
        to-exp(value(c)))
    (c:TDefVar) :
      KDefVar(
        n(c)
        to-tag!(type(c))
        to-exp?(value(c)))
    (c:TDefTuple) :
      to-tuple-defs(
        ns(c)
        types(c)
        value(c))
    (c:TDefn) :
      val func = KFn(
        tail?(c),
        append(targs(c), cargs(c))
        map(to-tag!, a1(c))
        to-tag!(a2(c))
        args(c)
        to-exp(body(c)))
      KDefn(n(c), func)
    (c:TDefmulti) :
      KDefmulti(
        n(c),
        append(targs(c), cargs(c)),
        map(to-tag!, a1(c)),
        to-tag!(a2(c)))
    (c:TDefmethod) :
      val func = KFn(
        tail?(c),
        append(targs(c), cargs(c)),
        map(to-tag!, a1(c)),
        to-tag!(a2(c)),
        args(c),
        to-exp(body(c)))
      val [multi, targs] = to-multi(multi(c))  
      KDefmethod(
        multi,
        targs,
        thisn(c),
        func)      
    (c:TInit) : 
      KInit(to-exp(exp(c)))
    (c) :
      println("Unsupported command: %_" % [c])
      KInit(KLiteral(false))
      

defn to-exp (e:TExp) -> KExp :
  match(e) :
    (e:TLet) :
      val def = KDef(
        n(e),
        to-tag!(ntype(e)),
        to-exp(value(e)))
      val body = to-exp(body(e))
      KLet(def, body)
    (e:TLetVar) :
      val def = KDefVar(
        n(e),
        to-tag!(ntype(e)),
        to-exp?(value(e)))
      val body = to-exp(body(e))
      KLet(def, body)
    (e:TLetTuple) :
      KLet(
        to-tuple-defs(ns(e), ntypes(e), value(e))
        to-exp(body(e)))
    (e:TLetRec) :
      KLetRec(
        seq-append(to-comms, defns(e)) as List<KDefn>,
        to-exp(body(e)))
    (e:TSeq) :
      KSeq(to-exp(a(e)), to-exp(b(e)))
    (e:TMatch) :
      KMatch(map(to-exp, args(e)),
             map(to-branch, branches(e)))
    (e:TFn) :
      KAFn(to-fn(e))
    (e:TMulti) :
      KAFn(KMultifn(map(to-fn, funcs(e))))
    (e:TNew) :
      KNew(
        to-tag(class(e)),
        seq-append(to-comms, methods(e)) as List<KDefmethod>)
    (e:TRef) :
      KVar(n(e))
    (e:TCast|TUpCast) :
      KCast(to-exp(exp(e)),
            to-tag(targ(e)))
    (e:TSet) :
      KSet(n(ref(e)), 
           to-tag!(type(ref(e))),
           to-exp(value(e)))
    (e:TDo) :
      val a1 = map(to-tag!{type(ctxt(_) as CExp)}, args(e))
      val a2 = to-tag!(type(e))
      val f = to-exp(func(e))
      val args = map(to-exp, args(e))
      KDo(f, args, a1, a2)
    (e:TLiteral) :
      KLiteral(value(e))
    (e:TTupleExp) :
      KTuple(map(to-exp, exps(e)))
    (e:TMix) :
      val exps* = select-all(sel(e) as SSel, exps(e))
      if length(exps*) == 1 : to-exp(head(exps*))
      else : KMix(map(to-curry,exps*))
    (e:TCurry) :
      to-curry(e)
    (e:TPrim) :
      println("Unsupported expression: %_" % [e])
      KLiteral(false)
    (e) :
      fatal("Unsupported Expression: %_" % [e])

defn to-tuple-defs (ns:List<Int>, ntypes:List<False|Type>, value:TExp) :
  ;Define the tuple
  val value* = KEnsureLength(to-exp(value), length(ntypes))
  val def1 = KDef(
               fresh-id(),
               KOf(TUPLE-TYPE-ID),
               value*)
  ;Destructure the tuple
  val def2 = let :
    val tuple = KVar(n(def1))
    for (n in ns, t in ntypes, i in 0 to false) map :
      KDef(n, to-tag!(t), KTupleGet(tuple, i))
  ;Translate let
  cons(def1, def2)

defn to-branch (e:TBranch) :
  KBranch(args(e), map(to-tag!, atypes(e)), to-exp(body(e)))

defn to-multi (e:TExp) -> [Int, List<KTag>] :
  match(e) :
    (e:TRef) : [n(e), List()]
    (e:TCurry) : [n(ref(e)), map(to-tag!, append(targs(e), cargs(e)))]
    (e:TMix) : to-multi(select-1(sel(e) as SSel, exps(e)))

defn to-child (c:TChild) :
  KChild(n(c),
         to-tag(parent(c)))

defn to-fn (e:TFn) :
  KFn(tail?(e),
      List(),
      map(to-tag!, a1(e)),
      to-tag!(a2(e)),
      args(e),
      to-exp(body(e)))

defn to-curry (e:TExp) :
  val a1 = types(a(type(e) as TArrow) as TTuple)
  val a2 = b(type(e) as TArrow)
  val a1* = map(to-tag, a1)
  val a2* = to-tag(a2)
  match(e) :
    (e:TCurry) :
      val targs = map(to-tag!, append(targs(e), cargs(e)))
      KCurry(n(ref(e)), targs, a1*, a2*)
    (e:TRef) :
      KCurry(n(e), List(), a1*, a2*)          

;Utilities
defn to-tag? (t:False|Type) : to-tag!(t) when t is Type
defn to-tag! (t:False|Type) : to-tag(t as Type)
defn to-exp? (e:False|TExp) : to-exp(e as TExp) when e is TExp

defn KLet (defs:List<KDef|KDefVar>, body:KExp) :
  if empty?(defs) : body
  else : KLet(head(defs), KLet(tail(defs), body))
  
defn select-1<?T> (ss:SSel, xs:List<?T>) -> T :
  for (x in xs, s in sels(ss)) find! :
    s is-not False

defn select-all<?T> (ss:SSel, xs:List<?T>) -> List<T> :
  to-list $
  for (x in xs, s in sels(ss)) filter :
    s is-not False
    
