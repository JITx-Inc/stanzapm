defpackage stz/type-to-kform :
  import core
  import collections
  import stz/namemap
  import stz/ids
  import stz/tl-ir
  import stz/kl-ir
  import stz/pl-ir with :
    prefix(Private, Protected, Public) => P
  import stz/type-calculus

public defn to-kform (p:TProg, nm:NameMap) :
  ;Using hierarchy and namemap (TODO)
  set-current-hierarchy(hier(p))
  CURRENT-NAMEMAP = nm

  ;Compute declarations
  val all-decls = HashTable<Int,Declare>()
  val package-decls = HashTable<Symbol,List<Declare>>()
  for pkg in packages(p) as List<TPackage> do :
    val decls = to-declarations(comms(pkg), nm)
    package-decls[name(pkg)] = decls
    for d in decls do : all-decls[n(d)] = d

  ;Compute imports
  defn compute-imports (pkg:Symbol) :
    val imported = HashTable<Int,Import>()
    val grouped = HashTable<Symbol,List<Import>>(List())
    defn record-import (pkg:Symbol, i:Import) :
      imported[n(i)] = i
      grouped[pkg] = cons(i, grouped[pkg])

    defn import (n:Int) :
      if not key?(imported, n) :
        val e = nm[n]
        if package(e) != pkg :
          if key?(all-decls, n) :
            val id = id(all-decls[n])
            record-import(package(e), Import(n, id))
            do-ids(import, id)
          else :
            println("No declaration for used id: %_" % [n])
    do(import, used())

    to-list $ for entry in grouped seq :
      ImportPackage(key(entry), value(entry))

  for pkg in packages(p) as List<TPackage> do :
    println("\n\nPackage %_" % [name(pkg)])

    ;Translate commands
    accumulate-used $ fn () :
      for comm in comms(pkg) do :
        println("Translate:")
        println(comm)
        val comm* = to-comms(comm)
        println("Translated to:")
        do(println, comm*)

    ;Compute imports
    val pkg-ids = PkgIds(
      package-decls[name(pkg)]
      compute-imports(name(pkg)))
    println("Package Ids:")
    println(pkg-ids)

;============================================================
;====================== Namemap =============================
;============================================================
;TODO: Won't be necessary after labels are included with extern
;definitions.

var CURRENT-NAMEMAP : False|NameMap = false
defn current-namemap () : CURRENT-NAMEMAP as NameMap

;============================================================
;=================== Declarations ===========================
;============================================================

;TODO: Declarations/Imports should be computed by type level IR
;since they are done using HiStanza types anyway.
defn to-declarations (cs:List<TComm>, nm:NameMap) -> List<Declare> :
  accumulate<Declare> $ fn (emit) :
    defn declare-targ (n:Int) :
      val e = nm[n]
      emit(Declare(n, TArgId(name(e)), info(e)))
    defn declare-targs (ns:Seqable<Int>) :
      do(declare-targ, ns)
    defn declare-field (n:Int) :
      val e = nm[n]
      emit(Declare(n, FieldId(name(e)), info(e)))

    for c in cs do :
      match(c) :
        ;HiStanza Commands
        (c:TDefType) :
          declare-targs(args(c))
          do(declare-targs{args(_)}, children(c))
          val e = nm[n(c)]
          val cs = for child in children(c) map :
            ChildDec(n(child), args(child), parent(child))
          val id = TypeId(name(e), args(c), parent(c), cs, to-visibility(visibility(e)))
          emit(Declare(n(c), id, info(e)))
        (c:TDef) :
          val e = nm[n(c)]
          val id = ValId(name(e), type(c) as Type, to-visibility(visibility(e)))
          emit(Declare(n(c), id, info(e)))
        (c:TDefVar) :
          val e = nm[n(c)]
          val id = VarId(name(e), type(c) as Type, to-visibility(visibility(e)))
          emit(Declare(n(c), id, info(e)))
        (c:TDefTuple) :
          for (n in ns(c), t in types(c)) do :
            val e = nm[n]
            val id = ValId(name(e), t as Type, to-visibility(visibility(e)))
            emit(Declare(n, id, info(e)))
        (c:TDefn) :
          declare-targs(cat(targs(c), cargs(c)))
          val e = nm[n(c)]
          val id = FnId(name(e), tail?(c), targs(c), cargs(c),
                        a1(c) as List<Type>, a2(c) as Type,
                        to-visibility(visibility(e)))
          emit(Declare(n(c), id, info(e)))
        (c:TDefmulti) :
          declare-targs(cat(targs(c), cargs(c)))
          val e = nm[n(c)]
          val id = MultiId(name(e), false, targs(c), cargs(c),
                           a1(c) as List<Type>, a2(c) as Type,
                           to-visibility(visibility(e)))
          emit(Declare(n(c), id, info(e)))
        (c:TDefmethod) :
          false
        (c:TInit) :
          false
          
        ;LoStanza commands
        (c:TLDefType) :
          declare-targs(args(c))
          val e = nm[n(c)]
          val fs = for f in fields(c) map :
            declare-field(n(f))
            FieldDec(n(f), type(f))
          val id = LSTypeId(name(e), args(c), parent(c), fs, to-visibility(visibility(e)))
          emit(Declare(n(c), id, info(e)))          
        (c:TLDef) :
          val e = nm[n(c)]
          val id = LSValId(name(e), type(c) as LSType, to-visibility(visibility(e)))
          emit(Declare(n(c), id, info(e)))
        (c:TLDefVar) :
          val e = nm[n(c)]
          val id = LSVarId(name(e), type(c) as LSType, to-visibility(visibility(e)))
          emit(Declare(n(c), id, info(e)))
        (c:TLDefn) :
          declare-targs(cat(targs(c), cargs(c)))
          val e = nm[n(c)]
          val id = LSFnId(name(e), tail?(c), targs(c), cargs(c),
                          a1(c), a2(c),
                          to-visibility(visibility(e)))
          emit(Declare(n(c), id, info(e)))
        (c:TLDefmethod) :
          false
        (c:TLInit) :
          false
          
        ;External commands  
        (c:TLExternFn) :
          val e = nm[n(c)]
          val id = LSExternFnId(name(e), name(e), a1(c), a2(c), to-visibility(visibility(e)))
          emit(Declare(n(c), id, info(e)))
        (c:TExtern) :
          val e = nm[n(c)]
          val id = LSExternId(name(e), name(e), type(c), to-visibility(visibility(e)))
          emit(Declare(n(c), id, info(e)))
          
        ;Unknown  
        (c) :
          fatal("Unsupported declaration: %_" % [c])

defn to-visibility (v:Vis) :
  match(v) :
    (v:Private) : PPrivate()
    (v:Protected) : PProtected()
    (v:Public) : PPublic()

;============================================================
;=================== Usages =================================
;============================================================

val USAGE-SET = HashTable<Int,True>()
defn used () : to-vector<Int>(keys(USAGE-SET))
defn record-use (n:Int) : USAGE-SET[n] = true

defn accumulate-used<?T> (f: () -> ?T) -> T :
  clear(USAGE-SET)
  f()

defn do-ids (f: Int -> ?, t:Type) :
  do(do-ids{f, _}, t)
  match(t) :
    (t:TOf) : f(n(t))
    (t:TTuple) : f(TUPLE-TYPE-ID)
    (t:TArrow) : f(FN-TYPE-ID)
    (t) : false

defn do-ids (f: Int -> ?, t:LSType) :
  do(do-ids{f, _:LSType}, t)
  match(t) :
    (t:StructT) : f(n(t))
    (t:RefT) : do-ids(f, type(t))
    (t) : false

defn do-ids? (f: Int -> ?, t:Type|False) :
  match(t:Type) : do-ids(f, t)

defn do-ids (f: Int -> ?, id:Id) :
  match(id) :
    (id:ValId) :
      do-ids(f, type(id))
    (id:VarId) :
      do-ids(f, type(id))
    (id:FnId) :
      do(do-ids{f, _}, a1(id))
      do-ids(f, a2(id))
    (id:MultiId) :
      do(do-ids{f, _}, a1(id))
      do-ids(f, a2(id))
    (id:TypeId) :
      do-ids?(f, parent(id))
      for c in children(id) do :
        f(n(c))
        do-ids(f, parent(c))
    (id:TArgId) :
      false

    (id:LSValId) :
      do-ids(f, type(id))
    (id:LSVarId) :
      do-ids(f, type(id))
    (id:LSFnId) :
      do(do-ids{f, _}, a1(id))
      do-ids(f, a2(id))
    (id:LSTypeId) :
      do-ids?(f, parent(id))
      for fd in fields(id) do :
        do-ids(f, type(fd))
    (id:FieldId) :
      false

    (id:LSExternFnId) :
      do(do-ids{f, _}, a1(id))
      do-ids(f, a2(id))
    (id:LSExternId) :
      do-ids(f, type(id))

;============================================================
;=================== Forms ==================================
;============================================================

;TODO: Extern labels should be included with the type ir.
defn to-comms (c:TComm) -> List<KComm> :
  wrap-in-list<KComm> $ match(c) :
    ;HiStanza commands
    (c:TDefType) :
      KDefTag(
        n(c),
        to-tag?(parent(c)),
        map(to-child, children(c)))
    (c:TDef) :
      KDef(
        n(c)
        to-tag!(type(c))
        to-exp(value(c)))
    (c:TDefVar) :
      KDefVar(
        n(c)
        to-tag!(type(c))
        to-exp?(value(c)))
    (c:TDefTuple) :
      to-tuple-defs(
        ns(c)
        types(c)
        value(c))
    (c:TDefn) :
      val func = KFn(
        tail?(c),
        append(targs(c), cargs(c))
        map(to-tag!, a1(c))
        to-tag!(a2(c))
        args(c)
        to-exp(body(c)))
      KDefn(n(c), func)
    (c:TDefmulti) :
      KDefmulti(
        n(c),
        false,
        append(targs(c), cargs(c)),
        map(to-tag!, a1(c)),
        to-tag!(a2(c)))
    (c:TDefmethod) :
      val func = KFn(
        tail?(c),
        append(targs(c), cargs(c)),
        map(to-tag!, a1(c)),
        to-tag!(a2(c)),
        args(c),
        to-exp(body(c)))
      val [multi, targs] = to-multi(multi(c))
      record-use(multi)
      KDefmethod(
        multi,
        targs,
        thisn(c),
        func)
    (c:TInit) :
      KInit(to-exp(exp(c)))
      
    ;LoStanza commands
    (c:TLDefType) :
      val p = to-tag?(parent(c))
      val [fs, rf] = to-fields(fields(c))
      KLSDefStruct(n(c), p, fs, rf)        
    (c:TLDef) :
      KLSDef(
        n(c),
        to-ls-type(type(c)),
        to-ls-exp-upcast(value(c), type(c)))
    (c:TLDefVar) :
      KLSDefVar(
        n(c),
        to-ls-type(type(c)),
        to-ls-exp-upcast?(value(c), type(c)))
    (c:TLDefn) :
      val func = KLSFn(
        tail?(c),
        append(targs(c), cargs(c)),
        map(to-ls-type!, a1(c)),
        to-ls-type!(a2(c)),
        args(c),
        to-ls-comm(body(c), a2(c)))
      KLSDefn(n(c), func)
    (c:TLDefmethod) :
      val func = KLSFn(
        tail?(c),
        append(targs(c), cargs(c)),
        map(to-ls-type!, a1(c)),
        to-ls-type!(a2(c)),
        args(c),
        to-ls-comm(body(c), a2(c)))
      val [multi, targs] = to-multi(multi(c)) 
      KLSDefmethod(multi, targs, func)
    (c:TLInit) :
      KLSInit(to-ls-comm(comm(c), false))

    (c:TLExternFn) :
      val e = current-namemap()[n(c)]
      val func = KLSFn(
        false,
        List(),
        map(to-ls-type!, a1(c)),
        to-ls-type!(a2(c)),
        args(c),
        to-ls-comm(body(c), a2(c)))
      KLSExternFn(n(c), name(e), func)
    (c:TExtern) :
      val e = current-namemap()[n(c)]
      KLSExtern(n(c), name(e), to-ls-type(type(c)))
      
    ;Unknown
    (c) :
      fatal("Unsupported command: %_" % [c])

defn to-exp (e:TExp) -> KExp :
  match(e) :
    (e:TLet) :
      val def = KDef(
        n(e),
        to-tag!(ntype(e)),
        to-exp(value(e)))
      val body = to-exp(body(e))
      KLet(def, body)
    (e:TLetVar) :
      val def = KDefVar(
        n(e),
        to-tag!(ntype(e)),
        to-exp?(value(e)))
      val body = to-exp(body(e))
      KLet(def, body)
    (e:TLetTuple) :
      KLet(
        to-tuple-defs(ns(e), ntypes(e), value(e))
        to-exp(body(e)))
    (e:TLetRec) :
      KLetRec(
        seq-append(to-comms, defns(e)) as List<KDefn>,
        to-exp(body(e)))
    (e:TSeq) :
      KSeq(to-exp(a(e)), to-exp(b(e)))
    (e:TMatch) :
      KMatch(map(to-exp, args(e)),
             map(to-branch, branches(e)))
    (e:TFn) :
      KAFn(to-fn(e))
    (e:TMulti) :
      KAFn(KMultifn(map(to-fn, funcs(e))))
    (e:TNew) :
      KNew(
        to-tag(class(e)),
        seq-append(to-comms, methods(e)) as List<KDefmethod>)
    (e:TRef) :
      record-use(n(e))
      KVar(n(e))
    (e:TCast|TUpCast) :
      KCast(to-exp(exp(e)),
            to-tag(targ(e)))
    (e:TSet) :
      record-use(n(ref(e)))
      KSet(n(ref(e)),
           to-tag!(type(ref(e))),
           to-exp(value(e)))
    (e:TDo) :
      val a1 = map(to-tag!{type(ctxt(_) as CExp)}, args(e))
      val a2 = to-tag!(type(e))
      val f = to-exp(func(e))
      val args = map(to-exp, args(e))
      KDo(f, args, a1, a2)
    (e:TLiteral) :
      KLiteral(value(e))
    (e:TTupleExp) :
      KTuple(map(to-exp, exps(e)))
    (e:TMix) :
      val exps* = select-all(sel(e) as SSel, exps(e))
      if length(exps*) == 1 : to-exp(head(exps*))
      else : KMix(map(to-exp,exps*))
    (e:TCurry) :
      record-use(n(ref(e)))
      val targs = map(to-tag!, append(targs(e), cargs(e)))
      KCurry(n(ref(e)), targs)
    (e:TPrim) :
      KPrim(op(e), map(to-exp, args(e)))
    (e) :
      fatal("Unsupported Expression: %_" % [e])

defn to-tag (t:Type) -> KTag :
  defn translate (t:Type) :
    match(t) :
      (t:TCap|TVar) : KTVar(n(t))
      (t:TOf) : KOf(n(t))
      (t:TTuple) : KOf(TUPLE-TYPE-ID)
      (t:TOr) : KOr(translate(a(t)), translate(b(t)))
      (t:TAnd) : KAnd(translate(a(t)), translate(b(t)))
      (t:TArrow) : KOf(FN-TYPE-ID)
      (t:TGradual) : KTop()
      (t:TBot) : KBot()
      (t) : fatal("No equivalent tag: %_" % [t])
  do-ids(record-use, t)
  translate(t)

defn to-tuple-defs (ns:List<Int>, ntypes:List<False|Type>, value:TExp) :
  ;Record use of tuple type
  record-use(TUPLE-TYPE-ID)
  ;Define the tuple
  val value* = KEnsureLength(to-exp(value), length(ntypes))
  val def1 = KDef(
               fresh-id(),
               KOf(TUPLE-TYPE-ID),
               value*)
  ;Destructure the tuple
  val def2 = let :
    val tuple = KVar(n(def1))
    for (n in ns, t in ntypes, i in 0 to false) map :
      KDef(n, to-tag!(t), KTupleGet(tuple, i))
  ;Translate let
  cons(def1, def2)

defn to-branch (e:TBranch) :
  KBranch(args(e), map(to-tag!, atypes(e)), to-exp(body(e)))

defn to-multi (e:TExp) -> [Int, List<KTag>] :
  match(e) :
    (e:TRef) : [n(e), List()]
    (e:TCurry) : [n(ref(e)), map(to-tag!, append(targs(e), cargs(e)))]
    (e:TMix) : to-multi(select-1(sel(e) as SSel, exps(e)))

defn to-child (c:Child) :
  record-use(n(c))
  KChild(n(c),
         to-tag(parent(c)))

defn to-fn (e:TFn) :
  KFn(tail?(e),
      List(),
      map(to-tag!, a1(e)),
      to-tag!(a2(e)),
      args(e),
      to-exp(body(e)))

defn to-tag? (t:False|Type) : to-tag!(t) when t is Type
defn to-tag! (t:False|Type) : to-tag(t as Type)
defn to-exp? (e:False|TExp) : to-exp(e as TExp) when e is TExp

;============================================================
;================= LoStanza Forms ===========================
;============================================================

defn to-ls-comm (c:LSComm, ret:False|LSType) -> KLSComm :
  ;Track block argument types
  val block-types = HashTable<Int,List<LSType>>()
  
  defn translate (c:LSComm) :
    match(c) :
      (c:LSCall) :
        KLSExec(to-ls-exp(exp(c)))
      (c:LSSet) :
        val et = type(exp(c)) as LSType
        KLSSet(
          to-loc(exp(c))
          to-ls-exp-upcast(value(c), et))      
      (c:LSLabels) :
        for b in blocks(c) do :
          block-types[n(b)] = atypes(b)
        KLSLabels $ for b in blocks(c) map :
          val types* = map(to-ls-type, atypes(b))
          val body* = translate(body(b))
          KLSLabeledBlock(n(b), args(b), types*, body*)
      (c:LSGoto) :
        val args* = to-ls-exp-upcast(args(c), block-types[n(c)])
        KLSGoto(n(c), args*)
      (c:LSReturn) :
        KLSReturn(to-ls-exp-upcast(exp(c), ret as LSType))
      (c:LSDef) :
        val dt = type(c) as LSType
        KLSDefLocal(n(c), to-ls-type(dt), to-ls-exp-upcast(value(c), dt))
      (c:LSDefVar) :
        val dt = type(c) as LSType
        val dt* = to-ls-type(dt)
        match(value(c)) :
          (v:LSExp) : KLSDefLocalVar(n(c), dt*, to-ls-exp-upcast(v, dt))
          (v:False) : KLSDefLocalVar(n(c), dt*, false)
      (c:LSSeq) :
        KLSSeq(translate(a(c)), translate(b(c)))        
      (c:LSIf) :
        KLSIf(to-ls-exp-upcast(pred(c), LongT()),
              translate(conseq(c)),
              translate(alt(c)))
      (c:LSMatch) :
        val branches* = for b in branches(c) map :
          val ts = map(type{_ as RefT}, atypes(b))
          KLSBranch(args(b),
                    map(to-tag, ts),
                    translate(body(b)))
        KLSMatch(map(to-ls-exp, args(c)), branches*)            
      (c:LSSkip) :
        KLSSkip()

  translate(c)

;TODO: LSFn shouldn't be using HiStanza expressions.
defn to-ls-ref (e:TExp) -> KLSExp :
  match(e) :
    (e:TRef) :
      record-use(n(e))
      KLSVar(n(e))
    (e:TMix) :      
      val exps* = select-all(sel(e) as SSel, exps(e))
      if length(exps*) == 1 : to-ls-ref(head(exps*))
      else : KLSMix(map(to-ls-ref,exps*))      
    (e:TCurry) :
      record-use(n(ref(e)))
      val targs = map(to-tag!, append(targs(e), cargs(e)))
      KLSCurry(n(ref(e)), targs)

defn to-ls-exp (e:LSExp) -> KLSExp :
  match(e) :
    (e:LSVar) :
      record-use(n(e))
      KLSVar(n(e))
    (e:LSNew) :
      record-use(n(e))
      val [fts, rft] = field-rest-types(n(e))
      match(rft:LSType) :
        KLSArray(n(e), to-ls-exp-upcast(args(e), cat(fts, repeat(rft))))
      else :    
        KLSRef(n(e), to-ls-exp-upcast(args(e), fts))
    (e:LSStruct) :
      record-use(n(e))
      val args* = to-ls-exp-upcast(args(e), field-types!(n(e), TGradual()))
      KLSStruct(n(e), args*)      
    (e:LSAddr) :
      KLSPtr(to-loc(exp(e)))
    (e:LSDeref|LSSlot|LSField) :
      KLSRead(to-loc(e))
    (e:LSDo) :
      val f* = to-ls-exp(func(e))
      val args* = to-ls-args(args(e), type(func(e)) as FnT)
      KLSCall(f*, args*, to-ls-type!(type(e)))
    (e:LSCallC) :
      val f* = to-ls-exp(func(e))
      val ft = type(func(e)) as FnT
      val args* = to-ls-args(args(e), ft)
      val num-std-args = length(a(ft))
      val std-args = headn(args*, num-std-args)
      val var-args = tailn(args*, num-std-args)
      KLSCallC(f*, std-args, var-args, to-ls-type!(type(e)))      
    (e:LSCast) :
      KLSCast(to-ls-exp(exp(e)), to-ls-type(targ(e)))
    (e:LSLiteral) :
      KLSLiteral(value(e))
    (e:LSAnd) :
      KLSAnd(to-ls-exp-upcast(a(e), LongT()),
             to-ls-exp-upcast(b(e), LongT()))
    (e:LSOr) :
      KLSOr(to-ls-exp-upcast(a(e), LongT()),
            to-ls-exp-upcast(b(e), LongT()))
    (e:LSMix) :
      val exps* = select-all(sel(e) as SSel, exps(e))
      if length(exps*) == 1 : to-ls-exp(head(exps*))
      else : KLSMix(map(to-ls-exp, exps*))
    (e:LSCurry) :
      record-use(n(ref(e)))
      val targs = append(targs(e), cargs(e))
      KLSCurry(n(ref(e)), map(to-tag!, targs))
    (e:LSFn) :
      to-ls-ref(ref(e))
    (e:LSSizeof) :
      println("Unsupported expression: %_" % [e])
      KLSLiteral(false)      
    (e:LSTagof) :
      println("Unsupported expression: %_" % [e])
      KLSLiteral(false)
    (e:LSDoInStack) :
      println("Unsupported expression: %_" % [e])
      KLSLiteral(false)
    (e:LSDoStack) :
      println("Unsupported expression: %_" % [e])
      KLSLiteral(false)
    (e:LSLetExp) :
      println("Unsupported expression: %_" % [e])
      KLSLiteral(false)
    (e:LSPrim) :
      println("Unsupported expression: %_" % [e])
      KLSLiteral(false)
    (e) :
      fatal("Unsupported expression: %_" % [e])

defn to-loc (e:LSExp) -> KLoc :
  match(e) :
    (e:LSDeref) :
      match(type(exp(e))) :
        (et:PtrT) : KDeptr(to-ls-exp(exp(e)), to-ls-type!(type(e)))
        (et:RefT) : KDeref(to-ls-exp(exp(e)), to-ls-type!(type(e)))
    (e:LSSlot) :
      val ptr = match(type(exp(e))) :
        (t:RestT) : KLSPtr(to-loc(exp(e)))
        (t:LSType) : to-ls-exp(exp(e))
      KSlot(ptr,
            to-ls-type!(type(e)),
            to-ls-exp-upcast(index(e), LongT()))  
    (e:LSField) :
      val base = deref-all(exp(e))
      val n = n(type(base) as StructT)
      record-use(n)
      KField(to-loc(base), field-n(n, name(e)))
    (e) :
      KValue(to-ls-exp(e))

;TODO: Upcasting should be done at type level also
defn to-ls-exp-upcast (e:LSExp, t:LSType) :
  val et = type(e) as LSType
  val e* = to-ls-exp(e)
  if implicit-upcast?(et, t) : KLSCast(e*, to-ls-type(t))
  else : e*

defn to-ls-exp-upcast (es:List<LSExp>, ts:Seqable<LSType>) :
  map(to-ls-exp-upcast, es, ts)

defn to-ls-exp-upcast? (e:False|LSExp, t:LSType) :
  match(e:LSExp) : to-ls-exp-upcast(e, t)

;TODO: Upcasting should be done at type level also
defn to-ls-args (es:List<LSExp>, t:FnT) :
  defn ex (ts:List<LSType>, r:False|LSType) :
    match(r:LSType) : cat(ts, repeat(r))
    else : ts
  to-ls-exp-upcast(es, ex(a(t), r(t)))

;TODO: Should probably be done during type level
defn* deref-all (e:LSExp) :
  match(type(e)) :
    (et:PtrT) :
      deref-all(LSDeref(e, type(et), false, false, info(e)))
    (et:RefT) :
      val t = type(et) as TOf
      val t* = StructT(n(t), type(t))
      deref-all(LSDeref(e, t*, false, false, info(e)))
    (et) :
      e

defn to-ls-type (t:LSType) -> KLSType :
  defn translate (t:False) :
    false
  defn translate (t:LSType) :
    match(t) :
      (t:ByteT) : KByteT()
      (t:IntT) : KIntT()
      (t:LongT) : KLongT()
      (t:FloatT) : KFloatT()
      (t:DoubleT) : KDoubleT()
      (t:UnknownT) : KUnknownT()
      (t:PtrT) : KPtrT(translate(type(t)))
      (t:RefT) : KRefT(to-tag(type(t)))
      (t:FnT) : KFnT(map(translate,a(t)), translate(r(t)), translate(b(t)))
      (t:StructT) : KStructT(n(t))
      (t) : fatal("Type cannot be converted to KLSType: %~" % [t])
  do-ids(record-use, t)
  translate(t)

defn to-field (f:Field) :
  KStructField(n(f), to-ls-type(type(f)))

defn to-rfield (f:Field) :
  val t = type(type(f) as RestT)
  KStructField(n(f), to-ls-type(t))

defn to-fields (fs:List<Field>) -> [List<KStructField>, False|KStructField] :
  if empty?(fs) :
    [List(), false]
  else if type(last(fs)) is RestT :
    [map(to-field, but-last(fs)), to-rfield(last(fs))]
  else :
    [map(to-field, fs), false]

defn to-ls-type! (t:False|LSType) : to-ls-type(t as LSType)

defn field-rest-types (n:Int) :
  val fs = field-types!(n, TGradual())
  if empty?(fs) :
    [List(), false]
  else :
    match(last(fs)) :
      (f:RestT) : [but-last(fs), type(f)]
      (f) : [fs, false]

defn field-n (sn:Int, fname:Symbol) :
  label<Int> return :
    val e = current-hierarchy()[sn] as LSHEntry
    for f in fields(e) first! :
      if name(f) == fname : One(n(f))
      else : None()

;============================================================
;=================== Utilities ==============================
;============================================================

defn wrap-in-list<T> (c:T|List<T>) -> List<T> :
  match(c) :
    (c:List<T>) : c
    (c:T) : List(c)

defn accumulate<T> (f: (T -> False) -> ?) :
  val accum = Vector<T>()
  f(add{accum, _})
  to-list(accum)

defn KLet (defs:List<KDef|KDefVar>, body:KExp) :
  if empty?(defs) : body
  else : KLet(head(defs), KLet(tail(defs), body))

defn select-1<?T> (ss:SSel, xs:List<?T>) -> T :
  for (x in xs, s in sels(ss)) find! :
    s is-not False

defn select-all<?T> (ss:SSel, xs:List<?T>) -> List<T> :
  to-list $
  for (x in xs, s in sels(ss)) filter :
    s is-not False
