defpackage stz/vm-encoder :
  import core
  import collections
  import stz/vm-ir
  import stz/loaded-ids
  import stz/basic-ops

public deftype EncodingResolver
public defmulti callc-format (r:EncodingResolver, xtypes:Tuple<VMType|False>, ytypes:Tuple<VMType>) -> Int
public defmulti liveness-map (r:EncodingResolver, live:Tuple<Int>, num-locals:Int) -> Int
public defmulti object-header-size (r:EncodingResolver) -> Int
public defmulti stack-size (r:EncodingResolver) -> Int
public defmulti dispatch-format (r:EncodingResolver, branches:Tuple<Tuple<TypeSet>>) -> Int
public defmulti match-format (r:EncodingResolver, branches:Tuple<Tuple<TypeSet>>) -> Int
public defmulti method-format (r:EncodingResolver, multi:Int, num-header-args:Int) -> Int

public defstruct EncodedFunction :
  buffer: ByteBuffer
  fileinfos: Vector<FileInfoEntry>
  
public defn encode (func:VMFunction,
                    pkgids:PackageIds
                    resolver:EncodingResolver) -> EncodedFunction :
  ;Encode instructions into this byte buffer
  val buffer = ByteBuffer()
  defn buffer-pos () : write-position(buffer) / 4

  ;Delay the generation of this instruction
  defn delayed-ins (f:() -> ?, instruction-words:Int) :
    val h = write-position(buffer)
    for i in 0 to instruction-words do :
      put(buffer, -1)
    within delay() :
      val h0 = write-position(buffer)
      set-write-position(buffer, h)
      f()
      val written = write-position(buffer) - h
      val expected = instruction-words * 4
      fatal("Incorrect size.") when written != expected
      set-write-position(buffer, h0)

  ;Accumulate file information entries for implementing
  ;stack traces.
  val fileinfo-table = Vector<FileInfoEntry>()
  defn record-info (info:FileInfo|False) :
    match(info:FileInfo) :
      add(fileinfo-table, FileInfoEntry(buffer-pos(), info))

  ;Instruction formats:
  ;A: [OPCODE | VALUE]
  ;   [  8    |  24  ]
  ;B: [OPCODE | X  | VALUE]
  ;   [  8    | 10 |  14  ]
  ;C: [OPCODE | _  | X  | VALUE]
  ;   [  8    | 14 | 10 |   32 ]
  ;D: [OPCODE | _  | X ] + VALUE
  ;   [  8    | 14 | 10] +   64
  ;E: [OPCODE | X  | Y  |   Z   | CONST ]
  ;   [  8    | 10 | 10 | 4 + 6 |   26  ]
  ;F: [OPCODE | X  | Y  |    N1  | N2]
  ;   [  8    | 10 | 10 | 4 + 14 | 18]
  defn emit-ins-a (opcode:Int, value:Int) :
    println("A: [%_ | %_]" % [opcode, value])
    put(buffer, opcode | (value << 8))
  defn emit-ins-b (opcode:Int, x:Int, value:Int) :    
    println("B: [%_ | %_ | %_]" % [opcode, x, value])
    put(buffer, opcode | (x << 8) | (value << 18))
  defn emit-ins-c (opcode:Int, x:Int, value:Int) :
    println("C: [%_ | _ | %_ | %_]" % [opcode, x, value])
    put(buffer, opcode | (x << 22))
    put(buffer, value)
  defn emit-ins-c (opcode:Int, x:Int, y:Int, value:Int) :
    println("C: [%_ | %_ | %_ | %_]" % [opcode, x, y, value])
    put(buffer, opcode | (x << 8) | (x << 22))
    put(buffer, value)    
  defn emit-ins-d (opcode:Int, x:Int, value:Long) :
    println("D: [%_ | _ | %_] + %~" % [opcode, x, value])
    put(buffer, opcode | (x << 22))
    put(buffer, value)
  defn emit-ins-e (opcode:Int, x:Int, y:Int, z:Int, const:Int) :
    println("E: [%_ | %_ | %_ | %_ | %_]" % [opcode, x, y, z, const])
    put(buffer, opcode | (x << 8) | (y << 18) | (z << 28))
    put(buffer, (z >> 4) | (const << 6))
  defn emit-ins-f (opcode:Int, x:Int, y:Int, n1:Int, n2:Int) :
    println("F: [%_ | %_ | %_ | %_ | %_]" % [opcode, x, y, n1, n2])
    put(buffer, opcode | (x << 8) | (y << 18) | (n1 << 28))
    put(buffer, ((n1 & 0x3FFFF) >> 4) | (n2 << 14))
  defn emit-ins-targets (dests:Seqable<Int>) :
    for d in dests do : put(buffer, d)

  ;Calculation of sizes
  defn object-size (num-obj:Int, size:Int) :
    num-obj * object-header-size(resolver) + size
  defn stack-size () :
    object-size(1, /stack-size(resolver))

  ;Retrieve the corresponding bits for the given immediate
  defn to-bits (y:VMImm) -> Int|Long :
    match(y) :
      (y:Local) : index(y)
      (y:NumConst) :
        match(value(y)) :
          (v:Char) : to-int(v)
          (v:Byte) : to-int(v)
          (v:Int) : v
          (v:Long) : v
          (v:Float) : bits(v)
          (v:Double) : bits(v)
      (y:Marker) : marker(typeid(y))
      (y:Tag) : typeid(y)
      (y:VoidMarker) : marker(-1)
      (y:CodeId) : id(y)
      (y:ExternId) : id(y)
      (y:GlobalId) : id(y)
      (y:DataId) : id(y)
      (y:ConstId) : id(y)

  ;Split a tuple of VMBranch into typesets and destinations
  defn split-types-and-dests (bs:Tuple<VMBranch>) -> [Tuple<Tuple<TypeSet>>, Tuple<Int>] :
    val types = for b in bs map :
      map(normalize, types(b))
    val targets = map(n, bs)
    [types, targets]

  ;Set register
  defn set-reg (i:Int, y:VMImm) :
    match(to-bits(y)) :
      (v:Int) : emit-ins-c(set-reg-opcode(y), i, v)
      (v:Long) : emit-ins-d(set-reg-opcode(y), i, v)    
  defn set-regs (ys:Seqable<VMImm>) :
    do(set-reg, 0 to false, ys)
  defn get-reg (x:Local|False, i:Int) :
    match(x:Local) :
      emit-ins-b(GET-REG-OPCODE, index(x), i)
  defn get-regs (xs:Seqable<Local|False>) :
    do(get-reg, xs, 0 to false)

  ;Set local
  defn set-local (x:Int, y:VMImm) :
    match(to-bits(y)) :
      (v:Int) : emit-ins-c(set-opcode(y), x, v)
      (v:Long) : emit-ins-d(set-opcode(y), x, v)

  ;Encode multivarity functions
  defn encode (multi:VMMultifn) :
    ;Declare function positions
    var func-positions
    ;Emit branch instructions
    for (entry in funcs(multi), i in 0 to false) do :
      val arity = key(entry)      
      within delayed-ins(2) :
        ;println("Emit branch: Function position at %_" % [func-positions[i]])
        val offset = func-positions[i] - buffer-pos()
        ;println("Offset = %_" % [offset])
        emit-ins-c(JUMP-REG-OPCODE, arg(multi), arity, offset)
    ;Emit default branch
    encode(default(multi))
    ;Emit other branches, and compute their positions
    func-positions = for entry in funcs(multi) map :
      val fpos = buffer-pos()
      ;println("Function position at %_" % [fpos])
      encode(value(entry))
      fpos

  ;Encode function instructions
  defn encode (func:VMFunc) :
    ;Compute num locals
    ;Reserve extra 3 locals for temporary moving
    val max-local = maximum(-1, seq(local, defs(func)))
    val num-locals = max-local + 1 + 3

    ;Put immediate in temporary local if not a local
    defn to-local (x:VMImm, num:Int) :
      match(x:Local) :
        index(x)
      else :
        val index = max-local + num + 1
        set-local(index, x)
        index

    ;Put immediate in register if not a function immediate
    defn to-function (f:VMImm) :
      match(f) :
        (f:Local) : index(f)
        (f:CodeId) : id(f)
        (f:ExternId) : id(f)
        (f) : to-local(f, 0)

    ;Create mapping from local ID to slot
    val deftable = to-inttable<VMDef> $
      for def in defs(func) seq :
        id(def) => def

    ;Use deftable to retrieve the type of an immediate
    defn imm-type (x:VMImm) :
      match(x:Local) : type(deftable[index(x)])
      else : type(x)
    defn imm-type (x:False) :
      x

    ;Create mapping from label ID to position
    val label-table = IntTable<Int>()
    defn jump-offset (n:Int) :
      label-table[n] - buffer-pos()
    defn jump-offsets (xs:Seqable<Int>) :
      to-tuple(seq(jump-offset, xs))
    defn jump-offsets (xs:Seqable<Int>, ys:Seqable<Int>) :
      jump-offsets(cat(xs,ys))

    ;Resolve an instruction
    defn sub-slot (x:Local) : Local(local(deftable[index(x)]))
    defn sub-slot (x:False) : false
    defn resolve-ins<?T> (ins:VMIns&?T) -> T :
      defn sub-id (n:Int) : pkgids[n]      
      map({_}, sub-slot, sub-id, ins)

    ;Retrieve arguments
    get-regs(seq(sub-slot, args(func)))
    
    ;Encode each instruction 
    for ins0 in ins(func) do :
      match(resolve-ins(ins0)) :
        (ins:LabelIns) :
          label-table[n(ins)] = buffer-pos()
        (ins:UnreachableIns) :
          false
        (ins:TCallIns) :
          set-regs(ys(ins))
          emit-ins-c(tcall-opcode(f(ins)), 0, to-function(f(ins)))
        (ins:TCallClosureIns) :
          set-regs(ys(ins))
          emit-ins-a(TCALL-CLOSURE-OPCODE, to-local(f(ins), 0))
        (ins:CallIns) : 
          set-regs(ys(ins))
          emit-ins-c(call-opcode(f(ins)), num-locals, to-function(f(ins)))
          record-info(info(ins))
          emit-ins-a(POP-FRAME-OPCODE, num-locals)
          get-regs(xs(ins))
        (ins:CallClosureIns) : 
          set-regs(ys(ins))
          emit-ins-c(CALL-CLOSURE-OPCODE, num-locals, to-local(f(ins), 0))
          record-info(info(ins))
          emit-ins-a(POP-FRAME-OPCODE, num-locals)
          get-regs(xs(ins))
        (ins:CallCIns) :
          val ins0 = ins0 as CallCIns
          val format = callc-format(resolver, xtypes, ytypes) where :
            val xtypes = map(imm-type,xs(ins0))
            val ytypes = map(imm-type,ys(ins0))
          set-regs(ys(ins))
          emit-ins-c(callc-opcode(f(ins)), format, num-locals, to-function(f(ins)))
          record-info(info(ins))
          get-regs(xs(ins))          
        (ins:YieldIns) : 
          set-regs(ys(ins))
          emit-ins-a(YIELD-OPCODE, to-local(f(ins), 0))
          record-info(info(ins))
          get-regs(xs(ins))
        (ins:ReturnIns) : 
          set-regs(xs(ins))
          emit-ins-a(RETURN-OPCODE, 0)
        (ins:DumpIns) :
          for x in xs(ins) do :
            emit-ins-a(DUMP-OPCODE, index(x))
        (ins:RecordLiveIns) : 
          val live-map = liveness-map(resolver, map(index, live(ins)), num-locals)
          emit-ins-a(LIVE-OPCODE, live-map)
        (ins:StoreIns) :          
          val ins0 = ins0 as StoreIns
          val code = store-opcode(y(ins), imm-type(x(ins0)))
          val z* = to-local(z(ins),0)
          match(y(ins)) :
            (y:VMImm) :             
              val x* = to-local(x(ins),1)
              val y* = to-local(y,2)
              emit-ins-e(code, x*, y*, z*, offset(ins))
            (y:False) :
              val x* = to-local(x(ins),1)
              emit-ins-e(code, x*, 0, z*, offset(ins))
        (ins:LoadIns) :
          val ins0 = ins0 as LoadIns
          val code = load-opcode(z(ins), imm-type(y(ins0)))
          match(z(ins)) :
            (z:VMImm) :
              val y* = to-local(y(ins),0)
              val z* = to-local(z, 1)
              emit-ins-e(code, index(x(ins)), y*, z*, offset(ins))
            (z:False) :
              val y* = to-local(y(ins),0)
              emit-ins-e(code, index(x(ins)), y*, 0, offset(ins))
        (ins:Op0Ins) :
          val code = op0-opcode(op(ins))
          emit-ins-a(code, index(x(ins)))
        (ins:Op1Ins) :
          val ins0 = ins0 as Op1Ins
          match(op(ins)) :
            (op:InstanceofOp) :
              ;Push argument into register
              set-reg(0, y(ins))
              ;Retrieve format
              val format = match-format(resolver, [[normalize(type(op))]])
              ;Emit typeof instruction
              emit-ins-c(TYPEOF-OPCODE, index(x(ins)), format)
            (op) :
              val opcode = op1-opcode(op, imm-type(x(ins0)), imm-type(y(ins0)))
              match(opcode:Int) :
                val x* = index(x(ins))
                val y* = to-local(y(ins), 0)
                emit-ins-b(opcode, x*, y*)
              else :
                set-local(index(x(ins)), y(ins))
        (ins:Op2Ins) :
          val ins0 = ins0 as Op2Ins
          val opcode = op2-opcode(op(ins), imm-type(x(ins0)), imm-type(y(ins0)))
          val x* = index(x(ins))
          val y* = to-local(y(ins), 0)
          val z* = to-local(z(ins), 1)
          emit-ins-c(opcode, x*, y*, z*)
        (ins:GotoIns) :
          within delayed-ins(1) :            
            emit-ins-a(GOTO-OPCODE, jump-offset(n(ins)))
        (ins:Branch1Ins) :
          match(op(ins)) :
            (op:InstanceofOp) :
              ;Push argument into register
              set-reg(0, x(ins))
              ;Retrieve format
              val format = match-format(resolver, [[normalize(type(op))]])
              ;Emit dispatch instruction
              ;Two targets, match success and default
              val num-targets = 2
              within delayed-ins(1 + num-targets) :
                val targets = jump-offsets([n2(ins), n1(ins)])
                emit-ins-a(DISPATCH-OPCODE, format)
                emit-ins-targets(targets)
            (op:False) :
              val x* = to-local(x(ins), 0)
              within delayed-ins(2) :
                emit-ins-f(JUMP-SET-OPCODE, x*, 0, jump-offset(n1(ins)), jump-offset(n2(ins)))
        (ins:Branch2Ins) :
          val ins0 = ins0 as Branch2Ins
          val code = branch2-opcode(op(ins), imm-type(x(ins0)))
          val x* = to-local(x(ins), 0)
          val y* = to-local(y(ins), 1)
          within delayed-ins(2) :
            emit-ins-f(code, x*, y*, jump-offset(n1(ins)), jump-offset(n2(ins)))
        (ins:NewStackIns) :
          emit-ins-c(RESERVE-OPCODE-CONST, 3, num-locals, stack-size())
          record-info(info(ins))
          emit-ins-a(POP-FRAME-OPCODE, num-locals)
          emit-ins-b(NEW-STACK-OPCODE, index(x(ins)), to-local(fid(ins),0))
        (ins:AllocIns) :
          if all?({_ is NumConst}, sizes(ins)) :
            val num-obj = length(sizes(ins))
            val size = sum $
              for s in sizes(ins) seq :
                value(s as NumConst) as Int
            emit-ins-c(RESERVE-OPCODE-CONST, 3, num-locals, object-size(num-obj,size))
            record-info(info(ins))
            emit-ins-a(POP-FRAME-OPCODE, num-locals)
            for (x in xs(ins), t in types(ins), sz in sizes(ins)) do :
              val s = value(sz as NumConst) as Int
              emit-ins-c(ALLOC-OPCODE-CONST, index(x), s, t)
          else :
            fatal("Multiple variable-sized allocations.") when length(sizes(ins)) > 1
            val x = xs(ins)[0]
            val type = types(ins)[0]
            val size = to-local(sizes(ins)[0], 0)
            emit-ins-c(RESERVE-OPCODE-LOCAL, 3, num-locals, size)
            record-info(info(ins))
            emit-ins-a(POP-FRAME-OPCODE, num-locals)
            emit-ins-c(ALLOC-OPCODE-LOCAL, index(x), size, type)
        (ins:DispatchIns) :
          ;Push arguments onto registers
          set-regs(ys(ins))
          val [types, dests] = split-types-and-dests(branches(ins))
          val format = dispatch-format(resolver, types)          
          ;Two targets for default and amb and then each branch for dispatch.
          val num-targets = 2 + length(branches(ins))
          within delayed-ins(1 + num-targets) :
            val targets = jump-offsets([default(ins), amb(ins)], dests)
            emit-ins-a(DISPATCH-OPCODE, format)            
            emit-ins-targets(targets)
        (ins:MatchIns) :
          ;Push arguments onto registers
          set-regs(ys(ins))
          val [types, dests] = split-types-and-dests(branches(ins))
          val format = match-format(resolver, types)
          ;One target for default and then each branch for dispatch.
          val num-targets = 1 + length(branches(ins))
          within delayed-ins(1 + num-targets) :
            val targets = jump-offsets([default(ins)], dests)
            emit-ins-a(DISPATCH-OPCODE, format)            
            emit-ins-targets(targets)
        (ins:MethodDispatchIns) :
          ;Push arguments onto registers
          set-regs(cat(ys(ins), zs(ins)))
          ;Retrieve format
          val format = method-format(resolver, multi(ins), length(ys(ins)))
          ;Only two targets for default and amb
          val num-targets = 2
          within delayed-ins(1 + num-targets) :
            val targets = jump-offsets([default(ins), amb(ins)])
            emit-ins-a(DISPATCH-METHOD-OPCODE, format)
            emit-ins-targets(targets)
        (ins:SetIns) :
          set-local(index(x(ins)), y(ins))

  ;Use delayed actions and encode instructions
  println("Function %_" % [id(func)])
  within indented() :
    within delay-actions() :
      encode(func as VMMultifn|VMFunc)
  EncodedFunction(buffer, fileinfo-table)

public defstruct FileInfoEntry :
  pc: Int
  fileinfo: FileInfo

;============================================================
;======================= Opcodes ============================
;============================================================

val opcode-counter = to-seq(0 to 256)
val SET-OPCODE-LOCAL = next(opcode-counter)
val SET-OPCODE-UNSIGNED = next(opcode-counter)
val SET-OPCODE-SIGNED = next(opcode-counter)
val SET-OPCODE-CODE = next(opcode-counter)
val SET-OPCODE-EXTERN = next(opcode-counter)
val SET-OPCODE-GLOBAL = next(opcode-counter)
val SET-OPCODE-DATA = next(opcode-counter)
val SET-OPCODE-CONST = next(opcode-counter)
val SET-OPCODE-WIDE = next(opcode-counter)
val SET-REG-OPCODE-LOCAL = next(opcode-counter)
val SET-REG-OPCODE-UNSIGNED = next(opcode-counter)
val SET-REG-OPCODE-SIGNED = next(opcode-counter)
val SET-REG-OPCODE-CODE = next(opcode-counter)
val SET-REG-OPCODE-EXTERN = next(opcode-counter)
val SET-REG-OPCODE-GLOBAL = next(opcode-counter)
val SET-REG-OPCODE-DATA = next(opcode-counter)
val SET-REG-OPCODE-CONST = next(opcode-counter)
val SET-REG-OPCODE-WIDE = next(opcode-counter)
val GET-REG-OPCODE = next(opcode-counter)
val CALL-OPCODE-LOCAL = next(opcode-counter)
val CALL-OPCODE-CODE = next(opcode-counter)
val CALL-OPCODE-EXTERN = next(opcode-counter)
val CALL-CLOSURE-OPCODE = next(opcode-counter)
val TCALL-OPCODE-LOCAL = next(opcode-counter)
val TCALL-OPCODE-CODE = next(opcode-counter)
val TCALL-OPCODE-EXTERN = next(opcode-counter)
val TCALL-CLOSURE-OPCODE = next(opcode-counter)
val CALLC-OPCODE-LOCAL = next(opcode-counter)
val CALLC-OPCODE-CODE = next(opcode-counter)
val CALLC-OPCODE-EXTERN = next(opcode-counter)
val POP-FRAME-OPCODE = next(opcode-counter)
val LIVE-OPCODE = next(opcode-counter)
val YIELD-OPCODE = next(opcode-counter)
val RETURN-OPCODE = next(opcode-counter)
val DUMP-OPCODE = next(opcode-counter)
;2-arity operations
val INT-ADD-OPCODE = next(opcode-counter)
val INT-SUB-OPCODE = next(opcode-counter)
val INT-MUL-OPCODE = next(opcode-counter)
val INT-DIV-OPCODE = next(opcode-counter)
val INT-MOD-OPCODE = next(opcode-counter)
val INT-AND-OPCODE = next(opcode-counter)
val INT-OR-OPCODE = next(opcode-counter)
val INT-XOR-OPCODE = next(opcode-counter)
val INT-SHL-OPCODE = next(opcode-counter)
val INT-SHR-OPCODE = next(opcode-counter)
val INT-ASHR-OPCODE = next(opcode-counter)
val INT-LT-OPCODE = next(opcode-counter)
val INT-GT-OPCODE = next(opcode-counter)
val INT-LE-OPCODE = next(opcode-counter)
val INT-GE-OPCODE = next(opcode-counter)
val EQ-OPCODE-REF-REF = next(opcode-counter)
val EQ-OPCODE-REF = next(opcode-counter)
val EQ-OPCODE-BYTE = next(opcode-counter)
val EQ-OPCODE-INT = next(opcode-counter)
val EQ-OPCODE-LONG = next(opcode-counter)
val EQ-OPCODE-FLOAT = next(opcode-counter)
val EQ-OPCODE-DOUBLE = next(opcode-counter)
val NE-OPCODE-REF-REF = next(opcode-counter)
val NE-OPCODE-REF = next(opcode-counter)
val NE-OPCODE-BYTE = next(opcode-counter)
val NE-OPCODE-INT = next(opcode-counter)
val NE-OPCODE-LONG = next(opcode-counter)
val NE-OPCODE-FLOAT = next(opcode-counter)
val NE-OPCODE-DOUBLE = next(opcode-counter)
val ADD-OPCODE-BYTE = next(opcode-counter)
val ADD-OPCODE-INT = next(opcode-counter)
val ADD-OPCODE-LONG = next(opcode-counter)
val ADD-OPCODE-FLOAT = next(opcode-counter)
val ADD-OPCODE-DOUBLE = next(opcode-counter)
val SUB-OPCODE-BYTE = next(opcode-counter)
val SUB-OPCODE-INT = next(opcode-counter)
val SUB-OPCODE-LONG = next(opcode-counter)
val SUB-OPCODE-FLOAT = next(opcode-counter)
val SUB-OPCODE-DOUBLE = next(opcode-counter)
val MUL-OPCODE-BYTE = next(opcode-counter)
val MUL-OPCODE-INT = next(opcode-counter)
val MUL-OPCODE-LONG = next(opcode-counter)
val MUL-OPCODE-FLOAT = next(opcode-counter)
val MUL-OPCODE-DOUBLE = next(opcode-counter)
val DIV-OPCODE-BYTE = next(opcode-counter)
val DIV-OPCODE-INT = next(opcode-counter)
val DIV-OPCODE-LONG = next(opcode-counter)
val DIV-OPCODE-FLOAT = next(opcode-counter)
val DIV-OPCODE-DOUBLE = next(opcode-counter)
val MOD-OPCODE-BYTE = next(opcode-counter)
val MOD-OPCODE-INT = next(opcode-counter)
val MOD-OPCODE-LONG = next(opcode-counter)
val AND-OPCODE-BYTE = next(opcode-counter)
val AND-OPCODE-INT = next(opcode-counter)
val AND-OPCODE-LONG = next(opcode-counter)
val OR-OPCODE-BYTE = next(opcode-counter)
val OR-OPCODE-INT = next(opcode-counter)
val OR-OPCODE-LONG = next(opcode-counter)
val XOR-OPCODE-BYTE = next(opcode-counter)
val XOR-OPCODE-INT = next(opcode-counter)
val XOR-OPCODE-LONG = next(opcode-counter)
val SHL-OPCODE-BYTE = next(opcode-counter)
val SHL-OPCODE-INT = next(opcode-counter)
val SHL-OPCODE-LONG = next(opcode-counter)
val SHR-OPCODE-BYTE = next(opcode-counter)
val SHR-OPCODE-INT = next(opcode-counter)
val SHR-OPCODE-LONG = next(opcode-counter)
val ASHR-OPCODE-BYTE = next(opcode-counter)
val ASHR-OPCODE-INT = next(opcode-counter)
val ASHR-OPCODE-LONG = next(opcode-counter)
val LT-OPCODE-INT = next(opcode-counter)
val LT-OPCODE-LONG = next(opcode-counter)
val LT-OPCODE-FLOAT = next(opcode-counter)
val LT-OPCODE-DOUBLE = next(opcode-counter)
val GT-OPCODE-INT = next(opcode-counter)
val GT-OPCODE-LONG = next(opcode-counter)
val GT-OPCODE-FLOAT = next(opcode-counter)
val GT-OPCODE-DOUBLE = next(opcode-counter)
val LE-OPCODE-INT = next(opcode-counter)
val LE-OPCODE-LONG = next(opcode-counter)
val LE-OPCODE-FLOAT = next(opcode-counter)
val LE-OPCODE-DOUBLE = next(opcode-counter)
val GE-OPCODE-INT = next(opcode-counter)
val GE-OPCODE-LONG = next(opcode-counter)
val GE-OPCODE-FLOAT = next(opcode-counter)
val GE-OPCODE-DOUBLE = next(opcode-counter)
val ULE-OPCODE-BYTE = next(opcode-counter)
val ULE-OPCODE-INT = next(opcode-counter)
val ULE-OPCODE-LONG = next(opcode-counter)
val ULT-OPCODE-BYTE = next(opcode-counter)
val ULT-OPCODE-INT = next(opcode-counter)
val ULT-OPCODE-LONG = next(opcode-counter)
val UGT-OPCODE-BYTE = next(opcode-counter)
val UGT-OPCODE-INT = next(opcode-counter)
val UGT-OPCODE-LONG = next(opcode-counter)
val UGE-OPCODE-BYTE = next(opcode-counter)
val UGE-OPCODE-INT = next(opcode-counter)
val UGE-OPCODE-LONG = next(opcode-counter)
;1-arity operations
val INT-NOT-OPCODE = next(opcode-counter)
val INT-NEG-OPCODE = next(opcode-counter)
val NOT-OPCODE-BYTE = next(opcode-counter)
val NOT-OPCODE-INT = next(opcode-counter)
val NOT-OPCODE-LONG = next(opcode-counter)
val NEG-OPCODE-INT = next(opcode-counter)
val NEG-OPCODE-LONG = next(opcode-counter)
val NEG-OPCODE-FLOAT = next(opcode-counter)
val NEG-OPCODE-DOUBLE = next(opcode-counter)
val DEREF-OPCODE = next(opcode-counter)
val TYPEOF-OPCODE = next(opcode-counter)
;branch operation
val JUMP-SET-OPCODE = next(opcode-counter)
val GOTO-OPCODE = next(opcode-counter)
;conversion operations
val CONV-OPCODE-BYTE-FLOAT = next(opcode-counter)
val CONV-OPCODE-BYTE-DOUBLE = next(opcode-counter)
val CONV-OPCODE-INT-BYTE = next(opcode-counter)
val CONV-OPCODE-INT-FLOAT = next(opcode-counter)
val CONV-OPCODE-INT-DOUBLE = next(opcode-counter)
val CONV-OPCODE-LONG-BYTE = next(opcode-counter)
val CONV-OPCODE-LONG-INT = next(opcode-counter)
val CONV-OPCODE-LONG-FLOAT = next(opcode-counter)
val CONV-OPCODE-LONG-DOUBLE = next(opcode-counter)
val CONV-OPCODE-FLOAT-BYTE = next(opcode-counter)
val CONV-OPCODE-FLOAT-INT = next(opcode-counter)
val CONV-OPCODE-FLOAT-LONG = next(opcode-counter)
val CONV-OPCODE-FLOAT-DOUBLE = next(opcode-counter)
val CONV-OPCODE-DOUBLE-BYTE = next(opcode-counter)
val CONV-OPCODE-DOUBLE-INT = next(opcode-counter)
val CONV-OPCODE-DOUBLE-LONG = next(opcode-counter)
val CONV-OPCODE-DOUBLE-FLOAT = next(opcode-counter)
;tagging operations
val DETAG-OPCODE = next(opcode-counter)
val TAG-OPCODE-BYTE = next(opcode-counter)
val TAG-OPCODE-CHAR = next(opcode-counter)
val TAG-OPCODE-INT = next(opcode-counter)
val TAG-OPCODE-FLOAT = next(opcode-counter)
;storing operations
val STORE-OPCODE = next(opcode-counter)
val STORE-OPCODE-VAR-OFFSET = next(opcode-counter)
val STORE-OPCODE-REF = next(opcode-counter)
val STORE-OPCODE-REF-VAR-OFFSET = next(opcode-counter)
;loading operations
val LOAD-OPCODE = next(opcode-counter)
val LOAD-OPCODE-VAR-OFFSET = next(opcode-counter)
val LOAD-OPCODE-REF = next(opcode-counter)
val LOAD-OPCODE-REF-VAR-OFFSET = next(opcode-counter)
;Allocation
val RESERVE-OPCODE-LOCAL = next(opcode-counter)
val RESERVE-OPCODE-CONST = next(opcode-counter)
val NEW-STACK-OPCODE = next(opcode-counter)
val ALLOC-OPCODE-CONST = next(opcode-counter)
val ALLOC-OPCODE-LOCAL = next(opcode-counter)
;system operations
val GC-OPCODE = next(opcode-counter)
val PRINT-STACK-TRACE-OPCODE = next(opcode-counter)
val CURRENT-STACK-OPCODE = next(opcode-counter)
val FLUSH-VM-OPCODE = next(opcode-counter)
val GLOBALS-OPCODE = next(opcode-counter)
val CONSTS-OPCODE = next(opcode-counter)
val CONSTS-DATA-OPCODE = next(opcode-counter)
;2-arity branch operations
val JUMP-INT-LT-OPCODE = next(opcode-counter)
val JUMP-INT-GT-OPCODE = next(opcode-counter)
val JUMP-INT-LE-OPCODE = next(opcode-counter)
val JUMP-INT-GE-OPCODE = next(opcode-counter)
val JUMP-EQ-OPCODE-REF = next(opcode-counter)
val JUMP-EQ-OPCODE-BYTE = next(opcode-counter)
val JUMP-EQ-OPCODE-INT = next(opcode-counter)
val JUMP-EQ-OPCODE-LONG = next(opcode-counter)
val JUMP-EQ-OPCODE-FLOAT = next(opcode-counter)
val JUMP-EQ-OPCODE-DOUBLE = next(opcode-counter)
val JUMP-NE-OPCODE-REF = next(opcode-counter)
val JUMP-NE-OPCODE-BYTE = next(opcode-counter)
val JUMP-NE-OPCODE-INT = next(opcode-counter)
val JUMP-NE-OPCODE-LONG = next(opcode-counter)
val JUMP-NE-OPCODE-FLOAT = next(opcode-counter)
val JUMP-NE-OPCODE-DOUBLE = next(opcode-counter)
val JUMP-LT-OPCODE-INT = next(opcode-counter)
val JUMP-LT-OPCODE-LONG = next(opcode-counter)
val JUMP-LT-OPCODE-FLOAT = next(opcode-counter)
val JUMP-LT-OPCODE-DOUBLE = next(opcode-counter)
val JUMP-GT-OPCODE-INT = next(opcode-counter)
val JUMP-GT-OPCODE-LONG = next(opcode-counter)
val JUMP-GT-OPCODE-FLOAT = next(opcode-counter)
val JUMP-GT-OPCODE-DOUBLE = next(opcode-counter)
val JUMP-LE-OPCODE-INT = next(opcode-counter)
val JUMP-LE-OPCODE-LONG = next(opcode-counter)
val JUMP-LE-OPCODE-FLOAT = next(opcode-counter)
val JUMP-LE-OPCODE-DOUBLE = next(opcode-counter)
val JUMP-GE-OPCODE-INT = next(opcode-counter)
val JUMP-GE-OPCODE-LONG = next(opcode-counter)
val JUMP-GE-OPCODE-FLOAT = next(opcode-counter)
val JUMP-GE-OPCODE-DOUBLE = next(opcode-counter)
val JUMP-ULE-OPCODE-BYTE = next(opcode-counter)
val JUMP-ULE-OPCODE-INT = next(opcode-counter)
val JUMP-ULE-OPCODE-LONG = next(opcode-counter)
val JUMP-ULT-OPCODE-BYTE = next(opcode-counter)
val JUMP-ULT-OPCODE-INT = next(opcode-counter)
val JUMP-ULT-OPCODE-LONG = next(opcode-counter)
val JUMP-UGT-OPCODE-BYTE = next(opcode-counter)
val JUMP-UGT-OPCODE-INT = next(opcode-counter)
val JUMP-UGT-OPCODE-LONG = next(opcode-counter)
val JUMP-UGE-OPCODE-BYTE = next(opcode-counter)
val JUMP-UGE-OPCODE-INT = next(opcode-counter)
val JUMP-UGE-OPCODE-LONG = next(opcode-counter)
;dispatch operation
val DISPATCH-OPCODE = next(opcode-counter)
val DISPATCH-METHOD-OPCODE = next(opcode-counter)
;jump on register
val JUMP-REG-OPCODE = next(opcode-counter)

defn set-reg-opcode (y:VMImm) :
  match(y) :
    (y:Local) : SET-REG-OPCODE-LOCAL
    (y:NumConst) :
      match(value(y)) :
        (v:Char) : SET-REG-OPCODE-UNSIGNED
        (v:Byte) : SET-REG-OPCODE-UNSIGNED
        (v:Int) : SET-REG-OPCODE-UNSIGNED
        (v:Long) : SET-REG-OPCODE-WIDE  ;OR SIGNED
        (v:Float) : SET-REG-OPCODE-UNSIGNED
        (v:Double) : SET-REG-OPCODE-WIDE
    (y:Marker) : SET-REG-OPCODE-UNSIGNED
    (y:Tag) : SET-REG-OPCODE-UNSIGNED
    (y:CodeId) : SET-REG-OPCODE-CODE
    (y:ExternId) : SET-REG-OPCODE-EXTERN
    (y:GlobalId) : SET-REG-OPCODE-GLOBAL
    (y:DataId) : SET-REG-OPCODE-DATA
    (y:ConstId) : SET-REG-OPCODE-CONST
    (y:VoidMarker) : SET-REG-OPCODE-UNSIGNED

defn set-opcode (y:VMImm) :
  match(y) :
    (y:Local) : SET-OPCODE-LOCAL
    (y:NumConst) :
      match(value(y)) :
        (v:Char) : SET-OPCODE-UNSIGNED
        (v:Byte) : SET-OPCODE-UNSIGNED
        (v:Int) : SET-OPCODE-UNSIGNED
        (v:Long) : SET-OPCODE-WIDE  ;OR SIGNED
        (v:Float) : SET-OPCODE-UNSIGNED
        (v:Double) : SET-OPCODE-WIDE
    (y:Marker) : SET-OPCODE-UNSIGNED
    (y:Tag) : SET-OPCODE-UNSIGNED
    (y:CodeId) : SET-OPCODE-CODE
    (y:ExternId) : SET-OPCODE-EXTERN
    (y:GlobalId) : SET-OPCODE-GLOBAL
    (y:DataId) : SET-OPCODE-DATA
    (y:ConstId) : SET-OPCODE-CONST
    (y:VoidMarker) : SET-OPCODE-UNSIGNED

defn call-opcode (f:VMImm) :
  match(f) :
    (f:Local) : CALL-OPCODE-LOCAL
    (f:CodeId) : CALL-OPCODE-CODE
    (f:ExternId) :  CALL-OPCODE-EXTERN

defn callc-opcode (f:VMImm) :
  match(f) :
    (f:Local) : CALLC-OPCODE-LOCAL
    (f:CodeId) : CALLC-OPCODE-CODE
    (f:ExternId) :  CALLC-OPCODE-EXTERN

defn tcall-opcode (f:VMImm) :
  match(f) :
    (f:Local) : TCALL-OPCODE-LOCAL
    (f:CodeId) : TCALL-OPCODE-CODE
    (f:ExternId) :  TCALL-OPCODE-EXTERN

defn store-opcode (offset:VMImm|False, base-type:VMType) :
  match(base-type, offset) :
    (bt:VMRef, offset:VMImm) : STORE-OPCODE-REF-VAR-OFFSET
    (bt:VMRef, offset:False) : STORE-OPCODE-REF
    (bt, offset:VMImm) : STORE-OPCODE-VAR-OFFSET
    (bt, offset:False) : STORE-OPCODE

defn load-opcode (offset:VMImm|False, base-type:VMType) :
  match(base-type, offset) :
    (bt:VMRef, offset:VMImm) : LOAD-OPCODE-REF-VAR-OFFSET
    (bt:VMRef, offset:False) : LOAD-OPCODE-REF
    (bt, offset:VMImm) : LOAD-OPCODE-VAR-OFFSET
    (bt, offset:False) : LOAD-OPCODE

defn op0-opcode (op:VMOp) :
  match(op) :
    (op:CurrentStackOp) : CURRENT-STACK-OPCODE
    (op:FlushVMOp) : FLUSH-VM-OPCODE
    (op:GlobalsOp) : GLOBALS-OPCODE
    (op:ConstsOp) : CONSTS-OPCODE
    (op:ConstsDataOp) : CONSTS-DATA-OPCODE

;Returns false if operation becomes a set operation.
defn op1-opcode (op:VMOp, xt:VMType, yt:VMType) -> Int|False :
  match(op, xt, yt) :
    (op:IntNotOp, xt:VMRef, yt:VMRef) : INT-NOT-OPCODE
    (op:IntNegOp, xt:VMRef, yt:VMRef) : INT-NEG-OPCODE
    (op:NotOp, xt:VMByte, yt:VMByte) : NOT-OPCODE-BYTE
    (op:NotOp, xt:VMInt, yt:VMInt) : NOT-OPCODE-INT
    (op:NotOp, xt:VMLong, yt:VMLong) : NOT-OPCODE-LONG
    (op:NegOp, xt:VMInt, yt:VMInt) : NEG-OPCODE-INT
    (op:NegOp, xt:VMLong, yt:VMLong) : NEG-OPCODE-LONG
    (op:NegOp, xt:VMFloat, yt:VMFloat) : NEG-OPCODE-FLOAT
    (op:NegOp, xt:VMDouble, yt:VMDouble) : NEG-OPCODE-DOUBLE
    (op:InterpretOp, xt, yt) : false
    (op:ConvOp, xt:VMByte, yt:VMByte) : false
    (op:ConvOp, xt:VMByte, yt:VMInt) : false
    (op:ConvOp, xt:VMByte, yt:VMLong) : false
    (op:ConvOp, xt:VMByte, yt:VMFloat) : CONV-OPCODE-BYTE-FLOAT
    (op:ConvOp, xt:VMByte, yt:VMDouble) : CONV-OPCODE-BYTE-DOUBLE
    (op:ConvOp, xt:VMInt, yt:VMByte) : CONV-OPCODE-INT-BYTE
    (op:ConvOp, xt:VMInt, yt:VMInt) : false
    (op:ConvOp, xt:VMInt, yt:VMLong) : false
    (op:ConvOp, xt:VMInt, yt:VMFloat) : CONV-OPCODE-INT-FLOAT
    (op:ConvOp, xt:VMInt, yt:VMDouble) : CONV-OPCODE-INT-DOUBLE
    (op:ConvOp, xt:VMLong, yt:VMByte) : CONV-OPCODE-LONG-BYTE
    (op:ConvOp, xt:VMLong, yt:VMInt) : CONV-OPCODE-LONG-INT
    (op:ConvOp, xt:VMLong, yt:VMLong) : false
    (op:ConvOp, xt:VMLong, yt:VMFloat) : CONV-OPCODE-LONG-FLOAT
    (op:ConvOp, xt:VMLong, yt:VMDouble) : CONV-OPCODE-LONG-DOUBLE
    (op:ConvOp, xt:VMFloat, yt:VMByte) : CONV-OPCODE-FLOAT-BYTE
    (op:ConvOp, xt:VMFloat, yt:VMInt) : CONV-OPCODE-FLOAT-INT
    (op:ConvOp, xt:VMFloat, yt:VMLong) : CONV-OPCODE-FLOAT-LONG
    (op:ConvOp, xt:VMFloat, yt:VMFloat) : false
    (op:ConvOp, xt:VMFloat, yt:VMDouble) : CONV-OPCODE-FLOAT-DOUBLE
    (op:ConvOp, xt:VMDouble, yt:VMByte) : CONV-OPCODE-DOUBLE-BYTE
    (op:ConvOp, xt:VMDouble, yt:VMInt) : CONV-OPCODE-DOUBLE-INT
    (op:ConvOp, xt:VMDouble, yt:VMLong) : CONV-OPCODE-DOUBLE-LONG
    (op:ConvOp, xt:VMDouble, yt:VMFloat) : CONV-OPCODE-DOUBLE-FLOAT
    (op:ConvOp, xt:VMDouble, yt:VMDouble) : false
    (op:TagOp, xt, yt) :
      switch(type(op)) :
        BYTE-TYPE : TAG-OPCODE-BYTE
        CHAR-TYPE : TAG-OPCODE-CHAR
        INT-TYPE : TAG-OPCODE-INT
        FLOAT-TYPE : TAG-OPCODE-FLOAT
    (op:DetagOp, xt, yt) : DETAG-OPCODE
    (op:DerefOp, xt, yt) : DEREF-OPCODE
    (op:GCOp, xt, yt) : GC-OPCODE
    (op:PrintStackTraceOp, xt, yt) : PRINT-STACK-TRACE-OPCODE

defn op2-opcode (op:VMOp, xt:VMType, yt:VMType) :
  match(op, xt, yt) :
    (op:IntAddOp, xt:VMRef, yt:VMRef) : INT-ADD-OPCODE
    (op:IntSubOp, xt:VMRef, yt:VMRef) : INT-SUB-OPCODE
    (op:IntMulOp, xt:VMRef, yt:VMRef) : INT-MUL-OPCODE
    (op:IntDivOp, xt:VMRef, yt:VMRef) : INT-DIV-OPCODE
    (op:IntModOp, xt:VMRef, yt:VMRef) : INT-MOD-OPCODE
    (op:IntAndOp, xt:VMRef, yt:VMRef) : INT-AND-OPCODE
    (op:IntOrOp, xt:VMRef, yt:VMRef) : INT-OR-OPCODE
    (op:IntXorOp, xt:VMRef, yt:VMRef) : INT-XOR-OPCODE
    (op:IntShlOp, xt:VMRef, yt:VMRef) : INT-SHL-OPCODE
    (op:IntShrOp, xt:VMRef, yt:VMRef) : INT-SHR-OPCODE
    (op:IntAshrOp, xt:VMRef, yt:VMRef) : INT-ASHR-OPCODE
    (op:IntLtOp, xt:VMRef, yt:VMRef) : INT-LT-OPCODE
    (op:IntGtOp, xt:VMRef, yt:VMRef) : INT-GT-OPCODE
    (op:IntLeOp, xt:VMRef, yt:VMRef) : INT-LE-OPCODE
    (op:IntGeOp, xt:VMRef, yt:VMRef) : INT-GE-OPCODE
    (op:EqOp, xt:VMRef, yt:VMRef) : EQ-OPCODE-REF-REF
    (op:EqOp, xt:VMLong, yt:VMRef) : EQ-OPCODE-REF
    (op:EqOp, xt:VMLong, yt:VMByte) : EQ-OPCODE-BYTE
    (op:EqOp, xt:VMLong, yt:VMInt) : EQ-OPCODE-INT
    (op:EqOp, xt:VMLong, yt:VMLong) : EQ-OPCODE-LONG
    (op:EqOp, xt:VMLong, yt:VMFloat) : EQ-OPCODE-FLOAT
    (op:EqOp, xt:VMLong, yt:VMDouble) : EQ-OPCODE-DOUBLE
    (op:NeOp, xt:VMRef, yt:VMRef) : NE-OPCODE-REF-REF
    (op:NeOp, xt:VMLong, yt:VMRef) : NE-OPCODE-REF
    (op:NeOp, xt:VMLong, yt:VMByte) : NE-OPCODE-BYTE
    (op:NeOp, xt:VMLong, yt:VMInt) : NE-OPCODE-INT
    (op:NeOp, xt:VMLong, yt:VMLong) : NE-OPCODE-LONG
    (op:NeOp, xt:VMLong, yt:VMFloat) : NE-OPCODE-FLOAT
    (op:NeOp, xt:VMLong, yt:VMDouble) : NE-OPCODE-DOUBLE
    (op:AddOp, xt:VMByte, yt:VMByte) : ADD-OPCODE-BYTE
    (op:AddOp, xt:VMInt, yt:VMInt) : ADD-OPCODE-INT
    (op:AddOp, xt:VMLong, yt:VMLong) : ADD-OPCODE-LONG
    (op:AddOp, xt:VMFloat, yt:VMFloat) : ADD-OPCODE-FLOAT
    (op:AddOp, xt:VMDouble, yt:VMDouble) : ADD-OPCODE-DOUBLE
    (op:SubOp, xt:VMByte, yt:VMByte) : SUB-OPCODE-BYTE
    (op:SubOp, xt:VMInt, yt:VMInt) : SUB-OPCODE-INT
    (op:SubOp, xt:VMLong, yt:VMLong) : SUB-OPCODE-LONG
    (op:SubOp, xt:VMFloat, yt:VMFloat) : SUB-OPCODE-FLOAT
    (op:SubOp, xt:VMDouble, yt:VMDouble) : SUB-OPCODE-DOUBLE
    (op:MulOp, xt:VMByte, yt:VMByte) : MUL-OPCODE-BYTE
    (op:MulOp, xt:VMInt, yt:VMInt) : MUL-OPCODE-INT
    (op:MulOp, xt:VMLong, yt:VMLong) : MUL-OPCODE-LONG
    (op:MulOp, xt:VMFloat, yt:VMFloat) : MUL-OPCODE-FLOAT
    (op:MulOp, xt:VMDouble, yt:VMDouble) : MUL-OPCODE-DOUBLE
    (op:DivOp, xt:VMByte, yt:VMByte) : DIV-OPCODE-BYTE
    (op:DivOp, xt:VMInt, yt:VMInt) : DIV-OPCODE-INT
    (op:DivOp, xt:VMLong, yt:VMLong) : DIV-OPCODE-LONG
    (op:DivOp, xt:VMFloat, yt:VMFloat) : DIV-OPCODE-FLOAT
    (op:DivOp, xt:VMDouble, yt:VMDouble) : DIV-OPCODE-DOUBLE
    (op:ModOp, xt:VMByte, yt:VMByte) : MOD-OPCODE-BYTE
    (op:ModOp, xt:VMInt, yt:VMInt) : MOD-OPCODE-INT
    (op:ModOp, xt:VMLong, yt:VMLong) : MOD-OPCODE-LONG
    (op:AndOp, xt:VMByte, yt:VMByte) : AND-OPCODE-BYTE
    (op:AndOp, xt:VMInt, yt:VMInt) : AND-OPCODE-INT
    (op:AndOp, xt:VMLong, yt:VMLong) : AND-OPCODE-LONG
    (op:OrOp, xt:VMByte, yt:VMByte) : OR-OPCODE-BYTE
    (op:OrOp, xt:VMInt, yt:VMInt) : OR-OPCODE-INT
    (op:OrOp, xt:VMLong, yt:VMLong) : OR-OPCODE-LONG
    (op:XorOp, xt:VMByte, yt:VMByte) : XOR-OPCODE-BYTE
    (op:XorOp, xt:VMInt, yt:VMInt) : XOR-OPCODE-INT
    (op:XorOp, xt:VMLong, yt:VMLong) : XOR-OPCODE-LONG
    (op:ShlOp, xt:VMByte, yt:VMByte) : SHL-OPCODE-BYTE
    (op:ShlOp, xt:VMInt, yt:VMInt) : SHL-OPCODE-INT
    (op:ShlOp, xt:VMLong, yt:VMLong) : SHL-OPCODE-LONG
    (op:ShrOp, xt:VMByte, yt:VMByte) : SHR-OPCODE-BYTE
    (op:ShrOp, xt:VMInt, yt:VMInt) : SHR-OPCODE-INT
    (op:ShrOp, xt:VMLong, yt:VMLong) : SHR-OPCODE-LONG
    (op:AshrOp, xt:VMByte, yt:VMByte) : ASHR-OPCODE-BYTE
    (op:AshrOp, xt:VMInt, yt:VMInt) : ASHR-OPCODE-INT
    (op:AshrOp, xt:VMLong, yt:VMLong) : ASHR-OPCODE-LONG
    (op:LtOp, xt:VMLong, yt:VMInt) : LT-OPCODE-INT
    (op:LtOp, xt:VMLong, yt:VMLong) : LT-OPCODE-LONG
    (op:LtOp, xt:VMLong, yt:VMFloat) : LT-OPCODE-FLOAT
    (op:LtOp, xt:VMLong, yt:VMDouble) : LT-OPCODE-DOUBLE
    (op:GtOp, xt:VMLong, yt:VMInt) : GT-OPCODE-INT
    (op:GtOp, xt:VMLong, yt:VMLong) : GT-OPCODE-LONG
    (op:GtOp, xt:VMLong, yt:VMFloat) : GT-OPCODE-FLOAT
    (op:GtOp, xt:VMLong, yt:VMDouble) : GT-OPCODE-DOUBLE
    (op:LeOp, xt:VMLong, yt:VMInt) : LE-OPCODE-INT
    (op:LeOp, xt:VMLong, yt:VMLong) : LE-OPCODE-LONG
    (op:LeOp, xt:VMLong, yt:VMFloat) : LE-OPCODE-FLOAT
    (op:LeOp, xt:VMLong, yt:VMDouble) : LE-OPCODE-DOUBLE
    (op:GeOp, xt:VMLong, yt:VMInt) : GE-OPCODE-INT
    (op:GeOp, xt:VMLong, yt:VMLong) : GE-OPCODE-LONG
    (op:GeOp, xt:VMLong, yt:VMFloat) : GE-OPCODE-FLOAT
    (op:GeOp, xt:VMLong, yt:VMDouble) : GE-OPCODE-DOUBLE
    (op:UltOp, xt:VMLong, yt:VMByte) : ULT-OPCODE-BYTE
    (op:UltOp, xt:VMLong, yt:VMInt) : ULT-OPCODE-INT
    (op:UltOp, xt:VMLong, yt:VMLong) : ULT-OPCODE-LONG
    (op:UleOp, xt:VMLong, yt:VMByte) : ULE-OPCODE-BYTE
    (op:UleOp, xt:VMLong, yt:VMInt) : ULE-OPCODE-INT
    (op:UleOp, xt:VMLong, yt:VMLong) : ULE-OPCODE-LONG
    (op:UgtOp, xt:VMLong, yt:VMByte) : UGT-OPCODE-BYTE
    (op:UgtOp, xt:VMLong, yt:VMInt) : UGT-OPCODE-INT
    (op:UgtOp, xt:VMLong, yt:VMLong) : UGT-OPCODE-LONG
    (op:UgeOp, xt:VMLong, yt:VMByte) : UGE-OPCODE-BYTE
    (op:UgeOp, xt:VMLong, yt:VMInt) : UGE-OPCODE-INT
    (op:UgeOp, xt:VMLong, yt:VMLong) : UGE-OPCODE-LONG

defn branch2-opcode (op:VMOp, xt:VMType) :
  match(op, xt) :
    (op:IntLtOp, xt:VMRef) : JUMP-INT-LT-OPCODE
    (op:IntGtOp, xt:VMRef) : JUMP-INT-GT-OPCODE
    (op:IntLeOp, xt:VMRef) : JUMP-INT-LE-OPCODE
    (op:IntGeOp, xt:VMRef) : JUMP-INT-GE-OPCODE
    (op:EqOp, xt:VMRef) : JUMP-EQ-OPCODE-REF
    (op:EqOp, xt:VMByte) : JUMP-EQ-OPCODE-BYTE
    (op:EqOp, xt:VMInt) : JUMP-EQ-OPCODE-INT
    (op:EqOp, xt:VMLong) : JUMP-EQ-OPCODE-LONG
    (op:EqOp, xt:VMFloat) : JUMP-EQ-OPCODE-FLOAT
    (op:EqOp, xt:VMDouble) : JUMP-EQ-OPCODE-DOUBLE
    (op:NeOp, xt:VMRef) : JUMP-NE-OPCODE-REF
    (op:NeOp, xt:VMByte) : JUMP-NE-OPCODE-BYTE
    (op:NeOp, xt:VMInt) : JUMP-NE-OPCODE-INT
    (op:NeOp, xt:VMLong) : JUMP-NE-OPCODE-LONG
    (op:NeOp, xt:VMFloat) : JUMP-NE-OPCODE-FLOAT
    (op:NeOp, xt:VMDouble) : JUMP-NE-OPCODE-DOUBLE
    (op:LtOp, xt:VMInt) : JUMP-LT-OPCODE-INT
    (op:LtOp, xt:VMLong) : JUMP-LT-OPCODE-LONG
    (op:LtOp, xt:VMFloat) : JUMP-LT-OPCODE-FLOAT
    (op:LtOp, xt:VMDouble) : JUMP-LT-OPCODE-DOUBLE
    (op:GtOp, xt:VMInt) : JUMP-GT-OPCODE-INT
    (op:GtOp, xt:VMLong) : JUMP-GT-OPCODE-LONG
    (op:GtOp, xt:VMFloat) : JUMP-GT-OPCODE-FLOAT
    (op:GtOp, xt:VMDouble) : JUMP-GT-OPCODE-DOUBLE
    (op:LeOp, xt:VMInt) : JUMP-LE-OPCODE-INT
    (op:LeOp, xt:VMLong) : JUMP-LE-OPCODE-LONG
    (op:LeOp, xt:VMFloat) : JUMP-LE-OPCODE-FLOAT
    (op:LeOp, xt:VMDouble) : JUMP-LE-OPCODE-DOUBLE
    (op:GeOp, xt:VMInt) : JUMP-GE-OPCODE-INT
    (op:GeOp, xt:VMLong) : JUMP-GE-OPCODE-LONG
    (op:GeOp, xt:VMFloat) : JUMP-GE-OPCODE-FLOAT
    (op:GeOp, xt:VMDouble) : JUMP-GE-OPCODE-DOUBLE
    (op:UltOp, xt:VMByte) : JUMP-ULT-OPCODE-BYTE
    (op:UltOp, xt:VMInt) : JUMP-ULT-OPCODE-INT
    (op:UltOp, xt:VMLong) : JUMP-ULT-OPCODE-LONG
    (op:UleOp, xt:VMByte) : JUMP-ULE-OPCODE-BYTE
    (op:UleOp, xt:VMInt) : JUMP-ULE-OPCODE-INT
    (op:UleOp, xt:VMLong) : JUMP-ULE-OPCODE-LONG
    (op:UgtOp, xt:VMByte) : JUMP-UGT-OPCODE-BYTE
    (op:UgtOp, xt:VMInt) : JUMP-UGT-OPCODE-INT
    (op:UgtOp, xt:VMLong) : JUMP-UGT-OPCODE-LONG
    (op:UgeOp, xt:VMByte) : JUMP-UGE-OPCODE-BYTE
    (op:UgeOp, xt:VMInt) : JUMP-UGE-OPCODE-INT
    (op:UgeOp, xt:VMLong) : JUMP-UGE-OPCODE-LONG

;============================================================
;==================== Tag Bits ==============================
;============================================================

public val INT-TAG-BITS = 0
public val REF-TAG-BITS = 1
public val MARKER-TAG-BITS = 2
public val BYTE-TAG-BITS = 3
public val CHAR-TAG-BITS = 4
public val FLOAT-TAG-BITS = 5

defn marker (type:Int) :
  type << 3 + MARKER-TAG-BITS

;============================================================
;====================== Utilities ===========================
;============================================================

var delay : (() -> ?) -> False =
  fn (f) : fatal("Not within delay-actions block.")
defn delay-actions<?T> (f:() -> ?T) :
  val delays = Vector<(() -> ?)>()
  defn delay-action (action:() -> ?)  : add(delays, action)
  val result = let-var delay = delay-action : f()
  for d in delays do : d()
  clear(delays)
  result
    
;============================================================
;====================== Driver ==============================
;============================================================

defn resolve (pkgids:PackageIds, vmp:VMPackage) :
  defn resolve (n:Int) : pkgids[n]
  defn resolve (x:False) : false
  defn resolve<?T> (x:?T&(VMGlobal|VMData|VMConst|VMClass|VMFunction|VMMethod|VMExtern)) :
    map-id(resolve,x) as T&(VMGlobal|VMData|VMConst|VMClass|VMFunction|VMMethod|VMExtern)
  VMPackage(
    packageio(vmp)
    resolve(init(vmp))
    map(resolve,globals(vmp))
    map(resolve,datas(vmp))
    map(resolve,consts(vmp))
    map(resolve,classes(vmp))
    map(resolve,funcs(vmp))
    map(resolve,methods(vmp))
    map(resolve,externs(vmp)))

public defn main () :
  val dummy-resolver = new EncodingResolver :
    defmethod callc-format (this, xtypes:Tuple<False|VMType>, ytypes:Tuple<VMType>) : 42
    defmethod liveness-map (this, live:Tuple<Int>, num-locals:Int) : 42
    defmethod object-header-size (this) : 8
    defmethod stack-size (this) : 4 * 8
    defmethod dispatch-format (this, branches:Tuple<Tuple<TypeSet>>) -> Int : 42
    defmethod match-format (this, branches:Tuple<Tuple<TypeSet>>) -> Int : 42
    defmethod method-format (this, multi:Int, num-header-args:Int) -> Int : 42
    
  val filenames = command-line-arguments()[1 to false]
  val vmpackages = to-tuple $ seq(read-vm-package, filenames)
  val loaded-ids = LoadedIds()
  make-package-ids(loaded-ids, vmpackages)
  var total-size:Int = 0
  for vmp0 in vmpackages do :
    val pkgids = package-ids(loaded-ids, vmp0)
    val vmp = resolve(pkgids, vmp0)
    for f in funcs(vmp) do :
      val f* = encode(f, pkgids, dummy-resolver)
      total-size = total-size + length(buffer(f*))
  println("Total: %_ bytes" % [total-size])

main()