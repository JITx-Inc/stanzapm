defpackage stz/vm-encoder :
  import core
  import collections
  import stz/vm-ir
  import stz/loaded-ids
  import stz/basic-ops

public deftype EncodingResolver
public defmulti callc-format (r:EncodingResolver, xtypes:Tuple<VMType|False>, ytypes:Tuple<VMType>) -> Int
public defmulti liveness-map (r:EncodingResolver, live:Tuple<Int>, num-locals:Int) -> Int
public defmulti object-header-size (r:EncodingResolver) -> Int
public defmulti stack-size (r:EncodingResolver) -> Int
public defmulti dispatch-format (r:EncodingResolver, branches:Tuple<Tuple<TypeSet>>) -> Int
public defmulti match-format (r:EncodingResolver, branches:Tuple<Tuple<TypeSet>>) -> Int
public defmulti method-format (r:EncodingResolver, multi:Int, num-header-args:Int, num-args:Int) -> Int
public defmulti marker (r:EncodingResolver, type:Int) -> Int
public defmulti void-marker (r:EncodingResolver) -> Int
public defmulti ref-offset (r:EncodingResolver) -> Int

public defstruct EncodedFunction :
  buffer: ByteBuffer
  fileinfos: Vector<FileInfoEntry>

public defstruct FileInfoEntry :
  pc: Int
  fileinfo: FileInfo
  
public defn encode (func:VMFunction,
                    pkgids:PackageIds
                    resolver:EncodingResolver) -> EncodedFunction :
  ;Encode instructions into this byte buffer
  val buffer = ByteBuffer()
  defn buffer-pos () : write-position(buffer) / 4

  ;Delay the generation of this instruction
  defn delayed-ins (f:() -> ?, instruction-words:Int) :
    val h = write-position(buffer)
    for i in 0 to instruction-words do :
      put(buffer, -1)
    within delay() :
      val h0 = write-position(buffer)
      set-write-position(buffer, h)
      f()
      val written = write-position(buffer) - h
      val expected = instruction-words * 4
      fatal("Incorrect size.") when written != expected
      set-write-position(buffer, h0)

  ;Accumulate file information entries for implementing
  ;stack traces.
  val fileinfo-table = Vector<FileInfoEntry>()
  defn record-info (info:FileInfo|False) :
    match(info:FileInfo) :
      add(fileinfo-table, FileInfoEntry(buffer-pos(), info))

  ;Instruction formats:
  ;A: [OPCODE | VALUE]
  ;   [  8    |  24  ]
  ;B: [OPCODE | X  | VALUE]
  ;   [  8    | 10 |  14  ]
  ;C: [OPCODE | X  | Y  | VALUE]
  ;   [  8    | 14 | 10 |   32 ]
  ;D: [OPCODE | X  | Y ] + VALUE
  ;   [  8    | 14 | 10] +   64
  ;E: [OPCODE | X  | Y  |   Z   | CONST ]
  ;   [  8    | 10 | 10 | 4 + 6 |   26  ]
  ;F: [OPCODE | X  | Y  |    N1  | N2]
  ;   [  8    | 10 | 10 | 4 + 14 | 18]
  defn emit-ins-a (opcode:Int, value:Int) :
    ;println("A: [%_ | %_]" % [opcode, value])
    put(buffer, opcode | (value << 8))
  defn emit-ins-b (opcode:Int, x:Int, value:Int) :    
    ;println("B: [%_ | %_ | %_]" % [opcode, x, value])
    put(buffer, opcode | (x << 8) | (value << 18))
  defn emit-ins-c (opcode:Int, x:Int, value:Int) :
    ;println("C: [%_ | _ | %_ | %_]" % [opcode, x, value])
    put(buffer, opcode | (x << 22))
    put(buffer, value)
  defn emit-ins-c (opcode:Int, x:Int, y:Int, value:Int) :
    ;println("C: [%_ | %_ | %_ | %_]" % [opcode, x, y, value])
    put(buffer, opcode | (x << 8) | (y << 22))
    put(buffer, value)    
  defn emit-ins-d (opcode:Int, x:Int, value:Long) :
    ;println("D: [%_ | _ | %_] + %~" % [opcode, x, value])
    put(buffer, opcode | (x << 22))
    put(buffer, value)
  defn emit-ins-e (opcode:Int, x:Int, y:Int, z:Int, const:Int) :
    ;println("E: [%_ | %_ | %_ | %_ | %_]" % [opcode, x, y, z, const])
    put(buffer, opcode | (x << 8) | (y << 18) | (z << 28))
    put(buffer, (z >> 4) | (const << 6))
  defn emit-ins-f (opcode:Int, x:Int, y:Int, n1:Int, n2:Int) :
    ;println("F: [%_ | %_ | %_ | %_ | %_]" % [opcode, x, y, n1, n2])
    put(buffer, opcode | (x << 8) | (y << 18) | (n1 << 28))
    put(buffer, ((n1 & 0x3FFFF) >> 4) | (n2 << 14))
  defn emit-ins-targets (dests:Tuple<Int>) :
    put(buffer, length(dests))
    for d in dests do : put(buffer, d)

  ;Calculation of sizes
  defn object-size (num-obj:Int, size:Int) :
    num-obj * object-header-size(resolver) + size
  defn stack-size () :
    object-size(1, /stack-size(resolver))

  ;Retrieve the corresponding bits for the given immediate
  defn to-bits (y:VMImm) -> Int|Long :
    match(y) :
      (y:Local) : index(y)
      (y:NumConst) :
        match(value(y)) :
          (v:Char) : to-int(v)
          (v:Byte) : to-int(v)
          (v:Int) : v
          (v:Long) : v
          (v:Float) : bits(v)
          (v:Double) : bits(v)
      (y:Marker) : marker(resolver, typeid(y))
      (y:Tag) : typeid(y)
      (y:VoidMarker) : void-marker(resolver)
      (y:CodeId) : id(y)
      (y:ExternId) : id(y)
      (y:ExternDefnId) : id(y)
      (y:GlobalId) : id(y)
      (y:DataId) : id(y)
      (y:ConstId) : id(y)

  ;Split a tuple of VMBranch into typesets and destinations
  defn split-types-and-dests (bs:Tuple<VMBranch>) -> [Tuple<Tuple<TypeSet>>, Tuple<Int>] :
    val types = for b in bs map :
      map(normalize, types(b))
    val targets = map(n, bs)
    [types, targets]

  ;Set register
  defn set-reg (i:Int, y:VMImm) :
    match(to-bits(y)) :
      (v:Int) : emit-ins-c(set-reg-opcode(y), i, v)
      (v:Long) : emit-ins-d(set-reg-opcode(y), i, v)    
  defn set-regs (ys:Seqable<VMImm>) :
    do(set-reg, 0 to false, ys)
  defn get-reg (x:Local|False, i:Int) :
    match(x:Local) :
      emit-ins-b(GET-REG-OPCODE, index(x), i)
  defn get-regs (xs:Seqable<Local|False>) :
    do(get-reg, xs, 0 to false)

  ;Set local
  defn set-local (x:Int, y:VMImm) :
    match(to-bits(y)) :
      (v:Int) : emit-ins-c(set-opcode(y), x, v)
      (v:Long) : emit-ins-d(set-opcode(y), x, v)

  ;Encode multivarity functions
  defn encode (multi:VMMultifn) :
    ;Declare function positions
    var func-positions
    ;Emit branch instructions
    for (entry in funcs(multi), i in 0 to false) do :
      val arity = key(entry)      
      within delayed-ins(2) :
        val offset = func-positions[i] - buffer-pos()
        emit-ins-c(JUMP-REG-OPCODE, arg(multi), arity, offset)
    ;Emit default branch
    encode(default(multi))
    ;Emit other branches, and compute their positions
    func-positions = for entry in funcs(multi) map :
      val fpos = buffer-pos()
      encode(value(entry))
      fpos

  ;Encode function instructions
  defn encode (func:VMFunc) :
    ;Compute num locals
    ;Reserve extra 3 locals for temporary moving
    val max-local = maximum(-1, seq(local, defs(func)))
    val num-locals = max-local + 1 + 3

    ;Put immediate in temporary local if not a local
    defn to-local (x:VMImm, num:Int) :
      match(x:Local) :
        index(x)
      else :
        val index = max-local + num + 1
        set-local(index, x)
        index

    ;Put immediate in register if not a function immediate
    defn to-function (f:VMImm) :
      match(f) :
        (f:Local) : index(f)
        (f:CodeId) : id(f)
        (f:ExternId) : id(f)
        (f) : to-local(f, 0)

    ;Create mapping from local ID to slot
    val deftable = to-inttable<VMDef> $
      for def in defs(func) seq :
        id(def) => def

    ;Use deftable to retrieve the type of an immediate
    defn imm-type (x:VMImm) :
      match(x:Local) : type(deftable[index(x)])
      else : type(x)
    defn imm-type (x:False) :
      x

    ;Create mapping from label ID to position
    val label-table = IntTable<Int>()
    defn jump-offset (n:Int) :
      label-table[n] - buffer-pos()
    defn jump-offsets (xs:Seqable<Int>) :
      to-tuple(seq(jump-offset, xs))
    defn jump-offsets (xs:Seqable<Int>, ys:Seqable<Int>) :
      jump-offsets(cat(xs,ys))

    ;Resolve an instruction
    defn sub-slot (x:Local) : Local(local(deftable[index(x)]))
    defn sub-slot (x:False) : false
    defn resolve-ins<?T> (ins:VMIns&?T) -> T :
      defn sub-id (n:Int) : pkgids[n]      
      map({_}, sub-slot, sub-id, ins)

    ;Enter function
    emit-ins-a(FNENTRY-OPCODE, num-locals)

    ;Retrieve arguments
    get-regs(seq(sub-slot, args(func)))
    
    ;Encode each instruction 
    for ins0 in ins(func) do :
      match(resolve-ins(ins0)) :
        (ins:LabelIns) :
          label-table[n(ins)] = buffer-pos()
        (ins:UnreachableIns) :
          false
        (ins:TCallIns) :
          set-regs(ys(ins))
          emit-ins-c(tcall-opcode(f(ins)), 0, to-function(f(ins)))
        (ins:TCallClosureIns) :
          set-regs(ys(ins))
          emit-ins-a(TCALL-CLOSURE-OPCODE, to-local(f(ins), 0))
        (ins:CallIns) : 
          set-regs(ys(ins))
          emit-ins-c(call-opcode(f(ins)), num-locals, to-function(f(ins)))
          record-info(info(ins))
          emit-ins-a(POP-FRAME-OPCODE, num-locals)
          get-regs(xs(ins))
        (ins:CallClosureIns) : 
          set-regs(ys(ins))
          emit-ins-c(CALL-CLOSURE-OPCODE, num-locals, to-local(f(ins), 0))
          record-info(info(ins))
          emit-ins-a(POP-FRAME-OPCODE, num-locals)
          get-regs(xs(ins))
        (ins:CallCIns) :
          val ins0 = ins0 as CallCIns
          val format = callc-format(resolver, xtypes, ytypes) where :
            val xtypes = map(imm-type,xs(ins0))
            val ytypes = map(imm-type,ys(ins0))
          set-regs(ys(ins))
          emit-ins-c(callc-opcode(f(ins)), format, num-locals, to-function(f(ins)))
          record-info(info(ins))
          get-regs(xs(ins))          
        (ins:YieldIns) : 
          set-regs(ys(ins))
          emit-ins-a(YIELD-OPCODE, to-local(f(ins), 0))
          record-info(info(ins))
          get-regs(xs(ins))
        (ins:ReturnIns) : 
          set-regs(xs(ins))
          emit-ins-a(RETURN-OPCODE, 0)
        (ins:DumpIns) :
          for x in xs(ins) do :
            emit-ins-a(DUMP-OPCODE, index(x))
        (ins:RecordLiveIns) : 
          val live-map = liveness-map(resolver, map(index, live(ins)), num-locals)
          emit-ins-a(LIVE-OPCODE, live-map)
        (ins:StoreIns) :          
          val ins0 = ins0 as StoreIns
          val code = store-opcode(y(ins0), imm-type(z(ins0)))
          val offset* = match(imm-type(x(ins0))) :
            (xt:VMRef) : offset(ins) - ref-offset(resolver) + object-header-size(resolver)
            (xt) : offset(ins)
          val x* = to-local(x(ins),0)
          val z* = to-local(z(ins),1)
          val y* = match(y(ins)) :
            (y:VMImm) : to-local(y,2)
            (y:False) : 0
          emit-ins-e(code, x*, y*, z*, offset*)
        (ins:LoadIns) :
          val ins0 = ins0 as LoadIns
          val code = load-opcode(z(ins0), imm-type(x(ins0)))
          val offset* = match(imm-type(y(ins0))) :
            (yt:VMRef) : offset(ins) - ref-offset(resolver) + object-header-size(resolver)
            (yt) : offset(ins)
          val y* = to-local(y(ins),0)
          val z* = match(z(ins)) :
            (z:VMImm) : to-local(z,1)
            (z:False) : 0
          emit-ins-e(code, index(x(ins)), y*, z*, offset*)
        (ins:Op0Ins) :
          val code = op0-opcode(op(ins))
          emit-ins-a(code, index(x(ins)))
        (ins:Op1Ins) :
          val ins0 = ins0 as Op1Ins
          match(op(ins)) :
            (op:InstanceofOp) :
              ;Push argument into register
              set-reg(0, y(ins))
              ;Retrieve format
              val format = match-format(resolver, [[normalize(type(op))]])
              ;Emit typeof instruction
              emit-ins-c(TYPEOF-OPCODE, index(x(ins)), format)
            (op) :
              val opcode = op1-opcode(op, imm-type(x(ins0)), imm-type(y(ins0)))
              match(opcode:Int) :
                val x* = index(x(ins))
                val y* = to-local(y(ins), 0)
                emit-ins-b(opcode, x*, y*)
              else :
                set-local(index(x(ins)), y(ins))
        (ins:Op2Ins) :
          val ins0 = ins0 as Op2Ins
          val opcode = op2-opcode(op(ins), imm-type(x(ins0)), imm-type(y(ins0)))
          val x* = index(x(ins))
          val y* = to-local(y(ins), 0)
          val z* = to-local(z(ins), 1)
          emit-ins-c(opcode, x*, y*, z*)
        (ins:GotoIns) :
          within delayed-ins(1) :            
            emit-ins-a(GOTO-OPCODE, jump-offset(n(ins)))
        (ins:Branch1Ins) :
          match(op(ins)) :
            (op:InstanceofOp) :
              ;Push argument into register
              set-reg(0, x(ins))
              ;Retrieve format
              val format = match-format(resolver, [[normalize(type(op))]])
              ;Emit dispatch instruction
              ;Two targets, match success and default
              val num-targets = 2
              within delayed-ins(1 + 1 + num-targets) :
                val targets = jump-offsets([n2(ins), n1(ins)])
                emit-ins-a(DISPATCH-OPCODE, format)
                emit-ins-targets(targets)
            (op:False) :
              val x* = to-local(x(ins), 0)
              within delayed-ins(2) :
                emit-ins-f(JUMP-SET-OPCODE, x*, 0, jump-offset(n1(ins)), jump-offset(n2(ins)))
        (ins:Branch2Ins) :
          val ins0 = ins0 as Branch2Ins
          val code = branch2-opcode(op(ins), imm-type(x(ins0)))
          val x* = to-local(x(ins), 0)
          val y* = to-local(y(ins), 1)
          within delayed-ins(2) :
            emit-ins-f(code, x*, y*, jump-offset(n1(ins)), jump-offset(n2(ins)))
        (ins:NewStackIns) :
          emit-ins-c(RESERVE-OPCODE-CONST, 3, num-locals, stack-size())
          record-info(info(ins))
          emit-ins-a(POP-FRAME-OPCODE, num-locals)
          emit-ins-b(NEW-STACK-OPCODE, index(x(ins)), to-local(fid(ins),0))
        (ins:AllocIns) :
          if all?({_ is NumConst}, sizes(ins)) :
            val num-obj = length(sizes(ins))
            val obj-sizes = for s in sizes(ins) map :
              val sz = value(s as NumConst) as Int
              max(sz, 8) ;Minimum size is 8
            val sum-of-sizes = object-size(num-obj, sum(obj-sizes))
            emit-ins-c(RESERVE-OPCODE-CONST, 3, num-locals, sum-of-sizes)
            record-info(info(ins))
            emit-ins-a(POP-FRAME-OPCODE, num-locals)
            for (x in xs(ins), t in types(ins), sz in obj-sizes) do :
              emit-ins-c(ALLOC-OPCODE-CONST, index(x), sz, t)
          else :
            fatal("Multiple variable-sized allocations.") when length(sizes(ins)) > 1
            val x = xs(ins)[0]
            val type = types(ins)[0]
            val size = to-local(sizes(ins)[0], 0)
            emit-ins-c(RESERVE-OPCODE-LOCAL, 3, num-locals, size)
            record-info(info(ins))
            emit-ins-a(POP-FRAME-OPCODE, num-locals)
            emit-ins-c(ALLOC-OPCODE-LOCAL, index(x), size, type)
        (ins:DispatchIns) :
          ;Push arguments onto registers
          set-regs(ys(ins))
          val [types, dests] = split-types-and-dests(branches(ins))
          val format = dispatch-format(resolver, types)          
          ;Two targets for default and amb and then each branch for dispatch.
          val num-targets = 2 + length(branches(ins))
          within delayed-ins(1 + 1 + num-targets) :
            val targets = jump-offsets([default(ins), amb(ins)], dests)
            emit-ins-a(DISPATCH-OPCODE, format)            
            emit-ins-targets(targets)
        (ins:MatchIns) :
          ;Push arguments onto registers
          set-regs(ys(ins))
          val [types, dests] = split-types-and-dests(branches(ins))
          val format = match-format(resolver, types)
          ;One target for default and then each branch for dispatch.
          val num-targets = 1 + length(branches(ins))
          within delayed-ins(1 + 1 + num-targets) :
            val targets = jump-offsets([default(ins)], dests)
            emit-ins-a(DISPATCH-OPCODE, format)            
            emit-ins-targets(targets)
        (ins:MethodDispatchIns) :
          ;Push arguments onto registers
          set-regs(cat(ys(ins), zs(ins)))
          ;Retrieve format
          val format = method-format(resolver, multi(ins), length(ys(ins)), length(zs(ins)))
          ;Only two targets for default and amb
          val num-targets = 2
          within delayed-ins(1 + 1 + num-targets) :
            val targets = jump-offsets([default(ins), amb(ins)])
            emit-ins-a(DISPATCH-METHOD-OPCODE, format)
            emit-ins-targets(targets)
        (ins:SetIns) :
          set-local(index(x(ins)), y(ins))

  ;Use delayed actions and encode instructions
  ;println("ENCODING")
  ;println(func)
  within delay-actions() :
    encode(func as VMMultifn|VMFunc)
  EncodedFunction(buffer, fileinfo-table)

;============================================================
;======================= Opcodes ============================
;============================================================

val SET-OPCODE-LOCAL = 0
val SET-OPCODE-UNSIGNED = 1
val SET-OPCODE-SIGNED = 2
val SET-OPCODE-CODE = 3
val SET-OPCODE-EXTERN = 4
val SET-OPCODE-EXTERN-DEFN = 21
val SET-OPCODE-GLOBAL = 5
val SET-OPCODE-DATA = 6
val SET-OPCODE-CONST = 7
val SET-OPCODE-WIDE = 8
val SET-REG-OPCODE-LOCAL = 9
val SET-REG-OPCODE-UNSIGNED = 10
val SET-REG-OPCODE-SIGNED = 11
val SET-REG-OPCODE-CODE = 12
val SET-REG-OPCODE-EXTERN = 13
val SET-REG-OPCODE-EXTERN-DEFN = 25
val SET-REG-OPCODE-GLOBAL = 14
val SET-REG-OPCODE-DATA = 15
val SET-REG-OPCODE-CONST = 16
val SET-REG-OPCODE-WIDE = 17
val GET-REG-OPCODE = 18
val CALL-OPCODE-LOCAL = 19
val CALL-OPCODE-CODE = 20
val CALL-CLOSURE-OPCODE = 22
val TCALL-OPCODE-LOCAL = 23
val TCALL-OPCODE-CODE = 24
val TCALL-CLOSURE-OPCODE = 26
val CALLC-OPCODE-LOCAL = 27
val CALLC-OPCODE-EXTERN = 29
val CALLC-OPCODE-EXTERN-DEFN = 28
val POP-FRAME-OPCODE = 30
val LIVE-OPCODE = 31
val YIELD-OPCODE = 32
val RETURN-OPCODE = 33
val DUMP-OPCODE = 34
;2-arity operations
val INT-ADD-OPCODE = 35
val INT-SUB-OPCODE = 36
val INT-MUL-OPCODE = 37
val INT-DIV-OPCODE = 38
val INT-MOD-OPCODE = 39
val INT-AND-OPCODE = 40
val INT-OR-OPCODE = 41
val INT-XOR-OPCODE = 42
val INT-SHL-OPCODE = 43
val INT-SHR-OPCODE = 44
val INT-ASHR-OPCODE = 45
val INT-LT-OPCODE = 46
val INT-GT-OPCODE = 47
val INT-LE-OPCODE = 48
val INT-GE-OPCODE = 49
val EQ-OPCODE-REF-REF = 50
val EQ-OPCODE-REF = 51
val EQ-OPCODE-BYTE = 52
val EQ-OPCODE-INT = 53
val EQ-OPCODE-LONG = 54
val EQ-OPCODE-FLOAT = 55
val EQ-OPCODE-DOUBLE = 56
val NE-OPCODE-REF-REF = 57
val NE-OPCODE-REF = 58
val NE-OPCODE-BYTE = 59
val NE-OPCODE-INT = 60
val NE-OPCODE-LONG = 61
val NE-OPCODE-FLOAT = 62
val NE-OPCODE-DOUBLE = 63
val ADD-OPCODE-BYTE = 64
val ADD-OPCODE-INT = 65
val ADD-OPCODE-LONG = 66
val ADD-OPCODE-FLOAT = 67
val ADD-OPCODE-DOUBLE = 68
val SUB-OPCODE-BYTE = 69
val SUB-OPCODE-INT = 70
val SUB-OPCODE-LONG = 71
val SUB-OPCODE-FLOAT = 72
val SUB-OPCODE-DOUBLE = 73
val MUL-OPCODE-BYTE = 74
val MUL-OPCODE-INT = 75
val MUL-OPCODE-LONG = 76
val MUL-OPCODE-FLOAT = 77
val MUL-OPCODE-DOUBLE = 78
val DIV-OPCODE-BYTE = 79
val DIV-OPCODE-INT = 80
val DIV-OPCODE-LONG = 81
val DIV-OPCODE-FLOAT = 82
val DIV-OPCODE-DOUBLE = 83
val MOD-OPCODE-BYTE = 84
val MOD-OPCODE-INT = 85
val MOD-OPCODE-LONG = 86
val AND-OPCODE-BYTE = 87
val AND-OPCODE-INT = 88
val AND-OPCODE-LONG = 89
val OR-OPCODE-BYTE = 90
val OR-OPCODE-INT = 91
val OR-OPCODE-LONG = 92
val XOR-OPCODE-BYTE = 93
val XOR-OPCODE-INT = 94
val XOR-OPCODE-LONG = 95
val SHL-OPCODE-BYTE = 96
val SHL-OPCODE-INT = 97
val SHL-OPCODE-LONG = 98
val SHR-OPCODE-BYTE = 99
val SHR-OPCODE-INT = 100
val SHR-OPCODE-LONG = 101
val ASHR-OPCODE-INT = 103
val ASHR-OPCODE-LONG = 104
val LT-OPCODE-INT = 105
val LT-OPCODE-LONG = 106
val LT-OPCODE-FLOAT = 107
val LT-OPCODE-DOUBLE = 108
val GT-OPCODE-INT = 109
val GT-OPCODE-LONG = 110
val GT-OPCODE-FLOAT = 111
val GT-OPCODE-DOUBLE = 112
val LE-OPCODE-INT = 113
val LE-OPCODE-LONG = 114
val LE-OPCODE-FLOAT = 115
val LE-OPCODE-DOUBLE = 116
val GE-OPCODE-INT = 117
val GE-OPCODE-LONG = 118
val GE-OPCODE-FLOAT = 119
val GE-OPCODE-DOUBLE = 120
val ULE-OPCODE-BYTE = 121
val ULE-OPCODE-INT = 122
val ULE-OPCODE-LONG = 123
val ULT-OPCODE-BYTE = 124
val ULT-OPCODE-INT = 125
val ULT-OPCODE-LONG = 126
val UGT-OPCODE-BYTE = 127
val UGT-OPCODE-INT = 128
val UGT-OPCODE-LONG = 129
val UGE-OPCODE-BYTE = 130
val UGE-OPCODE-INT = 131
val UGE-OPCODE-LONG = 132
;1-arity operations
val INT-NOT-OPCODE = 133
val INT-NEG-OPCODE = 134
val NOT-OPCODE-BYTE = 135
val NOT-OPCODE-INT = 136
val NOT-OPCODE-LONG = 137
val NEG-OPCODE-INT = 138
val NEG-OPCODE-LONG = 139
val NEG-OPCODE-FLOAT = 140
val NEG-OPCODE-DOUBLE = 141
val DEREF-OPCODE = 142
val TYPEOF-OPCODE = 143
;branch operation
val JUMP-SET-OPCODE = 144
val GOTO-OPCODE = 145
;conversion operations
val CONV-OPCODE-BYTE-FLOAT = 146
val CONV-OPCODE-BYTE-DOUBLE = 147
val CONV-OPCODE-INT-BYTE = 148
val CONV-OPCODE-INT-FLOAT = 149
val CONV-OPCODE-INT-DOUBLE = 150
val CONV-OPCODE-LONG-BYTE = 151
val CONV-OPCODE-LONG-INT = 152
val CONV-OPCODE-LONG-FLOAT = 153
val CONV-OPCODE-LONG-DOUBLE = 154
val CONV-OPCODE-FLOAT-BYTE = 155
val CONV-OPCODE-FLOAT-INT = 156
val CONV-OPCODE-FLOAT-LONG = 157
val CONV-OPCODE-FLOAT-DOUBLE = 158
val CONV-OPCODE-DOUBLE-BYTE = 159
val CONV-OPCODE-DOUBLE-INT = 160
val CONV-OPCODE-DOUBLE-LONG = 161
val CONV-OPCODE-DOUBLE-FLOAT = 162
;tagging operations
val DETAG-OPCODE = 163
val TAG-OPCODE-BYTE = 164
val TAG-OPCODE-CHAR = 165
val TAG-OPCODE-INT = 166
val TAG-OPCODE-FLOAT = 167
;storing operations
val STORE-OPCODE-1 = 168
val STORE-OPCODE-4 = 169
val STORE-OPCODE-8 = 170
val STORE-OPCODE-1-VAR-OFFSET = 171
val STORE-OPCODE-4-VAR-OFFSET = 172
val STORE-OPCODE-8-VAR-OFFSET = 173
;loading operations
val LOAD-OPCODE-1 = 174
val LOAD-OPCODE-4 = 175
val LOAD-OPCODE-8 = 176
val LOAD-OPCODE-1-VAR-OFFSET = 177
val LOAD-OPCODE-4-VAR-OFFSET = 178
val LOAD-OPCODE-8-VAR-OFFSET = 179
;Allocation
val RESERVE-OPCODE-LOCAL = 180
val RESERVE-OPCODE-CONST = 181
val NEW-STACK-OPCODE = 182
val ALLOC-OPCODE-CONST = 183
val ALLOC-OPCODE-LOCAL = 184
;system operations
val GC-OPCODE = 185
val PRINT-STACK-TRACE-OPCODE = 186
val CURRENT-STACK-OPCODE = 187
val FLUSH-VM-OPCODE = 188
val CONSTS-OPCODE = 190
val CONSTS-DATA-OPCODE = 191
;2-arity branch operations
val JUMP-INT-LT-OPCODE = 192
val JUMP-INT-GT-OPCODE = 193
val JUMP-INT-LE-OPCODE = 194
val JUMP-INT-GE-OPCODE = 195
val JUMP-EQ-OPCODE-REF = 196
val JUMP-EQ-OPCODE-BYTE = 197
val JUMP-EQ-OPCODE-INT = 198
val JUMP-EQ-OPCODE-LONG = 199
val JUMP-EQ-OPCODE-FLOAT = 200
val JUMP-EQ-OPCODE-DOUBLE = 201
val JUMP-NE-OPCODE-REF = 202
val JUMP-NE-OPCODE-BYTE = 203
val JUMP-NE-OPCODE-INT = 204
val JUMP-NE-OPCODE-LONG = 205
val JUMP-NE-OPCODE-FLOAT = 206
val JUMP-NE-OPCODE-DOUBLE = 207
val JUMP-LT-OPCODE-INT = 208
val JUMP-LT-OPCODE-LONG = 209
val JUMP-LT-OPCODE-FLOAT = 210
val JUMP-LT-OPCODE-DOUBLE = 211
val JUMP-GT-OPCODE-INT = 212
val JUMP-GT-OPCODE-LONG = 213
val JUMP-GT-OPCODE-FLOAT = 214
val JUMP-GT-OPCODE-DOUBLE = 215
val JUMP-LE-OPCODE-INT = 216
val JUMP-LE-OPCODE-LONG = 217
val JUMP-LE-OPCODE-FLOAT = 218
val JUMP-LE-OPCODE-DOUBLE = 219
val JUMP-GE-OPCODE-INT = 220
val JUMP-GE-OPCODE-LONG = 221
val JUMP-GE-OPCODE-FLOAT = 222
val JUMP-GE-OPCODE-DOUBLE = 223
val JUMP-ULE-OPCODE-BYTE = 224
val JUMP-ULE-OPCODE-INT = 225
val JUMP-ULE-OPCODE-LONG = 226
val JUMP-ULT-OPCODE-BYTE = 227
val JUMP-ULT-OPCODE-INT = 228
val JUMP-ULT-OPCODE-LONG = 229
val JUMP-UGT-OPCODE-BYTE = 230
val JUMP-UGT-OPCODE-INT = 231
val JUMP-UGT-OPCODE-LONG = 232
val JUMP-UGE-OPCODE-BYTE = 233
val JUMP-UGE-OPCODE-INT = 234
val JUMP-UGE-OPCODE-LONG = 235
;dispatch operation
val DISPATCH-OPCODE = 236
val DISPATCH-METHOD-OPCODE = 237
;jump on register
val JUMP-REG-OPCODE = 238
;function entry
val FNENTRY-OPCODE = 239

defn set-reg-opcode (y:VMImm) :
  match(y) :
    (y:Local) : SET-REG-OPCODE-LOCAL
    (y:NumConst) :
      match(value(y)) :
        (v:Char) : SET-REG-OPCODE-UNSIGNED
        (v:Byte) : SET-REG-OPCODE-UNSIGNED
        (v:Int) : SET-REG-OPCODE-UNSIGNED
        (v:Long) : SET-REG-OPCODE-WIDE  ;OR SIGNED
        (v:Float) : SET-REG-OPCODE-UNSIGNED
        (v:Double) : SET-REG-OPCODE-WIDE
    (y:Marker) : SET-REG-OPCODE-UNSIGNED
    (y:Tag) : SET-REG-OPCODE-UNSIGNED
    (y:CodeId) : SET-REG-OPCODE-CODE
    (y:ExternId) : SET-REG-OPCODE-EXTERN
    (y:ExternDefnId) : SET-REG-OPCODE-EXTERN-DEFN
    (y:GlobalId) : SET-REG-OPCODE-GLOBAL
    (y:DataId) : SET-REG-OPCODE-DATA
    (y:ConstId) : SET-REG-OPCODE-CONST
    (y:VoidMarker) : SET-REG-OPCODE-UNSIGNED

defn set-opcode (y:VMImm) :
  match(y) :
    (y:Local) : SET-OPCODE-LOCAL
    (y:NumConst) :
      match(value(y)) :
        (v:Char) : SET-OPCODE-UNSIGNED
        (v:Byte) : SET-OPCODE-UNSIGNED
        (v:Int) : SET-OPCODE-UNSIGNED
        (v:Long) : SET-OPCODE-WIDE  ;OR SIGNED
        (v:Float) : SET-OPCODE-UNSIGNED
        (v:Double) : SET-OPCODE-WIDE
    (y:Marker) : SET-OPCODE-UNSIGNED
    (y:Tag) : SET-OPCODE-UNSIGNED
    (y:CodeId) : SET-OPCODE-CODE
    (y:ExternId) : SET-OPCODE-EXTERN
    (y:ExternDefnId) : SET-OPCODE-EXTERN-DEFN
    (y:GlobalId) : SET-OPCODE-GLOBAL
    (y:DataId) : SET-OPCODE-DATA
    (y:ConstId) : SET-OPCODE-CONST
    (y:VoidMarker) : SET-OPCODE-UNSIGNED

defn call-opcode (f:VMImm) :
  match(f) :
    (f:Local) : CALL-OPCODE-LOCAL
    (f:CodeId) : CALL-OPCODE-CODE

defn callc-opcode (f:VMImm) :
  match(f) :
    (f:Local) : CALLC-OPCODE-LOCAL
    (f:ExternId) :  CALLC-OPCODE-EXTERN
    (f:ExternDefnId) :  CALLC-OPCODE-EXTERN-DEFN

defn tcall-opcode (f:VMImm) :
  match(f) :
    (f:Local) : TCALL-OPCODE-LOCAL
    (f:CodeId) : TCALL-OPCODE-CODE

defn store-opcode (offset:VMImm|False, val-type:VMType) :
  match(offset, val-type) :
    (o:False, vt:VMByte) : STORE-OPCODE-1
    (o:False, vt:VMInt) : STORE-OPCODE-4
    (o:False, vt:VMLong) : STORE-OPCODE-8
    (o:False, vt:VMFloat) : STORE-OPCODE-4
    (o:False, vt:VMDouble) : STORE-OPCODE-8
    (o:False, vt:VMRef) : STORE-OPCODE-8
    (o:VMImm, vt:VMByte) : STORE-OPCODE-1-VAR-OFFSET
    (o:VMImm, vt:VMInt) : STORE-OPCODE-4-VAR-OFFSET
    (o:VMImm, vt:VMLong) : STORE-OPCODE-8-VAR-OFFSET
    (o:VMImm, vt:VMFloat) : STORE-OPCODE-4-VAR-OFFSET
    (o:VMImm, vt:VMDouble) : STORE-OPCODE-8-VAR-OFFSET
    (o:VMImm, vt:VMRef) : STORE-OPCODE-8-VAR-OFFSET

defn load-opcode (offset:VMImm|False, xtype:VMType) :
  match(offset, xtype) :
    (o:False, xt:VMByte) : LOAD-OPCODE-1
    (o:False, xt:VMInt) : LOAD-OPCODE-4
    (o:False, xt:VMLong) : LOAD-OPCODE-8
    (o:False, xt:VMFloat) : LOAD-OPCODE-4
    (o:False, xt:VMDouble) : LOAD-OPCODE-8
    (o:False, xt:VMRef) : LOAD-OPCODE-8
    (o:VMImm, xt:VMByte) : LOAD-OPCODE-1-VAR-OFFSET
    (o:VMImm, xt:VMInt) : LOAD-OPCODE-4-VAR-OFFSET
    (o:VMImm, xt:VMLong) : LOAD-OPCODE-8-VAR-OFFSET
    (o:VMImm, xt:VMFloat) : LOAD-OPCODE-4-VAR-OFFSET
    (o:VMImm, xt:VMDouble) : LOAD-OPCODE-8-VAR-OFFSET
    (o:VMImm, xt:VMRef) : LOAD-OPCODE-8-VAR-OFFSET

defn op0-opcode (op:VMOp) :
  match(op) :
    (op:CurrentStackOp) : CURRENT-STACK-OPCODE
    (op:FlushVMOp) : FLUSH-VM-OPCODE
    (op:ConstsOp) : CONSTS-OPCODE
    (op:ConstsDataOp) : CONSTS-DATA-OPCODE

;Returns false if operation becomes a set operation.
defn op1-opcode (op:VMOp, xt:VMType, yt:VMType) -> Int|False :
  match(op, xt, yt) :
    (op:IntNotOp, xt:VMRef, yt:VMRef) : INT-NOT-OPCODE
    (op:IntNegOp, xt:VMRef, yt:VMRef) : INT-NEG-OPCODE
    (op:NotOp, xt:VMByte, yt:VMByte) : NOT-OPCODE-BYTE
    (op:NotOp, xt:VMInt, yt:VMInt) : NOT-OPCODE-INT
    (op:NotOp, xt:VMLong, yt:VMLong) : NOT-OPCODE-LONG
    (op:NegOp, xt:VMInt, yt:VMInt) : NEG-OPCODE-INT
    (op:NegOp, xt:VMLong, yt:VMLong) : NEG-OPCODE-LONG
    (op:NegOp, xt:VMFloat, yt:VMFloat) : NEG-OPCODE-FLOAT
    (op:NegOp, xt:VMDouble, yt:VMDouble) : NEG-OPCODE-DOUBLE
    (op:InterpretOp, xt, yt) : false
    (op:ConvOp, xt:VMByte, yt:VMByte) : false
    (op:ConvOp, xt:VMByte, yt:VMInt) : false
    (op:ConvOp, xt:VMByte, yt:VMLong) : false
    (op:ConvOp, xt:VMByte, yt:VMFloat) : CONV-OPCODE-BYTE-FLOAT
    (op:ConvOp, xt:VMByte, yt:VMDouble) : CONV-OPCODE-BYTE-DOUBLE
    (op:ConvOp, xt:VMInt, yt:VMByte) : CONV-OPCODE-INT-BYTE
    (op:ConvOp, xt:VMInt, yt:VMInt) : false
    (op:ConvOp, xt:VMInt, yt:VMLong) : false
    (op:ConvOp, xt:VMInt, yt:VMFloat) : CONV-OPCODE-INT-FLOAT
    (op:ConvOp, xt:VMInt, yt:VMDouble) : CONV-OPCODE-INT-DOUBLE
    (op:ConvOp, xt:VMLong, yt:VMByte) : CONV-OPCODE-LONG-BYTE
    (op:ConvOp, xt:VMLong, yt:VMInt) : CONV-OPCODE-LONG-INT
    (op:ConvOp, xt:VMLong, yt:VMLong) : false
    (op:ConvOp, xt:VMLong, yt:VMFloat) : CONV-OPCODE-LONG-FLOAT
    (op:ConvOp, xt:VMLong, yt:VMDouble) : CONV-OPCODE-LONG-DOUBLE
    (op:ConvOp, xt:VMFloat, yt:VMByte) : CONV-OPCODE-FLOAT-BYTE
    (op:ConvOp, xt:VMFloat, yt:VMInt) : CONV-OPCODE-FLOAT-INT
    (op:ConvOp, xt:VMFloat, yt:VMLong) : CONV-OPCODE-FLOAT-LONG
    (op:ConvOp, xt:VMFloat, yt:VMFloat) : false
    (op:ConvOp, xt:VMFloat, yt:VMDouble) : CONV-OPCODE-FLOAT-DOUBLE
    (op:ConvOp, xt:VMDouble, yt:VMByte) : CONV-OPCODE-DOUBLE-BYTE
    (op:ConvOp, xt:VMDouble, yt:VMInt) : CONV-OPCODE-DOUBLE-INT
    (op:ConvOp, xt:VMDouble, yt:VMLong) : CONV-OPCODE-DOUBLE-LONG
    (op:ConvOp, xt:VMDouble, yt:VMFloat) : CONV-OPCODE-DOUBLE-FLOAT
    (op:ConvOp, xt:VMDouble, yt:VMDouble) : false
    (op:TagOp, xt, yt) :
      switch(type(op)) :
        BYTE-TYPE : TAG-OPCODE-BYTE
        CHAR-TYPE : TAG-OPCODE-CHAR
        INT-TYPE : TAG-OPCODE-INT
        FLOAT-TYPE : TAG-OPCODE-FLOAT
    (op:DetagOp, xt, yt) : DETAG-OPCODE
    (op:DerefOp, xt, yt) : DEREF-OPCODE
    (op:GCOp, xt, yt) : GC-OPCODE
    (op:PrintStackTraceOp, xt, yt) : PRINT-STACK-TRACE-OPCODE

defn op2-opcode (op:VMOp, xt:VMType, yt:VMType) :
  match(op, xt, yt) :
    (op:IntAddOp, xt:VMRef, yt:VMRef) : INT-ADD-OPCODE
    (op:IntSubOp, xt:VMRef, yt:VMRef) : INT-SUB-OPCODE
    (op:IntMulOp, xt:VMRef, yt:VMRef) : INT-MUL-OPCODE
    (op:IntDivOp, xt:VMRef, yt:VMRef) : INT-DIV-OPCODE
    (op:IntModOp, xt:VMRef, yt:VMRef) : INT-MOD-OPCODE
    (op:IntAndOp, xt:VMRef, yt:VMRef) : INT-AND-OPCODE
    (op:IntOrOp, xt:VMRef, yt:VMRef) : INT-OR-OPCODE
    (op:IntXorOp, xt:VMRef, yt:VMRef) : INT-XOR-OPCODE
    (op:IntShlOp, xt:VMRef, yt:VMRef) : INT-SHL-OPCODE
    (op:IntShrOp, xt:VMRef, yt:VMRef) : INT-SHR-OPCODE
    (op:IntAshrOp, xt:VMRef, yt:VMRef) : INT-ASHR-OPCODE
    (op:IntLtOp, xt:VMRef, yt:VMRef) : INT-LT-OPCODE
    (op:IntGtOp, xt:VMRef, yt:VMRef) : INT-GT-OPCODE
    (op:IntLeOp, xt:VMRef, yt:VMRef) : INT-LE-OPCODE
    (op:IntGeOp, xt:VMRef, yt:VMRef) : INT-GE-OPCODE
    (op:EqOp, xt:VMRef, yt:VMRef) : EQ-OPCODE-REF-REF
    (op:EqOp, xt:VMLong, yt:VMRef) : EQ-OPCODE-REF
    (op:EqOp, xt:VMLong, yt:VMByte) : EQ-OPCODE-BYTE
    (op:EqOp, xt:VMLong, yt:VMInt) : EQ-OPCODE-INT
    (op:EqOp, xt:VMLong, yt:VMLong) : EQ-OPCODE-LONG
    (op:EqOp, xt:VMLong, yt:VMFloat) : EQ-OPCODE-FLOAT
    (op:EqOp, xt:VMLong, yt:VMDouble) : EQ-OPCODE-DOUBLE
    (op:NeOp, xt:VMRef, yt:VMRef) : NE-OPCODE-REF-REF
    (op:NeOp, xt:VMLong, yt:VMRef) : NE-OPCODE-REF
    (op:NeOp, xt:VMLong, yt:VMByte) : NE-OPCODE-BYTE
    (op:NeOp, xt:VMLong, yt:VMInt) : NE-OPCODE-INT
    (op:NeOp, xt:VMLong, yt:VMLong) : NE-OPCODE-LONG
    (op:NeOp, xt:VMLong, yt:VMFloat) : NE-OPCODE-FLOAT
    (op:NeOp, xt:VMLong, yt:VMDouble) : NE-OPCODE-DOUBLE
    (op:AddOp, xt:VMByte, yt:VMByte) : ADD-OPCODE-BYTE
    (op:AddOp, xt:VMInt, yt:VMInt) : ADD-OPCODE-INT
    (op:AddOp, xt:VMLong, yt:VMLong) : ADD-OPCODE-LONG
    (op:AddOp, xt:VMFloat, yt:VMFloat) : ADD-OPCODE-FLOAT
    (op:AddOp, xt:VMDouble, yt:VMDouble) : ADD-OPCODE-DOUBLE
    (op:SubOp, xt:VMByte, yt:VMByte) : SUB-OPCODE-BYTE
    (op:SubOp, xt:VMInt, yt:VMInt) : SUB-OPCODE-INT
    (op:SubOp, xt:VMLong, yt:VMLong) : SUB-OPCODE-LONG
    (op:SubOp, xt:VMFloat, yt:VMFloat) : SUB-OPCODE-FLOAT
    (op:SubOp, xt:VMDouble, yt:VMDouble) : SUB-OPCODE-DOUBLE
    (op:MulOp, xt:VMByte, yt:VMByte) : MUL-OPCODE-BYTE
    (op:MulOp, xt:VMInt, yt:VMInt) : MUL-OPCODE-INT
    (op:MulOp, xt:VMLong, yt:VMLong) : MUL-OPCODE-LONG
    (op:MulOp, xt:VMFloat, yt:VMFloat) : MUL-OPCODE-FLOAT
    (op:MulOp, xt:VMDouble, yt:VMDouble) : MUL-OPCODE-DOUBLE
    (op:DivOp, xt:VMByte, yt:VMByte) : DIV-OPCODE-BYTE
    (op:DivOp, xt:VMInt, yt:VMInt) : DIV-OPCODE-INT
    (op:DivOp, xt:VMLong, yt:VMLong) : DIV-OPCODE-LONG
    (op:DivOp, xt:VMFloat, yt:VMFloat) : DIV-OPCODE-FLOAT
    (op:DivOp, xt:VMDouble, yt:VMDouble) : DIV-OPCODE-DOUBLE
    (op:ModOp, xt:VMByte, yt:VMByte) : MOD-OPCODE-BYTE
    (op:ModOp, xt:VMInt, yt:VMInt) : MOD-OPCODE-INT
    (op:ModOp, xt:VMLong, yt:VMLong) : MOD-OPCODE-LONG
    (op:AndOp, xt:VMByte, yt:VMByte) : AND-OPCODE-BYTE
    (op:AndOp, xt:VMInt, yt:VMInt) : AND-OPCODE-INT
    (op:AndOp, xt:VMLong, yt:VMLong) : AND-OPCODE-LONG
    (op:OrOp, xt:VMByte, yt:VMByte) : OR-OPCODE-BYTE
    (op:OrOp, xt:VMInt, yt:VMInt) : OR-OPCODE-INT
    (op:OrOp, xt:VMLong, yt:VMLong) : OR-OPCODE-LONG
    (op:XorOp, xt:VMByte, yt:VMByte) : XOR-OPCODE-BYTE
    (op:XorOp, xt:VMInt, yt:VMInt) : XOR-OPCODE-INT
    (op:XorOp, xt:VMLong, yt:VMLong) : XOR-OPCODE-LONG
    (op:ShlOp, xt:VMByte, yt:VMByte) : SHL-OPCODE-BYTE
    (op:ShlOp, xt:VMInt, yt:VMInt) : SHL-OPCODE-INT
    (op:ShlOp, xt:VMLong, yt:VMLong) : SHL-OPCODE-LONG
    (op:ShrOp, xt:VMByte, yt:VMByte) : SHR-OPCODE-BYTE
    (op:ShrOp, xt:VMInt, yt:VMInt) : SHR-OPCODE-INT
    (op:ShrOp, xt:VMLong, yt:VMLong) : SHR-OPCODE-LONG
    (op:AshrOp, xt:VMInt, yt:VMInt) : ASHR-OPCODE-INT
    (op:AshrOp, xt:VMLong, yt:VMLong) : ASHR-OPCODE-LONG
    (op:LtOp, xt:VMLong, yt:VMInt) : LT-OPCODE-INT
    (op:LtOp, xt:VMLong, yt:VMLong) : LT-OPCODE-LONG
    (op:LtOp, xt:VMLong, yt:VMFloat) : LT-OPCODE-FLOAT
    (op:LtOp, xt:VMLong, yt:VMDouble) : LT-OPCODE-DOUBLE
    (op:GtOp, xt:VMLong, yt:VMInt) : GT-OPCODE-INT
    (op:GtOp, xt:VMLong, yt:VMLong) : GT-OPCODE-LONG
    (op:GtOp, xt:VMLong, yt:VMFloat) : GT-OPCODE-FLOAT
    (op:GtOp, xt:VMLong, yt:VMDouble) : GT-OPCODE-DOUBLE
    (op:LeOp, xt:VMLong, yt:VMInt) : LE-OPCODE-INT
    (op:LeOp, xt:VMLong, yt:VMLong) : LE-OPCODE-LONG
    (op:LeOp, xt:VMLong, yt:VMFloat) : LE-OPCODE-FLOAT
    (op:LeOp, xt:VMLong, yt:VMDouble) : LE-OPCODE-DOUBLE
    (op:GeOp, xt:VMLong, yt:VMInt) : GE-OPCODE-INT
    (op:GeOp, xt:VMLong, yt:VMLong) : GE-OPCODE-LONG
    (op:GeOp, xt:VMLong, yt:VMFloat) : GE-OPCODE-FLOAT
    (op:GeOp, xt:VMLong, yt:VMDouble) : GE-OPCODE-DOUBLE
    (op:UltOp, xt:VMLong, yt:VMByte) : ULT-OPCODE-BYTE
    (op:UltOp, xt:VMLong, yt:VMInt) : ULT-OPCODE-INT
    (op:UltOp, xt:VMLong, yt:VMLong) : ULT-OPCODE-LONG
    (op:UleOp, xt:VMLong, yt:VMByte) : ULE-OPCODE-BYTE
    (op:UleOp, xt:VMLong, yt:VMInt) : ULE-OPCODE-INT
    (op:UleOp, xt:VMLong, yt:VMLong) : ULE-OPCODE-LONG
    (op:UgtOp, xt:VMLong, yt:VMByte) : UGT-OPCODE-BYTE
    (op:UgtOp, xt:VMLong, yt:VMInt) : UGT-OPCODE-INT
    (op:UgtOp, xt:VMLong, yt:VMLong) : UGT-OPCODE-LONG
    (op:UgeOp, xt:VMLong, yt:VMByte) : UGE-OPCODE-BYTE
    (op:UgeOp, xt:VMLong, yt:VMInt) : UGE-OPCODE-INT
    (op:UgeOp, xt:VMLong, yt:VMLong) : UGE-OPCODE-LONG

defn branch2-opcode (op:VMOp, xt:VMType) :
  match(op, xt) :
    (op:IntLtOp, xt:VMRef) : JUMP-INT-LT-OPCODE
    (op:IntGtOp, xt:VMRef) : JUMP-INT-GT-OPCODE
    (op:IntLeOp, xt:VMRef) : JUMP-INT-LE-OPCODE
    (op:IntGeOp, xt:VMRef) : JUMP-INT-GE-OPCODE
    (op:EqOp, xt:VMRef) : JUMP-EQ-OPCODE-REF
    (op:EqOp, xt:VMByte) : JUMP-EQ-OPCODE-BYTE
    (op:EqOp, xt:VMInt) : JUMP-EQ-OPCODE-INT
    (op:EqOp, xt:VMLong) : JUMP-EQ-OPCODE-LONG
    (op:EqOp, xt:VMFloat) : JUMP-EQ-OPCODE-FLOAT
    (op:EqOp, xt:VMDouble) : JUMP-EQ-OPCODE-DOUBLE
    (op:NeOp, xt:VMRef) : JUMP-NE-OPCODE-REF
    (op:NeOp, xt:VMByte) : JUMP-NE-OPCODE-BYTE
    (op:NeOp, xt:VMInt) : JUMP-NE-OPCODE-INT
    (op:NeOp, xt:VMLong) : JUMP-NE-OPCODE-LONG
    (op:NeOp, xt:VMFloat) : JUMP-NE-OPCODE-FLOAT
    (op:NeOp, xt:VMDouble) : JUMP-NE-OPCODE-DOUBLE
    (op:LtOp, xt:VMInt) : JUMP-LT-OPCODE-INT
    (op:LtOp, xt:VMLong) : JUMP-LT-OPCODE-LONG
    (op:LtOp, xt:VMFloat) : JUMP-LT-OPCODE-FLOAT
    (op:LtOp, xt:VMDouble) : JUMP-LT-OPCODE-DOUBLE
    (op:GtOp, xt:VMInt) : JUMP-GT-OPCODE-INT
    (op:GtOp, xt:VMLong) : JUMP-GT-OPCODE-LONG
    (op:GtOp, xt:VMFloat) : JUMP-GT-OPCODE-FLOAT
    (op:GtOp, xt:VMDouble) : JUMP-GT-OPCODE-DOUBLE
    (op:LeOp, xt:VMInt) : JUMP-LE-OPCODE-INT
    (op:LeOp, xt:VMLong) : JUMP-LE-OPCODE-LONG
    (op:LeOp, xt:VMFloat) : JUMP-LE-OPCODE-FLOAT
    (op:LeOp, xt:VMDouble) : JUMP-LE-OPCODE-DOUBLE
    (op:GeOp, xt:VMInt) : JUMP-GE-OPCODE-INT
    (op:GeOp, xt:VMLong) : JUMP-GE-OPCODE-LONG
    (op:GeOp, xt:VMFloat) : JUMP-GE-OPCODE-FLOAT
    (op:GeOp, xt:VMDouble) : JUMP-GE-OPCODE-DOUBLE
    (op:UltOp, xt:VMByte) : JUMP-ULT-OPCODE-BYTE
    (op:UltOp, xt:VMInt) : JUMP-ULT-OPCODE-INT
    (op:UltOp, xt:VMLong) : JUMP-ULT-OPCODE-LONG
    (op:UleOp, xt:VMByte) : JUMP-ULE-OPCODE-BYTE
    (op:UleOp, xt:VMInt) : JUMP-ULE-OPCODE-INT
    (op:UleOp, xt:VMLong) : JUMP-ULE-OPCODE-LONG
    (op:UgtOp, xt:VMByte) : JUMP-UGT-OPCODE-BYTE
    (op:UgtOp, xt:VMInt) : JUMP-UGT-OPCODE-INT
    (op:UgtOp, xt:VMLong) : JUMP-UGT-OPCODE-LONG
    (op:UgeOp, xt:VMByte) : JUMP-UGE-OPCODE-BYTE
    (op:UgeOp, xt:VMInt) : JUMP-UGE-OPCODE-INT
    (op:UgeOp, xt:VMLong) : JUMP-UGE-OPCODE-LONG

;============================================================
;====================== Utilities ===========================
;============================================================

var delay : (() -> ?) -> False =
  fn (f) : fatal("Not within delay-actions block.")
defn delay-actions<?T> (f:() -> ?T) :
  val delays = Vector<(() -> ?)>()
  defn delay-action (action:() -> ?)  : add(delays, action)
  val result = let-var delay = delay-action : f()
  for d in delays do : d()
  clear(delays)
  result

;============================================================
;======================= Decoder ============================
;============================================================

extern vmloop : (ptr<byte>, int) -> int
lostanza defn decode (f:ref<EncodedFunction>) -> ref<False> :
  val buffer = buffer(f)
  val n = length(buffer)
  call-c vmloop(data(buffer), n.value)
  return false
    
