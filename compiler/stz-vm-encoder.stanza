defpackage stz/vm-encoder :
  import core
  import collections
  import stz/vm-ir
  import stz/loaded-ids
  import stz/basic-ops
  
public defn encode (func:VMFunction, pkgids:PackageIds) :
  println("Encode:")
  println(func)

  val pos-counter = to-seq(0 to false)
  val buffer = ByteBuffer()

  ;Instruction formats:  
  ;A: [OPCODE(16) | INDEX(16) | ITEM(32)] + WIDE(32)
  ;B: [OPCODE(16) | INDEX(16)]
  defn emit-ins-a (opcode:Int, index:Int, item:Int|Long) :
    fatal("Index out of bounds.") when index < 0 or index > 65535
    println("A: %_ %_ | %_" % [opcode, index, item])
    put(buffer, (opcode << 16) | index)
    match(item) :
      (item:Int) :
        put(buffer, item)
      (item:Long) :
        put(buffer, to-int(item >> 32L))
        put(buffer, to-int(item))
  defn emit-ins-b (opcode:Int, index:Int) :
    println("B: %_ %_" % [opcode, index])
    put(buffer, (opcode << 16) | index)

  ;Retrieve the corresponding bits for the given immediate
  defn to-bits (y:VMImm) -> Int|Long :
    match(y) :
      (y:Local) : index(y)
      (y:NumConst) :
        match(value(y)) :
          (v:Char) : to-int(v)
          (v:Byte) : to-int(v)
          (v:Int) : v
          (v:Long) : v
          (v:Float) : bits(v)
          (v:Double) : bits(v)
      (y:Marker) : marker(typeid(y))
      (y:Tag) : typeid(y)
      (y:VoidMarker) : marker(-1)
      (y:CodeId) : id(y)
      (y:ExternId) : id(y)
      (y:GlobalId) : id(y)
      (y:DataId) : id(y)
      (y:ConstId) : id(y)

  ;Set register
  defn set-reg (i:Int, y:VMImm) :
    emit-ins-a(set-reg-opcode(y), i, to-bits(y))
  defn set-regs (ys:Tuple<VMImm>) :
    do(set-reg, 0 to false, ys)
  defn get-reg (x:Local|False, i:Int) :
    emit-ins-b(GET-REG-OPCODE, i)
  defn get-regs (xs:Tuple<Local|False>) :
    do(get-reg, xs, 0 to false)

  ;Resolve an instruction
  defn resolve-ins<?T> (ins:VMIns&?T, pos:Int) -> T :
    ;defn sub-label (n:Int) : label-table[n] - pos
    ;defn sub-id (n:Int) : pkgids[n]
    ;map(sub-label, sub-slot, sub-id, ins)
    ins
  defn resolve-imm<?T> (x:?T&VMImm) -> T :
    ;map(sub-slot, {pkgids[_]}, x)
    x
  
  defn encode (func:VMFunc) :
    val num-locals = maximum(-1, seq(local, defs(func))) + 1
    for ins in ins(func) do :
      println("Encoding: %_" % [ins])
      val pos = next(pos-counter)
      match(ins) :
        (ins:CallIns) :
          val ins* = resolve-ins(ins, pos)
          ;1) Move all the values from ys(ins*) into the registers.
          ;  - The opcode should be different depending upon what we're putting in.
          ;2) Emit a CALL f(ins*) num-locals
          ;  - The opcode should be different depending on what we're calling.
          ;3) Record the info in the info table
          ;4) Emit a POPFRAME num-locals
          ;5) Retrieve the registers and put them into xs(ins).
          ;  - This is easy.
          set-regs(ys(ins*))
          emit-ins-a(call-opcode(f(ins*)), num-locals, to-bits(f(ins*)) as Int)
          emit-ins-b(POP-FRAME-OPCODE, num-locals)
          get-regs(xs(ins*))
        (ins) :
          println("Not yet encoded")

  match(func:VMFunc) :
    encode(func)

  println("BUFFER: %s" % [buffer])
  buffer

;============================================================
;======================= Opcodes ============================
;============================================================

val opcode-counter = to-seq(0 to false)
val SET-REG-OPCODE-LOCAL = next(opcode-counter)
val SET-REG-OPCODE-UNSIGNED = next(opcode-counter)
val SET-REG-OPCODE-SIGNED = next(opcode-counter)
val SET-REG-OPCODE-CODE = next(opcode-counter)
val SET-REG-OPCODE-EXTERN = next(opcode-counter)
val SET-REG-OPCODE-GLOBAL = next(opcode-counter)
val SET-REG-OPCODE-DATA = next(opcode-counter)
val SET-REG-OPCODE-CONST = next(opcode-counter)
val SET-REG-OPCODE-WIDE = next(opcode-counter)
val GET-REG-OPCODE = next(opcode-counter)
val CALL-OPCODE-LOCAL = next(opcode-counter)
val CALL-OPCODE-CODE = next(opcode-counter)
val CALL-OPCODE-EXTERN = next(opcode-counter)
val POP-FRAME-OPCODE = next(opcode-counter)

defn set-reg-opcode (y:VMImm) :
  match(y) :
    (y:Local) : SET-REG-OPCODE-LOCAL
    (y:NumConst) :
      match(value(y)) :
        (v:Char) : SET-REG-OPCODE-UNSIGNED
        (v:Byte) : SET-REG-OPCODE-UNSIGNED
        (v:Int) : SET-REG-OPCODE-UNSIGNED
        (v:Long) : SET-REG-OPCODE-WIDE  ;OR SIGNED
        (v:Float) : SET-REG-OPCODE-UNSIGNED
        (v:Double) : SET-REG-OPCODE-WIDE
    (y:Marker) : SET-REG-OPCODE-UNSIGNED
    (y:Tag) : SET-REG-OPCODE-UNSIGNED
    (y:CodeId) : SET-REG-OPCODE-CODE
    (y:ExternId) : SET-REG-OPCODE-EXTERN
    (y:GlobalId) : SET-REG-OPCODE-GLOBAL
    (y:DataId) : SET-REG-OPCODE-DATA
    (y:ConstId) : SET-REG-OPCODE-CONST
    (y:VoidMarker) : SET-REG-OPCODE-UNSIGNED

defn call-opcode (f:VMImm) :
  match(f) :
    (f:Local) : CALL-OPCODE-LOCAL
    (f:CodeId) : CALL-OPCODE-CODE
    (f:ExternId) :  CALL-OPCODE-EXTERN

;============================================================
;==================== Tag Bits ==============================
;============================================================

public val INT-TAG-BITS = 0
public val REF-TAG-BITS = 1
public val MARKER-TAG-BITS = 2
public val BYTE-TAG-BITS = 3
public val CHAR-TAG-BITS = 4
public val FLOAT-TAG-BITS = 5

defn marker (type:Int) :
  type << 3 + MARKER-TAG-BITS

;============================================================
;============================================================
;============================================================
    

defn resolve (pkgids:PackageIds, vmp:VMPackage) :
  defn resolve (n:Int) : pkgids[n]
  defn resolve (x:False) : false
  defn resolve<?T> (x:?T&(VMGlobal|VMData|VMConst|VMClass|VMFunction|VMMethod|VMExtern)) :
    map-id(resolve,x) as T&(VMGlobal|VMData|VMConst|VMClass|VMFunction|VMMethod|VMExtern)
  VMPackage(
    packageio(vmp)
    resolve(init(vmp))
    map(resolve,globals(vmp))
    map(resolve,datas(vmp))
    map(resolve,consts(vmp))
    map(resolve,classes(vmp))
    map(resolve,funcs(vmp))
    map(resolve,methods(vmp))
    map(resolve,externs(vmp)))

public defn main () :
  val filenames = command-line-arguments()[1 to false]
  val vmpackages = to-tuple $ seq(read-vm-package, filenames)
  val loaded-ids = LoadedIds()
  make-package-ids(loaded-ids, vmpackages)
  for vmp0 in vmpackages do :
    val pkgids = package-ids(loaded-ids, vmp0)
    val vmp = resolve(pkgids, vmp0)
    for f in funcs(vmp) do :
      encode(f, pkgids)

main()